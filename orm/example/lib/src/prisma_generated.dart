// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: non_constant_identifier_names

import 'package:orm/orm.dart';
import 'package:json_annotation/json_annotation.dart';
import 'dart:convert';

part 'prisma_generated.g.dart';

//******************************************************************************
// This file was generated by Prisma ORM
// GitHub: https://github.com/odroe/prisma
//******************************************************************************

class PrismaClient {

  final Engine engine;

  // final PrismaActions action;
  PrismaClient._(this.engine);
  factory PrismaClient()=>PrismaClient._(BinaryEngine(schema));

late final post = PostModel(engine) ;
late final user = UserModel(engine) ;
}

enum PostScalarFieldEnum implements PrismaEnum {
  id('id'),
  createdAt('createdAt'),
  updatedAt('updatedAt'),
  title('title'),
  published('published'),
  desc('desc'),
  userId('userId'),
;
  @override
  final String value;
  const PostScalarFieldEnum(this.value);
Entity toEntity(){ return Entity("PostScalarFieldEnum",true,value,null) ;}
}
enum SortOrder implements PrismaEnum {
  asc('asc'),
  desc('desc'),
;
  @override
  final String value;
  const SortOrder(this.value);
Entity toEntity(){ return Entity("SortOrder",true,value,null) ;}
}
enum TransactionIsolationLevel implements PrismaEnum {
  serializable('Serializable'),
;
  @override
  final String value;
  const TransactionIsolationLevel(this.value);
Entity toEntity(){ return Entity("TransactionIsolationLevel",true,value,null) ;}
}
enum UserScalarFieldEnum implements PrismaEnum {
  id('id'),
  userName('userName'),
  name('name'),
  password('password'),
  resturantId('resturantId'),
;
  @override
  final String value;
  const UserScalarFieldEnum(this.value);
Entity toEntity(){ return Entity("UserScalarFieldEnum",true,value,null) ;}
}



class PostWhereInput {
  const PostWhereInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.user,
  this.userId,
  });

  @JsonKey(name: 'AND' )
  final List<PostWhereInput>? aND;
  @JsonKey(name: 'OR' )
  final List<PostWhereInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<PostWhereInput>? nOT;
  @JsonKey(name: 'id' )
  final StringFilter? id;
  @JsonKey(name: 'createdAt' )
  final DateTimeFilter? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTimeFilter? updatedAt;
  @JsonKey(name: 'title' )
  final StringFilter? title;
  @JsonKey(name: 'published' )
  final BoolFilter? published;
  @JsonKey(name: 'desc' )
  final StringNullableFilter? desc;
  @JsonKey(name: 'User' )
  final UserRelationFilter? user;
  @JsonKey(name: 'userId' )
  final IntNullableFilter? userId;

List<Entity> toEntity()=>[if(aND !=null)Entity("AND",false,null,aND!.map((e) => Entity("AND", false, null, e.toEntity())).toList(),),if(oR !=null)Entity("OR",false,null,oR!.map((e) => Entity("OR", false, null, e.toEntity())).toList(),),if(nOT !=null)Entity("NOT",false,null,nOT!.map((e) => Entity("NOT", false, null, e.toEntity())).toList(),),if(id !=null)Entity("id",false,null,id!.toEntity(),),if(createdAt !=null)Entity("createdAt",false,null,createdAt!.toEntity(),),if(updatedAt !=null)Entity("updatedAt",false,null,updatedAt!.toEntity(),),if(title !=null)Entity("title",false,null,title!.toEntity(),),if(published !=null)Entity("published",false,null,published!.toEntity(),),if(desc !=null)Entity("desc",false,null,desc!.toEntity(),),if(user !=null)Entity("User",false,null,user!.toEntity(),),if(userId !=null)Entity("userId",false,null,userId!.toEntity(),),];
}
class PostOrderByWithRelationInput {
  const PostOrderByWithRelationInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.user,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt' )
  final SortOrder? updatedAt;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'published' )
  final SortOrder? published;
  @JsonKey(name: 'desc' )
  final SortOrder? desc;
  @JsonKey(name: 'User' )
  final UserOrderByWithRelationInput? user;
  @JsonKey(name: 'userId' )
  final SortOrder? userId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(createdAt !=null)createdAt!.toEntity(),if(updatedAt !=null)updatedAt!.toEntity(),if(title !=null)title!.toEntity(),if(published !=null)published!.toEntity(),if(desc !=null)desc!.toEntity(),if(user !=null)Entity("User",false,null,user!.toEntity(),),if(userId !=null)userId!.toEntity(),];
}
class PostWhereUniqueInput {
  const PostWhereUniqueInput({
  this.id,
  });

  @JsonKey(name: 'id' )
  final String? id;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),];
}
class PostOrderByWithAggregationInput {
  const PostOrderByWithAggregationInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  this.$count,
  this.$avg,
  this.$max,
  this.$min,
  this.$sum,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt' )
  final SortOrder? updatedAt;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'published' )
  final SortOrder? published;
  @JsonKey(name: 'desc' )
  final SortOrder? desc;
  @JsonKey(name: 'userId' )
  final SortOrder? userId;
  @JsonKey(name: '_count' )
  final PostCountOrderByAggregateInput? $count;
  @JsonKey(name: '_avg' )
  final PostAvgOrderByAggregateInput? $avg;
  @JsonKey(name: '_max' )
  final PostMaxOrderByAggregateInput? $max;
  @JsonKey(name: '_min' )
  final PostMinOrderByAggregateInput? $min;
  @JsonKey(name: '_sum' )
  final PostSumOrderByAggregateInput? $sum;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(createdAt !=null)createdAt!.toEntity(),if(updatedAt !=null)updatedAt!.toEntity(),if(title !=null)title!.toEntity(),if(published !=null)published!.toEntity(),if(desc !=null)desc!.toEntity(),if(userId !=null)userId!.toEntity(),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($avg !=null)Entity("_avg",false,null,$avg!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($sum !=null)Entity("_sum",false,null,$sum!.toEntity(),),];
}
class PostScalarWhereWithAggregatesInput {
  const PostScalarWhereWithAggregatesInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'AND' )
  final List<PostScalarWhereWithAggregatesInput>? aND;
  @JsonKey(name: 'OR' )
  final List<PostScalarWhereWithAggregatesInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<PostScalarWhereWithAggregatesInput>? nOT;
  @JsonKey(name: 'id' )
  final StringWithAggregatesFilter? id;
  @JsonKey(name: 'createdAt' )
  final DateTimeWithAggregatesFilter? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTimeWithAggregatesFilter? updatedAt;
  @JsonKey(name: 'title' )
  final StringWithAggregatesFilter? title;
  @JsonKey(name: 'published' )
  final BoolWithAggregatesFilter? published;
  @JsonKey(name: 'desc' )
  final StringNullableWithAggregatesFilter? desc;
  @JsonKey(name: 'userId' )
  final IntNullableWithAggregatesFilter? userId;

List<Entity> toEntity()=>[if(aND !=null)Entity("AND",false,null,aND!.map((e) => Entity("AND", false, null, e.toEntity())).toList(),),if(oR !=null)Entity("OR",false,null,oR!.map((e) => Entity("OR", false, null, e.toEntity())).toList(),),if(nOT !=null)Entity("NOT",false,null,nOT!.map((e) => Entity("NOT", false, null, e.toEntity())).toList(),),if(id !=null)Entity("id",false,null,id!.toEntity(),),if(createdAt !=null)Entity("createdAt",false,null,createdAt!.toEntity(),),if(updatedAt !=null)Entity("updatedAt",false,null,updatedAt!.toEntity(),),if(title !=null)Entity("title",false,null,title!.toEntity(),),if(published !=null)Entity("published",false,null,published!.toEntity(),),if(desc !=null)Entity("desc",false,null,desc!.toEntity(),),if(userId !=null)Entity("userId",false,null,userId!.toEntity(),),];
}
class UserWhereInput {
  const UserWhereInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  this.posts,
  });

  @JsonKey(name: 'AND' )
  final List<UserWhereInput>? aND;
  @JsonKey(name: 'OR' )
  final List<UserWhereInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<UserWhereInput>? nOT;
  @JsonKey(name: 'id' )
  final IntFilter? id;
  @JsonKey(name: 'userName' )
  final StringFilter? userName;
  @JsonKey(name: 'name' )
  final StringFilter? name;
  @JsonKey(name: 'password' )
  final StringFilter? password;
  @JsonKey(name: 'resturantId' )
  final IntNullableFilter? resturantId;
  @JsonKey(name: 'posts' )
  final PostListRelationFilter? posts;

List<Entity> toEntity()=>[if(aND !=null)Entity("AND",false,null,aND!.map((e) => Entity("AND", false, null, e.toEntity())).toList(),),if(oR !=null)Entity("OR",false,null,oR!.map((e) => Entity("OR", false, null, e.toEntity())).toList(),),if(nOT !=null)Entity("NOT",false,null,nOT!.map((e) => Entity("NOT", false, null, e.toEntity())).toList(),),if(id !=null)Entity("id",false,null,id!.toEntity(),),if(userName !=null)Entity("userName",false,null,userName!.toEntity(),),if(name !=null)Entity("name",false,null,name!.toEntity(),),if(password !=null)Entity("password",false,null,password!.toEntity(),),if(resturantId !=null)Entity("resturantId",false,null,resturantId!.toEntity(),),if(posts !=null)Entity("posts",false,null,posts!.toEntity(),),];
}
class UserOrderByWithRelationInput {
  const UserOrderByWithRelationInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  this.posts,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'userName' )
  final SortOrder? userName;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'password' )
  final SortOrder? password;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;
  @JsonKey(name: 'posts' )
  final PostOrderByRelationAggregateInput? posts;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(userName !=null)userName!.toEntity(),if(name !=null)name!.toEntity(),if(password !=null)password!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),if(posts !=null)Entity("posts",false,null,posts!.toEntity(),),];
}
class UserWhereUniqueInput {
  const UserWhereUniqueInput({
  this.id,
  this.userName,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String? userName;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(userName !=null)Entity("userName",true,userName!,null,),];
}
class UserOrderByWithAggregationInput {
  const UserOrderByWithAggregationInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  this.$count,
  this.$avg,
  this.$max,
  this.$min,
  this.$sum,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'userName' )
  final SortOrder? userName;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'password' )
  final SortOrder? password;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;
  @JsonKey(name: '_count' )
  final UserCountOrderByAggregateInput? $count;
  @JsonKey(name: '_avg' )
  final UserAvgOrderByAggregateInput? $avg;
  @JsonKey(name: '_max' )
  final UserMaxOrderByAggregateInput? $max;
  @JsonKey(name: '_min' )
  final UserMinOrderByAggregateInput? $min;
  @JsonKey(name: '_sum' )
  final UserSumOrderByAggregateInput? $sum;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(userName !=null)userName!.toEntity(),if(name !=null)name!.toEntity(),if(password !=null)password!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($avg !=null)Entity("_avg",false,null,$avg!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($sum !=null)Entity("_sum",false,null,$sum!.toEntity(),),];
}
class UserScalarWhereWithAggregatesInput {
  const UserScalarWhereWithAggregatesInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'AND' )
  final List<UserScalarWhereWithAggregatesInput>? aND;
  @JsonKey(name: 'OR' )
  final List<UserScalarWhereWithAggregatesInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<UserScalarWhereWithAggregatesInput>? nOT;
  @JsonKey(name: 'id' )
  final IntWithAggregatesFilter? id;
  @JsonKey(name: 'userName' )
  final StringWithAggregatesFilter? userName;
  @JsonKey(name: 'name' )
  final StringWithAggregatesFilter? name;
  @JsonKey(name: 'password' )
  final StringWithAggregatesFilter? password;
  @JsonKey(name: 'resturantId' )
  final IntNullableWithAggregatesFilter? resturantId;

List<Entity> toEntity()=>[if(aND !=null)Entity("AND",false,null,aND!.map((e) => Entity("AND", false, null, e.toEntity())).toList(),),if(oR !=null)Entity("OR",false,null,oR!.map((e) => Entity("OR", false, null, e.toEntity())).toList(),),if(nOT !=null)Entity("NOT",false,null,nOT!.map((e) => Entity("NOT", false, null, e.toEntity())).toList(),),if(id !=null)Entity("id",false,null,id!.toEntity(),),if(userName !=null)Entity("userName",false,null,userName!.toEntity(),),if(name !=null)Entity("name",false,null,name!.toEntity(),),if(password !=null)Entity("password",false,null,password!.toEntity(),),if(resturantId !=null)Entity("resturantId",false,null,resturantId!.toEntity(),),];
}
class PostCreateInput {
  const PostCreateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
 required this.title,
 required this.published,
  this.desc,
  this.user,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'published' )
  final bool published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'User' )
  final UserCreateNestedOneWithoutPostsInput? user;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),Entity("title",true,title,null,),Entity("published",true,published,null,),if(desc !=null)Entity("desc",true,desc!,null,),if(user !=null)Entity("User",false,null,user!.toEntity(),),];
}
class PostUncheckedCreateInput {
  const PostUncheckedCreateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
 required this.title,
 required this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'published' )
  final bool published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'userId' )
  final int? userId;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),Entity("title",true,title,null,),Entity("published",true,published,null,),if(desc !=null)Entity("desc",true,desc!,null,),if(userId !=null)Entity("userId",true,userId!,null,),];
}
class PostUpdateInput {
  const PostUpdateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.user,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'User' )
  final UserUpdateOneWithoutPostsNestedInput? user;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),if(user !=null)Entity("User",false,null,user!.toEntity(),),];
}
class PostUncheckedUpdateInput {
  const PostUncheckedUpdateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'userId' )
  final int? userId;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),if(userId !=null)Entity("userId",true,userId!,null,),];
}
class PostUpdateManyMutationInput {
  const PostUpdateManyMutationInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),];
}
class PostUncheckedUpdateManyInput {
  const PostUncheckedUpdateManyInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'userId' )
  final int? userId;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),if(userId !=null)Entity("userId",true,userId!,null,),];
}
class UserCreateInput {
  const UserCreateInput({
 required this.userName,
 required this.name,
 required this.password,
  this.resturantId,
  this.posts,
  });

  @JsonKey(name: 'userName' )
  final String userName;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'password' )
  final String password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;
  @JsonKey(name: 'posts' )
  final PostCreateNestedManyWithoutUserInput? posts;

List<Entity> toEntity()=>[Entity("userName",true,userName,null,),Entity("name",true,name,null,),Entity("password",true,password,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),if(posts !=null)Entity("posts",false,null,posts!.toEntity(),),];
}
class UserUncheckedCreateInput {
  const UserUncheckedCreateInput({
  this.id,
 required this.userName,
 required this.name,
 required this.password,
  this.resturantId,
  this.posts,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String userName;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'password' )
  final String password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;
  @JsonKey(name: 'posts' )
  final PostUncheckedCreateNestedManyWithoutUserInput? posts;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),Entity("userName",true,userName,null,),Entity("name",true,name,null,),Entity("password",true,password,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),if(posts !=null)Entity("posts",false,null,posts!.toEntity(),),];
}
class UserUpdateInput {
  const UserUpdateInput({
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  this.posts,
  });

  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;
  @JsonKey(name: 'posts' )
  final PostUpdateManyWithoutUserNestedInput? posts;

List<Entity> toEntity()=>[if(userName !=null)Entity("userName",true,userName!,null,),if(name !=null)Entity("name",true,name!,null,),if(password !=null)Entity("password",true,password!,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),if(posts !=null)Entity("posts",false,null,posts!.toEntity(),),];
}
class UserUncheckedUpdateInput {
  const UserUncheckedUpdateInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  this.posts,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;
  @JsonKey(name: 'posts' )
  final PostUncheckedUpdateManyWithoutUserNestedInput? posts;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(userName !=null)Entity("userName",true,userName!,null,),if(name !=null)Entity("name",true,name!,null,),if(password !=null)Entity("password",true,password!,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),if(posts !=null)Entity("posts",false,null,posts!.toEntity(),),];
}
class UserUpdateManyMutationInput {
  const UserUpdateManyMutationInput({
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

List<Entity> toEntity()=>[if(userName !=null)Entity("userName",true,userName!,null,),if(name !=null)Entity("name",true,name!,null,),if(password !=null)Entity("password",true,password!,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),];
}
class UserUncheckedUpdateManyInput {
  const UserUncheckedUpdateManyInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(userName !=null)Entity("userName",true,userName!,null,),if(name !=null)Entity("name",true,name!,null,),if(password !=null)Entity("password",true,password!,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),];
}
class StringFilter {
  const StringFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class DateTimeFilter {
  const DateTimeFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final DateTime? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class BoolFilter {
  const BoolFilter({
  this.equals,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final bool? equals;
  @JsonKey(name: 'not' )
  final bool? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class StringNullableFilter {
  const StringNullableFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class UserRelationFilter {
  const UserRelationFilter({
  this.is$,
  this.isNot,
  });

  @JsonKey(name: 'is' )
  final UserWhereInput? is$;
  @JsonKey(name: 'isNot' )
  final UserWhereInput? isNot;

List<Entity> toEntity()=>[if(is$ !=null)Entity("is",false,null,is$!.toEntity(),),if(isNot !=null)Entity("isNot",false,null,isNot!.toEntity(),),];
}
class IntNullableFilter {
  const IntNullableFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class PostCountOrderByAggregateInput {
  const PostCountOrderByAggregateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt' )
  final SortOrder? updatedAt;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'published' )
  final SortOrder? published;
  @JsonKey(name: 'desc' )
  final SortOrder? desc;
  @JsonKey(name: 'userId' )
  final SortOrder? userId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(createdAt !=null)createdAt!.toEntity(),if(updatedAt !=null)updatedAt!.toEntity(),if(title !=null)title!.toEntity(),if(published !=null)published!.toEntity(),if(desc !=null)desc!.toEntity(),if(userId !=null)userId!.toEntity(),];
}
class PostAvgOrderByAggregateInput {
  const PostAvgOrderByAggregateInput({
  this.userId,
  });

  @JsonKey(name: 'userId' )
  final SortOrder? userId;

List<Entity> toEntity()=>[if(userId !=null)userId!.toEntity(),];
}
class PostMaxOrderByAggregateInput {
  const PostMaxOrderByAggregateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt' )
  final SortOrder? updatedAt;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'published' )
  final SortOrder? published;
  @JsonKey(name: 'desc' )
  final SortOrder? desc;
  @JsonKey(name: 'userId' )
  final SortOrder? userId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(createdAt !=null)createdAt!.toEntity(),if(updatedAt !=null)updatedAt!.toEntity(),if(title !=null)title!.toEntity(),if(published !=null)published!.toEntity(),if(desc !=null)desc!.toEntity(),if(userId !=null)userId!.toEntity(),];
}
class PostMinOrderByAggregateInput {
  const PostMinOrderByAggregateInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'createdAt' )
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt' )
  final SortOrder? updatedAt;
  @JsonKey(name: 'title' )
  final SortOrder? title;
  @JsonKey(name: 'published' )
  final SortOrder? published;
  @JsonKey(name: 'desc' )
  final SortOrder? desc;
  @JsonKey(name: 'userId' )
  final SortOrder? userId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(createdAt !=null)createdAt!.toEntity(),if(updatedAt !=null)updatedAt!.toEntity(),if(title !=null)title!.toEntity(),if(published !=null)published!.toEntity(),if(desc !=null)desc!.toEntity(),if(userId !=null)userId!.toEntity(),];
}
class PostSumOrderByAggregateInput {
  const PostSumOrderByAggregateInput({
  this.userId,
  });

  @JsonKey(name: 'userId' )
  final SortOrder? userId;

List<Entity> toEntity()=>[if(userId !=null)userId!.toEntity(),];
}
class StringWithAggregatesFilter {
  const StringWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedStringFilter? $min;
  @JsonKey(name: '_max' )
  final NestedStringFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class DateTimeWithAggregatesFilter {
  const DateTimeWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final DateTime? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedDateTimeFilter? $min;
  @JsonKey(name: '_max' )
  final NestedDateTimeFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class BoolWithAggregatesFilter {
  const BoolWithAggregatesFilter({
  this.equals,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final bool? equals;
  @JsonKey(name: 'not' )
  final bool? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedBoolFilter? $min;
  @JsonKey(name: '_max' )
  final NestedBoolFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class StringNullableWithAggregatesFilter {
  const StringNullableWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;
  @JsonKey(name: '_count' )
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_min' )
  final NestedStringNullableFilter? $min;
  @JsonKey(name: '_max' )
  final NestedStringNullableFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class IntNullableWithAggregatesFilter {
  const IntNullableWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$avg,
  this.$sum,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;
  @JsonKey(name: '_count' )
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_avg' )
  final NestedFloatNullableFilter? $avg;
  @JsonKey(name: '_sum' )
  final NestedIntNullableFilter? $sum;
  @JsonKey(name: '_min' )
  final NestedIntNullableFilter? $min;
  @JsonKey(name: '_max' )
  final NestedIntNullableFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($avg !=null)Entity("_avg",false,null,$avg!.toEntity(),),if($sum !=null)Entity("_sum",false,null,$sum!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class IntFilter {
  const IntFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class PostListRelationFilter {
  const PostListRelationFilter({
  this.every,
  this.some,
  this.none,
  });

  @JsonKey(name: 'every' )
  final PostWhereInput? every;
  @JsonKey(name: 'some' )
  final PostWhereInput? some;
  @JsonKey(name: 'none' )
  final PostWhereInput? none;

List<Entity> toEntity()=>[if(every !=null)Entity("every",false,null,every!.toEntity(),),if(some !=null)Entity("some",false,null,some!.toEntity(),),if(none !=null)Entity("none",false,null,none!.toEntity(),),];
}
class PostOrderByRelationAggregateInput {
  const PostOrderByRelationAggregateInput({
  this.$count,
  });

  @JsonKey(name: '_count' )
  final SortOrder? $count;

List<Entity> toEntity()=>[if($count !=null)$count!.toEntity(),];
}
class UserCountOrderByAggregateInput {
  const UserCountOrderByAggregateInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'userName' )
  final SortOrder? userName;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'password' )
  final SortOrder? password;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(userName !=null)userName!.toEntity(),if(name !=null)name!.toEntity(),if(password !=null)password!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),];
}
class UserAvgOrderByAggregateInput {
  const UserAvgOrderByAggregateInput({
  this.id,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),];
}
class UserMaxOrderByAggregateInput {
  const UserMaxOrderByAggregateInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'userName' )
  final SortOrder? userName;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'password' )
  final SortOrder? password;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(userName !=null)userName!.toEntity(),if(name !=null)name!.toEntity(),if(password !=null)password!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),];
}
class UserMinOrderByAggregateInput {
  const UserMinOrderByAggregateInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'userName' )
  final SortOrder? userName;
  @JsonKey(name: 'name' )
  final SortOrder? name;
  @JsonKey(name: 'password' )
  final SortOrder? password;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(userName !=null)userName!.toEntity(),if(name !=null)name!.toEntity(),if(password !=null)password!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),];
}
class UserSumOrderByAggregateInput {
  const UserSumOrderByAggregateInput({
  this.id,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final SortOrder? id;
  @JsonKey(name: 'resturantId' )
  final SortOrder? resturantId;

List<Entity> toEntity()=>[if(id !=null)id!.toEntity(),if(resturantId !=null)resturantId!.toEntity(),];
}
class IntWithAggregatesFilter {
  const IntWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$avg,
  this.$sum,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_avg' )
  final NestedFloatFilter? $avg;
  @JsonKey(name: '_sum' )
  final NestedIntFilter? $sum;
  @JsonKey(name: '_min' )
  final NestedIntFilter? $min;
  @JsonKey(name: '_max' )
  final NestedIntFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($avg !=null)Entity("_avg",false,null,$avg!.toEntity(),),if($sum !=null)Entity("_sum",false,null,$sum!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class UserCreateNestedOneWithoutPostsInput {
  const UserCreateNestedOneWithoutPostsInput({
  this.create,
  this.connectOrCreate,
  this.connect,
  });

  @JsonKey(name: 'create' )
  final UserCreateWithoutPostsInput? create;
  @JsonKey(name: 'connectOrCreate' )
  final UserCreateOrConnectWithoutPostsInput? connectOrCreate;
  @JsonKey(name: 'connect' )
  final UserWhereUniqueInput? connect;

List<Entity> toEntity()=>[if(create !=null)Entity("create",false,null,create!.toEntity(),),if(connectOrCreate !=null)Entity("connectOrCreate",false,null,connectOrCreate!.toEntity(),),if(connect !=null)Entity("connect",false,null,connect!.toEntity(),),];
}
class StringFieldUpdateOperationsInput {
  const StringFieldUpdateOperationsInput({
  this.set$,
  });

  @JsonKey(name: 'set' )
  final String? set$;

List<Entity> toEntity()=>[if(set$ !=null)Entity("set",true,set$!,null,),];
}
class DateTimeFieldUpdateOperationsInput {
  const DateTimeFieldUpdateOperationsInput({
  this.set$,
  });

  @JsonKey(name: 'set' )
  final DateTime? set$;

List<Entity> toEntity()=>[if(set$ !=null)Entity("set",true,set$!,null,),];
}
class BoolFieldUpdateOperationsInput {
  const BoolFieldUpdateOperationsInput({
  this.set$,
  });

  @JsonKey(name: 'set' )
  final bool? set$;

List<Entity> toEntity()=>[if(set$ !=null)Entity("set",true,set$!,null,),];
}
class NullableStringFieldUpdateOperationsInput {
  const NullableStringFieldUpdateOperationsInput({
  this.set$,
  });

  @JsonKey(name: 'set' )
  final String? set$;

List<Entity> toEntity()=>[if(set$ !=null)Entity("set",true,set$!,null,),];
}
class UserUpdateOneWithoutPostsNestedInput {
  const UserUpdateOneWithoutPostsNestedInput({
  this.create,
  this.connectOrCreate,
  this.upsert,
  this.disconnect,
  this.delete,
  this.connect,
  this.update,
  });

  @JsonKey(name: 'create' )
  final UserCreateWithoutPostsInput? create;
  @JsonKey(name: 'connectOrCreate' )
  final UserCreateOrConnectWithoutPostsInput? connectOrCreate;
  @JsonKey(name: 'upsert' )
  final UserUpsertWithoutPostsInput? upsert;
  @JsonKey(name: 'disconnect' )
  final bool? disconnect;
  @JsonKey(name: 'delete' )
  final bool? delete;
  @JsonKey(name: 'connect' )
  final UserWhereUniqueInput? connect;
  @JsonKey(name: 'update' )
  final UserUpdateWithoutPostsInput? update;

List<Entity> toEntity()=>[if(create !=null)Entity("create",false,null,create!.toEntity(),),if(connectOrCreate !=null)Entity("connectOrCreate",false,null,connectOrCreate!.toEntity(),),if(upsert !=null)Entity("upsert",false,null,upsert!.toEntity(),),if(disconnect !=null)Entity("disconnect",true,disconnect!,null,),if(delete !=null)Entity("delete",true,delete!,null,),if(connect !=null)Entity("connect",false,null,connect!.toEntity(),),if(update !=null)Entity("update",false,null,update!.toEntity(),),];
}
class NullableIntFieldUpdateOperationsInput {
  const NullableIntFieldUpdateOperationsInput({
  this.set$,
  this.increment,
  this.decrement,
  this.multiply,
  this.divide,
  });

  @JsonKey(name: 'set' )
  final int? set$;
  @JsonKey(name: 'increment' )
  final int? increment;
  @JsonKey(name: 'decrement' )
  final int? decrement;
  @JsonKey(name: 'multiply' )
  final int? multiply;
  @JsonKey(name: 'divide' )
  final int? divide;

List<Entity> toEntity()=>[if(set$ !=null)Entity("set",true,set$!,null,),if(increment !=null)Entity("increment",true,increment!,null,),if(decrement !=null)Entity("decrement",true,decrement!,null,),if(multiply !=null)Entity("multiply",true,multiply!,null,),if(divide !=null)Entity("divide",true,divide!,null,),];
}
class PostCreateNestedManyWithoutUserInput {
  const PostCreateNestedManyWithoutUserInput({
  this.create,
  this.connectOrCreate,
  this.connect,
  });

  @JsonKey(name: 'create' )
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate' )
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'connect' )
  final List<PostWhereUniqueInput>? connect;

List<Entity> toEntity()=>[if(create !=null)Entity("create",false,null,create!.map((e) => Entity("create", false, null, e.toEntity())).toList(),),if(connectOrCreate !=null)Entity("connectOrCreate",false,null,connectOrCreate!.map((e) => Entity("connectOrCreate", false, null, e.toEntity())).toList(),),if(connect !=null)Entity("connect",false,null,connect!.map((e) => Entity("connect", false, null, e.toEntity())).toList(),),];
}
class PostUncheckedCreateNestedManyWithoutUserInput {
  const PostUncheckedCreateNestedManyWithoutUserInput({
  this.create,
  this.connectOrCreate,
  this.connect,
  });

  @JsonKey(name: 'create' )
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate' )
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'connect' )
  final List<PostWhereUniqueInput>? connect;

List<Entity> toEntity()=>[if(create !=null)Entity("create",false,null,create!.map((e) => Entity("create", false, null, e.toEntity())).toList(),),if(connectOrCreate !=null)Entity("connectOrCreate",false,null,connectOrCreate!.map((e) => Entity("connectOrCreate", false, null, e.toEntity())).toList(),),if(connect !=null)Entity("connect",false,null,connect!.map((e) => Entity("connect", false, null, e.toEntity())).toList(),),];
}
class PostUpdateManyWithoutUserNestedInput {
  const PostUpdateManyWithoutUserNestedInput({
  this.create,
  this.connectOrCreate,
  this.upsert,
  this.set$,
  this.disconnect,
  this.delete,
  this.connect,
  this.update,
  this.updateMany,
  this.deleteMany,
  });

  @JsonKey(name: 'create' )
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate' )
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'upsert' )
  final List<PostUpsertWithWhereUniqueWithoutUserInput>? upsert;
  @JsonKey(name: 'set' )
  final List<PostWhereUniqueInput>? set$;
  @JsonKey(name: 'disconnect' )
  final List<PostWhereUniqueInput>? disconnect;
  @JsonKey(name: 'delete' )
  final List<PostWhereUniqueInput>? delete;
  @JsonKey(name: 'connect' )
  final List<PostWhereUniqueInput>? connect;
  @JsonKey(name: 'update' )
  final List<PostUpdateWithWhereUniqueWithoutUserInput>? update;
  @JsonKey(name: 'updateMany' )
  final List<PostUpdateManyWithWhereWithoutUserInput>? updateMany;
  @JsonKey(name: 'deleteMany' )
  final List<PostScalarWhereInput>? deleteMany;

List<Entity> toEntity()=>[if(create !=null)Entity("create",false,null,create!.map((e) => Entity("create", false, null, e.toEntity())).toList(),),if(connectOrCreate !=null)Entity("connectOrCreate",false,null,connectOrCreate!.map((e) => Entity("connectOrCreate", false, null, e.toEntity())).toList(),),if(upsert !=null)Entity("upsert",false,null,upsert!.map((e) => Entity("upsert", false, null, e.toEntity())).toList(),),if(set$ !=null)Entity("set",false,null,set$!.map((e) => Entity("set", false, null, e.toEntity())).toList(),),if(disconnect !=null)Entity("disconnect",false,null,disconnect!.map((e) => Entity("disconnect", false, null, e.toEntity())).toList(),),if(delete !=null)Entity("delete",false,null,delete!.map((e) => Entity("delete", false, null, e.toEntity())).toList(),),if(connect !=null)Entity("connect",false,null,connect!.map((e) => Entity("connect", false, null, e.toEntity())).toList(),),if(update !=null)Entity("update",false,null,update!.map((e) => Entity("update", false, null, e.toEntity())).toList(),),if(updateMany !=null)Entity("updateMany",false,null,updateMany!.map((e) => Entity("updateMany", false, null, e.toEntity())).toList(),),if(deleteMany !=null)Entity("deleteMany",false,null,deleteMany!.map((e) => Entity("deleteMany", false, null, e.toEntity())).toList(),),];
}
class IntFieldUpdateOperationsInput {
  const IntFieldUpdateOperationsInput({
  this.set$,
  this.increment,
  this.decrement,
  this.multiply,
  this.divide,
  });

  @JsonKey(name: 'set' )
  final int? set$;
  @JsonKey(name: 'increment' )
  final int? increment;
  @JsonKey(name: 'decrement' )
  final int? decrement;
  @JsonKey(name: 'multiply' )
  final int? multiply;
  @JsonKey(name: 'divide' )
  final int? divide;

List<Entity> toEntity()=>[if(set$ !=null)Entity("set",true,set$!,null,),if(increment !=null)Entity("increment",true,increment!,null,),if(decrement !=null)Entity("decrement",true,decrement!,null,),if(multiply !=null)Entity("multiply",true,multiply!,null,),if(divide !=null)Entity("divide",true,divide!,null,),];
}
class PostUncheckedUpdateManyWithoutUserNestedInput {
  const PostUncheckedUpdateManyWithoutUserNestedInput({
  this.create,
  this.connectOrCreate,
  this.upsert,
  this.set$,
  this.disconnect,
  this.delete,
  this.connect,
  this.update,
  this.updateMany,
  this.deleteMany,
  });

  @JsonKey(name: 'create' )
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate' )
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'upsert' )
  final List<PostUpsertWithWhereUniqueWithoutUserInput>? upsert;
  @JsonKey(name: 'set' )
  final List<PostWhereUniqueInput>? set$;
  @JsonKey(name: 'disconnect' )
  final List<PostWhereUniqueInput>? disconnect;
  @JsonKey(name: 'delete' )
  final List<PostWhereUniqueInput>? delete;
  @JsonKey(name: 'connect' )
  final List<PostWhereUniqueInput>? connect;
  @JsonKey(name: 'update' )
  final List<PostUpdateWithWhereUniqueWithoutUserInput>? update;
  @JsonKey(name: 'updateMany' )
  final List<PostUpdateManyWithWhereWithoutUserInput>? updateMany;
  @JsonKey(name: 'deleteMany' )
  final List<PostScalarWhereInput>? deleteMany;

List<Entity> toEntity()=>[if(create !=null)Entity("create",false,null,create!.map((e) => Entity("create", false, null, e.toEntity())).toList(),),if(connectOrCreate !=null)Entity("connectOrCreate",false,null,connectOrCreate!.map((e) => Entity("connectOrCreate", false, null, e.toEntity())).toList(),),if(upsert !=null)Entity("upsert",false,null,upsert!.map((e) => Entity("upsert", false, null, e.toEntity())).toList(),),if(set$ !=null)Entity("set",false,null,set$!.map((e) => Entity("set", false, null, e.toEntity())).toList(),),if(disconnect !=null)Entity("disconnect",false,null,disconnect!.map((e) => Entity("disconnect", false, null, e.toEntity())).toList(),),if(delete !=null)Entity("delete",false,null,delete!.map((e) => Entity("delete", false, null, e.toEntity())).toList(),),if(connect !=null)Entity("connect",false,null,connect!.map((e) => Entity("connect", false, null, e.toEntity())).toList(),),if(update !=null)Entity("update",false,null,update!.map((e) => Entity("update", false, null, e.toEntity())).toList(),),if(updateMany !=null)Entity("updateMany",false,null,updateMany!.map((e) => Entity("updateMany", false, null, e.toEntity())).toList(),),if(deleteMany !=null)Entity("deleteMany",false,null,deleteMany!.map((e) => Entity("deleteMany", false, null, e.toEntity())).toList(),),];
}
class NestedStringFilter {
  const NestedStringFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedDateTimeFilter {
  const NestedDateTimeFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final DateTime? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedBoolFilter {
  const NestedBoolFilter({
  this.equals,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final bool? equals;
  @JsonKey(name: 'not' )
  final bool? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedStringNullableFilter {
  const NestedStringNullableFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedIntNullableFilter {
  const NestedIntNullableFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedStringWithAggregatesFilter {
  const NestedStringWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedStringFilter? $min;
  @JsonKey(name: '_max' )
  final NestedStringFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class NestedIntFilter {
  const NestedIntFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedDateTimeWithAggregatesFilter {
  const NestedDateTimeWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final DateTime? equals;
  @JsonKey(name: 'in' )
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn' )
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt' )
  final DateTime? lt;
  @JsonKey(name: 'lte' )
  final DateTime? lte;
  @JsonKey(name: 'gt' )
  final DateTime? gt;
  @JsonKey(name: 'gte' )
  final DateTime? gte;
  @JsonKey(name: 'not' )
  final DateTime? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedDateTimeFilter? $min;
  @JsonKey(name: '_max' )
  final NestedDateTimeFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class NestedBoolWithAggregatesFilter {
  const NestedBoolWithAggregatesFilter({
  this.equals,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final bool? equals;
  @JsonKey(name: 'not' )
  final bool? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_min' )
  final NestedBoolFilter? $min;
  @JsonKey(name: '_max' )
  final NestedBoolFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class NestedStringNullableWithAggregatesFilter {
  const NestedStringNullableWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.contains,
  this.startsWith,
  this.endsWith,
  this.not,
  this.$count,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final String? equals;
  @JsonKey(name: 'in' )
  final List<String>? in$;
  @JsonKey(name: 'notIn' )
  final List<String>? notIn;
  @JsonKey(name: 'lt' )
  final String? lt;
  @JsonKey(name: 'lte' )
  final String? lte;
  @JsonKey(name: 'gt' )
  final String? gt;
  @JsonKey(name: 'gte' )
  final String? gte;
  @JsonKey(name: 'contains' )
  final String? contains;
  @JsonKey(name: 'startsWith' )
  final String? startsWith;
  @JsonKey(name: 'endsWith' )
  final String? endsWith;
  @JsonKey(name: 'not' )
  final String? not;
  @JsonKey(name: '_count' )
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_min' )
  final NestedStringNullableFilter? $min;
  @JsonKey(name: '_max' )
  final NestedStringNullableFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(contains !=null)Entity("contains",true,contains!,null,),if(startsWith !=null)Entity("startsWith",true,startsWith!,null,),if(endsWith !=null)Entity("endsWith",true,endsWith!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class NestedIntNullableWithAggregatesFilter {
  const NestedIntNullableWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$avg,
  this.$sum,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;
  @JsonKey(name: '_count' )
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_avg' )
  final NestedFloatNullableFilter? $avg;
  @JsonKey(name: '_sum' )
  final NestedIntNullableFilter? $sum;
  @JsonKey(name: '_min' )
  final NestedIntNullableFilter? $min;
  @JsonKey(name: '_max' )
  final NestedIntNullableFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($avg !=null)Entity("_avg",false,null,$avg!.toEntity(),),if($sum !=null)Entity("_sum",false,null,$sum!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class NestedFloatNullableFilter {
  const NestedFloatNullableFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final double? equals;
  @JsonKey(name: 'in' )
  final List<double>? in$;
  @JsonKey(name: 'notIn' )
  final List<double>? notIn;
  @JsonKey(name: 'lt' )
  final double? lt;
  @JsonKey(name: 'lte' )
  final double? lte;
  @JsonKey(name: 'gt' )
  final double? gt;
  @JsonKey(name: 'gte' )
  final double? gte;
  @JsonKey(name: 'not' )
  final double? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class NestedIntWithAggregatesFilter {
  const NestedIntWithAggregatesFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  this.$count,
  this.$avg,
  this.$sum,
  this.$min,
  this.$max,
  });

  @JsonKey(name: 'equals' )
  final int? equals;
  @JsonKey(name: 'in' )
  final List<int>? in$;
  @JsonKey(name: 'notIn' )
  final List<int>? notIn;
  @JsonKey(name: 'lt' )
  final int? lt;
  @JsonKey(name: 'lte' )
  final int? lte;
  @JsonKey(name: 'gt' )
  final int? gt;
  @JsonKey(name: 'gte' )
  final int? gte;
  @JsonKey(name: 'not' )
  final int? not;
  @JsonKey(name: '_count' )
  final NestedIntFilter? $count;
  @JsonKey(name: '_avg' )
  final NestedFloatFilter? $avg;
  @JsonKey(name: '_sum' )
  final NestedIntFilter? $sum;
  @JsonKey(name: '_min' )
  final NestedIntFilter? $min;
  @JsonKey(name: '_max' )
  final NestedIntFilter? $max;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),if($count !=null)Entity("_count",false,null,$count!.toEntity(),),if($avg !=null)Entity("_avg",false,null,$avg!.toEntity(),),if($sum !=null)Entity("_sum",false,null,$sum!.toEntity(),),if($min !=null)Entity("_min",false,null,$min!.toEntity(),),if($max !=null)Entity("_max",false,null,$max!.toEntity(),),];
}
class NestedFloatFilter {
  const NestedFloatFilter({
  this.equals,
  this.in$,
  this.notIn,
  this.lt,
  this.lte,
  this.gt,
  this.gte,
  this.not,
  });

  @JsonKey(name: 'equals' )
  final double? equals;
  @JsonKey(name: 'in' )
  final List<double>? in$;
  @JsonKey(name: 'notIn' )
  final List<double>? notIn;
  @JsonKey(name: 'lt' )
  final double? lt;
  @JsonKey(name: 'lte' )
  final double? lte;
  @JsonKey(name: 'gt' )
  final double? gt;
  @JsonKey(name: 'gte' )
  final double? gte;
  @JsonKey(name: 'not' )
  final double? not;

List<Entity> toEntity()=>[if(equals !=null)Entity("equals",true,equals!,null,),if(in$ !=null)Entity("in",true,in$!,null,),if(notIn !=null)Entity("notIn",true,notIn!,null,),if(lt !=null)Entity("lt",true,lt!,null,),if(lte !=null)Entity("lte",true,lte!,null,),if(gt !=null)Entity("gt",true,gt!,null,),if(gte !=null)Entity("gte",true,gte!,null,),if(not !=null)Entity("not",true,not!,null,),];
}
class UserCreateWithoutPostsInput {
  const UserCreateWithoutPostsInput({
 required this.userName,
 required this.name,
 required this.password,
  this.resturantId,
  });

  @JsonKey(name: 'userName' )
  final String userName;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'password' )
  final String password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

List<Entity> toEntity()=>[Entity("userName",true,userName,null,),Entity("name",true,name,null,),Entity("password",true,password,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),];
}
class UserUncheckedCreateWithoutPostsInput {
  const UserUncheckedCreateWithoutPostsInput({
  this.id,
 required this.userName,
 required this.name,
 required this.password,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String userName;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'password' )
  final String password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),Entity("userName",true,userName,null,),Entity("name",true,name,null,),Entity("password",true,password,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),];
}
class UserCreateOrConnectWithoutPostsInput {
  const UserCreateOrConnectWithoutPostsInput({
 required this.where,
 required this.create,
  });

  @JsonKey(name: 'where' )
  final UserWhereUniqueInput where;
  @JsonKey(name: 'create' )
  final UserCreateWithoutPostsInput create;

List<Entity> toEntity()=>[Entity("where",false,null,where.toEntity(),),Entity("create",false,null,create.toEntity(),),];
}
class UserUpsertWithoutPostsInput {
  const UserUpsertWithoutPostsInput({
 required this.update,
 required this.create,
  });

  @JsonKey(name: 'update' )
  final UserUpdateWithoutPostsInput update;
  @JsonKey(name: 'create' )
  final UserCreateWithoutPostsInput create;

List<Entity> toEntity()=>[Entity("update",false,null,update.toEntity(),),Entity("create",false,null,create.toEntity(),),];
}
class UserUpdateWithoutPostsInput {
  const UserUpdateWithoutPostsInput({
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

List<Entity> toEntity()=>[if(userName !=null)Entity("userName",true,userName!,null,),if(name !=null)Entity("name",true,name!,null,),if(password !=null)Entity("password",true,password!,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),];
}
class UserUncheckedUpdateWithoutPostsInput {
  const UserUncheckedUpdateWithoutPostsInput({
  this.id,
  this.userName,
  this.name,
  this.password,
  this.resturantId,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(userName !=null)Entity("userName",true,userName!,null,),if(name !=null)Entity("name",true,name!,null,),if(password !=null)Entity("password",true,password!,null,),if(resturantId !=null)Entity("resturantId",true,resturantId!,null,),];
}
class PostCreateWithoutUserInput {
  const PostCreateWithoutUserInput({
  this.id,
  this.createdAt,
  this.updatedAt,
 required this.title,
 required this.published,
  this.desc,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'published' )
  final bool published;
  @JsonKey(name: 'desc' )
  final String? desc;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),Entity("title",true,title,null,),Entity("published",true,published,null,),if(desc !=null)Entity("desc",true,desc!,null,),];
}
class PostUncheckedCreateWithoutUserInput {
  const PostUncheckedCreateWithoutUserInput({
  this.id,
  this.createdAt,
  this.updatedAt,
 required this.title,
 required this.published,
  this.desc,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'published' )
  final bool published;
  @JsonKey(name: 'desc' )
  final String? desc;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),Entity("title",true,title,null,),Entity("published",true,published,null,),if(desc !=null)Entity("desc",true,desc!,null,),];
}
class PostCreateOrConnectWithoutUserInput {
  const PostCreateOrConnectWithoutUserInput({
 required this.where,
 required this.create,
  });

  @JsonKey(name: 'where' )
  final PostWhereUniqueInput where;
  @JsonKey(name: 'create' )
  final PostCreateWithoutUserInput create;

List<Entity> toEntity()=>[Entity("where",false,null,where.toEntity(),),Entity("create",false,null,create.toEntity(),),];
}
class PostUpsertWithWhereUniqueWithoutUserInput {
  const PostUpsertWithWhereUniqueWithoutUserInput({
 required this.where,
 required this.update,
 required this.create,
  });

  @JsonKey(name: 'where' )
  final PostWhereUniqueInput where;
  @JsonKey(name: 'update' )
  final PostUpdateWithoutUserInput update;
  @JsonKey(name: 'create' )
  final PostCreateWithoutUserInput create;

List<Entity> toEntity()=>[Entity("where",false,null,where.toEntity(),),Entity("update",false,null,update.toEntity(),),Entity("create",false,null,create.toEntity(),),];
}
class PostUpdateWithWhereUniqueWithoutUserInput {
  const PostUpdateWithWhereUniqueWithoutUserInput({
 required this.where,
 required this.data,
  });

  @JsonKey(name: 'where' )
  final PostWhereUniqueInput where;
  @JsonKey(name: 'data' )
  final PostUpdateWithoutUserInput data;

List<Entity> toEntity()=>[Entity("where",false,null,where.toEntity(),),Entity("data",false,null,data.toEntity(),),];
}
class PostUpdateManyWithWhereWithoutUserInput {
  const PostUpdateManyWithWhereWithoutUserInput({
 required this.where,
 required this.data,
  });

  @JsonKey(name: 'where' )
  final PostScalarWhereInput where;
  @JsonKey(name: 'data' )
  final PostUpdateManyMutationInput data;

List<Entity> toEntity()=>[Entity("where",false,null,where.toEntity(),),Entity("data",false,null,data.toEntity(),),];
}
class PostScalarWhereInput {
  const PostScalarWhereInput({
  this.aND,
  this.oR,
  this.nOT,
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  this.userId,
  });

  @JsonKey(name: 'AND' )
  final List<PostScalarWhereInput>? aND;
  @JsonKey(name: 'OR' )
  final List<PostScalarWhereInput>? oR;
  @JsonKey(name: 'NOT' )
  final List<PostScalarWhereInput>? nOT;
  @JsonKey(name: 'id' )
  final StringFilter? id;
  @JsonKey(name: 'createdAt' )
  final DateTimeFilter? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTimeFilter? updatedAt;
  @JsonKey(name: 'title' )
  final StringFilter? title;
  @JsonKey(name: 'published' )
  final BoolFilter? published;
  @JsonKey(name: 'desc' )
  final StringNullableFilter? desc;
  @JsonKey(name: 'userId' )
  final IntNullableFilter? userId;

List<Entity> toEntity()=>[if(aND !=null)Entity("AND",false,null,aND!.map((e) => Entity("AND", false, null, e.toEntity())).toList(),),if(oR !=null)Entity("OR",false,null,oR!.map((e) => Entity("OR", false, null, e.toEntity())).toList(),),if(nOT !=null)Entity("NOT",false,null,nOT!.map((e) => Entity("NOT", false, null, e.toEntity())).toList(),),if(id !=null)Entity("id",false,null,id!.toEntity(),),if(createdAt !=null)Entity("createdAt",false,null,createdAt!.toEntity(),),if(updatedAt !=null)Entity("updatedAt",false,null,updatedAt!.toEntity(),),if(title !=null)Entity("title",false,null,title!.toEntity(),),if(published !=null)Entity("published",false,null,published!.toEntity(),),if(desc !=null)Entity("desc",false,null,desc!.toEntity(),),if(userId !=null)Entity("userId",false,null,userId!.toEntity(),),];
}
class PostUpdateWithoutUserInput {
  const PostUpdateWithoutUserInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),];
}
class PostUncheckedUpdateWithoutUserInput {
  const PostUncheckedUpdateWithoutUserInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),];
}
class PostUncheckedUpdateManyWithoutPostsInput {
  const PostUncheckedUpdateManyWithoutPostsInput({
  this.id,
  this.createdAt,
  this.updatedAt,
  this.title,
  this.published,
  this.desc,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;

List<Entity> toEntity()=>[if(id !=null)Entity("id",true,id!,null,),if(createdAt !=null)Entity("createdAt",true,createdAt!,null,),if(updatedAt !=null)Entity("updatedAt",true,updatedAt!,null,),if(title !=null)Entity("title",true,title!,null,),if(published !=null)Entity("published",true,published!,null,),if(desc !=null)Entity("desc",true,desc!,null,),];
}



@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class AggregatePost {
  const AggregatePost({
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: '_count' )
  final PostCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final PostAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final PostSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final PostMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final PostMaxAggregateOutputType? $max;

  factory AggregatePost.fromJson(Map<String, dynamic> json) =>
    _$AggregatePostFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class PostGroupByOutputType {
  const PostGroupByOutputType({
   required  this.id,
   required  this.createdAt,
   required  this.updatedAt,
   required  this.title,
   required  this.published,
     this.desc,
     this.userId,
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: 'id' )
  final String id;
  @JsonKey(name: 'createdAt' )
  final DateTime createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime updatedAt;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'published' )
  final bool published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'userId' )
  final int? userId;
  @JsonKey(name: '_count' )
  final PostCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final PostAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final PostSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final PostMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final PostMaxAggregateOutputType? $max;

  factory PostGroupByOutputType.fromJson(Map<String, dynamic> json) =>
    _$PostGroupByOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class AggregateUser {
  const AggregateUser({
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: '_count' )
  final UserCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final UserAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final UserSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final UserMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final UserMaxAggregateOutputType? $max;

  factory AggregateUser.fromJson(Map<String, dynamic> json) =>
    _$AggregateUserFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserGroupByOutputType {
  const UserGroupByOutputType({
   required  this.id,
   required  this.userName,
   required  this.name,
   required  this.password,
     this.resturantId,
     this.$count,
     this.$avg,
     this.$sum,
     this.$min,
     this.$max,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'userName' )
  final String userName;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'password' )
  final String password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;
  @JsonKey(name: '_count' )
  final UserCountAggregateOutputType? $count;
  @JsonKey(name: '_avg' )
  final UserAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum' )
  final UserSumAggregateOutputType? $sum;
  @JsonKey(name: '_min' )
  final UserMinAggregateOutputType? $min;
  @JsonKey(name: '_max' )
  final UserMaxAggregateOutputType? $max;

  factory UserGroupByOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserGroupByOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class AffectedRowsOutput {
  const AffectedRowsOutput({
   required  this.count,
  });

  @JsonKey(name: 'count' )
  final int count;

  factory AffectedRowsOutput.fromJson(Map<String, dynamic> json) =>
    _$AffectedRowsOutputFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class PostCountAggregateOutputType {
  const PostCountAggregateOutputType({
   required  this.id,
   required  this.createdAt,
   required  this.updatedAt,
   required  this.title,
   required  this.published,
   required  this.desc,
   required  this.userId,
   required  this.$all,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'createdAt' )
  final int createdAt;
  @JsonKey(name: 'updatedAt' )
  final int updatedAt;
  @JsonKey(name: 'title' )
  final int title;
  @JsonKey(name: 'published' )
  final int published;
  @JsonKey(name: 'desc' )
  final int desc;
  @JsonKey(name: 'userId' )
  final int userId;
  @JsonKey(name: '_all' )
  final int $all;

  factory PostCountAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$PostCountAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class PostAvgAggregateOutputType {
  const PostAvgAggregateOutputType({
     this.userId,
  });

  @JsonKey(name: 'userId' )
  final double? userId;

  factory PostAvgAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$PostAvgAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class PostSumAggregateOutputType {
  const PostSumAggregateOutputType({
     this.userId,
  });

  @JsonKey(name: 'userId' )
  final int? userId;

  factory PostSumAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$PostSumAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class PostMinAggregateOutputType {
  const PostMinAggregateOutputType({
     this.id,
     this.createdAt,
     this.updatedAt,
     this.title,
     this.published,
     this.desc,
     this.userId,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'userId' )
  final int? userId;

  factory PostMinAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$PostMinAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class PostMaxAggregateOutputType {
  const PostMaxAggregateOutputType({
     this.id,
     this.createdAt,
     this.updatedAt,
     this.title,
     this.published,
     this.desc,
     this.userId,
  });

  @JsonKey(name: 'id' )
  final String? id;
  @JsonKey(name: 'createdAt' )
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime? updatedAt;
  @JsonKey(name: 'title' )
  final String? title;
  @JsonKey(name: 'published' )
  final bool? published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'userId' )
  final int? userId;

  factory PostMaxAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$PostMaxAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserCountOutputType {
  const UserCountOutputType({
   required  this.posts,
  });

  @JsonKey(name: 'posts' )
  final int posts;

  factory UserCountOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserCountOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserCountAggregateOutputType {
  const UserCountAggregateOutputType({
   required  this.id,
   required  this.userName,
   required  this.name,
   required  this.password,
   required  this.resturantId,
   required  this.$all,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'userName' )
  final int userName;
  @JsonKey(name: 'name' )
  final int name;
  @JsonKey(name: 'password' )
  final int password;
  @JsonKey(name: 'resturantId' )
  final int resturantId;
  @JsonKey(name: '_all' )
  final int $all;

  factory UserCountAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserCountAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserAvgAggregateOutputType {
  const UserAvgAggregateOutputType({
     this.id,
     this.resturantId,
  });

  @JsonKey(name: 'id' )
  final double? id;
  @JsonKey(name: 'resturantId' )
  final double? resturantId;

  factory UserAvgAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserAvgAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserSumAggregateOutputType {
  const UserSumAggregateOutputType({
     this.id,
     this.resturantId,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

  factory UserSumAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserSumAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserMinAggregateOutputType {
  const UserMinAggregateOutputType({
     this.id,
     this.userName,
     this.name,
     this.password,
     this.resturantId,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

  factory UserMinAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserMinAggregateOutputTypeFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType({
     this.id,
     this.userName,
     this.name,
     this.password,
     this.resturantId,
  });

  @JsonKey(name: 'id' )
  final int? id;
  @JsonKey(name: 'userName' )
  final String? userName;
  @JsonKey(name: 'name' )
  final String? name;
  @JsonKey(name: 'password' )
  final String? password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;

  factory UserMaxAggregateOutputType.fromJson(Map<String, dynamic> json) =>
    _$UserMaxAggregateOutputTypeFromJson(json);

}

@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class Post {
  const Post({
   required  this.id,
   required  this.createdAt,
   required  this.updatedAt,
   required  this.title,
   required  this.published,
     this.desc,
     this.user,
     this.userId,
  });

  @JsonKey(name: 'id' )
  final String id;
  @JsonKey(name: 'createdAt' )
  final DateTime createdAt;
  @JsonKey(name: 'updatedAt' )
  final DateTime updatedAt;
  @JsonKey(name: 'title' )
  final String title;
  @JsonKey(name: 'published' )
  final bool published;
  @JsonKey(name: 'desc' )
  final String? desc;
  @JsonKey(name: 'User' )
  final User? user;
  @JsonKey(name: 'userId' )
  final int? userId;

  factory Post.fromJson(Map<String, dynamic> json) =>
    _$PostFromJson(json);

}
@JsonSerializable(explicitToJson: true, createFactory: true, createToJson: false)
class User {
  const User({
   required  this.id,
   required  this.userName,
   required  this.name,
   required  this.password,
     this.resturantId,
     this.posts,
   required  this.$count,
  });

  @JsonKey(name: 'id' )
  final int id;
  @JsonKey(name: 'userName' )
  final String userName;
  @JsonKey(name: 'name' )
  final String name;
  @JsonKey(name: 'password' )
  final String password;
  @JsonKey(name: 'resturantId' )
  final int? resturantId;
  @JsonKey(name: 'posts' )
  final List<Post>? posts;
  @JsonKey(name: '_count' )
  final UserCountOutputType $count;

  factory User.fromJson(Map<String, dynamic> json) =>
    _$UserFromJson(json);

}



class PostModel {
  static const String model = "Post";
final Engine engine;
PostModel(this.engine);
static const  _outputField = [Output("id",[],[]),Output("createdAt",[],[]),Output("updatedAt",[],[]),Output("title",[],[]),Output("published",[],[]),Output("desc",[],[]),Output("userId",[],[])];
Future<Post?> findUnique({
    required  PostWhereUniqueInput where,
}
){
final entity=[Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "findUnique",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Post.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Post?> findFirst({
      PostWhereInput? where,
      List<PostOrderByWithRelationInput>? orderBy,
      PostWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<PostScalarFieldEnum>? distinct,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),if(cursor !=null)Entity("cursor",false,null,cursor.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),if(distinct !=null)Entity("distinct",false,distinct.map((e) =>e.value).toList(),null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "findFirst",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Post.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<Post>> findMany({
      PostWhereInput? where,
      List<PostOrderByWithRelationInput>? orderBy,
      PostWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<PostScalarFieldEnum>? distinct,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),if(cursor !=null)Entity("cursor",false,null,cursor.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),if(distinct !=null)Entity("distinct",false,distinct.map((e) =>e.value).toList(),null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "findMany",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return Post.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}Future<Post> createOne({
    required  PostCreateInput data,
}
){
final entity=[Entity("data",false,null,data.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "createOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return Post.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Post?> updateOne({
    required  PostUpdateInput data,
    required  PostWhereUniqueInput where,
}
){
final entity=[Entity("data",false,null,data.toEntity(),),Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "updateOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Post.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> updateMany({
    required  PostUpdateManyMutationInput data,
      PostWhereInput? where,
}
){
final entity=[Entity("data",false,null,data.toEntity(),),if(where !=null)Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "updateMany",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Post> upsertOne({
    required  PostWhereUniqueInput where,
    required  PostCreateInput create,
    required  PostUpdateInput update,
}
){
final entity=[Entity("where",false,null,where.toEntity(),),Entity("create",false,null,create.toEntity(),),Entity("update",false,null,update.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "upsertOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return Post.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<Post?> deleteOne({
    required  PostWhereUniqueInput where,
}
){
final entity=[Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "deleteOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return Post.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> deleteMany({
      PostWhereInput? where,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "deleteMany",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AggregatePost> aggregate({
      PostWhereInput? where,
      List<PostOrderByWithRelationInput>? orderBy,
      PostWhereUniqueInput? cursor,
      int? take,
      int? skip,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),if(cursor !=null)Entity("cursor",false,null,cursor.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "aggregate",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AggregatePost.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<PostGroupByOutputType>> groupBy({
      PostWhereInput? where,
      List<PostOrderByWithAggregationInput>? orderBy,
    required  List<PostScalarFieldEnum> by,
      PostScalarWhereWithAggregatesInput? having,
      int? take,
      int? skip,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),Entity("by",false,by.map((e) =>e.value).toList(),null,),if(having !=null)Entity("having",false,null,having.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "groupBy",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return PostGroupByOutputType.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}
}
class UserModel {
  static const String model = "User";
final Engine engine;
UserModel(this.engine);
static const  _outputField = [Output("id",[],[]),Output("userName",[],[]),Output("name",[],[]),Output("password",[],[]),Output("resturantId",[],[])];
Future<User?> findUnique({
    required  UserWhereUniqueInput where,
}
){
final entity=[Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "findUnique",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User?> findFirst({
      UserWhereInput? where,
      List<UserOrderByWithRelationInput>? orderBy,
      UserWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<UserScalarFieldEnum>? distinct,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),if(cursor !=null)Entity("cursor",false,null,cursor.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),if(distinct !=null)Entity("distinct",false,distinct.map((e) =>e.value).toList(),null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "findFirst",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<User>> findMany({
      UserWhereInput? where,
      List<UserOrderByWithRelationInput>? orderBy,
      UserWhereUniqueInput? cursor,
      int? take,
      int? skip,
      List<UserScalarFieldEnum>? distinct,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),if(cursor !=null)Entity("cursor",false,null,cursor.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),if(distinct !=null)Entity("distinct",false,distinct.map((e) =>e.value).toList(),null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "findMany",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return User.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}Future<User> createOne({
    required  UserCreateInput data,
}
){
final entity=[Entity("data",false,null,data.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "createOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User?> updateOne({
    required  UserUpdateInput data,
    required  UserWhereUniqueInput where,
}
){
final entity=[Entity("data",false,null,data.toEntity(),),Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "updateOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> updateMany({
    required  UserUpdateManyMutationInput data,
      UserWhereInput? where,
}
){
final entity=[Entity("data",false,null,data.toEntity(),),if(where !=null)Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "updateMany",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User> upsertOne({
    required  UserWhereUniqueInput where,
    required  UserCreateInput create,
    required  UserUpdateInput update,
}
){
final entity=[Entity("where",false,null,where.toEntity(),),Entity("create",false,null,create.toEntity(),),Entity("update",false,null,update.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "upsertOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<User?> deleteOne({
    required  UserWhereUniqueInput where,
}
){
final entity=[Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "deleteOne",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null){return null;}return User.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AffectedRowsOutput> deleteMany({
      UserWhereInput? where,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "deleteMany",
      operation: "mutation",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<AggregateUser> aggregate({
      UserWhereInput? where,
      List<UserOrderByWithRelationInput>? orderBy,
      UserWhereUniqueInput? cursor,
      int? take,
      int? skip,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),if(cursor !=null)Entity("cursor",false,null,cursor.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "aggregate",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      return AggregateUser.fromJson(value.data!.result! as Map<String,dynamic>);
   }
     );     

}Future<List<UserGroupByOutputType>> groupBy({
      UserWhereInput? where,
      List<UserOrderByWithAggregationInput>? orderBy,
    required  List<UserScalarFieldEnum> by,
      UserScalarWhereWithAggregatesInput? having,
      int? take,
      int? skip,
}
){
final entity=[if(where !=null)Entity("where",false,null,where.toEntity(),),if(orderBy !=null)Entity("orderBy",false,null,orderBy.map((e) => Entity("orderBy", false, null, e.toEntity())).toList(),),Entity("by",false,by.map((e) =>e.value).toList(),null,),if(having !=null)Entity("having",false,null,having.toEntity(),),if(take !=null)Entity("take",true,take,null,),if(skip !=null)Entity("skip",true,skip,null,),];
    final Query query = Query(
      engine: engine,
      model: model,
      method: "groupBy",
      operation: "query",
      entity:entity,
      output: _outputField,
      name: ""
    );
    return query.exec().then((value) {
      if(value.data?.result==null) return []; return (value.data!.result! as List).map((e) {return UserGroupByOutputType.fromJson(value.data!.result! as Map<String,dynamic>);} ).toList();
   }
     );     

}
}
const schema='''// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-dart"
}


datasource db {
    // could be postgresql or mysql
    provider = "sqlite"
    url      = "file:dev.db"
}



model Post {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title     String
    published Boolean
    desc      String?

    User   User? @relation(fields: [userId], references: [id])
    userId Int?
}

model User {
    id          Int    @id @default(autoincrement())
    userName    String @unique
    name        String
    password    String
    resturantId Int?
    posts       Post[]
}
''';
