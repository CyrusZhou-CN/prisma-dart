// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: non_constant_identifier_names

import 'package:orm/orm.dart';
import 'package:json_annotation/json_annotation.dart';
import 'dart:convert';

part 'prisma_generated.g.dart';

//******************************************************************************
// This file was generated by Prisma ORM
// GitHub: https://github.com/odroe/prisma
//******************************************************************************

class PrismaClient {
  final Engine engine;

  // final PrismaActions action;
  PrismaClient._(this.engine);
  factory PrismaClient() => PrismaClient._(BinaryEngine(schema));

  late final post = PostModel(engine);
  late final user = UserModel(engine);
}

enum PostScalarFieldEnum implements PrismaEnum {
  id('id'),
  createdAt('createdAt'),
  updatedAt('updatedAt'),
  title('title'),
  published('published'),
  desc('desc'),
  userId('userId'),
  ;

  @override
  final String value;
  const PostScalarFieldEnum(this.value);
}

enum SortOrder implements PrismaEnum {
  asc('asc'),
  desc('desc'),
  ;

  @override
  final String value;
  const SortOrder(this.value);
}

enum TransactionIsolationLevel implements PrismaEnum {
  serializable('Serializable'),
  ;

  @override
  final String value;
  const TransactionIsolationLevel(this.value);
}

enum UserScalarFieldEnum implements PrismaEnum {
  id('id'),
  userName('userName'),
  name('name'),
  password('password'),
  resturantId('resturantId'),
  ;

  @override
  final String value;
  const UserScalarFieldEnum(this.value);
}

class PostWhereInput implements ToField {
  const PostWhereInput({
    this.aND,
    this.oR,
    this.nOT,
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.user,
    this.userId,
  });

  @JsonKey(name: 'AND')
  final List<PostWhereInput>? aND;
  @JsonKey(name: 'OR')
  final List<PostWhereInput>? oR;
  @JsonKey(name: 'NOT')
  final List<PostWhereInput>? nOT;
  @JsonKey(name: 'id')
  final StringFilter? id;
  @JsonKey(name: 'createdAt')
  final DateTimeFilter? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTimeFilter? updatedAt;
  @JsonKey(name: 'title')
  final StringFilter? title;
  @JsonKey(name: 'published')
  final BoolFilter? published;
  @JsonKey(name: 'desc')
  final StringNullableFilter? desc;
  @JsonKey(name: 'User')
  final UserRelationFilter? user;
  @JsonKey(name: 'userId')
  final IntNullableFilter? userId;

  @override
  List<Field> toFields() => [
        if (aND != null)
          Field(
            "AND",
            true,
            false,
            null,
            toObjectField(aND!),
          ),
        if (oR != null)
          Field(
            "OR",
            true,
            false,
            null,
            toObjectField(oR!),
          ),
        if (nOT != null)
          Field(
            "NOT",
            true,
            false,
            null,
            toObjectField(nOT!),
          ),
        if (id != null)
          Field(
            "id",
            false,
            false,
            null,
            id!.toFields(),
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            null,
            createdAt!.toFields(),
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            null,
            updatedAt!.toFields(),
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            null,
            title!.toFields(),
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            null,
            published!.toFields(),
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            null,
            desc!.toFields(),
          ),
        if (user != null)
          Field(
            "User",
            false,
            false,
            null,
            user!.toFields(),
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            null,
            userId!.toFields(),
          ),
      ];
}

class PostOrderByWithRelationInput implements ToField {
  const PostOrderByWithRelationInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.user,
    this.userId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt')
  final SortOrder? updatedAt;
  @JsonKey(name: 'title')
  final SortOrder? title;
  @JsonKey(name: 'published')
  final SortOrder? published;
  @JsonKey(name: 'desc')
  final SortOrder? desc;
  @JsonKey(name: 'User')
  final UserOrderByWithRelationInput? user;
  @JsonKey(name: 'userId')
  final SortOrder? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!.value,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!.value,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!.value,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!.value,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!.value,
            null,
          ),
        if (user != null)
          Field(
            "User",
            false,
            false,
            null,
            user!.toFields(),
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
      ];
}

class PostWhereUniqueInput implements ToField {
  const PostWhereUniqueInput({
    this.id,
  });

  @JsonKey(name: 'id')
  final String? id;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
      ];
}

class PostOrderByWithAggregationInput implements ToField {
  const PostOrderByWithAggregationInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt')
  final SortOrder? updatedAt;
  @JsonKey(name: 'title')
  final SortOrder? title;
  @JsonKey(name: 'published')
  final SortOrder? published;
  @JsonKey(name: 'desc')
  final SortOrder? desc;
  @JsonKey(name: 'userId')
  final SortOrder? userId;
  @JsonKey(name: '_count')
  final PostCountOrderByAggregateInput? $count;
  @JsonKey(name: '_avg')
  final PostAvgOrderByAggregateInput? $avg;
  @JsonKey(name: '_max')
  final PostMaxOrderByAggregateInput? $max;
  @JsonKey(name: '_min')
  final PostMinOrderByAggregateInput? $min;
  @JsonKey(name: '_sum')
  final PostSumOrderByAggregateInput? $sum;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!.value,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!.value,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!.value,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!.value,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!.value,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($avg != null)
          Field(
            "_avg",
            false,
            false,
            null,
            $avg!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($sum != null)
          Field(
            "_sum",
            false,
            false,
            null,
            $sum!.toFields(),
          ),
      ];
}

class PostScalarWhereWithAggregatesInput implements ToField {
  const PostScalarWhereWithAggregatesInput({
    this.aND,
    this.oR,
    this.nOT,
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'AND')
  final List<PostScalarWhereWithAggregatesInput>? aND;
  @JsonKey(name: 'OR')
  final List<PostScalarWhereWithAggregatesInput>? oR;
  @JsonKey(name: 'NOT')
  final List<PostScalarWhereWithAggregatesInput>? nOT;
  @JsonKey(name: 'id')
  final StringWithAggregatesFilter? id;
  @JsonKey(name: 'createdAt')
  final DateTimeWithAggregatesFilter? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTimeWithAggregatesFilter? updatedAt;
  @JsonKey(name: 'title')
  final StringWithAggregatesFilter? title;
  @JsonKey(name: 'published')
  final BoolWithAggregatesFilter? published;
  @JsonKey(name: 'desc')
  final StringNullableWithAggregatesFilter? desc;
  @JsonKey(name: 'userId')
  final IntNullableWithAggregatesFilter? userId;

  @override
  List<Field> toFields() => [
        if (aND != null)
          Field(
            "AND",
            true,
            false,
            null,
            toObjectField(aND!),
          ),
        if (oR != null)
          Field(
            "OR",
            true,
            false,
            null,
            toObjectField(oR!),
          ),
        if (nOT != null)
          Field(
            "NOT",
            true,
            false,
            null,
            toObjectField(nOT!),
          ),
        if (id != null)
          Field(
            "id",
            false,
            false,
            null,
            id!.toFields(),
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            null,
            createdAt!.toFields(),
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            null,
            updatedAt!.toFields(),
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            null,
            title!.toFields(),
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            null,
            published!.toFields(),
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            null,
            desc!.toFields(),
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            null,
            userId!.toFields(),
          ),
      ];
}

class UserWhereInput implements ToField {
  const UserWhereInput({
    this.aND,
    this.oR,
    this.nOT,
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
    this.posts,
  });

  @JsonKey(name: 'AND')
  final List<UserWhereInput>? aND;
  @JsonKey(name: 'OR')
  final List<UserWhereInput>? oR;
  @JsonKey(name: 'NOT')
  final List<UserWhereInput>? nOT;
  @JsonKey(name: 'id')
  final IntFilter? id;
  @JsonKey(name: 'userName')
  final StringFilter? userName;
  @JsonKey(name: 'name')
  final StringFilter? name;
  @JsonKey(name: 'password')
  final StringFilter? password;
  @JsonKey(name: 'resturantId')
  final IntNullableFilter? resturantId;
  @JsonKey(name: 'posts')
  final PostListRelationFilter? posts;

  @override
  List<Field> toFields() => [
        if (aND != null)
          Field(
            "AND",
            true,
            false,
            null,
            toObjectField(aND!),
          ),
        if (oR != null)
          Field(
            "OR",
            true,
            false,
            null,
            toObjectField(oR!),
          ),
        if (nOT != null)
          Field(
            "NOT",
            true,
            false,
            null,
            toObjectField(nOT!),
          ),
        if (id != null)
          Field(
            "id",
            false,
            false,
            null,
            id!.toFields(),
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            null,
            userName!.toFields(),
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            null,
            name!.toFields(),
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            null,
            password!.toFields(),
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            null,
            resturantId!.toFields(),
          ),
        if (posts != null)
          Field(
            "posts",
            false,
            false,
            null,
            posts!.toFields(),
          ),
      ];
}

class UserOrderByWithRelationInput implements ToField {
  const UserOrderByWithRelationInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
    this.posts,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'userName')
  final SortOrder? userName;
  @JsonKey(name: 'name')
  final SortOrder? name;
  @JsonKey(name: 'password')
  final SortOrder? password;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;
  @JsonKey(name: 'posts')
  final PostOrderByRelationAggregateInput? posts;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!.value,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!.value,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
        if (posts != null)
          Field(
            "posts",
            false,
            false,
            null,
            posts!.toFields(),
          ),
      ];
}

class UserWhereUniqueInput implements ToField {
  const UserWhereUniqueInput({
    this.id,
    this.userName,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String? userName;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
      ];
}

class UserOrderByWithAggregationInput implements ToField {
  const UserOrderByWithAggregationInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'userName')
  final SortOrder? userName;
  @JsonKey(name: 'name')
  final SortOrder? name;
  @JsonKey(name: 'password')
  final SortOrder? password;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;
  @JsonKey(name: '_count')
  final UserCountOrderByAggregateInput? $count;
  @JsonKey(name: '_avg')
  final UserAvgOrderByAggregateInput? $avg;
  @JsonKey(name: '_max')
  final UserMaxOrderByAggregateInput? $max;
  @JsonKey(name: '_min')
  final UserMinOrderByAggregateInput? $min;
  @JsonKey(name: '_sum')
  final UserSumOrderByAggregateInput? $sum;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!.value,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!.value,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($avg != null)
          Field(
            "_avg",
            false,
            false,
            null,
            $avg!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($sum != null)
          Field(
            "_sum",
            false,
            false,
            null,
            $sum!.toFields(),
          ),
      ];
}

class UserScalarWhereWithAggregatesInput implements ToField {
  const UserScalarWhereWithAggregatesInput({
    this.aND,
    this.oR,
    this.nOT,
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'AND')
  final List<UserScalarWhereWithAggregatesInput>? aND;
  @JsonKey(name: 'OR')
  final List<UserScalarWhereWithAggregatesInput>? oR;
  @JsonKey(name: 'NOT')
  final List<UserScalarWhereWithAggregatesInput>? nOT;
  @JsonKey(name: 'id')
  final IntWithAggregatesFilter? id;
  @JsonKey(name: 'userName')
  final StringWithAggregatesFilter? userName;
  @JsonKey(name: 'name')
  final StringWithAggregatesFilter? name;
  @JsonKey(name: 'password')
  final StringWithAggregatesFilter? password;
  @JsonKey(name: 'resturantId')
  final IntNullableWithAggregatesFilter? resturantId;

  @override
  List<Field> toFields() => [
        if (aND != null)
          Field(
            "AND",
            true,
            false,
            null,
            toObjectField(aND!),
          ),
        if (oR != null)
          Field(
            "OR",
            true,
            false,
            null,
            toObjectField(oR!),
          ),
        if (nOT != null)
          Field(
            "NOT",
            true,
            false,
            null,
            toObjectField(nOT!),
          ),
        if (id != null)
          Field(
            "id",
            false,
            false,
            null,
            id!.toFields(),
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            null,
            userName!.toFields(),
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            null,
            name!.toFields(),
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            null,
            password!.toFields(),
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            null,
            resturantId!.toFields(),
          ),
      ];
}

class PostCreateInput implements ToField {
  const PostCreateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    required this.title,
    required this.published,
    this.desc,
    this.user,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'published')
  final bool published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'User')
  final UserCreateNestedOneWithoutPostsInput? user;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        Field(
          "title",
          false,
          false,
          title,
          null,
        ),
        Field(
          "published",
          false,
          false,
          published,
          null,
        ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
        if (user != null)
          Field(
            "User",
            false,
            false,
            null,
            user!.toFields(),
          ),
      ];
}

class PostUncheckedCreateInput implements ToField {
  const PostUncheckedCreateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    required this.title,
    required this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'published')
  final bool published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'userId')
  final int? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        Field(
          "title",
          false,
          false,
          title,
          null,
        ),
        Field(
          "published",
          false,
          false,
          published,
          null,
        ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!,
            null,
          ),
      ];
}

class PostUpdateInput implements ToField {
  const PostUpdateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.user,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'User')
  final UserUpdateOneWithoutPostsNestedInput? user;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
        if (user != null)
          Field(
            "User",
            false,
            false,
            null,
            user!.toFields(),
          ),
      ];
}

class PostUncheckedUpdateInput implements ToField {
  const PostUncheckedUpdateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'userId')
  final int? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!,
            null,
          ),
      ];
}

class PostUpdateManyMutationInput implements ToField {
  const PostUpdateManyMutationInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
      ];
}

class PostUncheckedUpdateManyInput implements ToField {
  const PostUncheckedUpdateManyInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'userId')
  final int? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!,
            null,
          ),
      ];
}

class UserCreateInput implements ToField {
  const UserCreateInput({
    required this.userName,
    required this.name,
    required this.password,
    this.resturantId,
    this.posts,
  });

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'password')
  final String password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;
  @JsonKey(name: 'posts')
  final PostCreateNestedManyWithoutUserInput? posts;

  @override
  List<Field> toFields() => [
        Field(
          "userName",
          false,
          false,
          userName,
          null,
        ),
        Field(
          "name",
          false,
          false,
          name,
          null,
        ),
        Field(
          "password",
          false,
          false,
          password,
          null,
        ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
        if (posts != null)
          Field(
            "posts",
            false,
            false,
            null,
            posts!.toFields(),
          ),
      ];
}

class UserUncheckedCreateInput implements ToField {
  const UserUncheckedCreateInput({
    this.id,
    required this.userName,
    required this.name,
    required this.password,
    this.resturantId,
    this.posts,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'password')
  final String password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;
  @JsonKey(name: 'posts')
  final PostUncheckedCreateNestedManyWithoutUserInput? posts;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        Field(
          "userName",
          false,
          false,
          userName,
          null,
        ),
        Field(
          "name",
          false,
          false,
          name,
          null,
        ),
        Field(
          "password",
          false,
          false,
          password,
          null,
        ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
        if (posts != null)
          Field(
            "posts",
            false,
            false,
            null,
            posts!.toFields(),
          ),
      ];
}

class UserUpdateInput implements ToField {
  const UserUpdateInput({
    this.userName,
    this.name,
    this.password,
    this.resturantId,
    this.posts,
  });

  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;
  @JsonKey(name: 'posts')
  final PostUpdateManyWithoutUserNestedInput? posts;

  @override
  List<Field> toFields() => [
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
        if (posts != null)
          Field(
            "posts",
            false,
            false,
            null,
            posts!.toFields(),
          ),
      ];
}

class UserUncheckedUpdateInput implements ToField {
  const UserUncheckedUpdateInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
    this.posts,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;
  @JsonKey(name: 'posts')
  final PostUncheckedUpdateManyWithoutUserNestedInput? posts;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
        if (posts != null)
          Field(
            "posts",
            false,
            false,
            null,
            posts!.toFields(),
          ),
      ];
}

class UserUpdateManyMutationInput implements ToField {
  const UserUpdateManyMutationInput({
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  @override
  List<Field> toFields() => [
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
      ];
}

class UserUncheckedUpdateManyInput implements ToField {
  const UserUncheckedUpdateManyInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
      ];
}

class StringFilter implements ToField {
  const StringFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class DateTimeFilter implements ToField {
  const DateTimeFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final DateTime? equals;
  @JsonKey(name: 'in')
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn')
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt')
  final DateTime? lt;
  @JsonKey(name: 'lte')
  final DateTime? lte;
  @JsonKey(name: 'gt')
  final DateTime? gt;
  @JsonKey(name: 'gte')
  final DateTime? gte;
  @JsonKey(name: 'not')
  final DateTime? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class BoolFilter implements ToField {
  const BoolFilter({
    this.equals,
    this.not,
  });

  @JsonKey(name: 'equals')
  final bool? equals;
  @JsonKey(name: 'not')
  final bool? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class StringNullableFilter implements ToField {
  const StringNullableFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class UserRelationFilter implements ToField {
  const UserRelationFilter({
    this.is$,
    this.isNot,
  });

  @JsonKey(name: 'is')
  final UserWhereInput? is$;
  @JsonKey(name: 'isNot')
  final UserWhereInput? isNot;

  @override
  List<Field> toFields() => [
        if (is$ != null)
          Field(
            "is",
            false,
            false,
            null,
            is$!.toFields(),
          ),
        if (isNot != null)
          Field(
            "isNot",
            false,
            false,
            null,
            isNot!.toFields(),
          ),
      ];
}

class IntNullableFilter implements ToField {
  const IntNullableFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class PostCountOrderByAggregateInput implements ToField {
  const PostCountOrderByAggregateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt')
  final SortOrder? updatedAt;
  @JsonKey(name: 'title')
  final SortOrder? title;
  @JsonKey(name: 'published')
  final SortOrder? published;
  @JsonKey(name: 'desc')
  final SortOrder? desc;
  @JsonKey(name: 'userId')
  final SortOrder? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!.value,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!.value,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!.value,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!.value,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!.value,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
      ];
}

class PostAvgOrderByAggregateInput implements ToField {
  const PostAvgOrderByAggregateInput({
    this.userId,
  });

  @JsonKey(name: 'userId')
  final SortOrder? userId;

  @override
  List<Field> toFields() => [
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
      ];
}

class PostMaxOrderByAggregateInput implements ToField {
  const PostMaxOrderByAggregateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt')
  final SortOrder? updatedAt;
  @JsonKey(name: 'title')
  final SortOrder? title;
  @JsonKey(name: 'published')
  final SortOrder? published;
  @JsonKey(name: 'desc')
  final SortOrder? desc;
  @JsonKey(name: 'userId')
  final SortOrder? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!.value,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!.value,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!.value,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!.value,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!.value,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
      ];
}

class PostMinOrderByAggregateInput implements ToField {
  const PostMinOrderByAggregateInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;
  @JsonKey(name: 'updatedAt')
  final SortOrder? updatedAt;
  @JsonKey(name: 'title')
  final SortOrder? title;
  @JsonKey(name: 'published')
  final SortOrder? published;
  @JsonKey(name: 'desc')
  final SortOrder? desc;
  @JsonKey(name: 'userId')
  final SortOrder? userId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!.value,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!.value,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!.value,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!.value,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!.value,
            null,
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
      ];
}

class PostSumOrderByAggregateInput implements ToField {
  const PostSumOrderByAggregateInput({
    this.userId,
  });

  @JsonKey(name: 'userId')
  final SortOrder? userId;

  @override
  List<Field> toFields() => [
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            userId!.value,
            null,
          ),
      ];
}

class StringWithAggregatesFilter implements ToField {
  const StringWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_min')
  final NestedStringFilter? $min;
  @JsonKey(name: '_max')
  final NestedStringFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class DateTimeWithAggregatesFilter implements ToField {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final DateTime? equals;
  @JsonKey(name: 'in')
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn')
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt')
  final DateTime? lt;
  @JsonKey(name: 'lte')
  final DateTime? lte;
  @JsonKey(name: 'gt')
  final DateTime? gt;
  @JsonKey(name: 'gte')
  final DateTime? gte;
  @JsonKey(name: 'not')
  final DateTime? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_min')
  final NestedDateTimeFilter? $min;
  @JsonKey(name: '_max')
  final NestedDateTimeFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class BoolWithAggregatesFilter implements ToField {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final bool? equals;
  @JsonKey(name: 'not')
  final bool? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_min')
  final NestedBoolFilter? $min;
  @JsonKey(name: '_max')
  final NestedBoolFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class StringNullableWithAggregatesFilter implements ToField {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;
  @JsonKey(name: '_count')
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_min')
  final NestedStringNullableFilter? $min;
  @JsonKey(name: '_max')
  final NestedStringNullableFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class IntNullableWithAggregatesFilter implements ToField {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;
  @JsonKey(name: '_count')
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_avg')
  final NestedFloatNullableFilter? $avg;
  @JsonKey(name: '_sum')
  final NestedIntNullableFilter? $sum;
  @JsonKey(name: '_min')
  final NestedIntNullableFilter? $min;
  @JsonKey(name: '_max')
  final NestedIntNullableFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($avg != null)
          Field(
            "_avg",
            false,
            false,
            null,
            $avg!.toFields(),
          ),
        if ($sum != null)
          Field(
            "_sum",
            false,
            false,
            null,
            $sum!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class IntFilter implements ToField {
  const IntFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class PostListRelationFilter implements ToField {
  const PostListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  @JsonKey(name: 'every')
  final PostWhereInput? every;
  @JsonKey(name: 'some')
  final PostWhereInput? some;
  @JsonKey(name: 'none')
  final PostWhereInput? none;

  @override
  List<Field> toFields() => [
        if (every != null)
          Field(
            "every",
            false,
            false,
            null,
            every!.toFields(),
          ),
        if (some != null)
          Field(
            "some",
            false,
            false,
            null,
            some!.toFields(),
          ),
        if (none != null)
          Field(
            "none",
            false,
            false,
            null,
            none!.toFields(),
          ),
      ];
}

class PostOrderByRelationAggregateInput implements ToField {
  const PostOrderByRelationAggregateInput({
    this.$count,
  });

  @JsonKey(name: '_count')
  final SortOrder? $count;

  @override
  List<Field> toFields() => [
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            $count!.value,
            null,
          ),
      ];
}

class UserCountOrderByAggregateInput implements ToField {
  const UserCountOrderByAggregateInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'userName')
  final SortOrder? userName;
  @JsonKey(name: 'name')
  final SortOrder? name;
  @JsonKey(name: 'password')
  final SortOrder? password;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!.value,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!.value,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
      ];
}

class UserAvgOrderByAggregateInput implements ToField {
  const UserAvgOrderByAggregateInput({
    this.id,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
      ];
}

class UserMaxOrderByAggregateInput implements ToField {
  const UserMaxOrderByAggregateInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'userName')
  final SortOrder? userName;
  @JsonKey(name: 'name')
  final SortOrder? name;
  @JsonKey(name: 'password')
  final SortOrder? password;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!.value,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!.value,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
      ];
}

class UserMinOrderByAggregateInput implements ToField {
  const UserMinOrderByAggregateInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'userName')
  final SortOrder? userName;
  @JsonKey(name: 'name')
  final SortOrder? name;
  @JsonKey(name: 'password')
  final SortOrder? password;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!.value,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!.value,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
      ];
}

class UserSumOrderByAggregateInput implements ToField {
  const UserSumOrderByAggregateInput({
    this.id,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final SortOrder? id;
  @JsonKey(name: 'resturantId')
  final SortOrder? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!.value,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!.value,
            null,
          ),
      ];
}

class IntWithAggregatesFilter implements ToField {
  const IntWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_avg')
  final NestedFloatFilter? $avg;
  @JsonKey(name: '_sum')
  final NestedIntFilter? $sum;
  @JsonKey(name: '_min')
  final NestedIntFilter? $min;
  @JsonKey(name: '_max')
  final NestedIntFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($avg != null)
          Field(
            "_avg",
            false,
            false,
            null,
            $avg!.toFields(),
          ),
        if ($sum != null)
          Field(
            "_sum",
            false,
            false,
            null,
            $sum!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class UserCreateNestedOneWithoutPostsInput implements ToField {
  const UserCreateNestedOneWithoutPostsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  @JsonKey(name: 'create')
  final UserCreateWithoutPostsInput? create;
  @JsonKey(name: 'connectOrCreate')
  final UserCreateOrConnectWithoutPostsInput? connectOrCreate;
  @JsonKey(name: 'connect')
  final UserWhereUniqueInput? connect;

  @override
  List<Field> toFields() => [
        if (create != null)
          Field(
            "create",
            false,
            false,
            null,
            create!.toFields(),
          ),
        if (connectOrCreate != null)
          Field(
            "connectOrCreate",
            false,
            false,
            null,
            connectOrCreate!.toFields(),
          ),
        if (connect != null)
          Field(
            "connect",
            false,
            false,
            null,
            connect!.toFields(),
          ),
      ];
}

class StringFieldUpdateOperationsInput implements ToField {
  const StringFieldUpdateOperationsInput({
    this.set$,
  });

  @JsonKey(name: 'set')
  final String? set$;

  @override
  List<Field> toFields() => [
        if (set$ != null)
          Field(
            "set",
            false,
            false,
            set$!,
            null,
          ),
      ];
}

class DateTimeFieldUpdateOperationsInput implements ToField {
  const DateTimeFieldUpdateOperationsInput({
    this.set$,
  });

  @JsonKey(name: 'set')
  final DateTime? set$;

  @override
  List<Field> toFields() => [
        if (set$ != null)
          Field(
            "set",
            false,
            false,
            set$!,
            null,
          ),
      ];
}

class BoolFieldUpdateOperationsInput implements ToField {
  const BoolFieldUpdateOperationsInput({
    this.set$,
  });

  @JsonKey(name: 'set')
  final bool? set$;

  @override
  List<Field> toFields() => [
        if (set$ != null)
          Field(
            "set",
            false,
            false,
            set$!,
            null,
          ),
      ];
}

class NullableStringFieldUpdateOperationsInput implements ToField {
  const NullableStringFieldUpdateOperationsInput({
    this.set$,
  });

  @JsonKey(name: 'set')
  final String? set$;

  @override
  List<Field> toFields() => [
        if (set$ != null)
          Field(
            "set",
            false,
            false,
            set$!,
            null,
          ),
      ];
}

class UserUpdateOneWithoutPostsNestedInput implements ToField {
  const UserUpdateOneWithoutPostsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  @JsonKey(name: 'create')
  final UserCreateWithoutPostsInput? create;
  @JsonKey(name: 'connectOrCreate')
  final UserCreateOrConnectWithoutPostsInput? connectOrCreate;
  @JsonKey(name: 'upsert')
  final UserUpsertWithoutPostsInput? upsert;
  @JsonKey(name: 'disconnect')
  final bool? disconnect;
  @JsonKey(name: 'delete')
  final bool? delete;
  @JsonKey(name: 'connect')
  final UserWhereUniqueInput? connect;
  @JsonKey(name: 'update')
  final UserUpdateWithoutPostsInput? update;

  @override
  List<Field> toFields() => [
        if (create != null)
          Field(
            "create",
            false,
            false,
            null,
            create!.toFields(),
          ),
        if (connectOrCreate != null)
          Field(
            "connectOrCreate",
            false,
            false,
            null,
            connectOrCreate!.toFields(),
          ),
        if (upsert != null)
          Field(
            "upsert",
            false,
            false,
            null,
            upsert!.toFields(),
          ),
        if (disconnect != null)
          Field(
            "disconnect",
            false,
            false,
            disconnect!,
            null,
          ),
        if (delete != null)
          Field(
            "delete",
            false,
            false,
            delete!,
            null,
          ),
        if (connect != null)
          Field(
            "connect",
            false,
            false,
            null,
            connect!.toFields(),
          ),
        if (update != null)
          Field(
            "update",
            false,
            false,
            null,
            update!.toFields(),
          ),
      ];
}

class NullableIntFieldUpdateOperationsInput implements ToField {
  const NullableIntFieldUpdateOperationsInput({
    this.set$,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  @JsonKey(name: 'set')
  final int? set$;
  @JsonKey(name: 'increment')
  final int? increment;
  @JsonKey(name: 'decrement')
  final int? decrement;
  @JsonKey(name: 'multiply')
  final int? multiply;
  @JsonKey(name: 'divide')
  final int? divide;

  @override
  List<Field> toFields() => [
        if (set$ != null)
          Field(
            "set",
            false,
            false,
            set$!,
            null,
          ),
        if (increment != null)
          Field(
            "increment",
            false,
            false,
            increment!,
            null,
          ),
        if (decrement != null)
          Field(
            "decrement",
            false,
            false,
            decrement!,
            null,
          ),
        if (multiply != null)
          Field(
            "multiply",
            false,
            false,
            multiply!,
            null,
          ),
        if (divide != null)
          Field(
            "divide",
            false,
            false,
            divide!,
            null,
          ),
      ];
}

class PostCreateNestedManyWithoutUserInput implements ToField {
  const PostCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  @JsonKey(name: 'create')
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate')
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'connect')
  final List<PostWhereUniqueInput>? connect;

  @override
  List<Field> toFields() => [
        if (create != null)
          Field(
            "create",
            true,
            false,
            null,
            toObjectField(create!),
          ),
        if (connectOrCreate != null)
          Field(
            "connectOrCreate",
            true,
            false,
            null,
            toObjectField(connectOrCreate!),
          ),
        if (connect != null)
          Field(
            "connect",
            true,
            false,
            null,
            toObjectField(connect!),
          ),
      ];
}

class PostUncheckedCreateNestedManyWithoutUserInput implements ToField {
  const PostUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  @JsonKey(name: 'create')
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate')
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'connect')
  final List<PostWhereUniqueInput>? connect;

  @override
  List<Field> toFields() => [
        if (create != null)
          Field(
            "create",
            true,
            false,
            null,
            toObjectField(create!),
          ),
        if (connectOrCreate != null)
          Field(
            "connectOrCreate",
            true,
            false,
            null,
            toObjectField(connectOrCreate!),
          ),
        if (connect != null)
          Field(
            "connect",
            true,
            false,
            null,
            toObjectField(connect!),
          ),
      ];
}

class PostUpdateManyWithoutUserNestedInput implements ToField {
  const PostUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set$,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  @JsonKey(name: 'create')
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate')
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'upsert')
  final List<PostUpsertWithWhereUniqueWithoutUserInput>? upsert;
  @JsonKey(name: 'set')
  final List<PostWhereUniqueInput>? set$;
  @JsonKey(name: 'disconnect')
  final List<PostWhereUniqueInput>? disconnect;
  @JsonKey(name: 'delete')
  final List<PostWhereUniqueInput>? delete;
  @JsonKey(name: 'connect')
  final List<PostWhereUniqueInput>? connect;
  @JsonKey(name: 'update')
  final List<PostUpdateWithWhereUniqueWithoutUserInput>? update;
  @JsonKey(name: 'updateMany')
  final List<PostUpdateManyWithWhereWithoutUserInput>? updateMany;
  @JsonKey(name: 'deleteMany')
  final List<PostScalarWhereInput>? deleteMany;

  @override
  List<Field> toFields() => [
        if (create != null)
          Field(
            "create",
            true,
            false,
            null,
            toObjectField(create!),
          ),
        if (connectOrCreate != null)
          Field(
            "connectOrCreate",
            true,
            false,
            null,
            toObjectField(connectOrCreate!),
          ),
        if (upsert != null)
          Field(
            "upsert",
            true,
            false,
            null,
            toObjectField(upsert!),
          ),
        if (set$ != null)
          Field(
            "set",
            true,
            false,
            null,
            toObjectField(set$!),
          ),
        if (disconnect != null)
          Field(
            "disconnect",
            true,
            false,
            null,
            toObjectField(disconnect!),
          ),
        if (delete != null)
          Field(
            "delete",
            true,
            false,
            null,
            toObjectField(delete!),
          ),
        if (connect != null)
          Field(
            "connect",
            true,
            false,
            null,
            toObjectField(connect!),
          ),
        if (update != null)
          Field(
            "update",
            true,
            false,
            null,
            toObjectField(update!),
          ),
        if (updateMany != null)
          Field(
            "updateMany",
            true,
            false,
            null,
            toObjectField(updateMany!),
          ),
        if (deleteMany != null)
          Field(
            "deleteMany",
            true,
            false,
            null,
            toObjectField(deleteMany!),
          ),
      ];
}

class IntFieldUpdateOperationsInput implements ToField {
  const IntFieldUpdateOperationsInput({
    this.set$,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  @JsonKey(name: 'set')
  final int? set$;
  @JsonKey(name: 'increment')
  final int? increment;
  @JsonKey(name: 'decrement')
  final int? decrement;
  @JsonKey(name: 'multiply')
  final int? multiply;
  @JsonKey(name: 'divide')
  final int? divide;

  @override
  List<Field> toFields() => [
        if (set$ != null)
          Field(
            "set",
            false,
            false,
            set$!,
            null,
          ),
        if (increment != null)
          Field(
            "increment",
            false,
            false,
            increment!,
            null,
          ),
        if (decrement != null)
          Field(
            "decrement",
            false,
            false,
            decrement!,
            null,
          ),
        if (multiply != null)
          Field(
            "multiply",
            false,
            false,
            multiply!,
            null,
          ),
        if (divide != null)
          Field(
            "divide",
            false,
            false,
            divide!,
            null,
          ),
      ];
}

class PostUncheckedUpdateManyWithoutUserNestedInput implements ToField {
  const PostUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set$,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  @JsonKey(name: 'create')
  final List<PostCreateWithoutUserInput>? create;
  @JsonKey(name: 'connectOrCreate')
  final List<PostCreateOrConnectWithoutUserInput>? connectOrCreate;
  @JsonKey(name: 'upsert')
  final List<PostUpsertWithWhereUniqueWithoutUserInput>? upsert;
  @JsonKey(name: 'set')
  final List<PostWhereUniqueInput>? set$;
  @JsonKey(name: 'disconnect')
  final List<PostWhereUniqueInput>? disconnect;
  @JsonKey(name: 'delete')
  final List<PostWhereUniqueInput>? delete;
  @JsonKey(name: 'connect')
  final List<PostWhereUniqueInput>? connect;
  @JsonKey(name: 'update')
  final List<PostUpdateWithWhereUniqueWithoutUserInput>? update;
  @JsonKey(name: 'updateMany')
  final List<PostUpdateManyWithWhereWithoutUserInput>? updateMany;
  @JsonKey(name: 'deleteMany')
  final List<PostScalarWhereInput>? deleteMany;

  @override
  List<Field> toFields() => [
        if (create != null)
          Field(
            "create",
            true,
            false,
            null,
            toObjectField(create!),
          ),
        if (connectOrCreate != null)
          Field(
            "connectOrCreate",
            true,
            false,
            null,
            toObjectField(connectOrCreate!),
          ),
        if (upsert != null)
          Field(
            "upsert",
            true,
            false,
            null,
            toObjectField(upsert!),
          ),
        if (set$ != null)
          Field(
            "set",
            true,
            false,
            null,
            toObjectField(set$!),
          ),
        if (disconnect != null)
          Field(
            "disconnect",
            true,
            false,
            null,
            toObjectField(disconnect!),
          ),
        if (delete != null)
          Field(
            "delete",
            true,
            false,
            null,
            toObjectField(delete!),
          ),
        if (connect != null)
          Field(
            "connect",
            true,
            false,
            null,
            toObjectField(connect!),
          ),
        if (update != null)
          Field(
            "update",
            true,
            false,
            null,
            toObjectField(update!),
          ),
        if (updateMany != null)
          Field(
            "updateMany",
            true,
            false,
            null,
            toObjectField(updateMany!),
          ),
        if (deleteMany != null)
          Field(
            "deleteMany",
            true,
            false,
            null,
            toObjectField(deleteMany!),
          ),
      ];
}

class NestedStringFilter implements ToField {
  const NestedStringFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedDateTimeFilter implements ToField {
  const NestedDateTimeFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final DateTime? equals;
  @JsonKey(name: 'in')
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn')
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt')
  final DateTime? lt;
  @JsonKey(name: 'lte')
  final DateTime? lte;
  @JsonKey(name: 'gt')
  final DateTime? gt;
  @JsonKey(name: 'gte')
  final DateTime? gte;
  @JsonKey(name: 'not')
  final DateTime? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedBoolFilter implements ToField {
  const NestedBoolFilter({
    this.equals,
    this.not,
  });

  @JsonKey(name: 'equals')
  final bool? equals;
  @JsonKey(name: 'not')
  final bool? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedStringNullableFilter implements ToField {
  const NestedStringNullableFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedIntNullableFilter implements ToField {
  const NestedIntNullableFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedStringWithAggregatesFilter implements ToField {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_min')
  final NestedStringFilter? $min;
  @JsonKey(name: '_max')
  final NestedStringFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class NestedIntFilter implements ToField {
  const NestedIntFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedDateTimeWithAggregatesFilter implements ToField {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final DateTime? equals;
  @JsonKey(name: 'in')
  final List<DateTime>? in$;
  @JsonKey(name: 'notIn')
  final List<DateTime>? notIn;
  @JsonKey(name: 'lt')
  final DateTime? lt;
  @JsonKey(name: 'lte')
  final DateTime? lte;
  @JsonKey(name: 'gt')
  final DateTime? gt;
  @JsonKey(name: 'gte')
  final DateTime? gte;
  @JsonKey(name: 'not')
  final DateTime? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_min')
  final NestedDateTimeFilter? $min;
  @JsonKey(name: '_max')
  final NestedDateTimeFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class NestedBoolWithAggregatesFilter implements ToField {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final bool? equals;
  @JsonKey(name: 'not')
  final bool? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_min')
  final NestedBoolFilter? $min;
  @JsonKey(name: '_max')
  final NestedBoolFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class NestedStringNullableWithAggregatesFilter implements ToField {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final String? equals;
  @JsonKey(name: 'in')
  final List<String>? in$;
  @JsonKey(name: 'notIn')
  final List<String>? notIn;
  @JsonKey(name: 'lt')
  final String? lt;
  @JsonKey(name: 'lte')
  final String? lte;
  @JsonKey(name: 'gt')
  final String? gt;
  @JsonKey(name: 'gte')
  final String? gte;
  @JsonKey(name: 'contains')
  final String? contains;
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @JsonKey(name: 'not')
  final String? not;
  @JsonKey(name: '_count')
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_min')
  final NestedStringNullableFilter? $min;
  @JsonKey(name: '_max')
  final NestedStringNullableFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (contains != null)
          Field(
            "contains",
            false,
            false,
            contains!,
            null,
          ),
        if (startsWith != null)
          Field(
            "startsWith",
            false,
            false,
            startsWith!,
            null,
          ),
        if (endsWith != null)
          Field(
            "endsWith",
            false,
            false,
            endsWith!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class NestedIntNullableWithAggregatesFilter implements ToField {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;
  @JsonKey(name: '_count')
  final NestedIntNullableFilter? $count;
  @JsonKey(name: '_avg')
  final NestedFloatNullableFilter? $avg;
  @JsonKey(name: '_sum')
  final NestedIntNullableFilter? $sum;
  @JsonKey(name: '_min')
  final NestedIntNullableFilter? $min;
  @JsonKey(name: '_max')
  final NestedIntNullableFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($avg != null)
          Field(
            "_avg",
            false,
            false,
            null,
            $avg!.toFields(),
          ),
        if ($sum != null)
          Field(
            "_sum",
            false,
            false,
            null,
            $sum!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class NestedFloatNullableFilter implements ToField {
  const NestedFloatNullableFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final double? equals;
  @JsonKey(name: 'in')
  final List<double>? in$;
  @JsonKey(name: 'notIn')
  final List<double>? notIn;
  @JsonKey(name: 'lt')
  final double? lt;
  @JsonKey(name: 'lte')
  final double? lte;
  @JsonKey(name: 'gt')
  final double? gt;
  @JsonKey(name: 'gte')
  final double? gte;
  @JsonKey(name: 'not')
  final double? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class NestedIntWithAggregatesFilter implements ToField {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'equals')
  final int? equals;
  @JsonKey(name: 'in')
  final List<int>? in$;
  @JsonKey(name: 'notIn')
  final List<int>? notIn;
  @JsonKey(name: 'lt')
  final int? lt;
  @JsonKey(name: 'lte')
  final int? lte;
  @JsonKey(name: 'gt')
  final int? gt;
  @JsonKey(name: 'gte')
  final int? gte;
  @JsonKey(name: 'not')
  final int? not;
  @JsonKey(name: '_count')
  final NestedIntFilter? $count;
  @JsonKey(name: '_avg')
  final NestedFloatFilter? $avg;
  @JsonKey(name: '_sum')
  final NestedIntFilter? $sum;
  @JsonKey(name: '_min')
  final NestedIntFilter? $min;
  @JsonKey(name: '_max')
  final NestedIntFilter? $max;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
        if ($count != null)
          Field(
            "_count",
            false,
            false,
            null,
            $count!.toFields(),
          ),
        if ($avg != null)
          Field(
            "_avg",
            false,
            false,
            null,
            $avg!.toFields(),
          ),
        if ($sum != null)
          Field(
            "_sum",
            false,
            false,
            null,
            $sum!.toFields(),
          ),
        if ($min != null)
          Field(
            "_min",
            false,
            false,
            null,
            $min!.toFields(),
          ),
        if ($max != null)
          Field(
            "_max",
            false,
            false,
            null,
            $max!.toFields(),
          ),
      ];
}

class NestedFloatFilter implements ToField {
  const NestedFloatFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  @JsonKey(name: 'equals')
  final double? equals;
  @JsonKey(name: 'in')
  final List<double>? in$;
  @JsonKey(name: 'notIn')
  final List<double>? notIn;
  @JsonKey(name: 'lt')
  final double? lt;
  @JsonKey(name: 'lte')
  final double? lte;
  @JsonKey(name: 'gt')
  final double? gt;
  @JsonKey(name: 'gte')
  final double? gte;
  @JsonKey(name: 'not')
  final double? not;

  @override
  List<Field> toFields() => [
        if (equals != null)
          Field(
            "equals",
            false,
            false,
            equals!,
            null,
          ),
        if (in$ != null)
          Field(
            "in",
            true,
            false,
            toScalerField(in$!),
            null,
          ),
        if (notIn != null)
          Field(
            "notIn",
            true,
            false,
            toScalerField(notIn!),
            null,
          ),
        if (lt != null)
          Field(
            "lt",
            false,
            false,
            lt!,
            null,
          ),
        if (lte != null)
          Field(
            "lte",
            false,
            false,
            lte!,
            null,
          ),
        if (gt != null)
          Field(
            "gt",
            false,
            false,
            gt!,
            null,
          ),
        if (gte != null)
          Field(
            "gte",
            false,
            false,
            gte!,
            null,
          ),
        if (not != null)
          Field(
            "not",
            false,
            false,
            not!,
            null,
          ),
      ];
}

class UserCreateWithoutPostsInput implements ToField {
  const UserCreateWithoutPostsInput({
    required this.userName,
    required this.name,
    required this.password,
    this.resturantId,
  });

  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'password')
  final String password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  @override
  List<Field> toFields() => [
        Field(
          "userName",
          false,
          false,
          userName,
          null,
        ),
        Field(
          "name",
          false,
          false,
          name,
          null,
        ),
        Field(
          "password",
          false,
          false,
          password,
          null,
        ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
      ];
}

class UserUncheckedCreateWithoutPostsInput implements ToField {
  const UserUncheckedCreateWithoutPostsInput({
    this.id,
    required this.userName,
    required this.name,
    required this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'password')
  final String password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        Field(
          "userName",
          false,
          false,
          userName,
          null,
        ),
        Field(
          "name",
          false,
          false,
          name,
          null,
        ),
        Field(
          "password",
          false,
          false,
          password,
          null,
        ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
      ];
}

class UserCreateOrConnectWithoutPostsInput implements ToField {
  const UserCreateOrConnectWithoutPostsInput({
    required this.where,
    required this.create,
  });

  @JsonKey(name: 'where')
  final UserWhereUniqueInput where;
  @JsonKey(name: 'create')
  final UserCreateWithoutPostsInput create;

  @override
  List<Field> toFields() => [
        Field(
          "where",
          false,
          false,
          null,
          where.toFields(),
        ),
        Field(
          "create",
          false,
          false,
          null,
          create.toFields(),
        ),
      ];
}

class UserUpsertWithoutPostsInput implements ToField {
  const UserUpsertWithoutPostsInput({
    required this.update,
    required this.create,
  });

  @JsonKey(name: 'update')
  final UserUpdateWithoutPostsInput update;
  @JsonKey(name: 'create')
  final UserCreateWithoutPostsInput create;

  @override
  List<Field> toFields() => [
        Field(
          "update",
          false,
          false,
          null,
          update.toFields(),
        ),
        Field(
          "create",
          false,
          false,
          null,
          create.toFields(),
        ),
      ];
}

class UserUpdateWithoutPostsInput implements ToField {
  const UserUpdateWithoutPostsInput({
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  @override
  List<Field> toFields() => [
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
      ];
}

class UserUncheckedUpdateWithoutPostsInput implements ToField {
  const UserUncheckedUpdateWithoutPostsInput({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (userName != null)
          Field(
            "userName",
            false,
            false,
            userName!,
            null,
          ),
        if (name != null)
          Field(
            "name",
            false,
            false,
            name!,
            null,
          ),
        if (password != null)
          Field(
            "password",
            false,
            false,
            password!,
            null,
          ),
        if (resturantId != null)
          Field(
            "resturantId",
            false,
            false,
            resturantId!,
            null,
          ),
      ];
}

class PostCreateWithoutUserInput implements ToField {
  const PostCreateWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    required this.title,
    required this.published,
    this.desc,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'published')
  final bool published;
  @JsonKey(name: 'desc')
  final String? desc;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        Field(
          "title",
          false,
          false,
          title,
          null,
        ),
        Field(
          "published",
          false,
          false,
          published,
          null,
        ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
      ];
}

class PostUncheckedCreateWithoutUserInput implements ToField {
  const PostUncheckedCreateWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    required this.title,
    required this.published,
    this.desc,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'published')
  final bool published;
  @JsonKey(name: 'desc')
  final String? desc;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        Field(
          "title",
          false,
          false,
          title,
          null,
        ),
        Field(
          "published",
          false,
          false,
          published,
          null,
        ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
      ];
}

class PostCreateOrConnectWithoutUserInput implements ToField {
  const PostCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  @JsonKey(name: 'where')
  final PostWhereUniqueInput where;
  @JsonKey(name: 'create')
  final PostCreateWithoutUserInput create;

  @override
  List<Field> toFields() => [
        Field(
          "where",
          false,
          false,
          null,
          where.toFields(),
        ),
        Field(
          "create",
          false,
          false,
          null,
          create.toFields(),
        ),
      ];
}

class PostUpsertWithWhereUniqueWithoutUserInput implements ToField {
  const PostUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  @JsonKey(name: 'where')
  final PostWhereUniqueInput where;
  @JsonKey(name: 'update')
  final PostUpdateWithoutUserInput update;
  @JsonKey(name: 'create')
  final PostCreateWithoutUserInput create;

  @override
  List<Field> toFields() => [
        Field(
          "where",
          false,
          false,
          null,
          where.toFields(),
        ),
        Field(
          "update",
          false,
          false,
          null,
          update.toFields(),
        ),
        Field(
          "create",
          false,
          false,
          null,
          create.toFields(),
        ),
      ];
}

class PostUpdateWithWhereUniqueWithoutUserInput implements ToField {
  const PostUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  @JsonKey(name: 'where')
  final PostWhereUniqueInput where;
  @JsonKey(name: 'data')
  final PostUpdateWithoutUserInput data;

  @override
  List<Field> toFields() => [
        Field(
          "where",
          false,
          false,
          null,
          where.toFields(),
        ),
        Field(
          "data",
          false,
          false,
          null,
          data.toFields(),
        ),
      ];
}

class PostUpdateManyWithWhereWithoutUserInput implements ToField {
  const PostUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  @JsonKey(name: 'where')
  final PostScalarWhereInput where;
  @JsonKey(name: 'data')
  final PostUpdateManyMutationInput data;

  @override
  List<Field> toFields() => [
        Field(
          "where",
          false,
          false,
          null,
          where.toFields(),
        ),
        Field(
          "data",
          false,
          false,
          null,
          data.toFields(),
        ),
      ];
}

class PostScalarWhereInput implements ToField {
  const PostScalarWhereInput({
    this.aND,
    this.oR,
    this.nOT,
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'AND')
  final List<PostScalarWhereInput>? aND;
  @JsonKey(name: 'OR')
  final List<PostScalarWhereInput>? oR;
  @JsonKey(name: 'NOT')
  final List<PostScalarWhereInput>? nOT;
  @JsonKey(name: 'id')
  final StringFilter? id;
  @JsonKey(name: 'createdAt')
  final DateTimeFilter? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTimeFilter? updatedAt;
  @JsonKey(name: 'title')
  final StringFilter? title;
  @JsonKey(name: 'published')
  final BoolFilter? published;
  @JsonKey(name: 'desc')
  final StringNullableFilter? desc;
  @JsonKey(name: 'userId')
  final IntNullableFilter? userId;

  @override
  List<Field> toFields() => [
        if (aND != null)
          Field(
            "AND",
            true,
            false,
            null,
            toObjectField(aND!),
          ),
        if (oR != null)
          Field(
            "OR",
            true,
            false,
            null,
            toObjectField(oR!),
          ),
        if (nOT != null)
          Field(
            "NOT",
            true,
            false,
            null,
            toObjectField(nOT!),
          ),
        if (id != null)
          Field(
            "id",
            false,
            false,
            null,
            id!.toFields(),
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            null,
            createdAt!.toFields(),
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            null,
            updatedAt!.toFields(),
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            null,
            title!.toFields(),
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            null,
            published!.toFields(),
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            null,
            desc!.toFields(),
          ),
        if (userId != null)
          Field(
            "userId",
            false,
            false,
            null,
            userId!.toFields(),
          ),
      ];
}

class PostUpdateWithoutUserInput implements ToField {
  const PostUpdateWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
      ];
}

class PostUncheckedUpdateWithoutUserInput implements ToField {
  const PostUncheckedUpdateWithoutUserInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
      ];
}

class PostUncheckedUpdateManyWithoutPostsInput implements ToField {
  const PostUncheckedUpdateManyWithoutPostsInput({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;

  @override
  List<Field> toFields() => [
        if (id != null)
          Field(
            "id",
            false,
            false,
            id!,
            null,
          ),
        if (createdAt != null)
          Field(
            "createdAt",
            false,
            false,
            createdAt!,
            null,
          ),
        if (updatedAt != null)
          Field(
            "updatedAt",
            false,
            false,
            updatedAt!,
            null,
          ),
        if (title != null)
          Field(
            "title",
            false,
            false,
            title!,
            null,
          ),
        if (published != null)
          Field(
            "published",
            false,
            false,
            published!,
            null,
          ),
        if (desc != null)
          Field(
            "desc",
            false,
            false,
            desc!,
            null,
          ),
      ];
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class AggregatePost {
  const AggregatePost({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: '_count')
  final PostCountAggregateOutputType? $count;
  @JsonKey(name: '_avg')
  final PostAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum')
  final PostSumAggregateOutputType? $sum;
  @JsonKey(name: '_min')
  final PostMinAggregateOutputType? $min;
  @JsonKey(name: '_max')
  final PostMaxAggregateOutputType? $max;

  factory AggregatePost.fromJson(Map<String, dynamic> json) =>
      _$AggregatePostFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class PostGroupByOutputType {
  const PostGroupByOutputType({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.title,
    required this.published,
    this.desc,
    this.userId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'createdAt')
  final DateTime createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime updatedAt;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'published')
  final bool published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'userId')
  final int? userId;
  @JsonKey(name: '_count')
  final PostCountAggregateOutputType? $count;
  @JsonKey(name: '_avg')
  final PostAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum')
  final PostSumAggregateOutputType? $sum;
  @JsonKey(name: '_min')
  final PostMinAggregateOutputType? $min;
  @JsonKey(name: '_max')
  final PostMaxAggregateOutputType? $max;

  factory PostGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$PostGroupByOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class AggregateUser {
  const AggregateUser({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: '_count')
  final UserCountAggregateOutputType? $count;
  @JsonKey(name: '_avg')
  final UserAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum')
  final UserSumAggregateOutputType? $sum;
  @JsonKey(name: '_min')
  final UserMinAggregateOutputType? $min;
  @JsonKey(name: '_max')
  final UserMaxAggregateOutputType? $max;

  factory AggregateUser.fromJson(Map<String, dynamic> json) =>
      _$AggregateUserFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserGroupByOutputType {
  const UserGroupByOutputType({
    required this.id,
    required this.userName,
    required this.name,
    required this.password,
    this.resturantId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'password')
  final String password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;
  @JsonKey(name: '_count')
  final UserCountAggregateOutputType? $count;
  @JsonKey(name: '_avg')
  final UserAvgAggregateOutputType? $avg;
  @JsonKey(name: '_sum')
  final UserSumAggregateOutputType? $sum;
  @JsonKey(name: '_min')
  final UserMinAggregateOutputType? $min;
  @JsonKey(name: '_max')
  final UserMaxAggregateOutputType? $max;

  factory UserGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserGroupByOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class AffectedRowsOutput {
  const AffectedRowsOutput({
    required this.count,
  });

  @JsonKey(name: 'count')
  final int count;

  factory AffectedRowsOutput.fromJson(Map<String, dynamic> json) =>
      _$AffectedRowsOutputFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class PostCountAggregateOutputType {
  const PostCountAggregateOutputType({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.title,
    required this.published,
    required this.desc,
    required this.userId,
    required this.$all,
  });

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'createdAt')
  final int createdAt;
  @JsonKey(name: 'updatedAt')
  final int updatedAt;
  @JsonKey(name: 'title')
  final int title;
  @JsonKey(name: 'published')
  final int published;
  @JsonKey(name: 'desc')
  final int desc;
  @JsonKey(name: 'userId')
  final int userId;
  @JsonKey(name: '_all')
  final int $all;

  factory PostCountAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$PostCountAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class PostAvgAggregateOutputType {
  const PostAvgAggregateOutputType({
    this.userId,
  });

  @JsonKey(name: 'userId')
  final double? userId;

  factory PostAvgAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$PostAvgAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class PostSumAggregateOutputType {
  const PostSumAggregateOutputType({
    this.userId,
  });

  @JsonKey(name: 'userId')
  final int? userId;

  factory PostSumAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$PostSumAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class PostMinAggregateOutputType {
  const PostMinAggregateOutputType({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'userId')
  final int? userId;

  factory PostMinAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$PostMinAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class PostMaxAggregateOutputType {
  const PostMaxAggregateOutputType({
    this.id,
    this.createdAt,
    this.updatedAt,
    this.title,
    this.published,
    this.desc,
    this.userId,
  });

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'createdAt')
  final DateTime? createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime? updatedAt;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'published')
  final bool? published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'userId')
  final int? userId;

  factory PostMaxAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$PostMaxAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserCountOutputType {
  const UserCountOutputType({
    required this.posts,
  });

  @JsonKey(name: 'posts')
  final int posts;

  factory UserCountOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserCountOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserCountAggregateOutputType {
  const UserCountAggregateOutputType({
    required this.id,
    required this.userName,
    required this.name,
    required this.password,
    required this.resturantId,
    required this.$all,
  });

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'userName')
  final int userName;
  @JsonKey(name: 'name')
  final int name;
  @JsonKey(name: 'password')
  final int password;
  @JsonKey(name: 'resturantId')
  final int resturantId;
  @JsonKey(name: '_all')
  final int $all;

  factory UserCountAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserCountAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserAvgAggregateOutputType {
  const UserAvgAggregateOutputType({
    this.id,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final double? id;
  @JsonKey(name: 'resturantId')
  final double? resturantId;

  factory UserAvgAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserAvgAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserSumAggregateOutputType {
  const UserSumAggregateOutputType({
    this.id,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  factory UserSumAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserSumAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserMinAggregateOutputType {
  const UserMinAggregateOutputType({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  factory UserMinAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserMinAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType({
    this.id,
    this.userName,
    this.name,
    this.password,
    this.resturantId,
  });

  @JsonKey(name: 'id')
  final int? id;
  @JsonKey(name: 'userName')
  final String? userName;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'password')
  final String? password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;

  factory UserMaxAggregateOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserMaxAggregateOutputTypeFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class Post {
  const Post({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.title,
    required this.published,
    this.desc,
    this.user,
    this.userId,
  });

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'createdAt')
  final DateTime createdAt;
  @JsonKey(name: 'updatedAt')
  final DateTime updatedAt;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'published')
  final bool published;
  @JsonKey(name: 'desc')
  final String? desc;
  @JsonKey(name: 'User')
  final User? user;
  @JsonKey(name: 'userId')
  final int? userId;

  factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json);
}

@JsonSerializable(
    explicitToJson: true, createFactory: true, createToJson: false)
class User {
  const User({
    required this.id,
    required this.userName,
    required this.name,
    required this.password,
    this.resturantId,
    this.posts,
    required this.$count,
  });

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'userName')
  final String userName;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'password')
  final String password;
  @JsonKey(name: 'resturantId')
  final int? resturantId;
  @JsonKey(name: 'posts')
  final List<Post>? posts;
  @JsonKey(name: '_count')
  final UserCountOutputType $count;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

class PostModel {
  static const String model = "Post";
  final Engine engine;
  PostModel(this.engine);
  static const _outputField = [
    Output("id"),
    Output("createdAt"),
    Output("updatedAt"),
    Output("title"),
    Output("published"),
    Output("desc"),
    Output("userId")
  ];
  Future<Post?> findUnique({
    required PostWhereUniqueInput where,
  }) {
    final input = [
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "findUnique",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return Post.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<Post?> findFirst({
    PostWhereInput? where,
    List<PostOrderByWithRelationInput>? orderBy,
    PostWhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<PostScalarFieldEnum>? distinct,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      if (cursor != null)
        Input(
          "cursor",
          false,
          null,
          cursor.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
      if (distinct != null)
        Input(
          "distinct",
          true,
          toEnumsField(distinct),
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "findFirst",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return Post.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<List<Post>> findMany({
    PostWhereInput? where,
    List<PostOrderByWithRelationInput>? orderBy,
    PostWhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<PostScalarFieldEnum>? distinct,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      if (cursor != null)
        Input(
          "cursor",
          false,
          null,
          cursor.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
      if (distinct != null)
        Input(
          "distinct",
          true,
          toEnumsField(distinct),
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "findMany",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) return [];
      return (value.data!.result! as List).map((e) {
        return Post.fromJson(value.data!.result! as Map<String, dynamic>);
      }).toList();
    });
  }

  Future<Post> createOne({
    required PostCreateInput data,
  }) {
    final input = [
      Input(
        "data",
        false,
        null,
        data.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "createOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return Post.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<Post?> updateOne({
    required PostUpdateInput data,
    required PostWhereUniqueInput where,
  }) {
    final input = [
      Input(
        "data",
        false,
        null,
        data.toFields(),
      ),
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "updateOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return Post.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<AffectedRowsOutput> updateMany({
    required PostUpdateManyMutationInput data,
    PostWhereInput? where,
  }) {
    final input = [
      Input(
        "data",
        false,
        null,
        data.toFields(),
      ),
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "updateMany",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(
          value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<Post> upsertOne({
    required PostWhereUniqueInput where,
    required PostCreateInput create,
    required PostUpdateInput update,
  }) {
    final input = [
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
      Input(
        "create",
        false,
        null,
        create.toFields(),
      ),
      Input(
        "update",
        false,
        null,
        update.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "upsertOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return Post.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<Post?> deleteOne({
    required PostWhereUniqueInput where,
  }) {
    final input = [
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "deleteOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return Post.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<AffectedRowsOutput> deleteMany({
    PostWhereInput? where,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "deleteMany",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(
          value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<AggregatePost> aggregate({
    PostWhereInput? where,
    List<PostOrderByWithRelationInput>? orderBy,
    PostWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      if (cursor != null)
        Input(
          "cursor",
          false,
          null,
          cursor.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "aggregate",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return AggregatePost.fromJson(
          value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<List<PostGroupByOutputType>> groupBy({
    PostWhereInput? where,
    List<PostOrderByWithAggregationInput>? orderBy,
    required List<PostScalarFieldEnum> by,
    PostScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      Input(
        "by",
        true,
        toEnumsField(by),
        null,
      ),
      if (having != null)
        Input(
          "having",
          false,
          null,
          having.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "groupBy",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) return [];
      return (value.data!.result! as List).map((e) {
        return PostGroupByOutputType.fromJson(
            value.data!.result! as Map<String, dynamic>);
      }).toList();
    });
  }
}

class UserModel {
  static const String model = "User";
  final Engine engine;
  UserModel(this.engine);
  static const _outputField = [
    Output("id"),
    Output("userName"),
    Output("name"),
    Output("password"),
    Output("resturantId")
  ];
  Future<User?> findUnique({
    required UserWhereUniqueInput where,
  }) {
    final input = [
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "findUnique",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return User.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<User?> findFirst({
    UserWhereInput? where,
    List<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<UserScalarFieldEnum>? distinct,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      if (cursor != null)
        Input(
          "cursor",
          false,
          null,
          cursor.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
      if (distinct != null)
        Input(
          "distinct",
          true,
          toEnumsField(distinct),
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "findFirst",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return User.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<List<User>> findMany({
    UserWhereInput? where,
    List<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<UserScalarFieldEnum>? distinct,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      if (cursor != null)
        Input(
          "cursor",
          false,
          null,
          cursor.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
      if (distinct != null)
        Input(
          "distinct",
          true,
          toEnumsField(distinct),
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "findMany",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) return [];
      return (value.data!.result! as List).map((e) {
        return User.fromJson(value.data!.result! as Map<String, dynamic>);
      }).toList();
    });
  }

  Future<User> createOne({
    required UserCreateInput data,
  }) {
    final input = [
      Input(
        "data",
        false,
        null,
        data.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "createOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return User.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<User?> updateOne({
    required UserUpdateInput data,
    required UserWhereUniqueInput where,
  }) {
    final input = [
      Input(
        "data",
        false,
        null,
        data.toFields(),
      ),
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "updateOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return User.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<AffectedRowsOutput> updateMany({
    required UserUpdateManyMutationInput data,
    UserWhereInput? where,
  }) {
    final input = [
      Input(
        "data",
        false,
        null,
        data.toFields(),
      ),
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "updateMany",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(
          value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<User> upsertOne({
    required UserWhereUniqueInput where,
    required UserCreateInput create,
    required UserUpdateInput update,
  }) {
    final input = [
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
      Input(
        "create",
        false,
        null,
        create.toFields(),
      ),
      Input(
        "update",
        false,
        null,
        update.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "upsertOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return User.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<User?> deleteOne({
    required UserWhereUniqueInput where,
  }) {
    final input = [
      Input(
        "where",
        false,
        null,
        where.toFields(),
      ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "deleteOne",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) {
        return null;
      }
      return User.fromJson(value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<AffectedRowsOutput> deleteMany({
    UserWhereInput? where,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "deleteMany",
        operation: "mutation",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return AffectedRowsOutput.fromJson(
          value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<AggregateUser> aggregate({
    UserWhereInput? where,
    List<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      if (cursor != null)
        Input(
          "cursor",
          false,
          null,
          cursor.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "aggregate",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      return AggregateUser.fromJson(
          value.data!.result! as Map<String, dynamic>);
    });
  }

  Future<List<UserGroupByOutputType>> groupBy({
    UserWhereInput? where,
    List<UserOrderByWithAggregationInput>? orderBy,
    required List<UserScalarFieldEnum> by,
    UserScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final input = [
      if (where != null)
        Input(
          "where",
          false,
          null,
          where.toFields(),
        ),
      if (orderBy != null)
        Input(
          "orderBy",
          true,
          null,
          toObjectField(orderBy),
        ),
      Input(
        "by",
        true,
        toEnumsField(by),
        null,
      ),
      if (having != null)
        Input(
          "having",
          false,
          null,
          having.toFields(),
        ),
      if (take != null)
        Input(
          "take",
          false,
          take,
          null,
        ),
      if (skip != null)
        Input(
          "skip",
          false,
          skip,
          null,
        ),
    ];
    final Query query = Query(
        engine: engine,
        model: model,
        method: "groupBy",
        operation: "query",
        input: input,
        output: _outputField,
        name: "");
    return query.exec().then((value) {
      if (value.data?.result == null) return [];
      return (value.data!.result! as List).map((e) {
        return UserGroupByOutputType.fromJson(
            value.data!.result! as Map<String, dynamic>);
      }).toList();
    });
  }
}

const schema = '''// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-dart"
}


datasource db {
    // could be postgresql or mysql
    provider = "sqlite"
    url      = "file:dev.db"
}



model Post {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title     String
    published Boolean
    desc      String?

    User   User? @relation(fields: [userId], references: [id])
    userId Int?
}

model User {
    id          Int    @id @default(autoincrement())
    userName    String @unique
    name        String
    password    String
    resturantId Int?
    posts       Post[]
}
''';
