// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: camel_case_types, constant_identifier_names, non_constant_identifier_names

import 'package:orm/orm.dart' as runtime;
import 'package:orm/dmmf.dart' as dmmf;

export 'package:orm/orm.dart'
    show PrismaNull, PrismaUnion, TransactionIsolationLevel;

//******************************************************************************
// This file was generated by Prisma ORM
// GitHub: https://github.com/odroe/prisma-dart
//******************************************************************************

enum PostScalarFieldEnum {
  id,
  title,
  content,
  published,
  authorId,
  created_at,
}

enum QueryMode {
  default$,
  insensitive,
}

enum SortOrder {
  asc,
  desc,
}

enum User_ScalarFieldEnum {
  id,
  name,
  createdAt,
}

class User_WhereInput {
  const User_WhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
    this.posts,
  });

  final List<User_WhereInput>? AND;
  final List<User_WhereInput>? OR;
  final List<User_WhereInput>? NOT;
  final runtime.PrismaUnion<IntFilter, int>? id;
  final runtime.PrismaUnion<StringFilter, String>? name;
  final runtime.PrismaUnion<DateTimeFilter, DateTime>? createdAt;
  final PostListRelationFilter? posts;
}

class User_OrderByWithRelationInput {
  const User_OrderByWithRelationInput({
    this.id,
    this.name,
    this.createdAt,
    this.posts,
  });

  final SortOrder? id;
  final SortOrder? name;
  final SortOrder? createdAt;
  final PostOrderByRelationAggregateInput? posts;
}

class User_WhereUniqueInput {
  const User_WhereUniqueInput({
    this.id,
  });

  final int? id;
}

class User_OrderByWithAggregationInput {
  const User_OrderByWithAggregationInput({
    this.id,
    this.name,
    this.createdAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final SortOrder? id;
  final SortOrder? name;
  final SortOrder? createdAt;
  final User_CountOrderByAggregateInput? $count;
  final User_AvgOrderByAggregateInput? $avg;
  final User_MaxOrderByAggregateInput? $max;
  final User_MinOrderByAggregateInput? $min;
  final User_SumOrderByAggregateInput? $sum;
}

class User_ScalarWhereWithAggregatesInput {
  const User_ScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.createdAt,
  });

  final List<User_ScalarWhereWithAggregatesInput>? AND;
  final List<User_ScalarWhereWithAggregatesInput>? OR;
  final List<User_ScalarWhereWithAggregatesInput>? NOT;
  final runtime.PrismaUnion<IntWithAggregatesFilter, int>? id;
  final runtime.PrismaUnion<StringWithAggregatesFilter, String>? name;
  final runtime.PrismaUnion<DateTimeWithAggregatesFilter, DateTime>? createdAt;
}

class PostWhereInput {
  const PostWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.author,
    this.created_at,
  });

  final List<PostWhereInput>? AND;
  final List<PostWhereInput>? OR;
  final List<PostWhereInput>? NOT;
  final runtime.PrismaUnion<IntFilter, int>? id;
  final runtime.PrismaUnion<StringFilter, String>? title;
  final runtime.PrismaUnion<StringFilter, String>? content;
  final runtime.PrismaUnion<BoolFilter, bool>? published;
  final runtime.PrismaUnion<IntFilter, int>? authorId;
  final runtime.PrismaUnion<User_RelationFilter, User_WhereInput>? author;
  final runtime.PrismaUnion<DateTimeFilter, DateTime>? created_at;
}

class PostOrderByWithRelationInput {
  const PostOrderByWithRelationInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.author,
    this.created_at,
  });

  final SortOrder? id;
  final SortOrder? title;
  final SortOrder? content;
  final SortOrder? published;
  final SortOrder? authorId;
  final User_OrderByWithRelationInput? author;
  final SortOrder? created_at;
}

class PostWhereUniqueInput {
  const PostWhereUniqueInput({
    this.id,
  });

  final int? id;
}

class PostOrderByWithAggregationInput {
  const PostOrderByWithAggregationInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final SortOrder? id;
  final SortOrder? title;
  final SortOrder? content;
  final SortOrder? published;
  final SortOrder? authorId;
  final SortOrder? created_at;
  final PostCountOrderByAggregateInput? $count;
  final PostAvgOrderByAggregateInput? $avg;
  final PostMaxOrderByAggregateInput? $max;
  final PostMinOrderByAggregateInput? $min;
  final PostSumOrderByAggregateInput? $sum;
}

class PostScalarWhereWithAggregatesInput {
  const PostScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final List<PostScalarWhereWithAggregatesInput>? AND;
  final List<PostScalarWhereWithAggregatesInput>? OR;
  final List<PostScalarWhereWithAggregatesInput>? NOT;
  final runtime.PrismaUnion<IntWithAggregatesFilter, int>? id;
  final runtime.PrismaUnion<StringWithAggregatesFilter, String>? title;
  final runtime.PrismaUnion<StringWithAggregatesFilter, String>? content;
  final runtime.PrismaUnion<BoolWithAggregatesFilter, bool>? published;
  final runtime.PrismaUnion<IntWithAggregatesFilter, int>? authorId;
  final runtime.PrismaUnion<DateTimeWithAggregatesFilter, DateTime>? created_at;
}

class User_CreateInput {
  const User_CreateInput({
    required this.name,
    this.createdAt,
    this.posts,
  });

  final String name;
  final DateTime? createdAt;
  final PostCreateNestedManyWithoutAuthorInput? posts;
}

class User_UncheckedCreateInput {
  const User_UncheckedCreateInput({
    this.id,
    required this.name,
    this.createdAt,
    this.posts,
  });

  final int? id;
  final String name;
  final DateTime? createdAt;
  final PostUncheckedCreateNestedManyWithoutAuthorInput? posts;
}

class User_UpdateInput {
  const User_UpdateInput({
    this.name,
    this.createdAt,
    this.posts,
  });

  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? name;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      createdAt;
  final PostUpdateManyWithoutAuthorNestedInput? posts;
}

class User_UncheckedUpdateInput {
  const User_UncheckedUpdateInput({
    this.id,
    this.name,
    this.createdAt,
    this.posts,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? name;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      createdAt;
  final PostUncheckedUpdateManyWithoutAuthorNestedInput? posts;
}

class User_CreateManyInput {
  const User_CreateManyInput({
    this.id,
    required this.name,
    this.createdAt,
  });

  final int? id;
  final String name;
  final DateTime? createdAt;
}

class User_UpdateManyMutationInput {
  const User_UpdateManyMutationInput({
    this.name,
    this.createdAt,
  });

  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? name;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      createdAt;
}

class User_UncheckedUpdateManyInput {
  const User_UncheckedUpdateManyInput({
    this.id,
    this.name,
    this.createdAt,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? name;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      createdAt;
}

class PostCreateInput {
  const PostCreateInput({
    required this.title,
    required this.content,
    required this.published,
    required this.author,
    this.created_at,
  });

  final String title;
  final String content;
  final bool published;
  final User_CreateNestedOneWithoutPostsInput author;
  final DateTime? created_at;
}

class PostUncheckedCreateInput {
  const PostUncheckedCreateInput({
    this.id,
    required this.title,
    required this.content,
    required this.published,
    required this.authorId,
    this.created_at,
  });

  final int? id;
  final String title;
  final String content;
  final bool published;
  final int authorId;
  final DateTime? created_at;
}

class PostUpdateInput {
  const PostUpdateInput({
    this.title,
    this.content,
    this.published,
    this.author,
    this.created_at,
  });

  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final User_UpdateOneRequiredWithoutPostsNestedInput? author;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class PostUncheckedUpdateInput {
  const PostUncheckedUpdateInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? authorId;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class PostCreateManyInput {
  const PostCreateManyInput({
    this.id,
    required this.title,
    required this.content,
    required this.published,
    required this.authorId,
    this.created_at,
  });

  final int? id;
  final String title;
  final String content;
  final bool published;
  final int authorId;
  final DateTime? created_at;
}

class PostUpdateManyMutationInput {
  const PostUpdateManyMutationInput({
    this.title,
    this.content,
    this.published,
    this.created_at,
  });

  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class PostUncheckedUpdateManyInput {
  const PostUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? authorId;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class IntFilter {
  const IntFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final int? equals;
  final List<int>? in$;
  final List<int>? notIn;
  final int? lt;
  final int? lte;
  final int? gt;
  final int? gte;
  final runtime.PrismaUnion<int, NestedIntFilter>? not;
}

class StringFilter {
  const StringFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
  });

  final String? equals;
  final List<String>? in$;
  final List<String>? notIn;
  final String? lt;
  final String? lte;
  final String? gt;
  final String? gte;
  final String? contains;
  final String? startsWith;
  final String? endsWith;
  final QueryMode? mode;
  final runtime.PrismaUnion<String, NestedStringFilter>? not;
}

class DateTimeFilter {
  const DateTimeFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final DateTime? equals;
  final List<DateTime>? in$;
  final List<DateTime>? notIn;
  final DateTime? lt;
  final DateTime? lte;
  final DateTime? gt;
  final DateTime? gte;
  final runtime.PrismaUnion<DateTime, NestedDateTimeFilter>? not;
}

class PostListRelationFilter {
  const PostListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final PostWhereInput? every;
  final PostWhereInput? some;
  final PostWhereInput? none;
}

class PostOrderByRelationAggregateInput {
  const PostOrderByRelationAggregateInput({
    this.$count,
  });

  final SortOrder? $count;
}

class User_CountOrderByAggregateInput {
  const User_CountOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
  });

  final SortOrder? id;
  final SortOrder? name;
  final SortOrder? createdAt;
}

class User_AvgOrderByAggregateInput {
  const User_AvgOrderByAggregateInput({
    this.id,
  });

  final SortOrder? id;
}

class User_MaxOrderByAggregateInput {
  const User_MaxOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
  });

  final SortOrder? id;
  final SortOrder? name;
  final SortOrder? createdAt;
}

class User_MinOrderByAggregateInput {
  const User_MinOrderByAggregateInput({
    this.id,
    this.name,
    this.createdAt,
  });

  final SortOrder? id;
  final SortOrder? name;
  final SortOrder? createdAt;
}

class User_SumOrderByAggregateInput {
  const User_SumOrderByAggregateInput({
    this.id,
  });

  final SortOrder? id;
}

class IntWithAggregatesFilter {
  const IntWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final int? equals;
  final List<int>? in$;
  final List<int>? notIn;
  final int? lt;
  final int? lte;
  final int? gt;
  final int? gte;
  final runtime.PrismaUnion<int, NestedIntWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedFloatFilter? $avg;
  final NestedIntFilter? $sum;
  final NestedIntFilter? $min;
  final NestedIntFilter? $max;
}

class StringWithAggregatesFilter {
  const StringWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final String? equals;
  final List<String>? in$;
  final List<String>? notIn;
  final String? lt;
  final String? lte;
  final String? gt;
  final String? gte;
  final String? contains;
  final String? startsWith;
  final String? endsWith;
  final QueryMode? mode;
  final runtime.PrismaUnion<String, NestedStringWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedStringFilter? $min;
  final NestedStringFilter? $max;
}

class DateTimeWithAggregatesFilter {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final DateTime? equals;
  final List<DateTime>? in$;
  final List<DateTime>? notIn;
  final DateTime? lt;
  final DateTime? lte;
  final DateTime? gt;
  final DateTime? gte;
  final runtime.PrismaUnion<DateTime, NestedDateTimeWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedDateTimeFilter? $min;
  final NestedDateTimeFilter? $max;
}

class BoolFilter {
  const BoolFilter({
    this.equals,
    this.not,
  });

  final bool? equals;
  final runtime.PrismaUnion<bool, NestedBoolFilter>? not;
}

class User_RelationFilter {
  const User_RelationFilter({
    this.is$,
    this.isNot,
  });

  final User_WhereInput? is$;
  final User_WhereInput? isNot;
}

class PostCountOrderByAggregateInput {
  const PostCountOrderByAggregateInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final SortOrder? id;
  final SortOrder? title;
  final SortOrder? content;
  final SortOrder? published;
  final SortOrder? authorId;
  final SortOrder? created_at;
}

class PostAvgOrderByAggregateInput {
  const PostAvgOrderByAggregateInput({
    this.id,
    this.authorId,
  });

  final SortOrder? id;
  final SortOrder? authorId;
}

class PostMaxOrderByAggregateInput {
  const PostMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final SortOrder? id;
  final SortOrder? title;
  final SortOrder? content;
  final SortOrder? published;
  final SortOrder? authorId;
  final SortOrder? created_at;
}

class PostMinOrderByAggregateInput {
  const PostMinOrderByAggregateInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final SortOrder? id;
  final SortOrder? title;
  final SortOrder? content;
  final SortOrder? published;
  final SortOrder? authorId;
  final SortOrder? created_at;
}

class PostSumOrderByAggregateInput {
  const PostSumOrderByAggregateInput({
    this.id,
    this.authorId,
  });

  final SortOrder? id;
  final SortOrder? authorId;
}

class BoolWithAggregatesFilter {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? equals;
  final runtime.PrismaUnion<bool, NestedBoolWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedBoolFilter? $min;
  final NestedBoolFilter? $max;
}

class PostCreateNestedManyWithoutAuthorInput {
  const PostCreateNestedManyWithoutAuthorInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final List<PostCreateWithoutAuthorInput>? create;
  final List<PostCreateOrConnectWithoutAuthorInput>? connectOrCreate;
  final PostCreateManyAuthorInputEnvelope? createMany;
  final List<PostWhereUniqueInput>? connect;
}

class PostUncheckedCreateNestedManyWithoutAuthorInput {
  const PostUncheckedCreateNestedManyWithoutAuthorInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final List<PostCreateWithoutAuthorInput>? create;
  final List<PostCreateOrConnectWithoutAuthorInput>? connectOrCreate;
  final PostCreateManyAuthorInputEnvelope? createMany;
  final List<PostWhereUniqueInput>? connect;
}

class StringFieldUpdateOperationsInput {
  const StringFieldUpdateOperationsInput({
    this.set$,
  });

  final String? set$;
}

class DateTimeFieldUpdateOperationsInput {
  const DateTimeFieldUpdateOperationsInput({
    this.set$,
  });

  final DateTime? set$;
}

class PostUpdateManyWithoutAuthorNestedInput {
  const PostUpdateManyWithoutAuthorNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set$,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final List<PostCreateWithoutAuthorInput>? create;
  final List<PostCreateOrConnectWithoutAuthorInput>? connectOrCreate;
  final List<PostUpsertWithWhereUniqueWithoutAuthorInput>? upsert;
  final PostCreateManyAuthorInputEnvelope? createMany;
  final List<PostWhereUniqueInput>? set$;
  final List<PostWhereUniqueInput>? disconnect;
  final List<PostWhereUniqueInput>? delete;
  final List<PostWhereUniqueInput>? connect;
  final List<PostUpdateWithWhereUniqueWithoutAuthorInput>? update;
  final List<PostUpdateManyWithWhereWithoutAuthorInput>? updateMany;
  final List<PostScalarWhereInput>? deleteMany;
}

class IntFieldUpdateOperationsInput {
  const IntFieldUpdateOperationsInput({
    this.set$,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final int? set$;
  final int? increment;
  final int? decrement;
  final int? multiply;
  final int? divide;
}

class PostUncheckedUpdateManyWithoutAuthorNestedInput {
  const PostUncheckedUpdateManyWithoutAuthorNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set$,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final List<PostCreateWithoutAuthorInput>? create;
  final List<PostCreateOrConnectWithoutAuthorInput>? connectOrCreate;
  final List<PostUpsertWithWhereUniqueWithoutAuthorInput>? upsert;
  final PostCreateManyAuthorInputEnvelope? createMany;
  final List<PostWhereUniqueInput>? set$;
  final List<PostWhereUniqueInput>? disconnect;
  final List<PostWhereUniqueInput>? delete;
  final List<PostWhereUniqueInput>? connect;
  final List<PostUpdateWithWhereUniqueWithoutAuthorInput>? update;
  final List<PostUpdateManyWithWhereWithoutAuthorInput>? updateMany;
  final List<PostScalarWhereInput>? deleteMany;
}

class User_CreateNestedOneWithoutPostsInput {
  const User_CreateNestedOneWithoutPostsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final runtime.PrismaUnion<User_CreateWithoutPostsInput,
      User_UncheckedCreateWithoutPostsInput>? create;
  final User_CreateOrConnectWithoutPostsInput? connectOrCreate;
  final User_WhereUniqueInput? connect;
}

class BoolFieldUpdateOperationsInput {
  const BoolFieldUpdateOperationsInput({
    this.set$,
  });

  final bool? set$;
}

class User_UpdateOneRequiredWithoutPostsNestedInput {
  const User_UpdateOneRequiredWithoutPostsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final runtime.PrismaUnion<User_CreateWithoutPostsInput,
      User_UncheckedCreateWithoutPostsInput>? create;
  final User_CreateOrConnectWithoutPostsInput? connectOrCreate;
  final User_UpsertWithoutPostsInput? upsert;
  final User_WhereUniqueInput? connect;
  final runtime.PrismaUnion<User_UpdateWithoutPostsInput,
      User_UncheckedUpdateWithoutPostsInput>? update;
}

class NestedIntFilter {
  const NestedIntFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final int? equals;
  final List<int>? in$;
  final List<int>? notIn;
  final int? lt;
  final int? lte;
  final int? gt;
  final int? gte;
  final runtime.PrismaUnion<int, NestedIntFilter>? not;
}

class NestedStringFilter {
  const NestedStringFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final String? equals;
  final List<String>? in$;
  final List<String>? notIn;
  final String? lt;
  final String? lte;
  final String? gt;
  final String? gte;
  final String? contains;
  final String? startsWith;
  final String? endsWith;
  final runtime.PrismaUnion<String, NestedStringFilter>? not;
}

class NestedDateTimeFilter {
  const NestedDateTimeFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final DateTime? equals;
  final List<DateTime>? in$;
  final List<DateTime>? notIn;
  final DateTime? lt;
  final DateTime? lte;
  final DateTime? gt;
  final DateTime? gte;
  final runtime.PrismaUnion<DateTime, NestedDateTimeFilter>? not;
}

class NestedIntWithAggregatesFilter {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final int? equals;
  final List<int>? in$;
  final List<int>? notIn;
  final int? lt;
  final int? lte;
  final int? gt;
  final int? gte;
  final runtime.PrismaUnion<int, NestedIntWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedFloatFilter? $avg;
  final NestedIntFilter? $sum;
  final NestedIntFilter? $min;
  final NestedIntFilter? $max;
}

class NestedFloatFilter {
  const NestedFloatFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final double? equals;
  final List<double>? in$;
  final List<double>? notIn;
  final double? lt;
  final double? lte;
  final double? gt;
  final double? gte;
  final runtime.PrismaUnion<double, NestedFloatFilter>? not;
}

class NestedStringWithAggregatesFilter {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final String? equals;
  final List<String>? in$;
  final List<String>? notIn;
  final String? lt;
  final String? lte;
  final String? gt;
  final String? gte;
  final String? contains;
  final String? startsWith;
  final String? endsWith;
  final runtime.PrismaUnion<String, NestedStringWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedStringFilter? $min;
  final NestedStringFilter? $max;
}

class NestedDateTimeWithAggregatesFilter {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.in$,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final DateTime? equals;
  final List<DateTime>? in$;
  final List<DateTime>? notIn;
  final DateTime? lt;
  final DateTime? lte;
  final DateTime? gt;
  final DateTime? gte;
  final runtime.PrismaUnion<DateTime, NestedDateTimeWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedDateTimeFilter? $min;
  final NestedDateTimeFilter? $max;
}

class NestedBoolFilter {
  const NestedBoolFilter({
    this.equals,
    this.not,
  });

  final bool? equals;
  final runtime.PrismaUnion<bool, NestedBoolFilter>? not;
}

class NestedBoolWithAggregatesFilter {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? equals;
  final runtime.PrismaUnion<bool, NestedBoolWithAggregatesFilter>? not;
  final NestedIntFilter? $count;
  final NestedBoolFilter? $min;
  final NestedBoolFilter? $max;
}

class PostCreateWithoutAuthorInput {
  const PostCreateWithoutAuthorInput({
    required this.title,
    required this.content,
    required this.published,
    this.created_at,
  });

  final String title;
  final String content;
  final bool published;
  final DateTime? created_at;
}

class PostUncheckedCreateWithoutAuthorInput {
  const PostUncheckedCreateWithoutAuthorInput({
    this.id,
    required this.title,
    required this.content,
    required this.published,
    this.created_at,
  });

  final int? id;
  final String title;
  final String content;
  final bool published;
  final DateTime? created_at;
}

class PostCreateOrConnectWithoutAuthorInput {
  const PostCreateOrConnectWithoutAuthorInput({
    required this.where,
    required this.create,
  });

  final PostWhereUniqueInput where;
  final runtime.PrismaUnion<PostCreateWithoutAuthorInput,
      PostUncheckedCreateWithoutAuthorInput> create;
}

class PostCreateManyAuthorInputEnvelope {
  const PostCreateManyAuthorInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final List<PostCreateManyAuthorInput> data;
  final bool? skipDuplicates;
}

class PostUpsertWithWhereUniqueWithoutAuthorInput {
  const PostUpsertWithWhereUniqueWithoutAuthorInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final PostWhereUniqueInput where;
  final runtime.PrismaUnion<PostUpdateWithoutAuthorInput,
      PostUncheckedUpdateWithoutAuthorInput> update;
  final runtime.PrismaUnion<PostCreateWithoutAuthorInput,
      PostUncheckedCreateWithoutAuthorInput> create;
}

class PostUpdateWithWhereUniqueWithoutAuthorInput {
  const PostUpdateWithWhereUniqueWithoutAuthorInput({
    required this.where,
    required this.data,
  });

  final PostWhereUniqueInput where;
  final runtime.PrismaUnion<PostUpdateWithoutAuthorInput,
      PostUncheckedUpdateWithoutAuthorInput> data;
}

class PostUpdateManyWithWhereWithoutAuthorInput {
  const PostUpdateManyWithWhereWithoutAuthorInput({
    required this.where,
    required this.data,
  });

  final PostScalarWhereInput where;
  final runtime.PrismaUnion<PostUpdateManyMutationInput,
      PostUncheckedUpdateManyWithoutPostsInput> data;
}

class PostScalarWhereInput {
  const PostScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final List<PostScalarWhereInput>? AND;
  final List<PostScalarWhereInput>? OR;
  final List<PostScalarWhereInput>? NOT;
  final runtime.PrismaUnion<IntFilter, int>? id;
  final runtime.PrismaUnion<StringFilter, String>? title;
  final runtime.PrismaUnion<StringFilter, String>? content;
  final runtime.PrismaUnion<BoolFilter, bool>? published;
  final runtime.PrismaUnion<IntFilter, int>? authorId;
  final runtime.PrismaUnion<DateTimeFilter, DateTime>? created_at;
}

class User_CreateWithoutPostsInput {
  const User_CreateWithoutPostsInput({
    required this.name,
    this.createdAt,
  });

  final String name;
  final DateTime? createdAt;
}

class User_UncheckedCreateWithoutPostsInput {
  const User_UncheckedCreateWithoutPostsInput({
    this.id,
    required this.name,
    this.createdAt,
  });

  final int? id;
  final String name;
  final DateTime? createdAt;
}

class User_CreateOrConnectWithoutPostsInput {
  const User_CreateOrConnectWithoutPostsInput({
    required this.where,
    required this.create,
  });

  final User_WhereUniqueInput where;
  final runtime.PrismaUnion<User_CreateWithoutPostsInput,
      User_UncheckedCreateWithoutPostsInput> create;
}

class User_UpsertWithoutPostsInput {
  const User_UpsertWithoutPostsInput({
    required this.update,
    required this.create,
  });

  final runtime.PrismaUnion<User_UpdateWithoutPostsInput,
      User_UncheckedUpdateWithoutPostsInput> update;
  final runtime.PrismaUnion<User_CreateWithoutPostsInput,
      User_UncheckedCreateWithoutPostsInput> create;
}

class User_UpdateWithoutPostsInput {
  const User_UpdateWithoutPostsInput({
    this.name,
    this.createdAt,
  });

  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? name;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      createdAt;
}

class User_UncheckedUpdateWithoutPostsInput {
  const User_UncheckedUpdateWithoutPostsInput({
    this.id,
    this.name,
    this.createdAt,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? name;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      createdAt;
}

class PostCreateManyAuthorInput {
  const PostCreateManyAuthorInput({
    this.id,
    required this.title,
    required this.content,
    required this.published,
    this.created_at,
  });

  final int? id;
  final String title;
  final String content;
  final bool published;
  final DateTime? created_at;
}

class PostUpdateWithoutAuthorInput {
  const PostUpdateWithoutAuthorInput({
    this.title,
    this.content,
    this.published,
    this.created_at,
  });

  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class PostUncheckedUpdateWithoutAuthorInput {
  const PostUncheckedUpdateWithoutAuthorInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.created_at,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class PostUncheckedUpdateManyWithoutPostsInput {
  const PostUncheckedUpdateManyWithoutPostsInput({
    this.id,
    this.title,
    this.content,
    this.published,
    this.created_at,
  });

  final runtime.PrismaUnion<int, IntFieldUpdateOperationsInput>? id;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? title;
  final runtime.PrismaUnion<String, StringFieldUpdateOperationsInput>? content;
  final runtime.PrismaUnion<bool, BoolFieldUpdateOperationsInput>? published;
  final runtime.PrismaUnion<DateTime, DateTimeFieldUpdateOperationsInput>?
      created_at;
}

class AggregateUser_ {
  const AggregateUser_({
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final User_AvgAggregateOutputType? $avg;
  final User_SumAggregateOutputType? $sum;
  final User_MinAggregateOutputType? $min;
  final User_MaxAggregateOutputType? $max;
}

class User_GroupByOutputType {
  const User_GroupByOutputType({
    required this.id,
    required this.name,
    required this.createdAt,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final int id;
  final String name;
  final DateTime createdAt;
  final User_AvgAggregateOutputType? $avg;
  final User_SumAggregateOutputType? $sum;
  final User_MinAggregateOutputType? $min;
  final User_MaxAggregateOutputType? $max;
}

class AggregatePost {
  const AggregatePost({
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final PostAvgAggregateOutputType? $avg;
  final PostSumAggregateOutputType? $sum;
  final PostMinAggregateOutputType? $min;
  final PostMaxAggregateOutputType? $max;
}

class PostGroupByOutputType {
  const PostGroupByOutputType({
    required this.id,
    required this.title,
    required this.content,
    required this.published,
    required this.authorId,
    required this.created_at,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final int id;
  final String title;
  final String content;
  final bool published;
  final int authorId;
  final DateTime created_at;
  final PostAvgAggregateOutputType? $avg;
  final PostSumAggregateOutputType? $sum;
  final PostMinAggregateOutputType? $min;
  final PostMaxAggregateOutputType? $max;
}

class AffectedRowsOutput {
  const AffectedRowsOutput({
    required this.count,
  });

  final int count;
}

class User_CountOutputType {
  const User_CountOutputType({
    required this.posts,
  });

  final int posts;
}

class User_CountAggregateOutputType {
  const User_CountAggregateOutputType({
    required this.id,
    required this.name,
    required this.createdAt,
    required this.$all,
  });

  final int id;
  final int name;
  final int createdAt;
  final int $all;
}

class User_AvgAggregateOutputType {
  const User_AvgAggregateOutputType({
    this.id,
  });

  final double? id;
}

class User_SumAggregateOutputType {
  const User_SumAggregateOutputType({
    this.id,
  });

  final int? id;
}

class User_MinAggregateOutputType {
  const User_MinAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
  });

  final int? id;
  final String? name;
  final DateTime? createdAt;
}

class User_MaxAggregateOutputType {
  const User_MaxAggregateOutputType({
    this.id,
    this.name,
    this.createdAt,
  });

  final int? id;
  final String? name;
  final DateTime? createdAt;
}

class PostCountAggregateOutputType {
  const PostCountAggregateOutputType({
    required this.id,
    required this.title,
    required this.content,
    required this.published,
    required this.authorId,
    required this.created_at,
    required this.$all,
  });

  final int id;
  final int title;
  final int content;
  final int published;
  final int authorId;
  final int created_at;
  final int $all;
}

class PostAvgAggregateOutputType {
  const PostAvgAggregateOutputType({
    this.id,
    this.authorId,
  });

  final double? id;
  final double? authorId;
}

class PostSumAggregateOutputType {
  const PostSumAggregateOutputType({
    this.id,
    this.authorId,
  });

  final int? id;
  final int? authorId;
}

class PostMinAggregateOutputType {
  const PostMinAggregateOutputType({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final int? id;
  final String? title;
  final String? content;
  final bool? published;
  final int? authorId;
  final DateTime? created_at;
}

class PostMaxAggregateOutputType {
  const PostMaxAggregateOutputType({
    this.id,
    this.title,
    this.content,
    this.published,
    this.authorId,
    this.created_at,
  });

  final int? id;
  final String? title;
  final String? content;
  final bool? published;
  final int? authorId;
  final DateTime? created_at;
}

class User_ {
  const User_({
    required this.id,
    required this.name,
    required this.createdAt,
    this.posts,
  });

  final int id;
  final String name;
  final DateTime createdAt;
  final List<Post>? posts;
}

class Post {
  const Post({
    required this.id,
    required this.title,
    required this.content,
    required this.published,
    required this.authorId,
    required this.author,
    required this.created_at,
  });

  final int id;
  final String title;
  final String content;
  final bool published;
  final int authorId;
  final User_ author;
  final DateTime created_at;
}

class User_Delegate {
  const User_Delegate({
    required runtime.Engine engine,
    required dmmf.Document document,
  })  : _engine = engine,
        _document = document;

  final runtime.Engine _engine;
  final dmmf.Document _document;

  Future<User_?> findUnique({
    required User_WhereUniqueInput where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'findUniqueUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<User_?> findFirst({
    User_WhereInput? where,
    List<User_OrderByWithRelationInput>? orderBy,
    User_WhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<User_ScalarFieldEnum>? distinct,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('cursor', cursor, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
      runtime.GraphQLVeriable('distinct', distinct, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'findFirstUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<List<User_>> findMany({
    User_WhereInput? where,
    List<User_OrderByWithRelationInput>? orderBy,
    User_WhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<User_ScalarFieldEnum>? distinct,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('cursor', cursor, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
      runtime.GraphQLVeriable('distinct', distinct, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'findManyUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<User_> create({
    required runtime.PrismaUnion<User_CreateInput, User_UncheckedCreateInput>
        data,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'createOneUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AffectedRowsOutput> createMany({
    required List<User_CreateManyInput> data,
    bool? skipDuplicates,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
      runtime.GraphQLVeriable('skipDuplicates', skipDuplicates,
          isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'createManyUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<User_?> update({
    required runtime.PrismaUnion<User_UpdateInput, User_UncheckedUpdateInput>
        data,
    required User_WhereUniqueInput where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
      runtime.GraphQLVeriable('where', where, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'updateOneUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AffectedRowsOutput> updateMany({
    required runtime.PrismaUnion<User_UpdateManyMutationInput,
            User_UncheckedUpdateManyInput>
        data,
    User_WhereInput? where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
      runtime.GraphQLVeriable('where', where, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'updateManyUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<User_> upsert({
    required User_WhereUniqueInput where,
    required runtime.PrismaUnion<User_CreateInput, User_UncheckedCreateInput>
        create,
    required runtime.PrismaUnion<User_UpdateInput, User_UncheckedUpdateInput>
        update,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: true),
      runtime.GraphQLVeriable('create', create, isRequired: true),
      runtime.GraphQLVeriable('update', update, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'upsertOneUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<User_?> delete({
    required User_WhereUniqueInput where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'deleteOneUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AffectedRowsOutput> deleteMany({
    User_WhereInput? where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'deleteManyUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AggregateUser_> aggregate({
    User_WhereInput? where,
    List<User_OrderByWithRelationInput>? orderBy,
    User_WhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('cursor', cursor, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'aggregateUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<List<User_GroupByOutputType>> groupBy({
    User_WhereInput? where,
    List<User_OrderByWithAggregationInput>? orderBy,
    required List<User_ScalarFieldEnum> by,
    User_ScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('by', by, isRequired: true),
      runtime.GraphQLVeriable('having', having, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'groupByUser_',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: User_ScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }
}

class PostDelegate {
  const PostDelegate({
    required runtime.Engine engine,
    required dmmf.Document document,
  })  : _engine = engine,
        _document = document;

  final runtime.Engine _engine;
  final dmmf.Document _document;

  Future<Post?> findUnique({
    required PostWhereUniqueInput where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'findUniquePost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<Post?> findFirst({
    PostWhereInput? where,
    List<PostOrderByWithRelationInput>? orderBy,
    PostWhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<PostScalarFieldEnum>? distinct,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('cursor', cursor, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
      runtime.GraphQLVeriable('distinct', distinct, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'findFirstPost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<List<Post>> findMany({
    PostWhereInput? where,
    List<PostOrderByWithRelationInput>? orderBy,
    PostWhereUniqueInput? cursor,
    int? take,
    int? skip,
    List<PostScalarFieldEnum>? distinct,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('cursor', cursor, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
      runtime.GraphQLVeriable('distinct', distinct, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'findManyPost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<Post> create({
    required runtime.PrismaUnion<PostCreateInput, PostUncheckedCreateInput>
        data,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'createOnePost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AffectedRowsOutput> createMany({
    required List<PostCreateManyInput> data,
    bool? skipDuplicates,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
      runtime.GraphQLVeriable('skipDuplicates', skipDuplicates,
          isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'createManyPost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<Post?> update({
    required runtime.PrismaUnion<PostUpdateInput, PostUncheckedUpdateInput>
        data,
    required PostWhereUniqueInput where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
      runtime.GraphQLVeriable('where', where, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'updateOnePost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AffectedRowsOutput> updateMany({
    required runtime.PrismaUnion<PostUpdateManyMutationInput,
            PostUncheckedUpdateManyInput>
        data,
    PostWhereInput? where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('data', data, isRequired: true),
      runtime.GraphQLVeriable('where', where, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'updateManyPost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<Post> upsert({
    required PostWhereUniqueInput where,
    required runtime.PrismaUnion<PostCreateInput, PostUncheckedCreateInput>
        create,
    required runtime.PrismaUnion<PostUpdateInput, PostUncheckedUpdateInput>
        update,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: true),
      runtime.GraphQLVeriable('create', create, isRequired: true),
      runtime.GraphQLVeriable('update', update, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'upsertOnePost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<Post?> delete({
    required PostWhereUniqueInput where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: true),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'deleteOnePost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AffectedRowsOutput> deleteMany({
    PostWhereInput? where,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'deleteManyPost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'mutation',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<AggregatePost> aggregate({
    PostWhereInput? where,
    List<PostOrderByWithRelationInput>? orderBy,
    PostWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('cursor', cursor, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'aggregatePost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }

  Future<List<PostGroupByOutputType>> groupBy({
    PostWhereInput? where,
    List<PostOrderByWithAggregationInput>? orderBy,
    required List<PostScalarFieldEnum> by,
    PostScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) async {
    final List<runtime.GraphQLVeriable> variables = <runtime.GraphQLVeriable>[
      runtime.GraphQLVeriable('where', where, isRequired: false),
      runtime.GraphQLVeriable('orderBy', orderBy, isRequired: false),
      runtime.GraphQLVeriable('by', by, isRequired: true),
      runtime.GraphQLVeriable('having', having, isRequired: false),
      runtime.GraphQLVeriable('take', take, isRequired: false),
      runtime.GraphQLVeriable('skip', skip, isRequired: false),
    ];
    final runtime.GraphQLSdl sdl = runtime.GraphQLSdl(
      document: _document,
      operationName: 'groupByPost',
      variables: variables,
      fields: runtime.GraphQLFieldsBuilder(
        fields: PostScalarFieldEnum.values,
        document: _document,
      ),
      location: 'query',
    );

    final runtime.QueryEngineResult result =
        await _engine.request(query: sdl.build());

    return result.data;
  }
}
