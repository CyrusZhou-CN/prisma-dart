// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of prisma.client;

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

UserWhereInput_AND _$UserWhereInput_ANDFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserWhereInput':
      return UserWhereInput_AND_withUserWhereInput.fromJson(json);
    case 'withUserWhereInputList':
      return UserWhereInput_AND_withUserWhereInputList.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UserWhereInput_AND',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserWhereInput_AND {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserWhereInput value) withUserWhereInput,
    required TResult Function(List<UserWhereInput> value)
        withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput value)? withUserWhereInput,
    TResult? Function(List<UserWhereInput> value)? withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserWhereInput value)? withUserWhereInput,
    TResult Function(List<UserWhereInput> value)? withUserWhereInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_AND_withUserWhereInput value)
        withUserWhereInput,
    required TResult Function(UserWhereInput_AND_withUserWhereInputList value)
        withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_AND_withUserWhereInput value)?
        withUserWhereInput,
    TResult? Function(UserWhereInput_AND_withUserWhereInputList value)?
        withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_AND_withUserWhereInput value)?
        withUserWhereInput,
    TResult Function(UserWhereInput_AND_withUserWhereInputList value)?
        withUserWhereInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereInput_ANDCopyWith<$Res> {
  factory $UserWhereInput_ANDCopyWith(
          UserWhereInput_AND value, $Res Function(UserWhereInput_AND) then) =
      _$UserWhereInput_ANDCopyWithImpl<$Res, UserWhereInput_AND>;
}

/// @nodoc
class _$UserWhereInput_ANDCopyWithImpl<$Res, $Val extends UserWhereInput_AND>
    implements $UserWhereInput_ANDCopyWith<$Res> {
  _$UserWhereInput_ANDCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserWhereInput_AND_withUserWhereInputCopyWith<$Res> {
  factory _$$UserWhereInput_AND_withUserWhereInputCopyWith(
          _$UserWhereInput_AND_withUserWhereInput value,
          $Res Function(_$UserWhereInput_AND_withUserWhereInput) then) =
      __$$UserWhereInput_AND_withUserWhereInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserWhereInput value});

  $UserWhereInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserWhereInput_AND_withUserWhereInputCopyWithImpl<$Res>
    extends _$UserWhereInput_ANDCopyWithImpl<$Res,
        _$UserWhereInput_AND_withUserWhereInput>
    implements _$$UserWhereInput_AND_withUserWhereInputCopyWith<$Res> {
  __$$UserWhereInput_AND_withUserWhereInputCopyWithImpl(
      _$UserWhereInput_AND_withUserWhereInput _value,
      $Res Function(_$UserWhereInput_AND_withUserWhereInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_AND_withUserWhereInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserWhereInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInputCopyWith<$Res> get value {
    return $UserWhereInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_AND_withUserWhereInput
    implements UserWhereInput_AND_withUserWhereInput {
  const _$UserWhereInput_AND_withUserWhereInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserWhereInput';

  factory _$UserWhereInput_AND_withUserWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_AND_withUserWhereInputFromJson(json);

  @override
  final UserWhereInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_AND.withUserWhereInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_AND_withUserWhereInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_AND_withUserWhereInputCopyWith<
          _$UserWhereInput_AND_withUserWhereInput>
      get copyWith => __$$UserWhereInput_AND_withUserWhereInputCopyWithImpl<
          _$UserWhereInput_AND_withUserWhereInput>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserWhereInput value) withUserWhereInput,
    required TResult Function(List<UserWhereInput> value)
        withUserWhereInputList,
  }) {
    return withUserWhereInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput value)? withUserWhereInput,
    TResult? Function(List<UserWhereInput> value)? withUserWhereInputList,
  }) {
    return withUserWhereInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserWhereInput value)? withUserWhereInput,
    TResult Function(List<UserWhereInput> value)? withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInput != null) {
      return withUserWhereInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_AND_withUserWhereInput value)
        withUserWhereInput,
    required TResult Function(UserWhereInput_AND_withUserWhereInputList value)
        withUserWhereInputList,
  }) {
    return withUserWhereInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_AND_withUserWhereInput value)?
        withUserWhereInput,
    TResult? Function(UserWhereInput_AND_withUserWhereInputList value)?
        withUserWhereInputList,
  }) {
    return withUserWhereInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_AND_withUserWhereInput value)?
        withUserWhereInput,
    TResult Function(UserWhereInput_AND_withUserWhereInputList value)?
        withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInput != null) {
      return withUserWhereInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_AND_withUserWhereInputToJson(
      this,
    );
  }
}

abstract class UserWhereInput_AND_withUserWhereInput
    implements UserWhereInput_AND {
  const factory UserWhereInput_AND_withUserWhereInput(
      final UserWhereInput value) = _$UserWhereInput_AND_withUserWhereInput;

  factory UserWhereInput_AND_withUserWhereInput.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_AND_withUserWhereInput.fromJson;

  @override
  UserWhereInput get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_AND_withUserWhereInputCopyWith<
          _$UserWhereInput_AND_withUserWhereInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserWhereInput_AND_withUserWhereInputListCopyWith<$Res> {
  factory _$$UserWhereInput_AND_withUserWhereInputListCopyWith(
          _$UserWhereInput_AND_withUserWhereInputList value,
          $Res Function(_$UserWhereInput_AND_withUserWhereInputList) then) =
      __$$UserWhereInput_AND_withUserWhereInputListCopyWithImpl<$Res>;
  @useResult
  $Res call({List<UserWhereInput> value});
}

/// @nodoc
class __$$UserWhereInput_AND_withUserWhereInputListCopyWithImpl<$Res>
    extends _$UserWhereInput_ANDCopyWithImpl<$Res,
        _$UserWhereInput_AND_withUserWhereInputList>
    implements _$$UserWhereInput_AND_withUserWhereInputListCopyWith<$Res> {
  __$$UserWhereInput_AND_withUserWhereInputListCopyWithImpl(
      _$UserWhereInput_AND_withUserWhereInputList _value,
      $Res Function(_$UserWhereInput_AND_withUserWhereInputList) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_AND_withUserWhereInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserWhereInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_AND_withUserWhereInputList
    implements UserWhereInput_AND_withUserWhereInputList {
  const _$UserWhereInput_AND_withUserWhereInputList(
      final List<UserWhereInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserWhereInputList';

  factory _$UserWhereInput_AND_withUserWhereInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_AND_withUserWhereInputListFromJson(json);

  final List<UserWhereInput> _value;
  @override
  List<UserWhereInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_AND.withUserWhereInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_AND_withUserWhereInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_AND_withUserWhereInputListCopyWith<
          _$UserWhereInput_AND_withUserWhereInputList>
      get copyWith => __$$UserWhereInput_AND_withUserWhereInputListCopyWithImpl<
          _$UserWhereInput_AND_withUserWhereInputList>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserWhereInput value) withUserWhereInput,
    required TResult Function(List<UserWhereInput> value)
        withUserWhereInputList,
  }) {
    return withUserWhereInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput value)? withUserWhereInput,
    TResult? Function(List<UserWhereInput> value)? withUserWhereInputList,
  }) {
    return withUserWhereInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserWhereInput value)? withUserWhereInput,
    TResult Function(List<UserWhereInput> value)? withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInputList != null) {
      return withUserWhereInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_AND_withUserWhereInput value)
        withUserWhereInput,
    required TResult Function(UserWhereInput_AND_withUserWhereInputList value)
        withUserWhereInputList,
  }) {
    return withUserWhereInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_AND_withUserWhereInput value)?
        withUserWhereInput,
    TResult? Function(UserWhereInput_AND_withUserWhereInputList value)?
        withUserWhereInputList,
  }) {
    return withUserWhereInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_AND_withUserWhereInput value)?
        withUserWhereInput,
    TResult Function(UserWhereInput_AND_withUserWhereInputList value)?
        withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInputList != null) {
      return withUserWhereInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_AND_withUserWhereInputListToJson(
      this,
    );
  }
}

abstract class UserWhereInput_AND_withUserWhereInputList
    implements UserWhereInput_AND {
  const factory UserWhereInput_AND_withUserWhereInputList(
          final List<UserWhereInput> value) =
      _$UserWhereInput_AND_withUserWhereInputList;

  factory UserWhereInput_AND_withUserWhereInputList.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_AND_withUserWhereInputList.fromJson;

  @override
  List<UserWhereInput> get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_AND_withUserWhereInputListCopyWith<
          _$UserWhereInput_AND_withUserWhereInputList>
      get copyWith => throw _privateConstructorUsedError;
}

UserWhereInput_NOT _$UserWhereInput_NOTFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserWhereInput':
      return UserWhereInput_NOT_withUserWhereInput.fromJson(json);
    case 'withUserWhereInputList':
      return UserWhereInput_NOT_withUserWhereInputList.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UserWhereInput_NOT',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserWhereInput_NOT {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserWhereInput value) withUserWhereInput,
    required TResult Function(List<UserWhereInput> value)
        withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput value)? withUserWhereInput,
    TResult? Function(List<UserWhereInput> value)? withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserWhereInput value)? withUserWhereInput,
    TResult Function(List<UserWhereInput> value)? withUserWhereInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_NOT_withUserWhereInput value)
        withUserWhereInput,
    required TResult Function(UserWhereInput_NOT_withUserWhereInputList value)
        withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_NOT_withUserWhereInput value)?
        withUserWhereInput,
    TResult? Function(UserWhereInput_NOT_withUserWhereInputList value)?
        withUserWhereInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_NOT_withUserWhereInput value)?
        withUserWhereInput,
    TResult Function(UserWhereInput_NOT_withUserWhereInputList value)?
        withUserWhereInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereInput_NOTCopyWith<$Res> {
  factory $UserWhereInput_NOTCopyWith(
          UserWhereInput_NOT value, $Res Function(UserWhereInput_NOT) then) =
      _$UserWhereInput_NOTCopyWithImpl<$Res, UserWhereInput_NOT>;
}

/// @nodoc
class _$UserWhereInput_NOTCopyWithImpl<$Res, $Val extends UserWhereInput_NOT>
    implements $UserWhereInput_NOTCopyWith<$Res> {
  _$UserWhereInput_NOTCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserWhereInput_NOT_withUserWhereInputCopyWith<$Res> {
  factory _$$UserWhereInput_NOT_withUserWhereInputCopyWith(
          _$UserWhereInput_NOT_withUserWhereInput value,
          $Res Function(_$UserWhereInput_NOT_withUserWhereInput) then) =
      __$$UserWhereInput_NOT_withUserWhereInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserWhereInput value});

  $UserWhereInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserWhereInput_NOT_withUserWhereInputCopyWithImpl<$Res>
    extends _$UserWhereInput_NOTCopyWithImpl<$Res,
        _$UserWhereInput_NOT_withUserWhereInput>
    implements _$$UserWhereInput_NOT_withUserWhereInputCopyWith<$Res> {
  __$$UserWhereInput_NOT_withUserWhereInputCopyWithImpl(
      _$UserWhereInput_NOT_withUserWhereInput _value,
      $Res Function(_$UserWhereInput_NOT_withUserWhereInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_NOT_withUserWhereInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserWhereInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInputCopyWith<$Res> get value {
    return $UserWhereInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_NOT_withUserWhereInput
    implements UserWhereInput_NOT_withUserWhereInput {
  const _$UserWhereInput_NOT_withUserWhereInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserWhereInput';

  factory _$UserWhereInput_NOT_withUserWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_NOT_withUserWhereInputFromJson(json);

  @override
  final UserWhereInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_NOT.withUserWhereInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_NOT_withUserWhereInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_NOT_withUserWhereInputCopyWith<
          _$UserWhereInput_NOT_withUserWhereInput>
      get copyWith => __$$UserWhereInput_NOT_withUserWhereInputCopyWithImpl<
          _$UserWhereInput_NOT_withUserWhereInput>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserWhereInput value) withUserWhereInput,
    required TResult Function(List<UserWhereInput> value)
        withUserWhereInputList,
  }) {
    return withUserWhereInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput value)? withUserWhereInput,
    TResult? Function(List<UserWhereInput> value)? withUserWhereInputList,
  }) {
    return withUserWhereInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserWhereInput value)? withUserWhereInput,
    TResult Function(List<UserWhereInput> value)? withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInput != null) {
      return withUserWhereInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_NOT_withUserWhereInput value)
        withUserWhereInput,
    required TResult Function(UserWhereInput_NOT_withUserWhereInputList value)
        withUserWhereInputList,
  }) {
    return withUserWhereInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_NOT_withUserWhereInput value)?
        withUserWhereInput,
    TResult? Function(UserWhereInput_NOT_withUserWhereInputList value)?
        withUserWhereInputList,
  }) {
    return withUserWhereInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_NOT_withUserWhereInput value)?
        withUserWhereInput,
    TResult Function(UserWhereInput_NOT_withUserWhereInputList value)?
        withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInput != null) {
      return withUserWhereInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_NOT_withUserWhereInputToJson(
      this,
    );
  }
}

abstract class UserWhereInput_NOT_withUserWhereInput
    implements UserWhereInput_NOT {
  const factory UserWhereInput_NOT_withUserWhereInput(
      final UserWhereInput value) = _$UserWhereInput_NOT_withUserWhereInput;

  factory UserWhereInput_NOT_withUserWhereInput.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_NOT_withUserWhereInput.fromJson;

  @override
  UserWhereInput get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_NOT_withUserWhereInputCopyWith<
          _$UserWhereInput_NOT_withUserWhereInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserWhereInput_NOT_withUserWhereInputListCopyWith<$Res> {
  factory _$$UserWhereInput_NOT_withUserWhereInputListCopyWith(
          _$UserWhereInput_NOT_withUserWhereInputList value,
          $Res Function(_$UserWhereInput_NOT_withUserWhereInputList) then) =
      __$$UserWhereInput_NOT_withUserWhereInputListCopyWithImpl<$Res>;
  @useResult
  $Res call({List<UserWhereInput> value});
}

/// @nodoc
class __$$UserWhereInput_NOT_withUserWhereInputListCopyWithImpl<$Res>
    extends _$UserWhereInput_NOTCopyWithImpl<$Res,
        _$UserWhereInput_NOT_withUserWhereInputList>
    implements _$$UserWhereInput_NOT_withUserWhereInputListCopyWith<$Res> {
  __$$UserWhereInput_NOT_withUserWhereInputListCopyWithImpl(
      _$UserWhereInput_NOT_withUserWhereInputList _value,
      $Res Function(_$UserWhereInput_NOT_withUserWhereInputList) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_NOT_withUserWhereInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserWhereInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_NOT_withUserWhereInputList
    implements UserWhereInput_NOT_withUserWhereInputList {
  const _$UserWhereInput_NOT_withUserWhereInputList(
      final List<UserWhereInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserWhereInputList';

  factory _$UserWhereInput_NOT_withUserWhereInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_NOT_withUserWhereInputListFromJson(json);

  final List<UserWhereInput> _value;
  @override
  List<UserWhereInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_NOT.withUserWhereInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_NOT_withUserWhereInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_NOT_withUserWhereInputListCopyWith<
          _$UserWhereInput_NOT_withUserWhereInputList>
      get copyWith => __$$UserWhereInput_NOT_withUserWhereInputListCopyWithImpl<
          _$UserWhereInput_NOT_withUserWhereInputList>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserWhereInput value) withUserWhereInput,
    required TResult Function(List<UserWhereInput> value)
        withUserWhereInputList,
  }) {
    return withUserWhereInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput value)? withUserWhereInput,
    TResult? Function(List<UserWhereInput> value)? withUserWhereInputList,
  }) {
    return withUserWhereInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserWhereInput value)? withUserWhereInput,
    TResult Function(List<UserWhereInput> value)? withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInputList != null) {
      return withUserWhereInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_NOT_withUserWhereInput value)
        withUserWhereInput,
    required TResult Function(UserWhereInput_NOT_withUserWhereInputList value)
        withUserWhereInputList,
  }) {
    return withUserWhereInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_NOT_withUserWhereInput value)?
        withUserWhereInput,
    TResult? Function(UserWhereInput_NOT_withUserWhereInputList value)?
        withUserWhereInputList,
  }) {
    return withUserWhereInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_NOT_withUserWhereInput value)?
        withUserWhereInput,
    TResult Function(UserWhereInput_NOT_withUserWhereInputList value)?
        withUserWhereInputList,
    required TResult orElse(),
  }) {
    if (withUserWhereInputList != null) {
      return withUserWhereInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_NOT_withUserWhereInputListToJson(
      this,
    );
  }
}

abstract class UserWhereInput_NOT_withUserWhereInputList
    implements UserWhereInput_NOT {
  const factory UserWhereInput_NOT_withUserWhereInputList(
          final List<UserWhereInput> value) =
      _$UserWhereInput_NOT_withUserWhereInputList;

  factory UserWhereInput_NOT_withUserWhereInputList.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_NOT_withUserWhereInputList.fromJson;

  @override
  List<UserWhereInput> get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_NOT_withUserWhereInputListCopyWith<
          _$UserWhereInput_NOT_withUserWhereInputList>
      get copyWith => throw _privateConstructorUsedError;
}

UserWhereInput_id _$UserWhereInput_idFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withIntFilter':
      return UserWhereInput_id_withIntFilter.fromJson(json);
    case 'withInt':
      return UserWhereInput_id_withInt.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UserWhereInput_id',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserWhereInput_id {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(IntFilter value) withIntFilter,
    required TResult Function(int value) withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(IntFilter value)? withIntFilter,
    TResult? Function(int value)? withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(IntFilter value)? withIntFilter,
    TResult Function(int value)? withInt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_id_withIntFilter value)
        withIntFilter,
    required TResult Function(UserWhereInput_id_withInt value) withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_id_withIntFilter value)? withIntFilter,
    TResult? Function(UserWhereInput_id_withInt value)? withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_id_withIntFilter value)? withIntFilter,
    TResult Function(UserWhereInput_id_withInt value)? withInt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereInput_idCopyWith<$Res> {
  factory $UserWhereInput_idCopyWith(
          UserWhereInput_id value, $Res Function(UserWhereInput_id) then) =
      _$UserWhereInput_idCopyWithImpl<$Res, UserWhereInput_id>;
}

/// @nodoc
class _$UserWhereInput_idCopyWithImpl<$Res, $Val extends UserWhereInput_id>
    implements $UserWhereInput_idCopyWith<$Res> {
  _$UserWhereInput_idCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserWhereInput_id_withIntFilterCopyWith<$Res> {
  factory _$$UserWhereInput_id_withIntFilterCopyWith(
          _$UserWhereInput_id_withIntFilter value,
          $Res Function(_$UserWhereInput_id_withIntFilter) then) =
      __$$UserWhereInput_id_withIntFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({IntFilter value});

  $IntFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserWhereInput_id_withIntFilterCopyWithImpl<$Res>
    extends _$UserWhereInput_idCopyWithImpl<$Res,
        _$UserWhereInput_id_withIntFilter>
    implements _$$UserWhereInput_id_withIntFilterCopyWith<$Res> {
  __$$UserWhereInput_id_withIntFilterCopyWithImpl(
      _$UserWhereInput_id_withIntFilter _value,
      $Res Function(_$UserWhereInput_id_withIntFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_id_withIntFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as IntFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $IntFilterCopyWith<$Res> get value {
    return $IntFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_id_withIntFilter
    implements UserWhereInput_id_withIntFilter {
  const _$UserWhereInput_id_withIntFilter(this.value, {final String? $type})
      : $type = $type ?? 'withIntFilter';

  factory _$UserWhereInput_id_withIntFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_id_withIntFilterFromJson(json);

  @override
  final IntFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_id.withIntFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_id_withIntFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_id_withIntFilterCopyWith<_$UserWhereInput_id_withIntFilter>
      get copyWith => __$$UserWhereInput_id_withIntFilterCopyWithImpl<
          _$UserWhereInput_id_withIntFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(IntFilter value) withIntFilter,
    required TResult Function(int value) withInt,
  }) {
    return withIntFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(IntFilter value)? withIntFilter,
    TResult? Function(int value)? withInt,
  }) {
    return withIntFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(IntFilter value)? withIntFilter,
    TResult Function(int value)? withInt,
    required TResult orElse(),
  }) {
    if (withIntFilter != null) {
      return withIntFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_id_withIntFilter value)
        withIntFilter,
    required TResult Function(UserWhereInput_id_withInt value) withInt,
  }) {
    return withIntFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_id_withIntFilter value)? withIntFilter,
    TResult? Function(UserWhereInput_id_withInt value)? withInt,
  }) {
    return withIntFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_id_withIntFilter value)? withIntFilter,
    TResult Function(UserWhereInput_id_withInt value)? withInt,
    required TResult orElse(),
  }) {
    if (withIntFilter != null) {
      return withIntFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_id_withIntFilterToJson(
      this,
    );
  }
}

abstract class UserWhereInput_id_withIntFilter implements UserWhereInput_id {
  const factory UserWhereInput_id_withIntFilter(final IntFilter value) =
      _$UserWhereInput_id_withIntFilter;

  factory UserWhereInput_id_withIntFilter.fromJson(Map<String, dynamic> json) =
      _$UserWhereInput_id_withIntFilter.fromJson;

  @override
  IntFilter get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_id_withIntFilterCopyWith<_$UserWhereInput_id_withIntFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserWhereInput_id_withIntCopyWith<$Res> {
  factory _$$UserWhereInput_id_withIntCopyWith(
          _$UserWhereInput_id_withInt value,
          $Res Function(_$UserWhereInput_id_withInt) then) =
      __$$UserWhereInput_id_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$UserWhereInput_id_withIntCopyWithImpl<$Res>
    extends _$UserWhereInput_idCopyWithImpl<$Res, _$UserWhereInput_id_withInt>
    implements _$$UserWhereInput_id_withIntCopyWith<$Res> {
  __$$UserWhereInput_id_withIntCopyWithImpl(_$UserWhereInput_id_withInt _value,
      $Res Function(_$UserWhereInput_id_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_id_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_id_withInt implements UserWhereInput_id_withInt {
  const _$UserWhereInput_id_withInt(this.value, {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$UserWhereInput_id_withInt.fromJson(Map<String, dynamic> json) =>
      _$$UserWhereInput_id_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_id.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_id_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_id_withIntCopyWith<_$UserWhereInput_id_withInt>
      get copyWith => __$$UserWhereInput_id_withIntCopyWithImpl<
          _$UserWhereInput_id_withInt>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(IntFilter value) withIntFilter,
    required TResult Function(int value) withInt,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(IntFilter value)? withIntFilter,
    TResult? Function(int value)? withInt,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(IntFilter value)? withIntFilter,
    TResult Function(int value)? withInt,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_id_withIntFilter value)
        withIntFilter,
    required TResult Function(UserWhereInput_id_withInt value) withInt,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_id_withIntFilter value)? withIntFilter,
    TResult? Function(UserWhereInput_id_withInt value)? withInt,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_id_withIntFilter value)? withIntFilter,
    TResult Function(UserWhereInput_id_withInt value)? withInt,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_id_withIntToJson(
      this,
    );
  }
}

abstract class UserWhereInput_id_withInt implements UserWhereInput_id {
  const factory UserWhereInput_id_withInt(final int value) =
      _$UserWhereInput_id_withInt;

  factory UserWhereInput_id_withInt.fromJson(Map<String, dynamic> json) =
      _$UserWhereInput_id_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_id_withIntCopyWith<_$UserWhereInput_id_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

UserWhereInput_name _$UserWhereInput_nameFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withStringFilter':
      return UserWhereInput_name_withStringFilter.fromJson(json);
    case 'withString':
      return UserWhereInput_name_withString.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UserWhereInput_name',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserWhereInput_name {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StringFilter value) withStringFilter,
    required TResult Function(String value) withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StringFilter value)? withStringFilter,
    TResult? Function(String value)? withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StringFilter value)? withStringFilter,
    TResult Function(String value)? withString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_name_withStringFilter value)
        withStringFilter,
    required TResult Function(UserWhereInput_name_withString value) withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_name_withStringFilter value)?
        withStringFilter,
    TResult? Function(UserWhereInput_name_withString value)? withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_name_withStringFilter value)?
        withStringFilter,
    TResult Function(UserWhereInput_name_withString value)? withString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereInput_nameCopyWith<$Res> {
  factory $UserWhereInput_nameCopyWith(
          UserWhereInput_name value, $Res Function(UserWhereInput_name) then) =
      _$UserWhereInput_nameCopyWithImpl<$Res, UserWhereInput_name>;
}

/// @nodoc
class _$UserWhereInput_nameCopyWithImpl<$Res, $Val extends UserWhereInput_name>
    implements $UserWhereInput_nameCopyWith<$Res> {
  _$UserWhereInput_nameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserWhereInput_name_withStringFilterCopyWith<$Res> {
  factory _$$UserWhereInput_name_withStringFilterCopyWith(
          _$UserWhereInput_name_withStringFilter value,
          $Res Function(_$UserWhereInput_name_withStringFilter) then) =
      __$$UserWhereInput_name_withStringFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({StringFilter value});

  $StringFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserWhereInput_name_withStringFilterCopyWithImpl<$Res>
    extends _$UserWhereInput_nameCopyWithImpl<$Res,
        _$UserWhereInput_name_withStringFilter>
    implements _$$UserWhereInput_name_withStringFilterCopyWith<$Res> {
  __$$UserWhereInput_name_withStringFilterCopyWithImpl(
      _$UserWhereInput_name_withStringFilter _value,
      $Res Function(_$UserWhereInput_name_withStringFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_name_withStringFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as StringFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StringFilterCopyWith<$Res> get value {
    return $StringFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_name_withStringFilter
    implements UserWhereInput_name_withStringFilter {
  const _$UserWhereInput_name_withStringFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withStringFilter';

  factory _$UserWhereInput_name_withStringFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_name_withStringFilterFromJson(json);

  @override
  final StringFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_name.withStringFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_name_withStringFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_name_withStringFilterCopyWith<
          _$UserWhereInput_name_withStringFilter>
      get copyWith => __$$UserWhereInput_name_withStringFilterCopyWithImpl<
          _$UserWhereInput_name_withStringFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StringFilter value) withStringFilter,
    required TResult Function(String value) withString,
  }) {
    return withStringFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StringFilter value)? withStringFilter,
    TResult? Function(String value)? withString,
  }) {
    return withStringFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StringFilter value)? withStringFilter,
    TResult Function(String value)? withString,
    required TResult orElse(),
  }) {
    if (withStringFilter != null) {
      return withStringFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_name_withStringFilter value)
        withStringFilter,
    required TResult Function(UserWhereInput_name_withString value) withString,
  }) {
    return withStringFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_name_withStringFilter value)?
        withStringFilter,
    TResult? Function(UserWhereInput_name_withString value)? withString,
  }) {
    return withStringFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_name_withStringFilter value)?
        withStringFilter,
    TResult Function(UserWhereInput_name_withString value)? withString,
    required TResult orElse(),
  }) {
    if (withStringFilter != null) {
      return withStringFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_name_withStringFilterToJson(
      this,
    );
  }
}

abstract class UserWhereInput_name_withStringFilter
    implements UserWhereInput_name {
  const factory UserWhereInput_name_withStringFilter(final StringFilter value) =
      _$UserWhereInput_name_withStringFilter;

  factory UserWhereInput_name_withStringFilter.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_name_withStringFilter.fromJson;

  @override
  StringFilter get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_name_withStringFilterCopyWith<
          _$UserWhereInput_name_withStringFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserWhereInput_name_withStringCopyWith<$Res> {
  factory _$$UserWhereInput_name_withStringCopyWith(
          _$UserWhereInput_name_withString value,
          $Res Function(_$UserWhereInput_name_withString) then) =
      __$$UserWhereInput_name_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UserWhereInput_name_withStringCopyWithImpl<$Res>
    extends _$UserWhereInput_nameCopyWithImpl<$Res,
        _$UserWhereInput_name_withString>
    implements _$$UserWhereInput_name_withStringCopyWith<$Res> {
  __$$UserWhereInput_name_withStringCopyWithImpl(
      _$UserWhereInput_name_withString _value,
      $Res Function(_$UserWhereInput_name_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_name_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_name_withString
    implements UserWhereInput_name_withString {
  const _$UserWhereInput_name_withString(this.value, {final String? $type})
      : $type = $type ?? 'withString';

  factory _$UserWhereInput_name_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_name_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_name.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_name_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_name_withStringCopyWith<_$UserWhereInput_name_withString>
      get copyWith => __$$UserWhereInput_name_withStringCopyWithImpl<
          _$UserWhereInput_name_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StringFilter value) withStringFilter,
    required TResult Function(String value) withString,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StringFilter value)? withStringFilter,
    TResult? Function(String value)? withString,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StringFilter value)? withStringFilter,
    TResult Function(String value)? withString,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_name_withStringFilter value)
        withStringFilter,
    required TResult Function(UserWhereInput_name_withString value) withString,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_name_withStringFilter value)?
        withStringFilter,
    TResult? Function(UserWhereInput_name_withString value)? withString,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_name_withStringFilter value)?
        withStringFilter,
    TResult Function(UserWhereInput_name_withString value)? withString,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_name_withStringToJson(
      this,
    );
  }
}

abstract class UserWhereInput_name_withString implements UserWhereInput_name {
  const factory UserWhereInput_name_withString(final String value) =
      _$UserWhereInput_name_withString;

  factory UserWhereInput_name_withString.fromJson(Map<String, dynamic> json) =
      _$UserWhereInput_name_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_name_withStringCopyWith<_$UserWhereInput_name_withString>
      get copyWith => throw _privateConstructorUsedError;
}

UserWhereInput_createdAt _$UserWhereInput_createdAtFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTimeFilter':
      return UserWhereInput_createdAt_withDateTimeFilter.fromJson(json);
    case 'withDateTime':
      return UserWhereInput_createdAt_withDateTime.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserWhereInput_createdAt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserWhereInput_createdAt {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DateTimeFilter value) withDateTimeFilter,
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DateTimeFilter value)? withDateTimeFilter,
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DateTimeFilter value)? withDateTimeFilter,
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_createdAt_withDateTimeFilter value)
        withDateTimeFilter,
    required TResult Function(UserWhereInput_createdAt_withDateTime value)
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_createdAt_withDateTimeFilter value)?
        withDateTimeFilter,
    TResult? Function(UserWhereInput_createdAt_withDateTime value)?
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_createdAt_withDateTimeFilter value)?
        withDateTimeFilter,
    TResult Function(UserWhereInput_createdAt_withDateTime value)? withDateTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereInput_createdAtCopyWith<$Res> {
  factory $UserWhereInput_createdAtCopyWith(UserWhereInput_createdAt value,
          $Res Function(UserWhereInput_createdAt) then) =
      _$UserWhereInput_createdAtCopyWithImpl<$Res, UserWhereInput_createdAt>;
}

/// @nodoc
class _$UserWhereInput_createdAtCopyWithImpl<$Res,
        $Val extends UserWhereInput_createdAt>
    implements $UserWhereInput_createdAtCopyWith<$Res> {
  _$UserWhereInput_createdAtCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserWhereInput_createdAt_withDateTimeFilterCopyWith<$Res> {
  factory _$$UserWhereInput_createdAt_withDateTimeFilterCopyWith(
          _$UserWhereInput_createdAt_withDateTimeFilter value,
          $Res Function(_$UserWhereInput_createdAt_withDateTimeFilter) then) =
      __$$UserWhereInput_createdAt_withDateTimeFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTimeFilter value});

  $DateTimeFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserWhereInput_createdAt_withDateTimeFilterCopyWithImpl<$Res>
    extends _$UserWhereInput_createdAtCopyWithImpl<$Res,
        _$UserWhereInput_createdAt_withDateTimeFilter>
    implements _$$UserWhereInput_createdAt_withDateTimeFilterCopyWith<$Res> {
  __$$UserWhereInput_createdAt_withDateTimeFilterCopyWithImpl(
      _$UserWhereInput_createdAt_withDateTimeFilter _value,
      $Res Function(_$UserWhereInput_createdAt_withDateTimeFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_createdAt_withDateTimeFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTimeFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeFilterCopyWith<$Res> get value {
    return $DateTimeFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_createdAt_withDateTimeFilter
    implements UserWhereInput_createdAt_withDateTimeFilter {
  const _$UserWhereInput_createdAt_withDateTimeFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTimeFilter';

  factory _$UserWhereInput_createdAt_withDateTimeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_createdAt_withDateTimeFilterFromJson(json);

  @override
  final DateTimeFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_createdAt.withDateTimeFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_createdAt_withDateTimeFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_createdAt_withDateTimeFilterCopyWith<
          _$UserWhereInput_createdAt_withDateTimeFilter>
      get copyWith =>
          __$$UserWhereInput_createdAt_withDateTimeFilterCopyWithImpl<
              _$UserWhereInput_createdAt_withDateTimeFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DateTimeFilter value) withDateTimeFilter,
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
  }) {
    return withDateTimeFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DateTimeFilter value)? withDateTimeFilter,
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
  }) {
    return withDateTimeFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DateTimeFilter value)? withDateTimeFilter,
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTimeFilter != null) {
      return withDateTimeFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_createdAt_withDateTimeFilter value)
        withDateTimeFilter,
    required TResult Function(UserWhereInput_createdAt_withDateTime value)
        withDateTime,
  }) {
    return withDateTimeFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_createdAt_withDateTimeFilter value)?
        withDateTimeFilter,
    TResult? Function(UserWhereInput_createdAt_withDateTime value)?
        withDateTime,
  }) {
    return withDateTimeFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_createdAt_withDateTimeFilter value)?
        withDateTimeFilter,
    TResult Function(UserWhereInput_createdAt_withDateTime value)? withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTimeFilter != null) {
      return withDateTimeFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_createdAt_withDateTimeFilterToJson(
      this,
    );
  }
}

abstract class UserWhereInput_createdAt_withDateTimeFilter
    implements UserWhereInput_createdAt {
  const factory UserWhereInput_createdAt_withDateTimeFilter(
          final DateTimeFilter value) =
      _$UserWhereInput_createdAt_withDateTimeFilter;

  factory UserWhereInput_createdAt_withDateTimeFilter.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_createdAt_withDateTimeFilter.fromJson;

  @override
  DateTimeFilter get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_createdAt_withDateTimeFilterCopyWith<
          _$UserWhereInput_createdAt_withDateTimeFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserWhereInput_createdAt_withDateTimeCopyWith<$Res> {
  factory _$$UserWhereInput_createdAt_withDateTimeCopyWith(
          _$UserWhereInput_createdAt_withDateTime value,
          $Res Function(_$UserWhereInput_createdAt_withDateTime) then) =
      __$$UserWhereInput_createdAt_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$UserWhereInput_createdAt_withDateTimeCopyWithImpl<$Res>
    extends _$UserWhereInput_createdAtCopyWithImpl<$Res,
        _$UserWhereInput_createdAt_withDateTime>
    implements _$$UserWhereInput_createdAt_withDateTimeCopyWith<$Res> {
  __$$UserWhereInput_createdAt_withDateTimeCopyWithImpl(
      _$UserWhereInput_createdAt_withDateTime _value,
      $Res Function(_$UserWhereInput_createdAt_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserWhereInput_createdAt_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserWhereInput_createdAt_withDateTime
    implements UserWhereInput_createdAt_withDateTime {
  const _$UserWhereInput_createdAt_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$UserWhereInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$UserWhereInput_createdAt_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserWhereInput_createdAt.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserWhereInput_createdAt_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserWhereInput_createdAt_withDateTimeCopyWith<
          _$UserWhereInput_createdAt_withDateTime>
      get copyWith => __$$UserWhereInput_createdAt_withDateTimeCopyWithImpl<
          _$UserWhereInput_createdAt_withDateTime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DateTimeFilter value) withDateTimeFilter,
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DateTimeFilter value)? withDateTimeFilter,
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DateTimeFilter value)? withDateTimeFilter,
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserWhereInput_createdAt_withDateTimeFilter value)
        withDateTimeFilter,
    required TResult Function(UserWhereInput_createdAt_withDateTime value)
        withDateTime,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserWhereInput_createdAt_withDateTimeFilter value)?
        withDateTimeFilter,
    TResult? Function(UserWhereInput_createdAt_withDateTime value)?
        withDateTime,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserWhereInput_createdAt_withDateTimeFilter value)?
        withDateTimeFilter,
    TResult Function(UserWhereInput_createdAt_withDateTime value)? withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserWhereInput_createdAt_withDateTimeToJson(
      this,
    );
  }
}

abstract class UserWhereInput_createdAt_withDateTime
    implements UserWhereInput_createdAt {
  const factory UserWhereInput_createdAt_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$UserWhereInput_createdAt_withDateTime;

  factory UserWhereInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$UserWhereInput_createdAt_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$UserWhereInput_createdAt_withDateTimeCopyWith<
          _$UserWhereInput_createdAt_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

UserWhereInput _$UserWhereInputFromJson(Map<String, dynamic> json) {
  return _UserWhereInput.fromJson(json);
}

/// @nodoc
mixin _$UserWhereInput {
  @JsonKey(name: 'AND')
  UserWhereInput_AND? get AND => throw _privateConstructorUsedError;
  @JsonKey(name: 'OR')
  List<UserWhereInput>? get OR => throw _privateConstructorUsedError;
  @JsonKey(name: 'NOT')
  UserWhereInput_NOT? get NOT => throw _privateConstructorUsedError;
  @JsonKey(name: 'id')
  UserWhereInput_id? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  UserWhereInput_name? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  UserWhereInput_createdAt? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserWhereInputCopyWith<UserWhereInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereInputCopyWith<$Res> {
  factory $UserWhereInputCopyWith(
          UserWhereInput value, $Res Function(UserWhereInput) then) =
      _$UserWhereInputCopyWithImpl<$Res, UserWhereInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'AND') UserWhereInput_AND? AND,
      @JsonKey(name: 'OR') List<UserWhereInput>? OR,
      @JsonKey(name: 'NOT') UserWhereInput_NOT? NOT,
      @JsonKey(name: 'id') UserWhereInput_id? id,
      @JsonKey(name: 'name') UserWhereInput_name? name,
      @JsonKey(name: 'createdAt') UserWhereInput_createdAt? createdAt});

  $UserWhereInput_ANDCopyWith<$Res>? get AND;
  $UserWhereInput_NOTCopyWith<$Res>? get NOT;
  $UserWhereInput_idCopyWith<$Res>? get id;
  $UserWhereInput_nameCopyWith<$Res>? get name;
  $UserWhereInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class _$UserWhereInputCopyWithImpl<$Res, $Val extends UserWhereInput>
    implements $UserWhereInputCopyWith<$Res> {
  _$UserWhereInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? AND = freezed,
    Object? OR = freezed,
    Object? NOT = freezed,
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      AND: freezed == AND
          ? _value.AND
          : AND // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_AND?,
      OR: freezed == OR
          ? _value.OR
          : OR // ignore: cast_nullable_to_non_nullable
              as List<UserWhereInput>?,
      NOT: freezed == NOT
          ? _value.NOT
          : NOT // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_NOT?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_createdAt?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInput_ANDCopyWith<$Res>? get AND {
    if (_value.AND == null) {
      return null;
    }

    return $UserWhereInput_ANDCopyWith<$Res>(_value.AND!, (value) {
      return _then(_value.copyWith(AND: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInput_NOTCopyWith<$Res>? get NOT {
    if (_value.NOT == null) {
      return null;
    }

    return $UserWhereInput_NOTCopyWith<$Res>(_value.NOT!, (value) {
      return _then(_value.copyWith(NOT: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInput_idCopyWith<$Res>? get id {
    if (_value.id == null) {
      return null;
    }

    return $UserWhereInput_idCopyWith<$Res>(_value.id!, (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInput_nameCopyWith<$Res>? get name {
    if (_value.name == null) {
      return null;
    }

    return $UserWhereInput_nameCopyWith<$Res>(_value.name!, (value) {
      return _then(_value.copyWith(name: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserWhereInput_createdAtCopyWith<$Res>? get createdAt {
    if (_value.createdAt == null) {
      return null;
    }

    return $UserWhereInput_createdAtCopyWith<$Res>(_value.createdAt!, (value) {
      return _then(_value.copyWith(createdAt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserWhereInputCopyWith<$Res>
    implements $UserWhereInputCopyWith<$Res> {
  factory _$$_UserWhereInputCopyWith(
          _$_UserWhereInput value, $Res Function(_$_UserWhereInput) then) =
      __$$_UserWhereInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'AND') UserWhereInput_AND? AND,
      @JsonKey(name: 'OR') List<UserWhereInput>? OR,
      @JsonKey(name: 'NOT') UserWhereInput_NOT? NOT,
      @JsonKey(name: 'id') UserWhereInput_id? id,
      @JsonKey(name: 'name') UserWhereInput_name? name,
      @JsonKey(name: 'createdAt') UserWhereInput_createdAt? createdAt});

  @override
  $UserWhereInput_ANDCopyWith<$Res>? get AND;
  @override
  $UserWhereInput_NOTCopyWith<$Res>? get NOT;
  @override
  $UserWhereInput_idCopyWith<$Res>? get id;
  @override
  $UserWhereInput_nameCopyWith<$Res>? get name;
  @override
  $UserWhereInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class __$$_UserWhereInputCopyWithImpl<$Res>
    extends _$UserWhereInputCopyWithImpl<$Res, _$_UserWhereInput>
    implements _$$_UserWhereInputCopyWith<$Res> {
  __$$_UserWhereInputCopyWithImpl(
      _$_UserWhereInput _value, $Res Function(_$_UserWhereInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? AND = freezed,
    Object? OR = freezed,
    Object? NOT = freezed,
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserWhereInput(
      AND: freezed == AND
          ? _value.AND
          : AND // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_AND?,
      OR: freezed == OR
          ? _value._OR
          : OR // ignore: cast_nullable_to_non_nullable
              as List<UserWhereInput>?,
      NOT: freezed == NOT
          ? _value.NOT
          : NOT // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_NOT?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserWhereInput_createdAt?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserWhereInput implements _UserWhereInput {
  const _$_UserWhereInput(
      {@JsonKey(name: 'AND') this.AND,
      @JsonKey(name: 'OR') final List<UserWhereInput>? OR,
      @JsonKey(name: 'NOT') this.NOT,
      @JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt})
      : _OR = OR;

  factory _$_UserWhereInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserWhereInputFromJson(json);

  @override
  @JsonKey(name: 'AND')
  final UserWhereInput_AND? AND;
  final List<UserWhereInput>? _OR;
  @override
  @JsonKey(name: 'OR')
  List<UserWhereInput>? get OR {
    final value = _OR;
    if (value == null) return null;
    if (_OR is EqualUnmodifiableListView) return _OR;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'NOT')
  final UserWhereInput_NOT? NOT;
  @override
  @JsonKey(name: 'id')
  final UserWhereInput_id? id;
  @override
  @JsonKey(name: 'name')
  final UserWhereInput_name? name;
  @override
  @JsonKey(name: 'createdAt')
  final UserWhereInput_createdAt? createdAt;

  @override
  String toString() {
    return 'UserWhereInput(AND: $AND, OR: $OR, NOT: $NOT, id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserWhereInput &&
            (identical(other.AND, AND) || other.AND == AND) &&
            const DeepCollectionEquality().equals(other._OR, _OR) &&
            (identical(other.NOT, NOT) || other.NOT == NOT) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, AND,
      const DeepCollectionEquality().hash(_OR), NOT, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserWhereInputCopyWith<_$_UserWhereInput> get copyWith =>
      __$$_UserWhereInputCopyWithImpl<_$_UserWhereInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserWhereInputToJson(
      this,
    );
  }
}

abstract class _UserWhereInput implements UserWhereInput {
  const factory _UserWhereInput(
      {@JsonKey(name: 'AND')
          final UserWhereInput_AND? AND,
      @JsonKey(name: 'OR')
          final List<UserWhereInput>? OR,
      @JsonKey(name: 'NOT')
          final UserWhereInput_NOT? NOT,
      @JsonKey(name: 'id')
          final UserWhereInput_id? id,
      @JsonKey(name: 'name')
          final UserWhereInput_name? name,
      @JsonKey(name: 'createdAt')
          final UserWhereInput_createdAt? createdAt}) = _$_UserWhereInput;

  factory _UserWhereInput.fromJson(Map<String, dynamic> json) =
      _$_UserWhereInput.fromJson;

  @override
  @JsonKey(name: 'AND')
  UserWhereInput_AND? get AND;
  @override
  @JsonKey(name: 'OR')
  List<UserWhereInput>? get OR;
  @override
  @JsonKey(name: 'NOT')
  UserWhereInput_NOT? get NOT;
  @override
  @JsonKey(name: 'id')
  UserWhereInput_id? get id;
  @override
  @JsonKey(name: 'name')
  UserWhereInput_name? get name;
  @override
  @JsonKey(name: 'createdAt')
  UserWhereInput_createdAt? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserWhereInputCopyWith<_$_UserWhereInput> get copyWith =>
      throw _privateConstructorUsedError;
}

UserOrderByWithRelationInput _$UserOrderByWithRelationInputFromJson(
    Map<String, dynamic> json) {
  return _UserOrderByWithRelationInput.fromJson(json);
}

/// @nodoc
mixin _$UserOrderByWithRelationInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  SortOrder? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserOrderByWithRelationInputCopyWith<UserOrderByWithRelationInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserOrderByWithRelationInputCopyWith<$Res> {
  factory $UserOrderByWithRelationInputCopyWith(
          UserOrderByWithRelationInput value,
          $Res Function(UserOrderByWithRelationInput) then) =
      _$UserOrderByWithRelationInputCopyWithImpl<$Res,
          UserOrderByWithRelationInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class _$UserOrderByWithRelationInputCopyWithImpl<$Res,
        $Val extends UserOrderByWithRelationInput>
    implements $UserOrderByWithRelationInputCopyWith<$Res> {
  _$UserOrderByWithRelationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserOrderByWithRelationInputCopyWith<$Res>
    implements $UserOrderByWithRelationInputCopyWith<$Res> {
  factory _$$_UserOrderByWithRelationInputCopyWith(
          _$_UserOrderByWithRelationInput value,
          $Res Function(_$_UserOrderByWithRelationInput) then) =
      __$$_UserOrderByWithRelationInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class __$$_UserOrderByWithRelationInputCopyWithImpl<$Res>
    extends _$UserOrderByWithRelationInputCopyWithImpl<$Res,
        _$_UserOrderByWithRelationInput>
    implements _$$_UserOrderByWithRelationInputCopyWith<$Res> {
  __$$_UserOrderByWithRelationInputCopyWithImpl(
      _$_UserOrderByWithRelationInput _value,
      $Res Function(_$_UserOrderByWithRelationInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserOrderByWithRelationInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserOrderByWithRelationInput implements _UserOrderByWithRelationInput {
  const _$_UserOrderByWithRelationInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserOrderByWithRelationInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;
  @override
  @JsonKey(name: 'name')
  final SortOrder? name;
  @override
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;

  @override
  String toString() {
    return 'UserOrderByWithRelationInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserOrderByWithRelationInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserOrderByWithRelationInputCopyWith<_$_UserOrderByWithRelationInput>
      get copyWith => __$$_UserOrderByWithRelationInputCopyWithImpl<
          _$_UserOrderByWithRelationInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserOrderByWithRelationInputToJson(
      this,
    );
  }
}

abstract class _UserOrderByWithRelationInput
    implements UserOrderByWithRelationInput {
  const factory _UserOrderByWithRelationInput(
          {@JsonKey(name: 'id') final SortOrder? id,
          @JsonKey(name: 'name') final SortOrder? name,
          @JsonKey(name: 'createdAt') final SortOrder? createdAt}) =
      _$_UserOrderByWithRelationInput;

  factory _UserOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =
      _$_UserOrderByWithRelationInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(name: 'name')
  SortOrder? get name;
  @override
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserOrderByWithRelationInputCopyWith<_$_UserOrderByWithRelationInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserWhereUniqueInput _$UserWhereUniqueInputFromJson(Map<String, dynamic> json) {
  return _UserWhereUniqueInput.fromJson(json);
}

/// @nodoc
mixin _$UserWhereUniqueInput {
  @JsonKey(name: 'id')
  int? get id => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserWhereUniqueInputCopyWith<UserWhereUniqueInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserWhereUniqueInputCopyWith<$Res> {
  factory $UserWhereUniqueInputCopyWith(UserWhereUniqueInput value,
          $Res Function(UserWhereUniqueInput) then) =
      _$UserWhereUniqueInputCopyWithImpl<$Res, UserWhereUniqueInput>;
  @useResult
  $Res call({@JsonKey(name: 'id') int? id});
}

/// @nodoc
class _$UserWhereUniqueInputCopyWithImpl<$Res,
        $Val extends UserWhereUniqueInput>
    implements $UserWhereUniqueInputCopyWith<$Res> {
  _$UserWhereUniqueInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserWhereUniqueInputCopyWith<$Res>
    implements $UserWhereUniqueInputCopyWith<$Res> {
  factory _$$_UserWhereUniqueInputCopyWith(_$_UserWhereUniqueInput value,
          $Res Function(_$_UserWhereUniqueInput) then) =
      __$$_UserWhereUniqueInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'id') int? id});
}

/// @nodoc
class __$$_UserWhereUniqueInputCopyWithImpl<$Res>
    extends _$UserWhereUniqueInputCopyWithImpl<$Res, _$_UserWhereUniqueInput>
    implements _$$_UserWhereUniqueInputCopyWith<$Res> {
  __$$_UserWhereUniqueInputCopyWithImpl(_$_UserWhereUniqueInput _value,
      $Res Function(_$_UserWhereUniqueInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$_UserWhereUniqueInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserWhereUniqueInput implements _UserWhereUniqueInput {
  const _$_UserWhereUniqueInput({@JsonKey(name: 'id') this.id});

  factory _$_UserWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserWhereUniqueInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;

  @override
  String toString() {
    return 'UserWhereUniqueInput(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserWhereUniqueInput &&
            (identical(other.id, id) || other.id == id));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserWhereUniqueInputCopyWith<_$_UserWhereUniqueInput> get copyWith =>
      __$$_UserWhereUniqueInputCopyWithImpl<_$_UserWhereUniqueInput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserWhereUniqueInputToJson(
      this,
    );
  }
}

abstract class _UserWhereUniqueInput implements UserWhereUniqueInput {
  const factory _UserWhereUniqueInput({@JsonKey(name: 'id') final int? id}) =
      _$_UserWhereUniqueInput;

  factory _UserWhereUniqueInput.fromJson(Map<String, dynamic> json) =
      _$_UserWhereUniqueInput.fromJson;

  @override
  @JsonKey(name: 'id')
  int? get id;
  @override
  @JsonKey(ignore: true)
  _$$_UserWhereUniqueInputCopyWith<_$_UserWhereUniqueInput> get copyWith =>
      throw _privateConstructorUsedError;
}

UserOrderByWithAggregationInput _$UserOrderByWithAggregationInputFromJson(
    Map<String, dynamic> json) {
  return _UserOrderByWithAggregationInput.fromJson(json);
}

/// @nodoc
mixin _$UserOrderByWithAggregationInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  SortOrder? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt => throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  UserCountOrderByAggregateInput? get prisma__count =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_avg')
  UserAvgOrderByAggregateInput? get prisma__avg =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  UserMaxOrderByAggregateInput? get prisma__max =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  UserMinOrderByAggregateInput? get prisma__min =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_sum')
  UserSumOrderByAggregateInput? get prisma__sum =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserOrderByWithAggregationInputCopyWith<UserOrderByWithAggregationInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserOrderByWithAggregationInputCopyWith<$Res> {
  factory $UserOrderByWithAggregationInputCopyWith(
          UserOrderByWithAggregationInput value,
          $Res Function(UserOrderByWithAggregationInput) then) =
      _$UserOrderByWithAggregationInputCopyWithImpl<$Res,
          UserOrderByWithAggregationInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt,
      @JsonKey(name: '_count') UserCountOrderByAggregateInput? prisma__count,
      @JsonKey(name: '_avg') UserAvgOrderByAggregateInput? prisma__avg,
      @JsonKey(name: '_max') UserMaxOrderByAggregateInput? prisma__max,
      @JsonKey(name: '_min') UserMinOrderByAggregateInput? prisma__min,
      @JsonKey(name: '_sum') UserSumOrderByAggregateInput? prisma__sum});

  $UserCountOrderByAggregateInputCopyWith<$Res>? get prisma__count;
  $UserAvgOrderByAggregateInputCopyWith<$Res>? get prisma__avg;
  $UserMaxOrderByAggregateInputCopyWith<$Res>? get prisma__max;
  $UserMinOrderByAggregateInputCopyWith<$Res>? get prisma__min;
  $UserSumOrderByAggregateInputCopyWith<$Res>? get prisma__sum;
}

/// @nodoc
class _$UserOrderByWithAggregationInputCopyWithImpl<$Res,
        $Val extends UserOrderByWithAggregationInput>
    implements $UserOrderByWithAggregationInputCopyWith<$Res> {
  _$UserOrderByWithAggregationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
    Object? prisma__count = freezed,
    Object? prisma__avg = freezed,
    Object? prisma__max = freezed,
    Object? prisma__min = freezed,
    Object? prisma__sum = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as UserCountOrderByAggregateInput?,
      prisma__avg: freezed == prisma__avg
          ? _value.prisma__avg
          : prisma__avg // ignore: cast_nullable_to_non_nullable
              as UserAvgOrderByAggregateInput?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as UserMaxOrderByAggregateInput?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as UserMinOrderByAggregateInput?,
      prisma__sum: freezed == prisma__sum
          ? _value.prisma__sum
          : prisma__sum // ignore: cast_nullable_to_non_nullable
              as UserSumOrderByAggregateInput?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCountOrderByAggregateInputCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $UserCountOrderByAggregateInputCopyWith<$Res>(_value.prisma__count!,
        (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserAvgOrderByAggregateInputCopyWith<$Res>? get prisma__avg {
    if (_value.prisma__avg == null) {
      return null;
    }

    return $UserAvgOrderByAggregateInputCopyWith<$Res>(_value.prisma__avg!,
        (value) {
      return _then(_value.copyWith(prisma__avg: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserMaxOrderByAggregateInputCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $UserMaxOrderByAggregateInputCopyWith<$Res>(_value.prisma__max!,
        (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserMinOrderByAggregateInputCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $UserMinOrderByAggregateInputCopyWith<$Res>(_value.prisma__min!,
        (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserSumOrderByAggregateInputCopyWith<$Res>? get prisma__sum {
    if (_value.prisma__sum == null) {
      return null;
    }

    return $UserSumOrderByAggregateInputCopyWith<$Res>(_value.prisma__sum!,
        (value) {
      return _then(_value.copyWith(prisma__sum: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserOrderByWithAggregationInputCopyWith<$Res>
    implements $UserOrderByWithAggregationInputCopyWith<$Res> {
  factory _$$_UserOrderByWithAggregationInputCopyWith(
          _$_UserOrderByWithAggregationInput value,
          $Res Function(_$_UserOrderByWithAggregationInput) then) =
      __$$_UserOrderByWithAggregationInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt,
      @JsonKey(name: '_count') UserCountOrderByAggregateInput? prisma__count,
      @JsonKey(name: '_avg') UserAvgOrderByAggregateInput? prisma__avg,
      @JsonKey(name: '_max') UserMaxOrderByAggregateInput? prisma__max,
      @JsonKey(name: '_min') UserMinOrderByAggregateInput? prisma__min,
      @JsonKey(name: '_sum') UserSumOrderByAggregateInput? prisma__sum});

  @override
  $UserCountOrderByAggregateInputCopyWith<$Res>? get prisma__count;
  @override
  $UserAvgOrderByAggregateInputCopyWith<$Res>? get prisma__avg;
  @override
  $UserMaxOrderByAggregateInputCopyWith<$Res>? get prisma__max;
  @override
  $UserMinOrderByAggregateInputCopyWith<$Res>? get prisma__min;
  @override
  $UserSumOrderByAggregateInputCopyWith<$Res>? get prisma__sum;
}

/// @nodoc
class __$$_UserOrderByWithAggregationInputCopyWithImpl<$Res>
    extends _$UserOrderByWithAggregationInputCopyWithImpl<$Res,
        _$_UserOrderByWithAggregationInput>
    implements _$$_UserOrderByWithAggregationInputCopyWith<$Res> {
  __$$_UserOrderByWithAggregationInputCopyWithImpl(
      _$_UserOrderByWithAggregationInput _value,
      $Res Function(_$_UserOrderByWithAggregationInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
    Object? prisma__count = freezed,
    Object? prisma__avg = freezed,
    Object? prisma__max = freezed,
    Object? prisma__min = freezed,
    Object? prisma__sum = freezed,
  }) {
    return _then(_$_UserOrderByWithAggregationInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as UserCountOrderByAggregateInput?,
      prisma__avg: freezed == prisma__avg
          ? _value.prisma__avg
          : prisma__avg // ignore: cast_nullable_to_non_nullable
              as UserAvgOrderByAggregateInput?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as UserMaxOrderByAggregateInput?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as UserMinOrderByAggregateInput?,
      prisma__sum: freezed == prisma__sum
          ? _value.prisma__sum
          : prisma__sum // ignore: cast_nullable_to_non_nullable
              as UserSumOrderByAggregateInput?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserOrderByWithAggregationInput
    implements _UserOrderByWithAggregationInput {
  const _$_UserOrderByWithAggregationInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt,
      @JsonKey(name: '_count') this.prisma__count,
      @JsonKey(name: '_avg') this.prisma__avg,
      @JsonKey(name: '_max') this.prisma__max,
      @JsonKey(name: '_min') this.prisma__min,
      @JsonKey(name: '_sum') this.prisma__sum});

  factory _$_UserOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UserOrderByWithAggregationInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;
  @override
  @JsonKey(name: 'name')
  final SortOrder? name;
  @override
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;
  @override
  @JsonKey(name: '_count')
  final UserCountOrderByAggregateInput? prisma__count;
  @override
  @JsonKey(name: '_avg')
  final UserAvgOrderByAggregateInput? prisma__avg;
  @override
  @JsonKey(name: '_max')
  final UserMaxOrderByAggregateInput? prisma__max;
  @override
  @JsonKey(name: '_min')
  final UserMinOrderByAggregateInput? prisma__min;
  @override
  @JsonKey(name: '_sum')
  final UserSumOrderByAggregateInput? prisma__sum;

  @override
  String toString() {
    return 'UserOrderByWithAggregationInput(id: $id, name: $name, createdAt: $createdAt, prisma__count: $prisma__count, prisma__avg: $prisma__avg, prisma__max: $prisma__max, prisma__min: $prisma__min, prisma__sum: $prisma__sum)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserOrderByWithAggregationInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__avg, prisma__avg) ||
                other.prisma__avg == prisma__avg) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__sum, prisma__sum) ||
                other.prisma__sum == prisma__sum));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt,
      prisma__count, prisma__avg, prisma__max, prisma__min, prisma__sum);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserOrderByWithAggregationInputCopyWith<
          _$_UserOrderByWithAggregationInput>
      get copyWith => __$$_UserOrderByWithAggregationInputCopyWithImpl<
          _$_UserOrderByWithAggregationInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserOrderByWithAggregationInputToJson(
      this,
    );
  }
}

abstract class _UserOrderByWithAggregationInput
    implements UserOrderByWithAggregationInput {
  const factory _UserOrderByWithAggregationInput(
          {@JsonKey(name: 'id')
              final SortOrder? id,
          @JsonKey(name: 'name')
              final SortOrder? name,
          @JsonKey(name: 'createdAt')
              final SortOrder? createdAt,
          @JsonKey(name: '_count')
              final UserCountOrderByAggregateInput? prisma__count,
          @JsonKey(name: '_avg')
              final UserAvgOrderByAggregateInput? prisma__avg,
          @JsonKey(name: '_max')
              final UserMaxOrderByAggregateInput? prisma__max,
          @JsonKey(name: '_min')
              final UserMinOrderByAggregateInput? prisma__min,
          @JsonKey(name: '_sum')
              final UserSumOrderByAggregateInput? prisma__sum}) =
      _$_UserOrderByWithAggregationInput;

  factory _UserOrderByWithAggregationInput.fromJson(Map<String, dynamic> json) =
      _$_UserOrderByWithAggregationInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(name: 'name')
  SortOrder? get name;
  @override
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt;
  @override
  @JsonKey(name: '_count')
  UserCountOrderByAggregateInput? get prisma__count;
  @override
  @JsonKey(name: '_avg')
  UserAvgOrderByAggregateInput? get prisma__avg;
  @override
  @JsonKey(name: '_max')
  UserMaxOrderByAggregateInput? get prisma__max;
  @override
  @JsonKey(name: '_min')
  UserMinOrderByAggregateInput? get prisma__min;
  @override
  @JsonKey(name: '_sum')
  UserSumOrderByAggregateInput? get prisma__sum;
  @override
  @JsonKey(ignore: true)
  _$$_UserOrderByWithAggregationInputCopyWith<
          _$_UserOrderByWithAggregationInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserScalarWhereWithAggregatesInput_AND
    _$UserScalarWhereWithAggregatesInput_ANDFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserScalarWhereWithAggregatesInput':
      return UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
          .fromJson(json);
    case 'withUserScalarWhereWithAggregatesInputList':
      return UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserScalarWhereWithAggregatesInput_AND',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserScalarWhereWithAggregatesInput_AND {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserScalarWhereWithAggregatesInput value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(List<UserScalarWhereWithAggregatesInput> value)
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserScalarWhereWithAggregatesInput_ANDCopyWith<$Res> {
  factory $UserScalarWhereWithAggregatesInput_ANDCopyWith(
          UserScalarWhereWithAggregatesInput_AND value,
          $Res Function(UserScalarWhereWithAggregatesInput_AND) then) =
      _$UserScalarWhereWithAggregatesInput_ANDCopyWithImpl<$Res,
          UserScalarWhereWithAggregatesInput_AND>;
}

/// @nodoc
class _$UserScalarWhereWithAggregatesInput_ANDCopyWithImpl<$Res,
        $Val extends UserScalarWhereWithAggregatesInput_AND>
    implements $UserScalarWhereWithAggregatesInput_ANDCopyWith<$Res> {
  _$UserScalarWhereWithAggregatesInput_ANDCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWith(
          _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
              value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput)
              then) =
      __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserScalarWhereWithAggregatesInput value});

  $UserScalarWhereWithAggregatesInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_ANDCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput>
    implements
        _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInputCopyWith<$Res> get value {
    return $UserScalarWhereWithAggregatesInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
    implements
        UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput {
  const _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withUserScalarWhereWithAggregatesInput';

  factory _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputFromJson(
          json);

  @override
  final UserScalarWhereWithAggregatesInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_AND.withUserScalarWhereWithAggregatesInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWith<
          _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserScalarWhereWithAggregatesInput value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(List<UserScalarWhereWithAggregatesInput> value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInput != null) {
      return withUserScalarWhereWithAggregatesInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInput != null) {
      return withUserScalarWhereWithAggregatesInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
    implements UserScalarWhereWithAggregatesInput_AND {
  const factory UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput(
          final UserScalarWhereWithAggregatesInput value) =
      _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput;

  factory UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
          .fromJson;

  @override
  UserScalarWhereWithAggregatesInput get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputCopyWith<
          _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWith(
          _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
              value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList)
              then) =
      __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserScalarWhereWithAggregatesInput> value});
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_ANDCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList>
    implements
        _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserScalarWhereWithAggregatesInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
    implements
        UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList {
  const _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList(
      final List<UserScalarWhereWithAggregatesInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserScalarWhereWithAggregatesInputList';

  factory _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListFromJson(
          json);

  final List<UserScalarWhereWithAggregatesInput> _value;
  @override
  List<UserScalarWhereWithAggregatesInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_AND.withUserScalarWhereWithAggregatesInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWith<
          _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserScalarWhereWithAggregatesInput value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(List<UserScalarWhereWithAggregatesInput> value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInputList != null) {
      return withUserScalarWhereWithAggregatesInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(
            UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInputList != null) {
      return withUserScalarWhereWithAggregatesInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
    implements UserScalarWhereWithAggregatesInput_AND {
  const factory UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList(
          final List<UserScalarWhereWithAggregatesInput> value) =
      _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList;

  factory UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList
          .fromJson;

  @override
  List<UserScalarWhereWithAggregatesInput> get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputListCopyWith<
          _$UserScalarWhereWithAggregatesInput_AND_withUserScalarWhereWithAggregatesInputList>
      get copyWith => throw _privateConstructorUsedError;
}

UserScalarWhereWithAggregatesInput_NOT
    _$UserScalarWhereWithAggregatesInput_NOTFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserScalarWhereWithAggregatesInput':
      return UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
          .fromJson(json);
    case 'withUserScalarWhereWithAggregatesInputList':
      return UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserScalarWhereWithAggregatesInput_NOT',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserScalarWhereWithAggregatesInput_NOT {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserScalarWhereWithAggregatesInput value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(List<UserScalarWhereWithAggregatesInput> value)
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserScalarWhereWithAggregatesInput_NOTCopyWith<$Res> {
  factory $UserScalarWhereWithAggregatesInput_NOTCopyWith(
          UserScalarWhereWithAggregatesInput_NOT value,
          $Res Function(UserScalarWhereWithAggregatesInput_NOT) then) =
      _$UserScalarWhereWithAggregatesInput_NOTCopyWithImpl<$Res,
          UserScalarWhereWithAggregatesInput_NOT>;
}

/// @nodoc
class _$UserScalarWhereWithAggregatesInput_NOTCopyWithImpl<$Res,
        $Val extends UserScalarWhereWithAggregatesInput_NOT>
    implements $UserScalarWhereWithAggregatesInput_NOTCopyWith<$Res> {
  _$UserScalarWhereWithAggregatesInput_NOTCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWith(
          _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
              value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput)
              then) =
      __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserScalarWhereWithAggregatesInput value});

  $UserScalarWhereWithAggregatesInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_NOTCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput>
    implements
        _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInputCopyWith<$Res> get value {
    return $UserScalarWhereWithAggregatesInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
    implements
        UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput {
  const _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withUserScalarWhereWithAggregatesInput';

  factory _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputFromJson(
          json);

  @override
  final UserScalarWhereWithAggregatesInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_NOT.withUserScalarWhereWithAggregatesInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWith<
          _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserScalarWhereWithAggregatesInput value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(List<UserScalarWhereWithAggregatesInput> value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInput != null) {
      return withUserScalarWhereWithAggregatesInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInput != null) {
      return withUserScalarWhereWithAggregatesInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
    implements UserScalarWhereWithAggregatesInput_NOT {
  const factory UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput(
          final UserScalarWhereWithAggregatesInput value) =
      _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput;

  factory UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
          .fromJson;

  @override
  UserScalarWhereWithAggregatesInput get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputCopyWith<
          _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWith(
          _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
              value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList)
              then) =
      __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserScalarWhereWithAggregatesInput> value});
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_NOTCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList>
    implements
        _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserScalarWhereWithAggregatesInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
    implements
        UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList {
  const _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList(
      final List<UserScalarWhereWithAggregatesInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserScalarWhereWithAggregatesInputList';

  factory _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListFromJson(
          json);

  final List<UserScalarWhereWithAggregatesInput> _value;
  @override
  List<UserScalarWhereWithAggregatesInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_NOT.withUserScalarWhereWithAggregatesInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWith<
          _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserScalarWhereWithAggregatesInput value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(List<UserScalarWhereWithAggregatesInput> value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserScalarWhereWithAggregatesInput value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(List<UserScalarWhereWithAggregatesInput> value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInputList != null) {
      return withUserScalarWhereWithAggregatesInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)
        withUserScalarWhereWithAggregatesInput,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
  }) {
    return withUserScalarWhereWithAggregatesInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInput
                value)?
        withUserScalarWhereWithAggregatesInput,
    TResult Function(
            UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
                value)?
        withUserScalarWhereWithAggregatesInputList,
    required TResult orElse(),
  }) {
    if (withUserScalarWhereWithAggregatesInputList != null) {
      return withUserScalarWhereWithAggregatesInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
    implements UserScalarWhereWithAggregatesInput_NOT {
  const factory UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList(
          final List<UserScalarWhereWithAggregatesInput> value) =
      _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList;

  factory UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList
          .fromJson;

  @override
  List<UserScalarWhereWithAggregatesInput> get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputListCopyWith<
          _$UserScalarWhereWithAggregatesInput_NOT_withUserScalarWhereWithAggregatesInputList>
      get copyWith => throw _privateConstructorUsedError;
}

UserScalarWhereWithAggregatesInput_id
    _$UserScalarWhereWithAggregatesInput_idFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withIntWithAggregatesFilter':
      return UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
          .fromJson(json);
    case 'withInt':
      return UserScalarWhereWithAggregatesInput_id_withInt.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserScalarWhereWithAggregatesInput_id',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserScalarWhereWithAggregatesInput_id {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(IntWithAggregatesFilter value)
        withIntWithAggregatesFilter,
    required TResult Function(int value) withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(IntWithAggregatesFilter value)?
        withIntWithAggregatesFilter,
    TResult? Function(int value)? withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(IntWithAggregatesFilter value)?
        withIntWithAggregatesFilter,
    TResult Function(int value)? withInt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)
        withIntWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_id_withInt value)
        withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)?
        withIntWithAggregatesFilter,
    TResult? Function(UserScalarWhereWithAggregatesInput_id_withInt value)?
        withInt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)?
        withIntWithAggregatesFilter,
    TResult Function(UserScalarWhereWithAggregatesInput_id_withInt value)?
        withInt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserScalarWhereWithAggregatesInput_idCopyWith<$Res> {
  factory $UserScalarWhereWithAggregatesInput_idCopyWith(
          UserScalarWhereWithAggregatesInput_id value,
          $Res Function(UserScalarWhereWithAggregatesInput_id) then) =
      _$UserScalarWhereWithAggregatesInput_idCopyWithImpl<$Res,
          UserScalarWhereWithAggregatesInput_id>;
}

/// @nodoc
class _$UserScalarWhereWithAggregatesInput_idCopyWithImpl<$Res,
        $Val extends UserScalarWhereWithAggregatesInput_id>
    implements $UserScalarWhereWithAggregatesInput_idCopyWith<$Res> {
  _$UserScalarWhereWithAggregatesInput_idCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWith(
          _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter)
              then) =
      __$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({IntWithAggregatesFilter value});

  $IntWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_idCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter>
    implements
        _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as IntWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $IntWithAggregatesFilterCopyWith<$Res> get value {
    return $IntWithAggregatesFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
    implements
        UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter {
  const _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withIntWithAggregatesFilter';

  factory _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterFromJson(
          json);

  @override
  final IntWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_id.withIntWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWith<
          _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(IntWithAggregatesFilter value)
        withIntWithAggregatesFilter,
    required TResult Function(int value) withInt,
  }) {
    return withIntWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(IntWithAggregatesFilter value)?
        withIntWithAggregatesFilter,
    TResult? Function(int value)? withInt,
  }) {
    return withIntWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(IntWithAggregatesFilter value)?
        withIntWithAggregatesFilter,
    TResult Function(int value)? withInt,
    required TResult orElse(),
  }) {
    if (withIntWithAggregatesFilter != null) {
      return withIntWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)
        withIntWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_id_withInt value)
        withInt,
  }) {
    return withIntWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)?
        withIntWithAggregatesFilter,
    TResult? Function(UserScalarWhereWithAggregatesInput_id_withInt value)?
        withInt,
  }) {
    return withIntWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)?
        withIntWithAggregatesFilter,
    TResult Function(UserScalarWhereWithAggregatesInput_id_withInt value)?
        withInt,
    required TResult orElse(),
  }) {
    if (withIntWithAggregatesFilter != null) {
      return withIntWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
    implements UserScalarWhereWithAggregatesInput_id {
  const factory UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter(
          final IntWithAggregatesFilter value) =
      _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter;

  factory UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
          .fromJson;

  @override
  IntWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilterCopyWith<
          _$UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_id_withIntCopyWith<$Res> {
  factory _$$UserScalarWhereWithAggregatesInput_id_withIntCopyWith(
          _$UserScalarWhereWithAggregatesInput_id_withInt value,
          $Res Function(_$UserScalarWhereWithAggregatesInput_id_withInt) then) =
      __$$UserScalarWhereWithAggregatesInput_id_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_id_withIntCopyWithImpl<$Res>
    extends _$UserScalarWhereWithAggregatesInput_idCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_id_withInt>
    implements _$$UserScalarWhereWithAggregatesInput_id_withIntCopyWith<$Res> {
  __$$UserScalarWhereWithAggregatesInput_id_withIntCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_id_withInt _value,
      $Res Function(_$UserScalarWhereWithAggregatesInput_id_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserScalarWhereWithAggregatesInput_id_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_id_withInt
    implements UserScalarWhereWithAggregatesInput_id_withInt {
  const _$UserScalarWhereWithAggregatesInput_id_withInt(this.value,
      {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$UserScalarWhereWithAggregatesInput_id_withInt.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_id_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_id.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserScalarWhereWithAggregatesInput_id_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_id_withIntCopyWith<
          _$UserScalarWhereWithAggregatesInput_id_withInt>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_id_withIntCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_id_withInt>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(IntWithAggregatesFilter value)
        withIntWithAggregatesFilter,
    required TResult Function(int value) withInt,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(IntWithAggregatesFilter value)?
        withIntWithAggregatesFilter,
    TResult? Function(int value)? withInt,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(IntWithAggregatesFilter value)?
        withIntWithAggregatesFilter,
    TResult Function(int value)? withInt,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)
        withIntWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_id_withInt value)
        withInt,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)?
        withIntWithAggregatesFilter,
    TResult? Function(UserScalarWhereWithAggregatesInput_id_withInt value)?
        withInt,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_id_withIntWithAggregatesFilter
                value)?
        withIntWithAggregatesFilter,
    TResult Function(UserScalarWhereWithAggregatesInput_id_withInt value)?
        withInt,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_id_withIntToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_id_withInt
    implements UserScalarWhereWithAggregatesInput_id {
  const factory UserScalarWhereWithAggregatesInput_id_withInt(final int value) =
      _$UserScalarWhereWithAggregatesInput_id_withInt;

  factory UserScalarWhereWithAggregatesInput_id_withInt.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_id_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_id_withIntCopyWith<
          _$UserScalarWhereWithAggregatesInput_id_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

UserScalarWhereWithAggregatesInput_name
    _$UserScalarWhereWithAggregatesInput_nameFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withStringWithAggregatesFilter':
      return UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
          .fromJson(json);
    case 'withString':
      return UserScalarWhereWithAggregatesInput_name_withString.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserScalarWhereWithAggregatesInput_name',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserScalarWhereWithAggregatesInput_name {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StringWithAggregatesFilter value)
        withStringWithAggregatesFilter,
    required TResult Function(String value) withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StringWithAggregatesFilter value)?
        withStringWithAggregatesFilter,
    TResult? Function(String value)? withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StringWithAggregatesFilter value)?
        withStringWithAggregatesFilter,
    TResult Function(String value)? withString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)
        withStringWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_name_withString value)
        withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)?
        withStringWithAggregatesFilter,
    TResult? Function(UserScalarWhereWithAggregatesInput_name_withString value)?
        withString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)?
        withStringWithAggregatesFilter,
    TResult Function(UserScalarWhereWithAggregatesInput_name_withString value)?
        withString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserScalarWhereWithAggregatesInput_nameCopyWith<$Res> {
  factory $UserScalarWhereWithAggregatesInput_nameCopyWith(
          UserScalarWhereWithAggregatesInput_name value,
          $Res Function(UserScalarWhereWithAggregatesInput_name) then) =
      _$UserScalarWhereWithAggregatesInput_nameCopyWithImpl<$Res,
          UserScalarWhereWithAggregatesInput_name>;
}

/// @nodoc
class _$UserScalarWhereWithAggregatesInput_nameCopyWithImpl<$Res,
        $Val extends UserScalarWhereWithAggregatesInput_name>
    implements $UserScalarWhereWithAggregatesInput_nameCopyWith<$Res> {
  _$UserScalarWhereWithAggregatesInput_nameCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWith(
          _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
              value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter)
              then) =
      __$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({StringWithAggregatesFilter value});

  $StringWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_nameCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter>
    implements
        _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as StringWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StringWithAggregatesFilterCopyWith<$Res> get value {
    return $StringWithAggregatesFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
    implements
        UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter {
  const _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withStringWithAggregatesFilter';

  factory _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterFromJson(
          json);

  @override
  final StringWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_name.withStringWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWith<
          _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StringWithAggregatesFilter value)
        withStringWithAggregatesFilter,
    required TResult Function(String value) withString,
  }) {
    return withStringWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StringWithAggregatesFilter value)?
        withStringWithAggregatesFilter,
    TResult? Function(String value)? withString,
  }) {
    return withStringWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StringWithAggregatesFilter value)?
        withStringWithAggregatesFilter,
    TResult Function(String value)? withString,
    required TResult orElse(),
  }) {
    if (withStringWithAggregatesFilter != null) {
      return withStringWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)
        withStringWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_name_withString value)
        withString,
  }) {
    return withStringWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)?
        withStringWithAggregatesFilter,
    TResult? Function(UserScalarWhereWithAggregatesInput_name_withString value)?
        withString,
  }) {
    return withStringWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)?
        withStringWithAggregatesFilter,
    TResult Function(UserScalarWhereWithAggregatesInput_name_withString value)?
        withString,
    required TResult orElse(),
  }) {
    if (withStringWithAggregatesFilter != null) {
      return withStringWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
    implements UserScalarWhereWithAggregatesInput_name {
  const factory UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter(
          final StringWithAggregatesFilter value) =
      _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter;

  factory UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
          .fromJson;

  @override
  StringWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilterCopyWith<
          _$UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_name_withStringCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_name_withStringCopyWith(
          _$UserScalarWhereWithAggregatesInput_name_withString value,
          $Res Function(_$UserScalarWhereWithAggregatesInput_name_withString)
              then) =
      __$$UserScalarWhereWithAggregatesInput_name_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_name_withStringCopyWithImpl<$Res>
    extends _$UserScalarWhereWithAggregatesInput_nameCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_name_withString>
    implements
        _$$UserScalarWhereWithAggregatesInput_name_withStringCopyWith<$Res> {
  __$$UserScalarWhereWithAggregatesInput_name_withStringCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_name_withString _value,
      $Res Function(_$UserScalarWhereWithAggregatesInput_name_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserScalarWhereWithAggregatesInput_name_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_name_withString
    implements UserScalarWhereWithAggregatesInput_name_withString {
  const _$UserScalarWhereWithAggregatesInput_name_withString(this.value,
      {final String? $type})
      : $type = $type ?? 'withString';

  factory _$UserScalarWhereWithAggregatesInput_name_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_name_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_name.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserScalarWhereWithAggregatesInput_name_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_name_withStringCopyWith<
          _$UserScalarWhereWithAggregatesInput_name_withString>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_name_withStringCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_name_withString>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StringWithAggregatesFilter value)
        withStringWithAggregatesFilter,
    required TResult Function(String value) withString,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StringWithAggregatesFilter value)?
        withStringWithAggregatesFilter,
    TResult? Function(String value)? withString,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StringWithAggregatesFilter value)?
        withStringWithAggregatesFilter,
    TResult Function(String value)? withString,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)
        withStringWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_name_withString value)
        withString,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)?
        withStringWithAggregatesFilter,
    TResult? Function(UserScalarWhereWithAggregatesInput_name_withString value)?
        withString,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_name_withStringWithAggregatesFilter
                value)?
        withStringWithAggregatesFilter,
    TResult Function(UserScalarWhereWithAggregatesInput_name_withString value)?
        withString,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_name_withStringToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_name_withString
    implements UserScalarWhereWithAggregatesInput_name {
  const factory UserScalarWhereWithAggregatesInput_name_withString(
          final String value) =
      _$UserScalarWhereWithAggregatesInput_name_withString;

  factory UserScalarWhereWithAggregatesInput_name_withString.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_name_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_name_withStringCopyWith<
          _$UserScalarWhereWithAggregatesInput_name_withString>
      get copyWith => throw _privateConstructorUsedError;
}

UserScalarWhereWithAggregatesInput_createdAt
    _$UserScalarWhereWithAggregatesInput_createdAtFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTimeWithAggregatesFilter':
      return UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
          .fromJson(json);
    case 'withDateTime':
      return UserScalarWhereWithAggregatesInput_createdAt_withDateTime.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserScalarWhereWithAggregatesInput_createdAt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserScalarWhereWithAggregatesInput_createdAt {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DateTimeWithAggregatesFilter value)
        withDateTimeWithAggregatesFilter,
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DateTimeWithAggregatesFilter value)?
        withDateTimeWithAggregatesFilter,
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DateTimeWithAggregatesFilter value)?
        withDateTimeWithAggregatesFilter,
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)
        withDateTimeWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)?
        withDateTimeWithAggregatesFilter,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)?
        withDateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)?
        withDateTimeWithAggregatesFilter,
    TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)?
        withDateTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserScalarWhereWithAggregatesInput_createdAtCopyWith<$Res> {
  factory $UserScalarWhereWithAggregatesInput_createdAtCopyWith(
          UserScalarWhereWithAggregatesInput_createdAt value,
          $Res Function(UserScalarWhereWithAggregatesInput_createdAt) then) =
      _$UserScalarWhereWithAggregatesInput_createdAtCopyWithImpl<$Res,
          UserScalarWhereWithAggregatesInput_createdAt>;
}

/// @nodoc
class _$UserScalarWhereWithAggregatesInput_createdAtCopyWithImpl<$Res,
        $Val extends UserScalarWhereWithAggregatesInput_createdAt>
    implements $UserScalarWhereWithAggregatesInput_createdAtCopyWith<$Res> {
  _$UserScalarWhereWithAggregatesInput_createdAtCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWith(
          _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
              value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter)
              then) =
      __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DateTimeWithAggregatesFilter value});

  $DateTimeWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_createdAtCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter>
    implements
        _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
          _value,
      $Res Function(
              _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTimeWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeWithAggregatesFilterCopyWith<$Res> get value {
    return $DateTimeWithAggregatesFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
    implements
        UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter {
  const _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTimeWithAggregatesFilter';

  factory _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterFromJson(
          json);

  @override
  final DateTimeWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_createdAt.withDateTimeWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWith<
          _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DateTimeWithAggregatesFilter value)
        withDateTimeWithAggregatesFilter,
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
  }) {
    return withDateTimeWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DateTimeWithAggregatesFilter value)?
        withDateTimeWithAggregatesFilter,
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
  }) {
    return withDateTimeWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DateTimeWithAggregatesFilter value)?
        withDateTimeWithAggregatesFilter,
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTimeWithAggregatesFilter != null) {
      return withDateTimeWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)
        withDateTimeWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)
        withDateTime,
  }) {
    return withDateTimeWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)?
        withDateTimeWithAggregatesFilter,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)?
        withDateTime,
  }) {
    return withDateTimeWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)?
        withDateTimeWithAggregatesFilter,
    TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)?
        withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTimeWithAggregatesFilter != null) {
      return withDateTimeWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
    implements UserScalarWhereWithAggregatesInput_createdAt {
  const factory UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter(
          final DateTimeWithAggregatesFilter value) =
      _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter;

  factory UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
          .fromJson;

  @override
  DateTimeWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilterCopyWith<
          _$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWith<
    $Res> {
  factory _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWith(
          _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime value,
          $Res Function(
                  _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime)
              then) =
      __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWithImpl<
          $Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWithImpl<
        $Res>
    extends _$UserScalarWhereWithAggregatesInput_createdAtCopyWithImpl<$Res,
        _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime>
    implements
        _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWith<
            $Res> {
  __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWithImpl(
      _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime _value,
      $Res Function(_$UserScalarWhereWithAggregatesInput_createdAt_withDateTime)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserScalarWhereWithAggregatesInput_createdAt_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime
    implements UserScalarWhereWithAggregatesInput_createdAt_withDateTime {
  const _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeFromJson(
          json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput_createdAt.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWith<
          _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime>
      get copyWith =>
          __$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWithImpl<
                  _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DateTimeWithAggregatesFilter value)
        withDateTimeWithAggregatesFilter,
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DateTimeWithAggregatesFilter value)?
        withDateTimeWithAggregatesFilter,
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DateTimeWithAggregatesFilter value)?
        withDateTimeWithAggregatesFilter,
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)
        withDateTimeWithAggregatesFilter,
    required TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)
        withDateTime,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)?
        withDateTimeWithAggregatesFilter,
    TResult? Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)?
        withDateTime,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTimeWithAggregatesFilter
                value)?
        withDateTimeWithAggregatesFilter,
    TResult Function(
            UserScalarWhereWithAggregatesInput_createdAt_withDateTime value)?
        withDateTime,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeToJson(
      this,
    );
  }
}

abstract class UserScalarWhereWithAggregatesInput_createdAt_withDateTime
    implements UserScalarWhereWithAggregatesInput_createdAt {
  const factory UserScalarWhereWithAggregatesInput_createdAt_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime;

  factory UserScalarWhereWithAggregatesInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$UserScalarWhereWithAggregatesInput_createdAt_withDateTimeCopyWith<
          _$UserScalarWhereWithAggregatesInput_createdAt_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

UserScalarWhereWithAggregatesInput _$UserScalarWhereWithAggregatesInputFromJson(
    Map<String, dynamic> json) {
  return _UserScalarWhereWithAggregatesInput.fromJson(json);
}

/// @nodoc
mixin _$UserScalarWhereWithAggregatesInput {
  @JsonKey(name: 'AND')
  UserScalarWhereWithAggregatesInput_AND? get AND =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'OR')
  List<UserScalarWhereWithAggregatesInput>? get OR =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'NOT')
  UserScalarWhereWithAggregatesInput_NOT? get NOT =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'id')
  UserScalarWhereWithAggregatesInput_id? get id =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  UserScalarWhereWithAggregatesInput_name? get name =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  UserScalarWhereWithAggregatesInput_createdAt? get createdAt =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserScalarWhereWithAggregatesInputCopyWith<
          UserScalarWhereWithAggregatesInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserScalarWhereWithAggregatesInputCopyWith<$Res> {
  factory $UserScalarWhereWithAggregatesInputCopyWith(
          UserScalarWhereWithAggregatesInput value,
          $Res Function(UserScalarWhereWithAggregatesInput) then) =
      _$UserScalarWhereWithAggregatesInputCopyWithImpl<$Res,
          UserScalarWhereWithAggregatesInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'AND')
          UserScalarWhereWithAggregatesInput_AND? AND,
      @JsonKey(name: 'OR')
          List<UserScalarWhereWithAggregatesInput>? OR,
      @JsonKey(name: 'NOT')
          UserScalarWhereWithAggregatesInput_NOT? NOT,
      @JsonKey(name: 'id')
          UserScalarWhereWithAggregatesInput_id? id,
      @JsonKey(name: 'name')
          UserScalarWhereWithAggregatesInput_name? name,
      @JsonKey(name: 'createdAt')
          UserScalarWhereWithAggregatesInput_createdAt? createdAt});

  $UserScalarWhereWithAggregatesInput_ANDCopyWith<$Res>? get AND;
  $UserScalarWhereWithAggregatesInput_NOTCopyWith<$Res>? get NOT;
  $UserScalarWhereWithAggregatesInput_idCopyWith<$Res>? get id;
  $UserScalarWhereWithAggregatesInput_nameCopyWith<$Res>? get name;
  $UserScalarWhereWithAggregatesInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class _$UserScalarWhereWithAggregatesInputCopyWithImpl<$Res,
        $Val extends UserScalarWhereWithAggregatesInput>
    implements $UserScalarWhereWithAggregatesInputCopyWith<$Res> {
  _$UserScalarWhereWithAggregatesInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? AND = freezed,
    Object? OR = freezed,
    Object? NOT = freezed,
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      AND: freezed == AND
          ? _value.AND
          : AND // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_AND?,
      OR: freezed == OR
          ? _value.OR
          : OR // ignore: cast_nullable_to_non_nullable
              as List<UserScalarWhereWithAggregatesInput>?,
      NOT: freezed == NOT
          ? _value.NOT
          : NOT // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_NOT?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_createdAt?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInput_ANDCopyWith<$Res>? get AND {
    if (_value.AND == null) {
      return null;
    }

    return $UserScalarWhereWithAggregatesInput_ANDCopyWith<$Res>(_value.AND!,
        (value) {
      return _then(_value.copyWith(AND: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInput_NOTCopyWith<$Res>? get NOT {
    if (_value.NOT == null) {
      return null;
    }

    return $UserScalarWhereWithAggregatesInput_NOTCopyWith<$Res>(_value.NOT!,
        (value) {
      return _then(_value.copyWith(NOT: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInput_idCopyWith<$Res>? get id {
    if (_value.id == null) {
      return null;
    }

    return $UserScalarWhereWithAggregatesInput_idCopyWith<$Res>(_value.id!,
        (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInput_nameCopyWith<$Res>? get name {
    if (_value.name == null) {
      return null;
    }

    return $UserScalarWhereWithAggregatesInput_nameCopyWith<$Res>(_value.name!,
        (value) {
      return _then(_value.copyWith(name: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserScalarWhereWithAggregatesInput_createdAtCopyWith<$Res>? get createdAt {
    if (_value.createdAt == null) {
      return null;
    }

    return $UserScalarWhereWithAggregatesInput_createdAtCopyWith<$Res>(
        _value.createdAt!, (value) {
      return _then(_value.copyWith(createdAt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserScalarWhereWithAggregatesInputCopyWith<$Res>
    implements $UserScalarWhereWithAggregatesInputCopyWith<$Res> {
  factory _$$_UserScalarWhereWithAggregatesInputCopyWith(
          _$_UserScalarWhereWithAggregatesInput value,
          $Res Function(_$_UserScalarWhereWithAggregatesInput) then) =
      __$$_UserScalarWhereWithAggregatesInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'AND')
          UserScalarWhereWithAggregatesInput_AND? AND,
      @JsonKey(name: 'OR')
          List<UserScalarWhereWithAggregatesInput>? OR,
      @JsonKey(name: 'NOT')
          UserScalarWhereWithAggregatesInput_NOT? NOT,
      @JsonKey(name: 'id')
          UserScalarWhereWithAggregatesInput_id? id,
      @JsonKey(name: 'name')
          UserScalarWhereWithAggregatesInput_name? name,
      @JsonKey(name: 'createdAt')
          UserScalarWhereWithAggregatesInput_createdAt? createdAt});

  @override
  $UserScalarWhereWithAggregatesInput_ANDCopyWith<$Res>? get AND;
  @override
  $UserScalarWhereWithAggregatesInput_NOTCopyWith<$Res>? get NOT;
  @override
  $UserScalarWhereWithAggregatesInput_idCopyWith<$Res>? get id;
  @override
  $UserScalarWhereWithAggregatesInput_nameCopyWith<$Res>? get name;
  @override
  $UserScalarWhereWithAggregatesInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class __$$_UserScalarWhereWithAggregatesInputCopyWithImpl<$Res>
    extends _$UserScalarWhereWithAggregatesInputCopyWithImpl<$Res,
        _$_UserScalarWhereWithAggregatesInput>
    implements _$$_UserScalarWhereWithAggregatesInputCopyWith<$Res> {
  __$$_UserScalarWhereWithAggregatesInputCopyWithImpl(
      _$_UserScalarWhereWithAggregatesInput _value,
      $Res Function(_$_UserScalarWhereWithAggregatesInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? AND = freezed,
    Object? OR = freezed,
    Object? NOT = freezed,
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserScalarWhereWithAggregatesInput(
      AND: freezed == AND
          ? _value.AND
          : AND // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_AND?,
      OR: freezed == OR
          ? _value._OR
          : OR // ignore: cast_nullable_to_non_nullable
              as List<UserScalarWhereWithAggregatesInput>?,
      NOT: freezed == NOT
          ? _value.NOT
          : NOT // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_NOT?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserScalarWhereWithAggregatesInput_createdAt?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserScalarWhereWithAggregatesInput
    implements _UserScalarWhereWithAggregatesInput {
  const _$_UserScalarWhereWithAggregatesInput(
      {@JsonKey(name: 'AND') this.AND,
      @JsonKey(name: 'OR') final List<UserScalarWhereWithAggregatesInput>? OR,
      @JsonKey(name: 'NOT') this.NOT,
      @JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt})
      : _OR = OR;

  factory _$_UserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UserScalarWhereWithAggregatesInputFromJson(json);

  @override
  @JsonKey(name: 'AND')
  final UserScalarWhereWithAggregatesInput_AND? AND;
  final List<UserScalarWhereWithAggregatesInput>? _OR;
  @override
  @JsonKey(name: 'OR')
  List<UserScalarWhereWithAggregatesInput>? get OR {
    final value = _OR;
    if (value == null) return null;
    if (_OR is EqualUnmodifiableListView) return _OR;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'NOT')
  final UserScalarWhereWithAggregatesInput_NOT? NOT;
  @override
  @JsonKey(name: 'id')
  final UserScalarWhereWithAggregatesInput_id? id;
  @override
  @JsonKey(name: 'name')
  final UserScalarWhereWithAggregatesInput_name? name;
  @override
  @JsonKey(name: 'createdAt')
  final UserScalarWhereWithAggregatesInput_createdAt? createdAt;

  @override
  String toString() {
    return 'UserScalarWhereWithAggregatesInput(AND: $AND, OR: $OR, NOT: $NOT, id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserScalarWhereWithAggregatesInput &&
            (identical(other.AND, AND) || other.AND == AND) &&
            const DeepCollectionEquality().equals(other._OR, _OR) &&
            (identical(other.NOT, NOT) || other.NOT == NOT) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, AND,
      const DeepCollectionEquality().hash(_OR), NOT, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserScalarWhereWithAggregatesInputCopyWith<
          _$_UserScalarWhereWithAggregatesInput>
      get copyWith => __$$_UserScalarWhereWithAggregatesInputCopyWithImpl<
          _$_UserScalarWhereWithAggregatesInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserScalarWhereWithAggregatesInputToJson(
      this,
    );
  }
}

abstract class _UserScalarWhereWithAggregatesInput
    implements UserScalarWhereWithAggregatesInput {
  const factory _UserScalarWhereWithAggregatesInput(
          {@JsonKey(name: 'AND')
              final UserScalarWhereWithAggregatesInput_AND? AND,
          @JsonKey(name: 'OR')
              final List<UserScalarWhereWithAggregatesInput>? OR,
          @JsonKey(name: 'NOT')
              final UserScalarWhereWithAggregatesInput_NOT? NOT,
          @JsonKey(name: 'id')
              final UserScalarWhereWithAggregatesInput_id? id,
          @JsonKey(name: 'name')
              final UserScalarWhereWithAggregatesInput_name? name,
          @JsonKey(name: 'createdAt')
              final UserScalarWhereWithAggregatesInput_createdAt? createdAt}) =
      _$_UserScalarWhereWithAggregatesInput;

  factory _UserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =
      _$_UserScalarWhereWithAggregatesInput.fromJson;

  @override
  @JsonKey(name: 'AND')
  UserScalarWhereWithAggregatesInput_AND? get AND;
  @override
  @JsonKey(name: 'OR')
  List<UserScalarWhereWithAggregatesInput>? get OR;
  @override
  @JsonKey(name: 'NOT')
  UserScalarWhereWithAggregatesInput_NOT? get NOT;
  @override
  @JsonKey(name: 'id')
  UserScalarWhereWithAggregatesInput_id? get id;
  @override
  @JsonKey(name: 'name')
  UserScalarWhereWithAggregatesInput_name? get name;
  @override
  @JsonKey(name: 'createdAt')
  UserScalarWhereWithAggregatesInput_createdAt? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserScalarWhereWithAggregatesInputCopyWith<
          _$_UserScalarWhereWithAggregatesInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserCreateInput _$UserCreateInputFromJson(Map<String, dynamic> json) {
  return _UserCreateInput.fromJson(json);
}

/// @nodoc
mixin _$UserCreateInput {
  @JsonKey(name: 'name')
  String get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  DateTime? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserCreateInputCopyWith<UserCreateInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserCreateInputCopyWith<$Res> {
  factory $UserCreateInputCopyWith(
          UserCreateInput value, $Res Function(UserCreateInput) then) =
      _$UserCreateInputCopyWithImpl<$Res, UserCreateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) DateTime? createdAt});
}

/// @nodoc
class _$UserCreateInputCopyWithImpl<$Res, $Val extends UserCreateInput>
    implements $UserCreateInputCopyWith<$Res> {
  _$UserCreateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserCreateInputCopyWith<$Res>
    implements $UserCreateInputCopyWith<$Res> {
  factory _$$_UserCreateInputCopyWith(
          _$_UserCreateInput value, $Res Function(_$_UserCreateInput) then) =
      __$$_UserCreateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) DateTime? createdAt});
}

/// @nodoc
class __$$_UserCreateInputCopyWithImpl<$Res>
    extends _$UserCreateInputCopyWithImpl<$Res, _$_UserCreateInput>
    implements _$$_UserCreateInputCopyWith<$Res> {
  __$$_UserCreateInputCopyWithImpl(
      _$_UserCreateInput _value, $Res Function(_$_UserCreateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserCreateInput(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserCreateInput implements _UserCreateInput {
  const _$_UserCreateInput(
      {@JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) this.createdAt});

  factory _$_UserCreateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserCreateInputFromJson(json);

  @override
  @JsonKey(name: 'name')
  final String name;
  @override
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  final DateTime? createdAt;

  @override
  String toString() {
    return 'UserCreateInput(name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserCreateInput &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserCreateInputCopyWith<_$_UserCreateInput> get copyWith =>
      __$$_UserCreateInputCopyWithImpl<_$_UserCreateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserCreateInputToJson(
      this,
    );
  }
}

abstract class _UserCreateInput implements UserCreateInput {
  const factory _UserCreateInput(
      {@JsonKey(name: 'name')
          required final String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
          final DateTime? createdAt}) = _$_UserCreateInput;

  factory _UserCreateInput.fromJson(Map<String, dynamic> json) =
      _$_UserCreateInput.fromJson;

  @override
  @JsonKey(name: 'name')
  String get name;
  @override
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  DateTime? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserCreateInputCopyWith<_$_UserCreateInput> get copyWith =>
      throw _privateConstructorUsedError;
}

UserUncheckedCreateInput _$UserUncheckedCreateInputFromJson(
    Map<String, dynamic> json) {
  return _UserUncheckedCreateInput.fromJson(json);
}

/// @nodoc
mixin _$UserUncheckedCreateInput {
  @JsonKey(name: 'id')
  int? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  String get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  DateTime? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserUncheckedCreateInputCopyWith<UserUncheckedCreateInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedCreateInputCopyWith<$Res> {
  factory $UserUncheckedCreateInputCopyWith(UserUncheckedCreateInput value,
          $Res Function(UserUncheckedCreateInput) then) =
      _$UserUncheckedCreateInputCopyWithImpl<$Res, UserUncheckedCreateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) DateTime? createdAt});
}

/// @nodoc
class _$UserUncheckedCreateInputCopyWithImpl<$Res,
        $Val extends UserUncheckedCreateInput>
    implements $UserUncheckedCreateInputCopyWith<$Res> {
  _$UserUncheckedCreateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserUncheckedCreateInputCopyWith<$Res>
    implements $UserUncheckedCreateInputCopyWith<$Res> {
  factory _$$_UserUncheckedCreateInputCopyWith(
          _$_UserUncheckedCreateInput value,
          $Res Function(_$_UserUncheckedCreateInput) then) =
      __$$_UserUncheckedCreateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) DateTime? createdAt});
}

/// @nodoc
class __$$_UserUncheckedCreateInputCopyWithImpl<$Res>
    extends _$UserUncheckedCreateInputCopyWithImpl<$Res,
        _$_UserUncheckedCreateInput>
    implements _$$_UserUncheckedCreateInputCopyWith<$Res> {
  __$$_UserUncheckedCreateInputCopyWithImpl(_$_UserUncheckedCreateInput _value,
      $Res Function(_$_UserUncheckedCreateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserUncheckedCreateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserUncheckedCreateInput implements _UserUncheckedCreateInput {
  const _$_UserUncheckedCreateInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) this.createdAt});

  factory _$_UserUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserUncheckedCreateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'name')
  final String name;
  @override
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  final DateTime? createdAt;

  @override
  String toString() {
    return 'UserUncheckedCreateInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserUncheckedCreateInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserUncheckedCreateInputCopyWith<_$_UserUncheckedCreateInput>
      get copyWith => __$$_UserUncheckedCreateInputCopyWithImpl<
          _$_UserUncheckedCreateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserUncheckedCreateInputToJson(
      this,
    );
  }
}

abstract class _UserUncheckedCreateInput implements UserUncheckedCreateInput {
  const factory _UserUncheckedCreateInput(
      {@JsonKey(name: 'id')
          final int? id,
      @JsonKey(name: 'name')
          required final String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
          final DateTime? createdAt}) = _$_UserUncheckedCreateInput;

  factory _UserUncheckedCreateInput.fromJson(Map<String, dynamic> json) =
      _$_UserUncheckedCreateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  int? get id;
  @override
  @JsonKey(name: 'name')
  String get name;
  @override
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  DateTime? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserUncheckedCreateInputCopyWith<_$_UserUncheckedCreateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUpdateInput_name _$UserUpdateInput_nameFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return UserUpdateInput_name_withString.fromJson(json);
    case 'withStringFieldUpdateOperationsInput':
      return UserUpdateInput_name_withStringFieldUpdateOperationsInput.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUpdateInput_name',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUpdateInput_name {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateInput_name_withString value) withString,
    required TResult Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput_name_withString value)? withString,
    TResult? Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateInput_name_withString value)? withString,
    TResult Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUpdateInput_nameCopyWith<$Res> {
  factory $UserUpdateInput_nameCopyWith(UserUpdateInput_name value,
          $Res Function(UserUpdateInput_name) then) =
      _$UserUpdateInput_nameCopyWithImpl<$Res, UserUpdateInput_name>;
}

/// @nodoc
class _$UserUpdateInput_nameCopyWithImpl<$Res,
        $Val extends UserUpdateInput_name>
    implements $UserUpdateInput_nameCopyWith<$Res> {
  _$UserUpdateInput_nameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUpdateInput_name_withStringCopyWith<$Res> {
  factory _$$UserUpdateInput_name_withStringCopyWith(
          _$UserUpdateInput_name_withString value,
          $Res Function(_$UserUpdateInput_name_withString) then) =
      __$$UserUpdateInput_name_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UserUpdateInput_name_withStringCopyWithImpl<$Res>
    extends _$UserUpdateInput_nameCopyWithImpl<$Res,
        _$UserUpdateInput_name_withString>
    implements _$$UserUpdateInput_name_withStringCopyWith<$Res> {
  __$$UserUpdateInput_name_withStringCopyWithImpl(
      _$UserUpdateInput_name_withString _value,
      $Res Function(_$UserUpdateInput_name_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUpdateInput_name_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateInput_name_withString
    implements UserUpdateInput_name_withString {
  const _$UserUpdateInput_name_withString(this.value, {final String? $type})
      : $type = $type ?? 'withString';

  factory _$UserUpdateInput_name_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateInput_name_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateInput_name.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUpdateInput_name_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateInput_name_withStringCopyWith<_$UserUpdateInput_name_withString>
      get copyWith => __$$UserUpdateInput_name_withStringCopyWithImpl<
          _$UserUpdateInput_name_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateInput_name_withString value) withString,
    required TResult Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput_name_withString value)? withString,
    TResult? Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateInput_name_withString value)? withString,
    TResult Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateInput_name_withStringToJson(
      this,
    );
  }
}

abstract class UserUpdateInput_name_withString implements UserUpdateInput_name {
  const factory UserUpdateInput_name_withString(final String value) =
      _$UserUpdateInput_name_withString;

  factory UserUpdateInput_name_withString.fromJson(Map<String, dynamic> json) =
      _$UserUpdateInput_name_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UserUpdateInput_name_withStringCopyWith<_$UserUpdateInput_name_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith(
          _$UserUpdateInput_name_withStringFieldUpdateOperationsInput value,
          $Res Function(
                  _$UserUpdateInput_name_withStringFieldUpdateOperationsInput)
              then) =
      __$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({StringFieldUpdateOperationsInput value});

  $StringFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUpdateInput_nameCopyWithImpl<$Res,
        _$UserUpdateInput_name_withStringFieldUpdateOperationsInput>
    implements
        _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl(
      _$UserUpdateInput_name_withStringFieldUpdateOperationsInput _value,
      $Res Function(_$UserUpdateInput_name_withStringFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUpdateInput_name_withStringFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as StringFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StringFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $StringFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateInput_name_withStringFieldUpdateOperationsInput
    implements UserUpdateInput_name_withStringFieldUpdateOperationsInput {
  const _$UserUpdateInput_name_withStringFieldUpdateOperationsInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withStringFieldUpdateOperationsInput';

  factory _$UserUpdateInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputFromJson(
          json);

  @override
  final StringFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateInput_name.withStringFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUpdateInput_name_withStringFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUpdateInput_name_withStringFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUpdateInput_name_withStringFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateInput_name_withString value) withString,
    required TResult Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput_name_withString value)? withString,
    TResult? Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateInput_name_withString value)? withString,
    TResult Function(
            UserUpdateInput_name_withStringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUpdateInput_name_withStringFieldUpdateOperationsInput
    implements UserUpdateInput_name {
  const factory UserUpdateInput_name_withStringFieldUpdateOperationsInput(
          final StringFieldUpdateOperationsInput value) =
      _$UserUpdateInput_name_withStringFieldUpdateOperationsInput;

  factory UserUpdateInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateInput_name_withStringFieldUpdateOperationsInput.fromJson;

  @override
  StringFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUpdateInput_name_withStringFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUpdateInput_createdAt _$UserUpdateInput_createdAtFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return UserUpdateInput_createdAt_withDateTime.fromJson(json);
    case 'withDateTimeFieldUpdateOperationsInput':
      return UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUpdateInput_createdAt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUpdateInput_createdAt {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUpdateInput_createdAtCopyWith<$Res> {
  factory $UserUpdateInput_createdAtCopyWith(UserUpdateInput_createdAt value,
          $Res Function(UserUpdateInput_createdAt) then) =
      _$UserUpdateInput_createdAtCopyWithImpl<$Res, UserUpdateInput_createdAt>;
}

/// @nodoc
class _$UserUpdateInput_createdAtCopyWithImpl<$Res,
        $Val extends UserUpdateInput_createdAt>
    implements $UserUpdateInput_createdAtCopyWith<$Res> {
  _$UserUpdateInput_createdAtCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUpdateInput_createdAt_withDateTimeCopyWith<$Res> {
  factory _$$UserUpdateInput_createdAt_withDateTimeCopyWith(
          _$UserUpdateInput_createdAt_withDateTime value,
          $Res Function(_$UserUpdateInput_createdAt_withDateTime) then) =
      __$$UserUpdateInput_createdAt_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$UserUpdateInput_createdAt_withDateTimeCopyWithImpl<$Res>
    extends _$UserUpdateInput_createdAtCopyWithImpl<$Res,
        _$UserUpdateInput_createdAt_withDateTime>
    implements _$$UserUpdateInput_createdAt_withDateTimeCopyWith<$Res> {
  __$$UserUpdateInput_createdAt_withDateTimeCopyWithImpl(
      _$UserUpdateInput_createdAt_withDateTime _value,
      $Res Function(_$UserUpdateInput_createdAt_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUpdateInput_createdAt_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateInput_createdAt_withDateTime
    implements UserUpdateInput_createdAt_withDateTime {
  const _$UserUpdateInput_createdAt_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$UserUpdateInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateInput_createdAt_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateInput_createdAt.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUpdateInput_createdAt_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateInput_createdAt_withDateTimeCopyWith<
          _$UserUpdateInput_createdAt_withDateTime>
      get copyWith => __$$UserUpdateInput_createdAt_withDateTimeCopyWithImpl<
          _$UserUpdateInput_createdAt_withDateTime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateInput_createdAt_withDateTimeToJson(
      this,
    );
  }
}

abstract class UserUpdateInput_createdAt_withDateTime
    implements UserUpdateInput_createdAt {
  const factory UserUpdateInput_createdAt_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$UserUpdateInput_createdAt_withDateTime;

  factory UserUpdateInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateInput_createdAt_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$UserUpdateInput_createdAt_withDateTimeCopyWith<
          _$UserUpdateInput_createdAt_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith(
          _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput value,
          $Res Function(
                  _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput)
              then) =
      __$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DateTimeFieldUpdateOperationsInput value});

  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUpdateInput_createdAtCopyWithImpl<$Res,
        _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>
    implements
        _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl(
      _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput _value,
      $Res Function(
              _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTimeFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $DateTimeFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements
        UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput {
  const _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTimeFieldUpdateOperationsInput';

  factory _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputFromJson(
          json);

  @override
  final DateTimeFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateInput_createdAt.withDateTimeFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements UserUpdateInput_createdAt {
  const factory UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput(
          final DateTimeFieldUpdateOperationsInput value) =
      _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput;

  factory UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson;

  @override
  DateTimeFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUpdateInput _$UserUpdateInputFromJson(Map<String, dynamic> json) {
  return _UserUpdateInput.fromJson(json);
}

/// @nodoc
mixin _$UserUpdateInput {
  @JsonKey(name: 'name')
  UserUpdateInput_name? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  UserUpdateInput_createdAt? get createdAt =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserUpdateInputCopyWith<UserUpdateInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUpdateInputCopyWith<$Res> {
  factory $UserUpdateInputCopyWith(
          UserUpdateInput value, $Res Function(UserUpdateInput) then) =
      _$UserUpdateInputCopyWithImpl<$Res, UserUpdateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'name') UserUpdateInput_name? name,
      @JsonKey(name: 'createdAt') UserUpdateInput_createdAt? createdAt});

  $UserUpdateInput_nameCopyWith<$Res>? get name;
  $UserUpdateInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class _$UserUpdateInputCopyWithImpl<$Res, $Val extends UserUpdateInput>
    implements $UserUpdateInputCopyWith<$Res> {
  _$UserUpdateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUpdateInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUpdateInput_createdAt?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateInput_nameCopyWith<$Res>? get name {
    if (_value.name == null) {
      return null;
    }

    return $UserUpdateInput_nameCopyWith<$Res>(_value.name!, (value) {
      return _then(_value.copyWith(name: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateInput_createdAtCopyWith<$Res>? get createdAt {
    if (_value.createdAt == null) {
      return null;
    }

    return $UserUpdateInput_createdAtCopyWith<$Res>(_value.createdAt!, (value) {
      return _then(_value.copyWith(createdAt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserUpdateInputCopyWith<$Res>
    implements $UserUpdateInputCopyWith<$Res> {
  factory _$$_UserUpdateInputCopyWith(
          _$_UserUpdateInput value, $Res Function(_$_UserUpdateInput) then) =
      __$$_UserUpdateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name') UserUpdateInput_name? name,
      @JsonKey(name: 'createdAt') UserUpdateInput_createdAt? createdAt});

  @override
  $UserUpdateInput_nameCopyWith<$Res>? get name;
  @override
  $UserUpdateInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class __$$_UserUpdateInputCopyWithImpl<$Res>
    extends _$UserUpdateInputCopyWithImpl<$Res, _$_UserUpdateInput>
    implements _$$_UserUpdateInputCopyWith<$Res> {
  __$$_UserUpdateInputCopyWithImpl(
      _$_UserUpdateInput _value, $Res Function(_$_UserUpdateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserUpdateInput(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUpdateInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUpdateInput_createdAt?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserUpdateInput implements _UserUpdateInput {
  const _$_UserUpdateInput(
      {@JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserUpdateInputFromJson(json);

  @override
  @JsonKey(name: 'name')
  final UserUpdateInput_name? name;
  @override
  @JsonKey(name: 'createdAt')
  final UserUpdateInput_createdAt? createdAt;

  @override
  String toString() {
    return 'UserUpdateInput(name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserUpdateInput &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserUpdateInputCopyWith<_$_UserUpdateInput> get copyWith =>
      __$$_UserUpdateInputCopyWithImpl<_$_UserUpdateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserUpdateInputToJson(
      this,
    );
  }
}

abstract class _UserUpdateInput implements UserUpdateInput {
  const factory _UserUpdateInput(
      {@JsonKey(name: 'name')
          final UserUpdateInput_name? name,
      @JsonKey(name: 'createdAt')
          final UserUpdateInput_createdAt? createdAt}) = _$_UserUpdateInput;

  factory _UserUpdateInput.fromJson(Map<String, dynamic> json) =
      _$_UserUpdateInput.fromJson;

  @override
  @JsonKey(name: 'name')
  UserUpdateInput_name? get name;
  @override
  @JsonKey(name: 'createdAt')
  UserUpdateInput_createdAt? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserUpdateInputCopyWith<_$_UserUpdateInput> get copyWith =>
      throw _privateConstructorUsedError;
}

UserUncheckedUpdateInput_id _$UserUncheckedUpdateInput_idFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withInt':
      return UserUncheckedUpdateInput_id_withInt.fromJson(json);
    case 'withIntFieldUpdateOperationsInput':
      return UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUncheckedUpdateInput_id',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUncheckedUpdateInput_id {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(IntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateInput_id_withInt value)
        withInt,
    required TResult Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_id_withInt value)? withInt,
    TResult? Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_id_withInt value)? withInt,
    TResult Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateInput_idCopyWith<$Res> {
  factory $UserUncheckedUpdateInput_idCopyWith(
          UserUncheckedUpdateInput_id value,
          $Res Function(UserUncheckedUpdateInput_id) then) =
      _$UserUncheckedUpdateInput_idCopyWithImpl<$Res,
          UserUncheckedUpdateInput_id>;
}

/// @nodoc
class _$UserUncheckedUpdateInput_idCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateInput_id>
    implements $UserUncheckedUpdateInput_idCopyWith<$Res> {
  _$UserUncheckedUpdateInput_idCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateInput_id_withIntCopyWith<$Res> {
  factory _$$UserUncheckedUpdateInput_id_withIntCopyWith(
          _$UserUncheckedUpdateInput_id_withInt value,
          $Res Function(_$UserUncheckedUpdateInput_id_withInt) then) =
      __$$UserUncheckedUpdateInput_id_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$UserUncheckedUpdateInput_id_withIntCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateInput_idCopyWithImpl<$Res,
        _$UserUncheckedUpdateInput_id_withInt>
    implements _$$UserUncheckedUpdateInput_id_withIntCopyWith<$Res> {
  __$$UserUncheckedUpdateInput_id_withIntCopyWithImpl(
      _$UserUncheckedUpdateInput_id_withInt _value,
      $Res Function(_$UserUncheckedUpdateInput_id_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUncheckedUpdateInput_id_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateInput_id_withInt
    implements UserUncheckedUpdateInput_id_withInt {
  const _$UserUncheckedUpdateInput_id_withInt(this.value, {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$UserUncheckedUpdateInput_id_withInt.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateInput_id_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput_id.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUncheckedUpdateInput_id_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateInput_id_withIntCopyWith<
          _$UserUncheckedUpdateInput_id_withInt>
      get copyWith => __$$UserUncheckedUpdateInput_id_withIntCopyWithImpl<
          _$UserUncheckedUpdateInput_id_withInt>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(IntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateInput_id_withInt value)
        withInt,
    required TResult Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_id_withInt value)? withInt,
    TResult? Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_id_withInt value)? withInt,
    TResult Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateInput_id_withIntToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateInput_id_withInt
    implements UserUncheckedUpdateInput_id {
  const factory UserUncheckedUpdateInput_id_withInt(final int value) =
      _$UserUncheckedUpdateInput_id_withInt;

  factory UserUncheckedUpdateInput_id_withInt.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateInput_id_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateInput_id_withIntCopyWith<
          _$UserUncheckedUpdateInput_id_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWith(
          _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput value,
          $Res Function(
                  _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput)
              then) =
      __$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({IntFieldUpdateOperationsInput value});

  $IntFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUncheckedUpdateInput_idCopyWithImpl<$Res,
        _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput>
    implements
        _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWithImpl(
      _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput _value,
      $Res Function(
              _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as IntFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $IntFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $IntFieldUpdateOperationsInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
    implements UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput {
  const _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withIntFieldUpdateOperationsInput';

  factory _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputFromJson(
          json);

  @override
  final IntFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput_id.withIntFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(IntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withIntFieldUpdateOperationsInput != null) {
      return withIntFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateInput_id_withInt value)
        withInt,
    required TResult Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_id_withInt value)? withInt,
    TResult? Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_id_withInt value)? withInt,
    TResult Function(
            UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withIntFieldUpdateOperationsInput != null) {
      return withIntFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput
    implements UserUncheckedUpdateInput_id {
  const factory UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput(
          final IntFieldUpdateOperationsInput value) =
      _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput;

  factory UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput.fromJson;

  @override
  IntFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateInput_id_withIntFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateInput_name _$UserUncheckedUpdateInput_nameFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return UserUncheckedUpdateInput_name_withString.fromJson(json);
    case 'withStringFieldUpdateOperationsInput':
      return UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUncheckedUpdateInput_name',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUncheckedUpdateInput_name {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateInput_name_withString value)
        withString,
    required TResult Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_name_withString value)?
        withString,
    TResult? Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_name_withString value)?
        withString,
    TResult Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateInput_nameCopyWith<$Res> {
  factory $UserUncheckedUpdateInput_nameCopyWith(
          UserUncheckedUpdateInput_name value,
          $Res Function(UserUncheckedUpdateInput_name) then) =
      _$UserUncheckedUpdateInput_nameCopyWithImpl<$Res,
          UserUncheckedUpdateInput_name>;
}

/// @nodoc
class _$UserUncheckedUpdateInput_nameCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateInput_name>
    implements $UserUncheckedUpdateInput_nameCopyWith<$Res> {
  _$UserUncheckedUpdateInput_nameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateInput_name_withStringCopyWith<$Res> {
  factory _$$UserUncheckedUpdateInput_name_withStringCopyWith(
          _$UserUncheckedUpdateInput_name_withString value,
          $Res Function(_$UserUncheckedUpdateInput_name_withString) then) =
      __$$UserUncheckedUpdateInput_name_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UserUncheckedUpdateInput_name_withStringCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateInput_nameCopyWithImpl<$Res,
        _$UserUncheckedUpdateInput_name_withString>
    implements _$$UserUncheckedUpdateInput_name_withStringCopyWith<$Res> {
  __$$UserUncheckedUpdateInput_name_withStringCopyWithImpl(
      _$UserUncheckedUpdateInput_name_withString _value,
      $Res Function(_$UserUncheckedUpdateInput_name_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUncheckedUpdateInput_name_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateInput_name_withString
    implements UserUncheckedUpdateInput_name_withString {
  const _$UserUncheckedUpdateInput_name_withString(this.value,
      {final String? $type})
      : $type = $type ?? 'withString';

  factory _$UserUncheckedUpdateInput_name_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateInput_name_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput_name.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUncheckedUpdateInput_name_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateInput_name_withStringCopyWith<
          _$UserUncheckedUpdateInput_name_withString>
      get copyWith => __$$UserUncheckedUpdateInput_name_withStringCopyWithImpl<
          _$UserUncheckedUpdateInput_name_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateInput_name_withString value)
        withString,
    required TResult Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_name_withString value)?
        withString,
    TResult? Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_name_withString value)?
        withString,
    TResult Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateInput_name_withStringToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateInput_name_withString
    implements UserUncheckedUpdateInput_name {
  const factory UserUncheckedUpdateInput_name_withString(final String value) =
      _$UserUncheckedUpdateInput_name_withString;

  factory UserUncheckedUpdateInput_name_withString.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateInput_name_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateInput_name_withStringCopyWith<
          _$UserUncheckedUpdateInput_name_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith(
          _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
              value,
          $Res Function(
                  _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput)
              then) =
      __$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({StringFieldUpdateOperationsInput value});

  $StringFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUncheckedUpdateInput_nameCopyWithImpl<$Res,
        _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput>
    implements
        _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl(
      _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as StringFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StringFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $StringFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
    implements
        UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput {
  const _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withStringFieldUpdateOperationsInput';

  factory _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputFromJson(
          json);

  @override
  final StringFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput_name.withStringFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateInput_name_withString value)
        withString,
    required TResult Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_name_withString value)?
        withString,
    TResult? Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_name_withString value)?
        withString,
    TResult Function(
            UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
    implements UserUncheckedUpdateInput_name {
  const factory UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput(
          final StringFieldUpdateOperationsInput value) =
      _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput;

  factory UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput
          .fromJson;

  @override
  StringFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateInput_name_withStringFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateInput_createdAt _$UserUncheckedUpdateInput_createdAtFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return UserUncheckedUpdateInput_createdAt_withDateTime.fromJson(json);
    case 'withDateTimeFieldUpdateOperationsInput':
      return UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUncheckedUpdateInput_createdAt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUncheckedUpdateInput_createdAt {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateInput_createdAtCopyWith<$Res> {
  factory $UserUncheckedUpdateInput_createdAtCopyWith(
          UserUncheckedUpdateInput_createdAt value,
          $Res Function(UserUncheckedUpdateInput_createdAt) then) =
      _$UserUncheckedUpdateInput_createdAtCopyWithImpl<$Res,
          UserUncheckedUpdateInput_createdAt>;
}

/// @nodoc
class _$UserUncheckedUpdateInput_createdAtCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateInput_createdAt>
    implements $UserUncheckedUpdateInput_createdAtCopyWith<$Res> {
  _$UserUncheckedUpdateInput_createdAtCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWith(
          _$UserUncheckedUpdateInput_createdAt_withDateTime value,
          $Res Function(_$UserUncheckedUpdateInput_createdAt_withDateTime)
              then) =
      __$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateInput_createdAtCopyWithImpl<$Res,
        _$UserUncheckedUpdateInput_createdAt_withDateTime>
    implements
        _$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWith<$Res> {
  __$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWithImpl(
      _$UserUncheckedUpdateInput_createdAt_withDateTime _value,
      $Res Function(_$UserUncheckedUpdateInput_createdAt_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUncheckedUpdateInput_createdAt_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateInput_createdAt_withDateTime
    implements UserUncheckedUpdateInput_createdAt_withDateTime {
  const _$UserUncheckedUpdateInput_createdAt_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$UserUncheckedUpdateInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateInput_createdAt_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput_createdAt.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUncheckedUpdateInput_createdAt_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWith<
          _$UserUncheckedUpdateInput_createdAt_withDateTime>
      get copyWith =>
          __$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWithImpl<
                  _$UserUncheckedUpdateInput_createdAt_withDateTime>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateInput_createdAt_withDateTimeToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateInput_createdAt_withDateTime
    implements UserUncheckedUpdateInput_createdAt {
  const factory UserUncheckedUpdateInput_createdAt_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$UserUncheckedUpdateInput_createdAt_withDateTime;

  factory UserUncheckedUpdateInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateInput_createdAt_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateInput_createdAt_withDateTimeCopyWith<
          _$UserUncheckedUpdateInput_createdAt_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith(
          _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
              value,
          $Res Function(
                  _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput)
              then) =
      __$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DateTimeFieldUpdateOperationsInput value});

  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUncheckedUpdateInput_createdAtCopyWithImpl<$Res,
        _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>
    implements
        _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl(
      _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTimeFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $DateTimeFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements
        UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput {
  const _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTimeFieldUpdateOperationsInput';

  factory _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputFromJson(
          json);

  @override
  final DateTimeFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput_createdAt.withDateTimeFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements UserUncheckedUpdateInput_createdAt {
  const factory UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput(
          final DateTimeFieldUpdateOperationsInput value) =
      _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput;

  factory UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson;

  @override
  DateTimeFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateInput _$UserUncheckedUpdateInputFromJson(
    Map<String, dynamic> json) {
  return _UserUncheckedUpdateInput.fromJson(json);
}

/// @nodoc
mixin _$UserUncheckedUpdateInput {
  @JsonKey(name: 'id')
  UserUncheckedUpdateInput_id? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  UserUncheckedUpdateInput_name? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  UserUncheckedUpdateInput_createdAt? get createdAt =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserUncheckedUpdateInputCopyWith<UserUncheckedUpdateInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateInputCopyWith<$Res> {
  factory $UserUncheckedUpdateInputCopyWith(UserUncheckedUpdateInput value,
          $Res Function(UserUncheckedUpdateInput) then) =
      _$UserUncheckedUpdateInputCopyWithImpl<$Res, UserUncheckedUpdateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id')
          UserUncheckedUpdateInput_id? id,
      @JsonKey(name: 'name')
          UserUncheckedUpdateInput_name? name,
      @JsonKey(name: 'createdAt')
          UserUncheckedUpdateInput_createdAt? createdAt});

  $UserUncheckedUpdateInput_idCopyWith<$Res>? get id;
  $UserUncheckedUpdateInput_nameCopyWith<$Res>? get name;
  $UserUncheckedUpdateInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class _$UserUncheckedUpdateInputCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateInput>
    implements $UserUncheckedUpdateInputCopyWith<$Res> {
  _$UserUncheckedUpdateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput_createdAt?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateInput_idCopyWith<$Res>? get id {
    if (_value.id == null) {
      return null;
    }

    return $UserUncheckedUpdateInput_idCopyWith<$Res>(_value.id!, (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateInput_nameCopyWith<$Res>? get name {
    if (_value.name == null) {
      return null;
    }

    return $UserUncheckedUpdateInput_nameCopyWith<$Res>(_value.name!, (value) {
      return _then(_value.copyWith(name: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateInput_createdAtCopyWith<$Res>? get createdAt {
    if (_value.createdAt == null) {
      return null;
    }

    return $UserUncheckedUpdateInput_createdAtCopyWith<$Res>(_value.createdAt!,
        (value) {
      return _then(_value.copyWith(createdAt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserUncheckedUpdateInputCopyWith<$Res>
    implements $UserUncheckedUpdateInputCopyWith<$Res> {
  factory _$$_UserUncheckedUpdateInputCopyWith(
          _$_UserUncheckedUpdateInput value,
          $Res Function(_$_UserUncheckedUpdateInput) then) =
      __$$_UserUncheckedUpdateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id')
          UserUncheckedUpdateInput_id? id,
      @JsonKey(name: 'name')
          UserUncheckedUpdateInput_name? name,
      @JsonKey(name: 'createdAt')
          UserUncheckedUpdateInput_createdAt? createdAt});

  @override
  $UserUncheckedUpdateInput_idCopyWith<$Res>? get id;
  @override
  $UserUncheckedUpdateInput_nameCopyWith<$Res>? get name;
  @override
  $UserUncheckedUpdateInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class __$$_UserUncheckedUpdateInputCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateInputCopyWithImpl<$Res,
        _$_UserUncheckedUpdateInput>
    implements _$$_UserUncheckedUpdateInputCopyWith<$Res> {
  __$$_UserUncheckedUpdateInputCopyWithImpl(_$_UserUncheckedUpdateInput _value,
      $Res Function(_$_UserUncheckedUpdateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserUncheckedUpdateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput_createdAt?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserUncheckedUpdateInput implements _UserUncheckedUpdateInput {
  const _$_UserUncheckedUpdateInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserUncheckedUpdateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final UserUncheckedUpdateInput_id? id;
  @override
  @JsonKey(name: 'name')
  final UserUncheckedUpdateInput_name? name;
  @override
  @JsonKey(name: 'createdAt')
  final UserUncheckedUpdateInput_createdAt? createdAt;

  @override
  String toString() {
    return 'UserUncheckedUpdateInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserUncheckedUpdateInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserUncheckedUpdateInputCopyWith<_$_UserUncheckedUpdateInput>
      get copyWith => __$$_UserUncheckedUpdateInputCopyWithImpl<
          _$_UserUncheckedUpdateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserUncheckedUpdateInputToJson(
      this,
    );
  }
}

abstract class _UserUncheckedUpdateInput implements UserUncheckedUpdateInput {
  const factory _UserUncheckedUpdateInput(
          {@JsonKey(name: 'id')
              final UserUncheckedUpdateInput_id? id,
          @JsonKey(name: 'name')
              final UserUncheckedUpdateInput_name? name,
          @JsonKey(name: 'createdAt')
              final UserUncheckedUpdateInput_createdAt? createdAt}) =
      _$_UserUncheckedUpdateInput;

  factory _UserUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =
      _$_UserUncheckedUpdateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  UserUncheckedUpdateInput_id? get id;
  @override
  @JsonKey(name: 'name')
  UserUncheckedUpdateInput_name? get name;
  @override
  @JsonKey(name: 'createdAt')
  UserUncheckedUpdateInput_createdAt? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserUncheckedUpdateInputCopyWith<_$_UserUncheckedUpdateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserCreateManyInput _$UserCreateManyInputFromJson(Map<String, dynamic> json) {
  return _UserCreateManyInput.fromJson(json);
}

/// @nodoc
mixin _$UserCreateManyInput {
  @JsonKey(name: 'id')
  int? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  String get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  DateTime? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserCreateManyInputCopyWith<UserCreateManyInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserCreateManyInputCopyWith<$Res> {
  factory $UserCreateManyInputCopyWith(
          UserCreateManyInput value, $Res Function(UserCreateManyInput) then) =
      _$UserCreateManyInputCopyWithImpl<$Res, UserCreateManyInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) DateTime? createdAt});
}

/// @nodoc
class _$UserCreateManyInputCopyWithImpl<$Res, $Val extends UserCreateManyInput>
    implements $UserCreateManyInputCopyWith<$Res> {
  _$UserCreateManyInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserCreateManyInputCopyWith<$Res>
    implements $UserCreateManyInputCopyWith<$Res> {
  factory _$$_UserCreateManyInputCopyWith(_$_UserCreateManyInput value,
          $Res Function(_$_UserCreateManyInput) then) =
      __$$_UserCreateManyInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') int? id,
      @JsonKey(name: 'name') String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) DateTime? createdAt});
}

/// @nodoc
class __$$_UserCreateManyInputCopyWithImpl<$Res>
    extends _$UserCreateManyInputCopyWithImpl<$Res, _$_UserCreateManyInput>
    implements _$$_UserCreateManyInputCopyWith<$Res> {
  __$$_UserCreateManyInputCopyWithImpl(_$_UserCreateManyInput _value,
      $Res Function(_$_UserCreateManyInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserCreateManyInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserCreateManyInput implements _UserCreateManyInput {
  const _$_UserCreateManyInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson) this.createdAt});

  factory _$_UserCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserCreateManyInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final int? id;
  @override
  @JsonKey(name: 'name')
  final String name;
  @override
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  final DateTime? createdAt;

  @override
  String toString() {
    return 'UserCreateManyInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserCreateManyInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserCreateManyInputCopyWith<_$_UserCreateManyInput> get copyWith =>
      __$$_UserCreateManyInputCopyWithImpl<_$_UserCreateManyInput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserCreateManyInputToJson(
      this,
    );
  }
}

abstract class _UserCreateManyInput implements UserCreateManyInput {
  const factory _UserCreateManyInput(
      {@JsonKey(name: 'id')
          final int? id,
      @JsonKey(name: 'name')
          required final String name,
      @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
          final DateTime? createdAt}) = _$_UserCreateManyInput;

  factory _UserCreateManyInput.fromJson(Map<String, dynamic> json) =
      _$_UserCreateManyInput.fromJson;

  @override
  @JsonKey(name: 'id')
  int? get id;
  @override
  @JsonKey(name: 'name')
  String get name;
  @override
  @JsonKey(name: 'createdAt', toJson: dateTimeToJson)
  DateTime? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserCreateManyInputCopyWith<_$_UserCreateManyInput> get copyWith =>
      throw _privateConstructorUsedError;
}

UserUpdateManyMutationInput_name _$UserUpdateManyMutationInput_nameFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return UserUpdateManyMutationInput_name_withString.fromJson(json);
    case 'withStringFieldUpdateOperationsInput':
      return UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUpdateManyMutationInput_name',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUpdateManyMutationInput_name {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateManyMutationInput_name_withString value)
        withString,
    required TResult Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput_name_withString value)?
        withString,
    TResult? Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput_name_withString value)?
        withString,
    TResult Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUpdateManyMutationInput_nameCopyWith<$Res> {
  factory $UserUpdateManyMutationInput_nameCopyWith(
          UserUpdateManyMutationInput_name value,
          $Res Function(UserUpdateManyMutationInput_name) then) =
      _$UserUpdateManyMutationInput_nameCopyWithImpl<$Res,
          UserUpdateManyMutationInput_name>;
}

/// @nodoc
class _$UserUpdateManyMutationInput_nameCopyWithImpl<$Res,
        $Val extends UserUpdateManyMutationInput_name>
    implements $UserUpdateManyMutationInput_nameCopyWith<$Res> {
  _$UserUpdateManyMutationInput_nameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUpdateManyMutationInput_name_withStringCopyWith<$Res> {
  factory _$$UserUpdateManyMutationInput_name_withStringCopyWith(
          _$UserUpdateManyMutationInput_name_withString value,
          $Res Function(_$UserUpdateManyMutationInput_name_withString) then) =
      __$$UserUpdateManyMutationInput_name_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UserUpdateManyMutationInput_name_withStringCopyWithImpl<$Res>
    extends _$UserUpdateManyMutationInput_nameCopyWithImpl<$Res,
        _$UserUpdateManyMutationInput_name_withString>
    implements _$$UserUpdateManyMutationInput_name_withStringCopyWith<$Res> {
  __$$UserUpdateManyMutationInput_name_withStringCopyWithImpl(
      _$UserUpdateManyMutationInput_name_withString _value,
      $Res Function(_$UserUpdateManyMutationInput_name_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUpdateManyMutationInput_name_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateManyMutationInput_name_withString
    implements UserUpdateManyMutationInput_name_withString {
  const _$UserUpdateManyMutationInput_name_withString(this.value,
      {final String? $type})
      : $type = $type ?? 'withString';

  factory _$UserUpdateManyMutationInput_name_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateManyMutationInput_name_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateManyMutationInput_name.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUpdateManyMutationInput_name_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateManyMutationInput_name_withStringCopyWith<
          _$UserUpdateManyMutationInput_name_withString>
      get copyWith =>
          __$$UserUpdateManyMutationInput_name_withStringCopyWithImpl<
              _$UserUpdateManyMutationInput_name_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateManyMutationInput_name_withString value)
        withString,
    required TResult Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput_name_withString value)?
        withString,
    TResult? Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput_name_withString value)?
        withString,
    TResult Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateManyMutationInput_name_withStringToJson(
      this,
    );
  }
}

abstract class UserUpdateManyMutationInput_name_withString
    implements UserUpdateManyMutationInput_name {
  const factory UserUpdateManyMutationInput_name_withString(
      final String value) = _$UserUpdateManyMutationInput_name_withString;

  factory UserUpdateManyMutationInput_name_withString.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateManyMutationInput_name_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UserUpdateManyMutationInput_name_withStringCopyWith<
          _$UserUpdateManyMutationInput_name_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWith(
          _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
              value,
          $Res Function(
                  _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput)
              then) =
      __$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({StringFieldUpdateOperationsInput value});

  $StringFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUpdateManyMutationInput_nameCopyWithImpl<$Res,
        _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput>
    implements
        _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWithImpl(
      _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as StringFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StringFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $StringFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
    implements
        UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput {
  const _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withStringFieldUpdateOperationsInput';

  factory _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputFromJson(
          json);

  @override
  final StringFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateManyMutationInput_name.withStringFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUpdateManyMutationInput_name_withString value)
        withString,
    required TResult Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput_name_withString value)?
        withString,
    TResult? Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput_name_withString value)?
        withString,
    TResult Function(
            UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
    implements UserUpdateManyMutationInput_name {
  const factory UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput(
          final StringFieldUpdateOperationsInput value) =
      _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput;

  factory UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput
          .fromJson;

  @override
  StringFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUpdateManyMutationInput_name_withStringFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUpdateManyMutationInput_createdAt
    _$UserUpdateManyMutationInput_createdAtFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return UserUpdateManyMutationInput_createdAt_withDateTime.fromJson(json);
    case 'withDateTimeFieldUpdateOperationsInput':
      return UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUpdateManyMutationInput_createdAt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUpdateManyMutationInput_createdAt {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUpdateManyMutationInput_createdAtCopyWith<$Res> {
  factory $UserUpdateManyMutationInput_createdAtCopyWith(
          UserUpdateManyMutationInput_createdAt value,
          $Res Function(UserUpdateManyMutationInput_createdAt) then) =
      _$UserUpdateManyMutationInput_createdAtCopyWithImpl<$Res,
          UserUpdateManyMutationInput_createdAt>;
}

/// @nodoc
class _$UserUpdateManyMutationInput_createdAtCopyWithImpl<$Res,
        $Val extends UserUpdateManyMutationInput_createdAt>
    implements $UserUpdateManyMutationInput_createdAtCopyWith<$Res> {
  _$UserUpdateManyMutationInput_createdAtCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWith<
    $Res> {
  factory _$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWith(
          _$UserUpdateManyMutationInput_createdAt_withDateTime value,
          $Res Function(_$UserUpdateManyMutationInput_createdAt_withDateTime)
              then) =
      __$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWithImpl<$Res>
    extends _$UserUpdateManyMutationInput_createdAtCopyWithImpl<$Res,
        _$UserUpdateManyMutationInput_createdAt_withDateTime>
    implements
        _$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWith<$Res> {
  __$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWithImpl(
      _$UserUpdateManyMutationInput_createdAt_withDateTime _value,
      $Res Function(_$UserUpdateManyMutationInput_createdAt_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUpdateManyMutationInput_createdAt_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateManyMutationInput_createdAt_withDateTime
    implements UserUpdateManyMutationInput_createdAt_withDateTime {
  const _$UserUpdateManyMutationInput_createdAt_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$UserUpdateManyMutationInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateManyMutationInput_createdAt_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateManyMutationInput_createdAt.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUpdateManyMutationInput_createdAt_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWith<
          _$UserUpdateManyMutationInput_createdAt_withDateTime>
      get copyWith =>
          __$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWithImpl<
                  _$UserUpdateManyMutationInput_createdAt_withDateTime>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateManyMutationInput_createdAt_withDateTimeToJson(
      this,
    );
  }
}

abstract class UserUpdateManyMutationInput_createdAt_withDateTime
    implements UserUpdateManyMutationInput_createdAt {
  const factory UserUpdateManyMutationInput_createdAt_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$UserUpdateManyMutationInput_createdAt_withDateTime;

  factory UserUpdateManyMutationInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateManyMutationInput_createdAt_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$UserUpdateManyMutationInput_createdAt_withDateTimeCopyWith<
          _$UserUpdateManyMutationInput_createdAt_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith(
          _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
              value,
          $Res Function(
                  _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput)
              then) =
      __$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DateTimeFieldUpdateOperationsInput value});

  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUpdateManyMutationInput_createdAtCopyWithImpl<$Res,
        _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput>
    implements
        _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl(
      _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTimeFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $DateTimeFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements
        UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput {
  const _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTimeFieldUpdateOperationsInput';

  factory _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputFromJson(
          json);

  @override
  final DateTimeFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUpdateManyMutationInput_createdAt.withDateTimeFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements UserUpdateManyMutationInput_createdAt {
  const factory UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput(
          final DateTimeFieldUpdateOperationsInput value) =
      _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput;

  factory UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson;

  @override
  DateTimeFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUpdateManyMutationInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUpdateManyMutationInput _$UserUpdateManyMutationInputFromJson(
    Map<String, dynamic> json) {
  return _UserUpdateManyMutationInput.fromJson(json);
}

/// @nodoc
mixin _$UserUpdateManyMutationInput {
  @JsonKey(name: 'name')
  UserUpdateManyMutationInput_name? get name =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  UserUpdateManyMutationInput_createdAt? get createdAt =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserUpdateManyMutationInputCopyWith<UserUpdateManyMutationInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUpdateManyMutationInputCopyWith<$Res> {
  factory $UserUpdateManyMutationInputCopyWith(
          UserUpdateManyMutationInput value,
          $Res Function(UserUpdateManyMutationInput) then) =
      _$UserUpdateManyMutationInputCopyWithImpl<$Res,
          UserUpdateManyMutationInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'name')
          UserUpdateManyMutationInput_name? name,
      @JsonKey(name: 'createdAt')
          UserUpdateManyMutationInput_createdAt? createdAt});

  $UserUpdateManyMutationInput_nameCopyWith<$Res>? get name;
  $UserUpdateManyMutationInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class _$UserUpdateManyMutationInputCopyWithImpl<$Res,
        $Val extends UserUpdateManyMutationInput>
    implements $UserUpdateManyMutationInputCopyWith<$Res> {
  _$UserUpdateManyMutationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUpdateManyMutationInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUpdateManyMutationInput_createdAt?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateManyMutationInput_nameCopyWith<$Res>? get name {
    if (_value.name == null) {
      return null;
    }

    return $UserUpdateManyMutationInput_nameCopyWith<$Res>(_value.name!,
        (value) {
      return _then(_value.copyWith(name: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateManyMutationInput_createdAtCopyWith<$Res>? get createdAt {
    if (_value.createdAt == null) {
      return null;
    }

    return $UserUpdateManyMutationInput_createdAtCopyWith<$Res>(
        _value.createdAt!, (value) {
      return _then(_value.copyWith(createdAt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserUpdateManyMutationInputCopyWith<$Res>
    implements $UserUpdateManyMutationInputCopyWith<$Res> {
  factory _$$_UserUpdateManyMutationInputCopyWith(
          _$_UserUpdateManyMutationInput value,
          $Res Function(_$_UserUpdateManyMutationInput) then) =
      __$$_UserUpdateManyMutationInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name')
          UserUpdateManyMutationInput_name? name,
      @JsonKey(name: 'createdAt')
          UserUpdateManyMutationInput_createdAt? createdAt});

  @override
  $UserUpdateManyMutationInput_nameCopyWith<$Res>? get name;
  @override
  $UserUpdateManyMutationInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class __$$_UserUpdateManyMutationInputCopyWithImpl<$Res>
    extends _$UserUpdateManyMutationInputCopyWithImpl<$Res,
        _$_UserUpdateManyMutationInput>
    implements _$$_UserUpdateManyMutationInputCopyWith<$Res> {
  __$$_UserUpdateManyMutationInputCopyWithImpl(
      _$_UserUpdateManyMutationInput _value,
      $Res Function(_$_UserUpdateManyMutationInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserUpdateManyMutationInput(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUpdateManyMutationInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUpdateManyMutationInput_createdAt?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserUpdateManyMutationInput implements _UserUpdateManyMutationInput {
  const _$_UserUpdateManyMutationInput(
      {@JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserUpdateManyMutationInputFromJson(json);

  @override
  @JsonKey(name: 'name')
  final UserUpdateManyMutationInput_name? name;
  @override
  @JsonKey(name: 'createdAt')
  final UserUpdateManyMutationInput_createdAt? createdAt;

  @override
  String toString() {
    return 'UserUpdateManyMutationInput(name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserUpdateManyMutationInput &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserUpdateManyMutationInputCopyWith<_$_UserUpdateManyMutationInput>
      get copyWith => __$$_UserUpdateManyMutationInputCopyWithImpl<
          _$_UserUpdateManyMutationInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserUpdateManyMutationInputToJson(
      this,
    );
  }
}

abstract class _UserUpdateManyMutationInput
    implements UserUpdateManyMutationInput {
  const factory _UserUpdateManyMutationInput(
          {@JsonKey(name: 'name')
              final UserUpdateManyMutationInput_name? name,
          @JsonKey(name: 'createdAt')
              final UserUpdateManyMutationInput_createdAt? createdAt}) =
      _$_UserUpdateManyMutationInput;

  factory _UserUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =
      _$_UserUpdateManyMutationInput.fromJson;

  @override
  @JsonKey(name: 'name')
  UserUpdateManyMutationInput_name? get name;
  @override
  @JsonKey(name: 'createdAt')
  UserUpdateManyMutationInput_createdAt? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserUpdateManyMutationInputCopyWith<_$_UserUpdateManyMutationInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateManyInput_id _$UserUncheckedUpdateManyInput_idFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withInt':
      return UserUncheckedUpdateManyInput_id_withInt.fromJson(json);
    case 'withIntFieldUpdateOperationsInput':
      return UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUncheckedUpdateManyInput_id',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUncheckedUpdateManyInput_id {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(IntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateManyInput_id_withInt value)
        withInt,
    required TResult Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateManyInput_id_withInt value)? withInt,
    TResult? Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_id_withInt value)? withInt,
    TResult Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateManyInput_idCopyWith<$Res> {
  factory $UserUncheckedUpdateManyInput_idCopyWith(
          UserUncheckedUpdateManyInput_id value,
          $Res Function(UserUncheckedUpdateManyInput_id) then) =
      _$UserUncheckedUpdateManyInput_idCopyWithImpl<$Res,
          UserUncheckedUpdateManyInput_id>;
}

/// @nodoc
class _$UserUncheckedUpdateManyInput_idCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateManyInput_id>
    implements $UserUncheckedUpdateManyInput_idCopyWith<$Res> {
  _$UserUncheckedUpdateManyInput_idCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateManyInput_id_withIntCopyWith<$Res> {
  factory _$$UserUncheckedUpdateManyInput_id_withIntCopyWith(
          _$UserUncheckedUpdateManyInput_id_withInt value,
          $Res Function(_$UserUncheckedUpdateManyInput_id_withInt) then) =
      __$$UserUncheckedUpdateManyInput_id_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$UserUncheckedUpdateManyInput_id_withIntCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateManyInput_idCopyWithImpl<$Res,
        _$UserUncheckedUpdateManyInput_id_withInt>
    implements _$$UserUncheckedUpdateManyInput_id_withIntCopyWith<$Res> {
  __$$UserUncheckedUpdateManyInput_id_withIntCopyWithImpl(
      _$UserUncheckedUpdateManyInput_id_withInt _value,
      $Res Function(_$UserUncheckedUpdateManyInput_id_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUncheckedUpdateManyInput_id_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateManyInput_id_withInt
    implements UserUncheckedUpdateManyInput_id_withInt {
  const _$UserUncheckedUpdateManyInput_id_withInt(this.value,
      {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$UserUncheckedUpdateManyInput_id_withInt.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateManyInput_id_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput_id.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUncheckedUpdateManyInput_id_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateManyInput_id_withIntCopyWith<
          _$UserUncheckedUpdateManyInput_id_withInt>
      get copyWith => __$$UserUncheckedUpdateManyInput_id_withIntCopyWithImpl<
          _$UserUncheckedUpdateManyInput_id_withInt>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(IntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateManyInput_id_withInt value)
        withInt,
    required TResult Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateManyInput_id_withInt value)? withInt,
    TResult? Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_id_withInt value)? withInt,
    TResult Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateManyInput_id_withIntToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateManyInput_id_withInt
    implements UserUncheckedUpdateManyInput_id {
  const factory UserUncheckedUpdateManyInput_id_withInt(final int value) =
      _$UserUncheckedUpdateManyInput_id_withInt;

  factory UserUncheckedUpdateManyInput_id_withInt.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateManyInput_id_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateManyInput_id_withIntCopyWith<
          _$UserUncheckedUpdateManyInput_id_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWith(
          _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput value,
          $Res Function(
                  _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput)
              then) =
      __$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({IntFieldUpdateOperationsInput value});

  $IntFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUncheckedUpdateManyInput_idCopyWithImpl<$Res,
        _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput>
    implements
        _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWithImpl(
      _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as IntFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $IntFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $IntFieldUpdateOperationsInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
    implements
        UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput {
  const _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withIntFieldUpdateOperationsInput';

  factory _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputFromJson(
          json);

  @override
  final IntFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput_id.withIntFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(IntFieldUpdateOperationsInput value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(IntFieldUpdateOperationsInput value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withIntFieldUpdateOperationsInput != null) {
      return withIntFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserUncheckedUpdateManyInput_id_withInt value)
        withInt,
    required TResult Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateManyInput_id_withInt value)? withInt,
    TResult? Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
  }) {
    return withIntFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_id_withInt value)? withInt,
    TResult Function(
            UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
                value)?
        withIntFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withIntFieldUpdateOperationsInput != null) {
      return withIntFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
    implements UserUncheckedUpdateManyInput_id {
  const factory UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput(
          final IntFieldUpdateOperationsInput value) =
      _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput;

  factory UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput
          .fromJson;

  @override
  IntFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateManyInput_id_withIntFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateManyInput_name _$UserUncheckedUpdateManyInput_nameFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return UserUncheckedUpdateManyInput_name_withString.fromJson(json);
    case 'withStringFieldUpdateOperationsInput':
      return UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUncheckedUpdateManyInput_name',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUncheckedUpdateManyInput_name {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateManyInput_name_withString value)
        withString,
    required TResult Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateManyInput_name_withString value)?
        withString,
    TResult? Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_name_withString value)?
        withString,
    TResult Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateManyInput_nameCopyWith<$Res> {
  factory $UserUncheckedUpdateManyInput_nameCopyWith(
          UserUncheckedUpdateManyInput_name value,
          $Res Function(UserUncheckedUpdateManyInput_name) then) =
      _$UserUncheckedUpdateManyInput_nameCopyWithImpl<$Res,
          UserUncheckedUpdateManyInput_name>;
}

/// @nodoc
class _$UserUncheckedUpdateManyInput_nameCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateManyInput_name>
    implements $UserUncheckedUpdateManyInput_nameCopyWith<$Res> {
  _$UserUncheckedUpdateManyInput_nameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateManyInput_name_withStringCopyWith<$Res> {
  factory _$$UserUncheckedUpdateManyInput_name_withStringCopyWith(
          _$UserUncheckedUpdateManyInput_name_withString value,
          $Res Function(_$UserUncheckedUpdateManyInput_name_withString) then) =
      __$$UserUncheckedUpdateManyInput_name_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$UserUncheckedUpdateManyInput_name_withStringCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateManyInput_nameCopyWithImpl<$Res,
        _$UserUncheckedUpdateManyInput_name_withString>
    implements _$$UserUncheckedUpdateManyInput_name_withStringCopyWith<$Res> {
  __$$UserUncheckedUpdateManyInput_name_withStringCopyWithImpl(
      _$UserUncheckedUpdateManyInput_name_withString _value,
      $Res Function(_$UserUncheckedUpdateManyInput_name_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUncheckedUpdateManyInput_name_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateManyInput_name_withString
    implements UserUncheckedUpdateManyInput_name_withString {
  const _$UserUncheckedUpdateManyInput_name_withString(this.value,
      {final String? $type})
      : $type = $type ?? 'withString';

  factory _$UserUncheckedUpdateManyInput_name_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateManyInput_name_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput_name.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUncheckedUpdateManyInput_name_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateManyInput_name_withStringCopyWith<
          _$UserUncheckedUpdateManyInput_name_withString>
      get copyWith =>
          __$$UserUncheckedUpdateManyInput_name_withStringCopyWithImpl<
              _$UserUncheckedUpdateManyInput_name_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateManyInput_name_withString value)
        withString,
    required TResult Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateManyInput_name_withString value)?
        withString,
    TResult? Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_name_withString value)?
        withString,
    TResult Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateManyInput_name_withStringToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateManyInput_name_withString
    implements UserUncheckedUpdateManyInput_name {
  const factory UserUncheckedUpdateManyInput_name_withString(
      final String value) = _$UserUncheckedUpdateManyInput_name_withString;

  factory UserUncheckedUpdateManyInput_name_withString.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateManyInput_name_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateManyInput_name_withStringCopyWith<
          _$UserUncheckedUpdateManyInput_name_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWith(
          _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
              value,
          $Res Function(
                  _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput)
              then) =
      __$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({StringFieldUpdateOperationsInput value});

  $StringFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUncheckedUpdateManyInput_nameCopyWithImpl<$Res,
        _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput>
    implements
        _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWithImpl(
      _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as StringFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $StringFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $StringFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
    implements
        UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput {
  const _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withStringFieldUpdateOperationsInput';

  factory _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputFromJson(
          json);

  @override
  final StringFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput_name.withStringFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(StringFieldUpdateOperationsInput value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(StringFieldUpdateOperationsInput value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateManyInput_name_withString value)
        withString,
    required TResult Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserUncheckedUpdateManyInput_name_withString value)?
        withString,
    TResult? Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
  }) {
    return withStringFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_name_withString value)?
        withString,
    TResult Function(
            UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
                value)?
        withStringFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withStringFieldUpdateOperationsInput != null) {
      return withStringFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
    implements UserUncheckedUpdateManyInput_name {
  const factory UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput(
          final StringFieldUpdateOperationsInput value) =
      _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput;

  factory UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput
          .fromJson;

  @override
  StringFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateManyInput_name_withStringFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateManyInput_createdAt
    _$UserUncheckedUpdateManyInput_createdAtFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return UserUncheckedUpdateManyInput_createdAt_withDateTime.fromJson(json);
    case 'withDateTimeFieldUpdateOperationsInput':
      return UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'UserUncheckedUpdateManyInput_createdAt',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UserUncheckedUpdateManyInput_createdAt {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateManyInput_createdAtCopyWith<$Res> {
  factory $UserUncheckedUpdateManyInput_createdAtCopyWith(
          UserUncheckedUpdateManyInput_createdAt value,
          $Res Function(UserUncheckedUpdateManyInput_createdAt) then) =
      _$UserUncheckedUpdateManyInput_createdAtCopyWithImpl<$Res,
          UserUncheckedUpdateManyInput_createdAt>;
}

/// @nodoc
class _$UserUncheckedUpdateManyInput_createdAtCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateManyInput_createdAt>
    implements $UserUncheckedUpdateManyInput_createdAtCopyWith<$Res> {
  _$UserUncheckedUpdateManyInput_createdAtCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWith(
          _$UserUncheckedUpdateManyInput_createdAt_withDateTime value,
          $Res Function(_$UserUncheckedUpdateManyInput_createdAt_withDateTime)
              then) =
      __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateManyInput_createdAtCopyWithImpl<$Res,
        _$UserUncheckedUpdateManyInput_createdAt_withDateTime>
    implements
        _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWith<$Res> {
  __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWithImpl(
      _$UserUncheckedUpdateManyInput_createdAt_withDateTime _value,
      $Res Function(_$UserUncheckedUpdateManyInput_createdAt_withDateTime)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UserUncheckedUpdateManyInput_createdAt_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateManyInput_createdAt_withDateTime
    implements UserUncheckedUpdateManyInput_createdAt_withDateTime {
  const _$UserUncheckedUpdateManyInput_createdAt_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$UserUncheckedUpdateManyInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput_createdAt.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserUncheckedUpdateManyInput_createdAt_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWith<
          _$UserUncheckedUpdateManyInput_createdAt_withDateTime>
      get copyWith =>
          __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWithImpl<
                  _$UserUncheckedUpdateManyInput_createdAt_withDateTime>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateManyInput_createdAt_withDateTime
    implements UserUncheckedUpdateManyInput_createdAt {
  const factory UserUncheckedUpdateManyInput_createdAt_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$UserUncheckedUpdateManyInput_createdAt_withDateTime;

  factory UserUncheckedUpdateManyInput_createdAt_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateManyInput_createdAt_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeCopyWith<
          _$UserUncheckedUpdateManyInput_createdAt_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
    $Res> {
  factory _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith(
          _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
              value,
          $Res Function(
                  _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput)
              then) =
      __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({DateTimeFieldUpdateOperationsInput value});

  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
        $Res>
    extends _$UserUncheckedUpdateManyInput_createdAtCopyWithImpl<$Res,
        _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput>
    implements
        _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
            $Res> {
  __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl(
      _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
          _value,
      $Res Function(
              _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTimeFieldUpdateOperationsInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeFieldUpdateOperationsInputCopyWith<$Res> get value {
    return $DateTimeFieldUpdateOperationsInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements
        UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput {
  const _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTimeFieldUpdateOperationsInput';

  factory _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputFromJson(
          json);

  @override
  final DateTimeFieldUpdateOperationsInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput_createdAt.withDateTimeFieldUpdateOperationsInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith =>
          __$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWithImpl<
                  _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(DateTimeFieldUpdateOperationsInput value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(DateTimeFieldUpdateOperationsInput value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTime value)
        withDateTime,
    required TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTime value)?
        withDateTime,
    TResult? Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
  }) {
    return withDateTimeFieldUpdateOperationsInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserUncheckedUpdateManyInput_createdAt_withDateTime value)?
        withDateTime,
    TResult Function(
            UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
                value)?
        withDateTimeFieldUpdateOperationsInput,
    required TResult orElse(),
  }) {
    if (withDateTimeFieldUpdateOperationsInput != null) {
      return withDateTimeFieldUpdateOperationsInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
    implements UserUncheckedUpdateManyInput_createdAt {
  const factory UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput(
          final DateTimeFieldUpdateOperationsInput value) =
      _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput;

  factory UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput
          .fromJson;

  @override
  DateTimeFieldUpdateOperationsInput get value;
  @JsonKey(ignore: true)
  _$$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInputCopyWith<
          _$UserUncheckedUpdateManyInput_createdAt_withDateTimeFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserUncheckedUpdateManyInput _$UserUncheckedUpdateManyInputFromJson(
    Map<String, dynamic> json) {
  return _UserUncheckedUpdateManyInput.fromJson(json);
}

/// @nodoc
mixin _$UserUncheckedUpdateManyInput {
  @JsonKey(name: 'id')
  UserUncheckedUpdateManyInput_id? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  UserUncheckedUpdateManyInput_name? get name =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  UserUncheckedUpdateManyInput_createdAt? get createdAt =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserUncheckedUpdateManyInputCopyWith<UserUncheckedUpdateManyInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserUncheckedUpdateManyInputCopyWith<$Res> {
  factory $UserUncheckedUpdateManyInputCopyWith(
          UserUncheckedUpdateManyInput value,
          $Res Function(UserUncheckedUpdateManyInput) then) =
      _$UserUncheckedUpdateManyInputCopyWithImpl<$Res,
          UserUncheckedUpdateManyInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id')
          UserUncheckedUpdateManyInput_id? id,
      @JsonKey(name: 'name')
          UserUncheckedUpdateManyInput_name? name,
      @JsonKey(name: 'createdAt')
          UserUncheckedUpdateManyInput_createdAt? createdAt});

  $UserUncheckedUpdateManyInput_idCopyWith<$Res>? get id;
  $UserUncheckedUpdateManyInput_nameCopyWith<$Res>? get name;
  $UserUncheckedUpdateManyInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class _$UserUncheckedUpdateManyInputCopyWithImpl<$Res,
        $Val extends UserUncheckedUpdateManyInput>
    implements $UserUncheckedUpdateManyInputCopyWith<$Res> {
  _$UserUncheckedUpdateManyInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput_createdAt?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateManyInput_idCopyWith<$Res>? get id {
    if (_value.id == null) {
      return null;
    }

    return $UserUncheckedUpdateManyInput_idCopyWith<$Res>(_value.id!, (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateManyInput_nameCopyWith<$Res>? get name {
    if (_value.name == null) {
      return null;
    }

    return $UserUncheckedUpdateManyInput_nameCopyWith<$Res>(_value.name!,
        (value) {
      return _then(_value.copyWith(name: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateManyInput_createdAtCopyWith<$Res>? get createdAt {
    if (_value.createdAt == null) {
      return null;
    }

    return $UserUncheckedUpdateManyInput_createdAtCopyWith<$Res>(
        _value.createdAt!, (value) {
      return _then(_value.copyWith(createdAt: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserUncheckedUpdateManyInputCopyWith<$Res>
    implements $UserUncheckedUpdateManyInputCopyWith<$Res> {
  factory _$$_UserUncheckedUpdateManyInputCopyWith(
          _$_UserUncheckedUpdateManyInput value,
          $Res Function(_$_UserUncheckedUpdateManyInput) then) =
      __$$_UserUncheckedUpdateManyInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id')
          UserUncheckedUpdateManyInput_id? id,
      @JsonKey(name: 'name')
          UserUncheckedUpdateManyInput_name? name,
      @JsonKey(name: 'createdAt')
          UserUncheckedUpdateManyInput_createdAt? createdAt});

  @override
  $UserUncheckedUpdateManyInput_idCopyWith<$Res>? get id;
  @override
  $UserUncheckedUpdateManyInput_nameCopyWith<$Res>? get name;
  @override
  $UserUncheckedUpdateManyInput_createdAtCopyWith<$Res>? get createdAt;
}

/// @nodoc
class __$$_UserUncheckedUpdateManyInputCopyWithImpl<$Res>
    extends _$UserUncheckedUpdateManyInputCopyWithImpl<$Res,
        _$_UserUncheckedUpdateManyInput>
    implements _$$_UserUncheckedUpdateManyInputCopyWith<$Res> {
  __$$_UserUncheckedUpdateManyInputCopyWithImpl(
      _$_UserUncheckedUpdateManyInput _value,
      $Res Function(_$_UserUncheckedUpdateManyInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserUncheckedUpdateManyInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput_id?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput_name?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput_createdAt?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserUncheckedUpdateManyInput implements _UserUncheckedUpdateManyInput {
  const _$_UserUncheckedUpdateManyInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserUncheckedUpdateManyInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final UserUncheckedUpdateManyInput_id? id;
  @override
  @JsonKey(name: 'name')
  final UserUncheckedUpdateManyInput_name? name;
  @override
  @JsonKey(name: 'createdAt')
  final UserUncheckedUpdateManyInput_createdAt? createdAt;

  @override
  String toString() {
    return 'UserUncheckedUpdateManyInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserUncheckedUpdateManyInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserUncheckedUpdateManyInputCopyWith<_$_UserUncheckedUpdateManyInput>
      get copyWith => __$$_UserUncheckedUpdateManyInputCopyWithImpl<
          _$_UserUncheckedUpdateManyInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserUncheckedUpdateManyInputToJson(
      this,
    );
  }
}

abstract class _UserUncheckedUpdateManyInput
    implements UserUncheckedUpdateManyInput {
  const factory _UserUncheckedUpdateManyInput(
          {@JsonKey(name: 'id')
              final UserUncheckedUpdateManyInput_id? id,
          @JsonKey(name: 'name')
              final UserUncheckedUpdateManyInput_name? name,
          @JsonKey(name: 'createdAt')
              final UserUncheckedUpdateManyInput_createdAt? createdAt}) =
      _$_UserUncheckedUpdateManyInput;

  factory _UserUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =
      _$_UserUncheckedUpdateManyInput.fromJson;

  @override
  @JsonKey(name: 'id')
  UserUncheckedUpdateManyInput_id? get id;
  @override
  @JsonKey(name: 'name')
  UserUncheckedUpdateManyInput_name? get name;
  @override
  @JsonKey(name: 'createdAt')
  UserUncheckedUpdateManyInput_createdAt? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserUncheckedUpdateManyInputCopyWith<_$_UserUncheckedUpdateManyInput>
      get copyWith => throw _privateConstructorUsedError;
}

IntFilter_not _$IntFilter_notFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withInt':
      return IntFilter_not_withInt.fromJson(json);
    case 'withNestedIntFilter':
      return IntFilter_not_withNestedIntFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'IntFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$IntFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntFilter value) withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntFilter value)? withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntFilter value)? withNestedIntFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntFilter_not_withInt value) withInt,
    required TResult Function(IntFilter_not_withNestedIntFilter value)
        withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntFilter_not_withInt value)? withInt,
    TResult? Function(IntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntFilter_not_withInt value)? withInt,
    TResult Function(IntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntFilter_notCopyWith<$Res> {
  factory $IntFilter_notCopyWith(
          IntFilter_not value, $Res Function(IntFilter_not) then) =
      _$IntFilter_notCopyWithImpl<$Res, IntFilter_not>;
}

/// @nodoc
class _$IntFilter_notCopyWithImpl<$Res, $Val extends IntFilter_not>
    implements $IntFilter_notCopyWith<$Res> {
  _$IntFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$IntFilter_not_withIntCopyWith<$Res> {
  factory _$$IntFilter_not_withIntCopyWith(_$IntFilter_not_withInt value,
          $Res Function(_$IntFilter_not_withInt) then) =
      __$$IntFilter_not_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IntFilter_not_withIntCopyWithImpl<$Res>
    extends _$IntFilter_notCopyWithImpl<$Res, _$IntFilter_not_withInt>
    implements _$$IntFilter_not_withIntCopyWith<$Res> {
  __$$IntFilter_not_withIntCopyWithImpl(_$IntFilter_not_withInt _value,
      $Res Function(_$IntFilter_not_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IntFilter_not_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IntFilter_not_withInt implements IntFilter_not_withInt {
  const _$IntFilter_not_withInt(this.value, {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$IntFilter_not_withInt.fromJson(Map<String, dynamic> json) =>
      _$$IntFilter_not_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntFilter_not.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IntFilter_not_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IntFilter_not_withIntCopyWith<_$IntFilter_not_withInt> get copyWith =>
      __$$IntFilter_not_withIntCopyWithImpl<_$IntFilter_not_withInt>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntFilter value) withNestedIntFilter,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntFilter value)? withNestedIntFilter,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntFilter value)? withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntFilter_not_withInt value) withInt,
    required TResult Function(IntFilter_not_withNestedIntFilter value)
        withNestedIntFilter,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntFilter_not_withInt value)? withInt,
    TResult? Function(IntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntFilter_not_withInt value)? withInt,
    TResult Function(IntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IntFilter_not_withIntToJson(
      this,
    );
  }
}

abstract class IntFilter_not_withInt implements IntFilter_not {
  const factory IntFilter_not_withInt(final int value) =
      _$IntFilter_not_withInt;

  factory IntFilter_not_withInt.fromJson(Map<String, dynamic> json) =
      _$IntFilter_not_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$IntFilter_not_withIntCopyWith<_$IntFilter_not_withInt> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IntFilter_not_withNestedIntFilterCopyWith<$Res> {
  factory _$$IntFilter_not_withNestedIntFilterCopyWith(
          _$IntFilter_not_withNestedIntFilter value,
          $Res Function(_$IntFilter_not_withNestedIntFilter) then) =
      __$$IntFilter_not_withNestedIntFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedIntFilter value});

  $NestedIntFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$IntFilter_not_withNestedIntFilterCopyWithImpl<$Res>
    extends _$IntFilter_notCopyWithImpl<$Res,
        _$IntFilter_not_withNestedIntFilter>
    implements _$$IntFilter_not_withNestedIntFilterCopyWith<$Res> {
  __$$IntFilter_not_withNestedIntFilterCopyWithImpl(
      _$IntFilter_not_withNestedIntFilter _value,
      $Res Function(_$IntFilter_not_withNestedIntFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IntFilter_not_withNestedIntFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res> get value {
    return $NestedIntFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$IntFilter_not_withNestedIntFilter
    implements IntFilter_not_withNestedIntFilter {
  const _$IntFilter_not_withNestedIntFilter(this.value, {final String? $type})
      : $type = $type ?? 'withNestedIntFilter';

  factory _$IntFilter_not_withNestedIntFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$IntFilter_not_withNestedIntFilterFromJson(json);

  @override
  final NestedIntFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntFilter_not.withNestedIntFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IntFilter_not_withNestedIntFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IntFilter_not_withNestedIntFilterCopyWith<
          _$IntFilter_not_withNestedIntFilter>
      get copyWith => __$$IntFilter_not_withNestedIntFilterCopyWithImpl<
          _$IntFilter_not_withNestedIntFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntFilter value) withNestedIntFilter,
  }) {
    return withNestedIntFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntFilter value)? withNestedIntFilter,
  }) {
    return withNestedIntFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntFilter value)? withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntFilter != null) {
      return withNestedIntFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntFilter_not_withInt value) withInt,
    required TResult Function(IntFilter_not_withNestedIntFilter value)
        withNestedIntFilter,
  }) {
    return withNestedIntFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntFilter_not_withInt value)? withInt,
    TResult? Function(IntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
  }) {
    return withNestedIntFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntFilter_not_withInt value)? withInt,
    TResult Function(IntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntFilter != null) {
      return withNestedIntFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IntFilter_not_withNestedIntFilterToJson(
      this,
    );
  }
}

abstract class IntFilter_not_withNestedIntFilter implements IntFilter_not {
  const factory IntFilter_not_withNestedIntFilter(final NestedIntFilter value) =
      _$IntFilter_not_withNestedIntFilter;

  factory IntFilter_not_withNestedIntFilter.fromJson(
      Map<String, dynamic> json) = _$IntFilter_not_withNestedIntFilter.fromJson;

  @override
  NestedIntFilter get value;
  @JsonKey(ignore: true)
  _$$IntFilter_not_withNestedIntFilterCopyWith<
          _$IntFilter_not_withNestedIntFilter>
      get copyWith => throw _privateConstructorUsedError;
}

IntFilter _$IntFilterFromJson(Map<String, dynamic> json) {
  return _IntFilter.fromJson(json);
}

/// @nodoc
mixin _$IntFilter {
  @JsonKey(name: 'equals')
  int? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<int>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<int>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  int? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  int? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  int? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  int? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  IntFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IntFilterCopyWith<IntFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntFilterCopyWith<$Res> {
  factory $IntFilterCopyWith(IntFilter value, $Res Function(IntFilter) then) =
      _$IntFilterCopyWithImpl<$Res, IntFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') IntFilter_not? not});

  $IntFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$IntFilterCopyWithImpl<$Res, $Val extends IntFilter>
    implements $IntFilterCopyWith<$Res> {
  _$IntFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as IntFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IntFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $IntFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IntFilterCopyWith<$Res> implements $IntFilterCopyWith<$Res> {
  factory _$$_IntFilterCopyWith(
          _$_IntFilter value, $Res Function(_$_IntFilter) then) =
      __$$_IntFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') IntFilter_not? not});

  @override
  $IntFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_IntFilterCopyWithImpl<$Res>
    extends _$IntFilterCopyWithImpl<$Res, _$_IntFilter>
    implements _$$_IntFilterCopyWith<$Res> {
  __$$_IntFilterCopyWithImpl(
      _$_IntFilter _value, $Res Function(_$_IntFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_IntFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as IntFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IntFilter implements _IntFilter {
  const _$_IntFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<int>? dart__in,
      @JsonKey(name: 'notIn') final List<int>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'not') this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_IntFilter.fromJson(Map<String, dynamic> json) =>
      _$$_IntFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final int? equals;
  final List<int>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final int? lt;
  @override
  @JsonKey(name: 'lte')
  final int? lte;
  @override
  @JsonKey(name: 'gt')
  final int? gt;
  @override
  @JsonKey(name: 'gte')
  final int? gte;
  @override
  @JsonKey(name: 'not')
  final IntFilter_not? not;

  @override
  String toString() {
    return 'IntFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntFilterCopyWith<_$_IntFilter> get copyWith =>
      __$$_IntFilterCopyWithImpl<_$_IntFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IntFilterToJson(
      this,
    );
  }
}

abstract class _IntFilter implements IntFilter {
  const factory _IntFilter(
      {@JsonKey(name: 'equals') final int? equals,
      @JsonKey(name: 'in') final List<int>? dart__in,
      @JsonKey(name: 'notIn') final List<int>? notIn,
      @JsonKey(name: 'lt') final int? lt,
      @JsonKey(name: 'lte') final int? lte,
      @JsonKey(name: 'gt') final int? gt,
      @JsonKey(name: 'gte') final int? gte,
      @JsonKey(name: 'not') final IntFilter_not? not}) = _$_IntFilter;

  factory _IntFilter.fromJson(Map<String, dynamic> json) =
      _$_IntFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  int? get equals;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn;
  @override
  @JsonKey(name: 'lt')
  int? get lt;
  @override
  @JsonKey(name: 'lte')
  int? get lte;
  @override
  @JsonKey(name: 'gt')
  int? get gt;
  @override
  @JsonKey(name: 'gte')
  int? get gte;
  @override
  @JsonKey(name: 'not')
  IntFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_IntFilterCopyWith<_$_IntFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

StringFilter_not _$StringFilter_notFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return StringFilter_not_withString.fromJson(json);
    case 'withNestedStringFilter':
      return StringFilter_not_withNestedStringFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'StringFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$StringFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringFilter value) withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringFilter value)? withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringFilter value)? withNestedStringFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StringFilter_not_withString value) withString,
    required TResult Function(StringFilter_not_withNestedStringFilter value)
        withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StringFilter_not_withString value)? withString,
    TResult? Function(StringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StringFilter_not_withString value)? withString,
    TResult Function(StringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringFilter_notCopyWith<$Res> {
  factory $StringFilter_notCopyWith(
          StringFilter_not value, $Res Function(StringFilter_not) then) =
      _$StringFilter_notCopyWithImpl<$Res, StringFilter_not>;
}

/// @nodoc
class _$StringFilter_notCopyWithImpl<$Res, $Val extends StringFilter_not>
    implements $StringFilter_notCopyWith<$Res> {
  _$StringFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StringFilter_not_withStringCopyWith<$Res> {
  factory _$$StringFilter_not_withStringCopyWith(
          _$StringFilter_not_withString value,
          $Res Function(_$StringFilter_not_withString) then) =
      __$$StringFilter_not_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$StringFilter_not_withStringCopyWithImpl<$Res>
    extends _$StringFilter_notCopyWithImpl<$Res, _$StringFilter_not_withString>
    implements _$$StringFilter_not_withStringCopyWith<$Res> {
  __$$StringFilter_not_withStringCopyWithImpl(
      _$StringFilter_not_withString _value,
      $Res Function(_$StringFilter_not_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$StringFilter_not_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StringFilter_not_withString implements StringFilter_not_withString {
  const _$StringFilter_not_withString(this.value, {final String? $type})
      : $type = $type ?? 'withString';

  factory _$StringFilter_not_withString.fromJson(Map<String, dynamic> json) =>
      _$$StringFilter_not_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'StringFilter_not.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StringFilter_not_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StringFilter_not_withStringCopyWith<_$StringFilter_not_withString>
      get copyWith => __$$StringFilter_not_withStringCopyWithImpl<
          _$StringFilter_not_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringFilter value) withNestedStringFilter,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringFilter value)? withNestedStringFilter,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringFilter value)? withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StringFilter_not_withString value) withString,
    required TResult Function(StringFilter_not_withNestedStringFilter value)
        withNestedStringFilter,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StringFilter_not_withString value)? withString,
    TResult? Function(StringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StringFilter_not_withString value)? withString,
    TResult Function(StringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StringFilter_not_withStringToJson(
      this,
    );
  }
}

abstract class StringFilter_not_withString implements StringFilter_not {
  const factory StringFilter_not_withString(final String value) =
      _$StringFilter_not_withString;

  factory StringFilter_not_withString.fromJson(Map<String, dynamic> json) =
      _$StringFilter_not_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$StringFilter_not_withStringCopyWith<_$StringFilter_not_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StringFilter_not_withNestedStringFilterCopyWith<$Res> {
  factory _$$StringFilter_not_withNestedStringFilterCopyWith(
          _$StringFilter_not_withNestedStringFilter value,
          $Res Function(_$StringFilter_not_withNestedStringFilter) then) =
      __$$StringFilter_not_withNestedStringFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedStringFilter value});

  $NestedStringFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$StringFilter_not_withNestedStringFilterCopyWithImpl<$Res>
    extends _$StringFilter_notCopyWithImpl<$Res,
        _$StringFilter_not_withNestedStringFilter>
    implements _$$StringFilter_not_withNestedStringFilterCopyWith<$Res> {
  __$$StringFilter_not_withNestedStringFilterCopyWithImpl(
      _$StringFilter_not_withNestedStringFilter _value,
      $Res Function(_$StringFilter_not_withNestedStringFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$StringFilter_not_withNestedStringFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilterCopyWith<$Res> get value {
    return $NestedStringFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$StringFilter_not_withNestedStringFilter
    implements StringFilter_not_withNestedStringFilter {
  const _$StringFilter_not_withNestedStringFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedStringFilter';

  factory _$StringFilter_not_withNestedStringFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$StringFilter_not_withNestedStringFilterFromJson(json);

  @override
  final NestedStringFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'StringFilter_not.withNestedStringFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StringFilter_not_withNestedStringFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StringFilter_not_withNestedStringFilterCopyWith<
          _$StringFilter_not_withNestedStringFilter>
      get copyWith => __$$StringFilter_not_withNestedStringFilterCopyWithImpl<
          _$StringFilter_not_withNestedStringFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringFilter value) withNestedStringFilter,
  }) {
    return withNestedStringFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringFilter value)? withNestedStringFilter,
  }) {
    return withNestedStringFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringFilter value)? withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringFilter != null) {
      return withNestedStringFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StringFilter_not_withString value) withString,
    required TResult Function(StringFilter_not_withNestedStringFilter value)
        withNestedStringFilter,
  }) {
    return withNestedStringFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StringFilter_not_withString value)? withString,
    TResult? Function(StringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
  }) {
    return withNestedStringFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StringFilter_not_withString value)? withString,
    TResult Function(StringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringFilter != null) {
      return withNestedStringFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StringFilter_not_withNestedStringFilterToJson(
      this,
    );
  }
}

abstract class StringFilter_not_withNestedStringFilter
    implements StringFilter_not {
  const factory StringFilter_not_withNestedStringFilter(
          final NestedStringFilter value) =
      _$StringFilter_not_withNestedStringFilter;

  factory StringFilter_not_withNestedStringFilter.fromJson(
          Map<String, dynamic> json) =
      _$StringFilter_not_withNestedStringFilter.fromJson;

  @override
  NestedStringFilter get value;
  @JsonKey(ignore: true)
  _$$StringFilter_not_withNestedStringFilterCopyWith<
          _$StringFilter_not_withNestedStringFilter>
      get copyWith => throw _privateConstructorUsedError;
}

StringFilter _$StringFilterFromJson(Map<String, dynamic> json) {
  return _StringFilter.fromJson(json);
}

/// @nodoc
mixin _$StringFilter {
  @JsonKey(name: 'equals')
  String? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<String>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<String>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  String? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  String? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  String? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  String? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'contains')
  String? get contains => throw _privateConstructorUsedError;
  @JsonKey(name: 'startsWith')
  String? get startsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'endsWith')
  String? get endsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'mode')
  QueryMode? get mode => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  StringFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringFilterCopyWith<StringFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringFilterCopyWith<$Res> {
  factory $StringFilterCopyWith(
          StringFilter value, $Res Function(StringFilter) then) =
      _$StringFilterCopyWithImpl<$Res, StringFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'mode') QueryMode? mode,
      @JsonKey(name: 'not') StringFilter_not? not});

  $StringFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$StringFilterCopyWithImpl<$Res, $Val extends StringFilter>
    implements $StringFilterCopyWith<$Res> {
  _$StringFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? mode = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as QueryMode?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as StringFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $StringFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $StringFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_StringFilterCopyWith<$Res>
    implements $StringFilterCopyWith<$Res> {
  factory _$$_StringFilterCopyWith(
          _$_StringFilter value, $Res Function(_$_StringFilter) then) =
      __$$_StringFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'mode') QueryMode? mode,
      @JsonKey(name: 'not') StringFilter_not? not});

  @override
  $StringFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_StringFilterCopyWithImpl<$Res>
    extends _$StringFilterCopyWithImpl<$Res, _$_StringFilter>
    implements _$$_StringFilterCopyWith<$Res> {
  __$$_StringFilterCopyWithImpl(
      _$_StringFilter _value, $Res Function(_$_StringFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? mode = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_StringFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as QueryMode?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as StringFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StringFilter implements _StringFilter {
  const _$_StringFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<String>? dart__in,
      @JsonKey(name: 'notIn') final List<String>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'contains') this.contains,
      @JsonKey(name: 'startsWith') this.startsWith,
      @JsonKey(name: 'endsWith') this.endsWith,
      @JsonKey(name: 'mode') this.mode,
      @JsonKey(name: 'not') this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_StringFilter.fromJson(Map<String, dynamic> json) =>
      _$$_StringFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final String? equals;
  final List<String>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final String? lt;
  @override
  @JsonKey(name: 'lte')
  final String? lte;
  @override
  @JsonKey(name: 'gt')
  final String? gt;
  @override
  @JsonKey(name: 'gte')
  final String? gte;
  @override
  @JsonKey(name: 'contains')
  final String? contains;
  @override
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @override
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @override
  @JsonKey(name: 'mode')
  final QueryMode? mode;
  @override
  @JsonKey(name: 'not')
  final StringFilter_not? not;

  @override
  String toString() {
    return 'StringFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, contains: $contains, startsWith: $startsWith, endsWith: $endsWith, mode: $mode, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.contains, contains) ||
                other.contains == contains) &&
            (identical(other.startsWith, startsWith) ||
                other.startsWith == startsWith) &&
            (identical(other.endsWith, endsWith) ||
                other.endsWith == endsWith) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      contains,
      startsWith,
      endsWith,
      mode,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringFilterCopyWith<_$_StringFilter> get copyWith =>
      __$$_StringFilterCopyWithImpl<_$_StringFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StringFilterToJson(
      this,
    );
  }
}

abstract class _StringFilter implements StringFilter {
  const factory _StringFilter(
      {@JsonKey(name: 'equals') final String? equals,
      @JsonKey(name: 'in') final List<String>? dart__in,
      @JsonKey(name: 'notIn') final List<String>? notIn,
      @JsonKey(name: 'lt') final String? lt,
      @JsonKey(name: 'lte') final String? lte,
      @JsonKey(name: 'gt') final String? gt,
      @JsonKey(name: 'gte') final String? gte,
      @JsonKey(name: 'contains') final String? contains,
      @JsonKey(name: 'startsWith') final String? startsWith,
      @JsonKey(name: 'endsWith') final String? endsWith,
      @JsonKey(name: 'mode') final QueryMode? mode,
      @JsonKey(name: 'not') final StringFilter_not? not}) = _$_StringFilter;

  factory _StringFilter.fromJson(Map<String, dynamic> json) =
      _$_StringFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  String? get equals;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn;
  @override
  @JsonKey(name: 'lt')
  String? get lt;
  @override
  @JsonKey(name: 'lte')
  String? get lte;
  @override
  @JsonKey(name: 'gt')
  String? get gt;
  @override
  @JsonKey(name: 'gte')
  String? get gte;
  @override
  @JsonKey(name: 'contains')
  String? get contains;
  @override
  @JsonKey(name: 'startsWith')
  String? get startsWith;
  @override
  @JsonKey(name: 'endsWith')
  String? get endsWith;
  @override
  @JsonKey(name: 'mode')
  QueryMode? get mode;
  @override
  @JsonKey(name: 'not')
  StringFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_StringFilterCopyWith<_$_StringFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

DateTimeFilter_not _$DateTimeFilter_notFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return DateTimeFilter_not_withDateTime.fromJson(json);
    case 'withNestedDateTimeFilter':
      return DateTimeFilter_not_withNestedDateTimeFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'DateTimeFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$DateTimeFilter_not {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DateTimeFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(DateTimeFilter_not_withNestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DateTimeFilter_not_withDateTime value)? withDateTime,
    TResult? Function(DateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DateTimeFilter_not_withDateTime value)? withDateTime,
    TResult Function(DateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeFilter_notCopyWith<$Res> {
  factory $DateTimeFilter_notCopyWith(
          DateTimeFilter_not value, $Res Function(DateTimeFilter_not) then) =
      _$DateTimeFilter_notCopyWithImpl<$Res, DateTimeFilter_not>;
}

/// @nodoc
class _$DateTimeFilter_notCopyWithImpl<$Res, $Val extends DateTimeFilter_not>
    implements $DateTimeFilter_notCopyWith<$Res> {
  _$DateTimeFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DateTimeFilter_not_withDateTimeCopyWith<$Res> {
  factory _$$DateTimeFilter_not_withDateTimeCopyWith(
          _$DateTimeFilter_not_withDateTime value,
          $Res Function(_$DateTimeFilter_not_withDateTime) then) =
      __$$DateTimeFilter_not_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$DateTimeFilter_not_withDateTimeCopyWithImpl<$Res>
    extends _$DateTimeFilter_notCopyWithImpl<$Res,
        _$DateTimeFilter_not_withDateTime>
    implements _$$DateTimeFilter_not_withDateTimeCopyWith<$Res> {
  __$$DateTimeFilter_not_withDateTimeCopyWithImpl(
      _$DateTimeFilter_not_withDateTime _value,
      $Res Function(_$DateTimeFilter_not_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$DateTimeFilter_not_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DateTimeFilter_not_withDateTime
    implements DateTimeFilter_not_withDateTime {
  const _$DateTimeFilter_not_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$DateTimeFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$DateTimeFilter_not_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'DateTimeFilter_not.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DateTimeFilter_not_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DateTimeFilter_not_withDateTimeCopyWith<_$DateTimeFilter_not_withDateTime>
      get copyWith => __$$DateTimeFilter_not_withDateTimeCopyWithImpl<
          _$DateTimeFilter_not_withDateTime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DateTimeFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(DateTimeFilter_not_withNestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DateTimeFilter_not_withDateTime value)? withDateTime,
    TResult? Function(DateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DateTimeFilter_not_withDateTime value)? withDateTime,
    TResult Function(DateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DateTimeFilter_not_withDateTimeToJson(
      this,
    );
  }
}

abstract class DateTimeFilter_not_withDateTime implements DateTimeFilter_not {
  const factory DateTimeFilter_not_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$DateTimeFilter_not_withDateTime;

  factory DateTimeFilter_not_withDateTime.fromJson(Map<String, dynamic> json) =
      _$DateTimeFilter_not_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$DateTimeFilter_not_withDateTimeCopyWith<_$DateTimeFilter_not_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DateTimeFilter_not_withNestedDateTimeFilterCopyWith<$Res> {
  factory _$$DateTimeFilter_not_withNestedDateTimeFilterCopyWith(
          _$DateTimeFilter_not_withNestedDateTimeFilter value,
          $Res Function(_$DateTimeFilter_not_withNestedDateTimeFilter) then) =
      __$$DateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedDateTimeFilter value});

  $NestedDateTimeFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$DateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl<$Res>
    extends _$DateTimeFilter_notCopyWithImpl<$Res,
        _$DateTimeFilter_not_withNestedDateTimeFilter>
    implements _$$DateTimeFilter_not_withNestedDateTimeFilterCopyWith<$Res> {
  __$$DateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl(
      _$DateTimeFilter_not_withNestedDateTimeFilter _value,
      $Res Function(_$DateTimeFilter_not_withNestedDateTimeFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$DateTimeFilter_not_withNestedDateTimeFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilterCopyWith<$Res> get value {
    return $NestedDateTimeFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$DateTimeFilter_not_withNestedDateTimeFilter
    implements DateTimeFilter_not_withNestedDateTimeFilter {
  const _$DateTimeFilter_not_withNestedDateTimeFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedDateTimeFilter';

  factory _$DateTimeFilter_not_withNestedDateTimeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$DateTimeFilter_not_withNestedDateTimeFilterFromJson(json);

  @override
  final NestedDateTimeFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'DateTimeFilter_not.withNestedDateTimeFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DateTimeFilter_not_withNestedDateTimeFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DateTimeFilter_not_withNestedDateTimeFilterCopyWith<
          _$DateTimeFilter_not_withNestedDateTimeFilter>
      get copyWith =>
          __$$DateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl<
              _$DateTimeFilter_not_withNestedDateTimeFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeFilter != null) {
      return withNestedDateTimeFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DateTimeFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(DateTimeFilter_not_withNestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DateTimeFilter_not_withDateTime value)? withDateTime,
    TResult? Function(DateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DateTimeFilter_not_withDateTime value)? withDateTime,
    TResult Function(DateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeFilter != null) {
      return withNestedDateTimeFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DateTimeFilter_not_withNestedDateTimeFilterToJson(
      this,
    );
  }
}

abstract class DateTimeFilter_not_withNestedDateTimeFilter
    implements DateTimeFilter_not {
  const factory DateTimeFilter_not_withNestedDateTimeFilter(
          final NestedDateTimeFilter value) =
      _$DateTimeFilter_not_withNestedDateTimeFilter;

  factory DateTimeFilter_not_withNestedDateTimeFilter.fromJson(
          Map<String, dynamic> json) =
      _$DateTimeFilter_not_withNestedDateTimeFilter.fromJson;

  @override
  NestedDateTimeFilter get value;
  @JsonKey(ignore: true)
  _$$DateTimeFilter_not_withNestedDateTimeFilterCopyWith<
          _$DateTimeFilter_not_withNestedDateTimeFilter>
      get copyWith => throw _privateConstructorUsedError;
}

DateTimeFilter _$DateTimeFilterFromJson(Map<String, dynamic> json) {
  return _DateTimeFilter.fromJson(json);
}

/// @nodoc
mixin _$DateTimeFilter {
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  DateTimeFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DateTimeFilterCopyWith<DateTimeFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeFilterCopyWith<$Res> {
  factory $DateTimeFilterCopyWith(
          DateTimeFilter value, $Res Function(DateTimeFilter) then) =
      _$DateTimeFilterCopyWithImpl<$Res, DateTimeFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') DateTimeFilter_not? not});

  $DateTimeFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$DateTimeFilterCopyWithImpl<$Res, $Val extends DateTimeFilter>
    implements $DateTimeFilterCopyWith<$Res> {
  _$DateTimeFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as DateTimeFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $DateTimeFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_DateTimeFilterCopyWith<$Res>
    implements $DateTimeFilterCopyWith<$Res> {
  factory _$$_DateTimeFilterCopyWith(
          _$_DateTimeFilter value, $Res Function(_$_DateTimeFilter) then) =
      __$$_DateTimeFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') DateTimeFilter_not? not});

  @override
  $DateTimeFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_DateTimeFilterCopyWithImpl<$Res>
    extends _$DateTimeFilterCopyWithImpl<$Res, _$_DateTimeFilter>
    implements _$$_DateTimeFilterCopyWith<$Res> {
  __$$_DateTimeFilterCopyWithImpl(
      _$_DateTimeFilter _value, $Res Function(_$_DateTimeFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_DateTimeFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as DateTimeFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DateTimeFilter implements _DateTimeFilter {
  const _$_DateTimeFilter(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson)
          this.equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson)
          final List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson)
          final List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson)
          this.lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson)
          this.lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson)
          this.gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson)
          this.gte,
      @JsonKey(name: 'not')
          this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_DateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$$_DateTimeFilterFromJson(json);

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  final DateTime? equals;
  final List<DateTime>? _dart__in;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<DateTime>? _notIn;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  final DateTime? lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  final DateTime? lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  final DateTime? gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  final DateTime? gte;
  @override
  @JsonKey(name: 'not')
  final DateTimeFilter_not? not;

  @override
  String toString() {
    return 'DateTimeFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DateTimeFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DateTimeFilterCopyWith<_$_DateTimeFilter> get copyWith =>
      __$$_DateTimeFilterCopyWithImpl<_$_DateTimeFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DateTimeFilterToJson(
      this,
    );
  }
}

abstract class _DateTimeFilter implements DateTimeFilter {
  const factory _DateTimeFilter(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson)
          final DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson)
          final List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson)
          final List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson)
          final DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson)
          final DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson)
          final DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson)
          final DateTime? gte,
      @JsonKey(name: 'not')
          final DateTimeFilter_not? not}) = _$_DateTimeFilter;

  factory _DateTimeFilter.fromJson(Map<String, dynamic> json) =
      _$_DateTimeFilter.fromJson;

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn;
  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte;
  @override
  @JsonKey(name: 'not')
  DateTimeFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_DateTimeFilterCopyWith<_$_DateTimeFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

UserCountOrderByAggregateInput _$UserCountOrderByAggregateInputFromJson(
    Map<String, dynamic> json) {
  return _UserCountOrderByAggregateInput.fromJson(json);
}

/// @nodoc
mixin _$UserCountOrderByAggregateInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  SortOrder? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserCountOrderByAggregateInputCopyWith<UserCountOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserCountOrderByAggregateInputCopyWith<$Res> {
  factory $UserCountOrderByAggregateInputCopyWith(
          UserCountOrderByAggregateInput value,
          $Res Function(UserCountOrderByAggregateInput) then) =
      _$UserCountOrderByAggregateInputCopyWithImpl<$Res,
          UserCountOrderByAggregateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class _$UserCountOrderByAggregateInputCopyWithImpl<$Res,
        $Val extends UserCountOrderByAggregateInput>
    implements $UserCountOrderByAggregateInputCopyWith<$Res> {
  _$UserCountOrderByAggregateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserCountOrderByAggregateInputCopyWith<$Res>
    implements $UserCountOrderByAggregateInputCopyWith<$Res> {
  factory _$$_UserCountOrderByAggregateInputCopyWith(
          _$_UserCountOrderByAggregateInput value,
          $Res Function(_$_UserCountOrderByAggregateInput) then) =
      __$$_UserCountOrderByAggregateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class __$$_UserCountOrderByAggregateInputCopyWithImpl<$Res>
    extends _$UserCountOrderByAggregateInputCopyWithImpl<$Res,
        _$_UserCountOrderByAggregateInput>
    implements _$$_UserCountOrderByAggregateInputCopyWith<$Res> {
  __$$_UserCountOrderByAggregateInputCopyWithImpl(
      _$_UserCountOrderByAggregateInput _value,
      $Res Function(_$_UserCountOrderByAggregateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserCountOrderByAggregateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserCountOrderByAggregateInput
    implements _UserCountOrderByAggregateInput {
  const _$_UserCountOrderByAggregateInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UserCountOrderByAggregateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;
  @override
  @JsonKey(name: 'name')
  final SortOrder? name;
  @override
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;

  @override
  String toString() {
    return 'UserCountOrderByAggregateInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserCountOrderByAggregateInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserCountOrderByAggregateInputCopyWith<_$_UserCountOrderByAggregateInput>
      get copyWith => __$$_UserCountOrderByAggregateInputCopyWithImpl<
          _$_UserCountOrderByAggregateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserCountOrderByAggregateInputToJson(
      this,
    );
  }
}

abstract class _UserCountOrderByAggregateInput
    implements UserCountOrderByAggregateInput {
  const factory _UserCountOrderByAggregateInput(
          {@JsonKey(name: 'id') final SortOrder? id,
          @JsonKey(name: 'name') final SortOrder? name,
          @JsonKey(name: 'createdAt') final SortOrder? createdAt}) =
      _$_UserCountOrderByAggregateInput;

  factory _UserCountOrderByAggregateInput.fromJson(Map<String, dynamic> json) =
      _$_UserCountOrderByAggregateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(name: 'name')
  SortOrder? get name;
  @override
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserCountOrderByAggregateInputCopyWith<_$_UserCountOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserAvgOrderByAggregateInput _$UserAvgOrderByAggregateInputFromJson(
    Map<String, dynamic> json) {
  return _UserAvgOrderByAggregateInput.fromJson(json);
}

/// @nodoc
mixin _$UserAvgOrderByAggregateInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserAvgOrderByAggregateInputCopyWith<UserAvgOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserAvgOrderByAggregateInputCopyWith<$Res> {
  factory $UserAvgOrderByAggregateInputCopyWith(
          UserAvgOrderByAggregateInput value,
          $Res Function(UserAvgOrderByAggregateInput) then) =
      _$UserAvgOrderByAggregateInputCopyWithImpl<$Res,
          UserAvgOrderByAggregateInput>;
  @useResult
  $Res call({@JsonKey(name: 'id') SortOrder? id});
}

/// @nodoc
class _$UserAvgOrderByAggregateInputCopyWithImpl<$Res,
        $Val extends UserAvgOrderByAggregateInput>
    implements $UserAvgOrderByAggregateInputCopyWith<$Res> {
  _$UserAvgOrderByAggregateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserAvgOrderByAggregateInputCopyWith<$Res>
    implements $UserAvgOrderByAggregateInputCopyWith<$Res> {
  factory _$$_UserAvgOrderByAggregateInputCopyWith(
          _$_UserAvgOrderByAggregateInput value,
          $Res Function(_$_UserAvgOrderByAggregateInput) then) =
      __$$_UserAvgOrderByAggregateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'id') SortOrder? id});
}

/// @nodoc
class __$$_UserAvgOrderByAggregateInputCopyWithImpl<$Res>
    extends _$UserAvgOrderByAggregateInputCopyWithImpl<$Res,
        _$_UserAvgOrderByAggregateInput>
    implements _$$_UserAvgOrderByAggregateInputCopyWith<$Res> {
  __$$_UserAvgOrderByAggregateInputCopyWithImpl(
      _$_UserAvgOrderByAggregateInput _value,
      $Res Function(_$_UserAvgOrderByAggregateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$_UserAvgOrderByAggregateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserAvgOrderByAggregateInput implements _UserAvgOrderByAggregateInput {
  const _$_UserAvgOrderByAggregateInput({@JsonKey(name: 'id') this.id});

  factory _$_UserAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserAvgOrderByAggregateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;

  @override
  String toString() {
    return 'UserAvgOrderByAggregateInput(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserAvgOrderByAggregateInput &&
            (identical(other.id, id) || other.id == id));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserAvgOrderByAggregateInputCopyWith<_$_UserAvgOrderByAggregateInput>
      get copyWith => __$$_UserAvgOrderByAggregateInputCopyWithImpl<
          _$_UserAvgOrderByAggregateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserAvgOrderByAggregateInputToJson(
      this,
    );
  }
}

abstract class _UserAvgOrderByAggregateInput
    implements UserAvgOrderByAggregateInput {
  const factory _UserAvgOrderByAggregateInput(
          {@JsonKey(name: 'id') final SortOrder? id}) =
      _$_UserAvgOrderByAggregateInput;

  factory _UserAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =
      _$_UserAvgOrderByAggregateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(ignore: true)
  _$$_UserAvgOrderByAggregateInputCopyWith<_$_UserAvgOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserMaxOrderByAggregateInput _$UserMaxOrderByAggregateInputFromJson(
    Map<String, dynamic> json) {
  return _UserMaxOrderByAggregateInput.fromJson(json);
}

/// @nodoc
mixin _$UserMaxOrderByAggregateInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  SortOrder? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserMaxOrderByAggregateInputCopyWith<UserMaxOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserMaxOrderByAggregateInputCopyWith<$Res> {
  factory $UserMaxOrderByAggregateInputCopyWith(
          UserMaxOrderByAggregateInput value,
          $Res Function(UserMaxOrderByAggregateInput) then) =
      _$UserMaxOrderByAggregateInputCopyWithImpl<$Res,
          UserMaxOrderByAggregateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class _$UserMaxOrderByAggregateInputCopyWithImpl<$Res,
        $Val extends UserMaxOrderByAggregateInput>
    implements $UserMaxOrderByAggregateInputCopyWith<$Res> {
  _$UserMaxOrderByAggregateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserMaxOrderByAggregateInputCopyWith<$Res>
    implements $UserMaxOrderByAggregateInputCopyWith<$Res> {
  factory _$$_UserMaxOrderByAggregateInputCopyWith(
          _$_UserMaxOrderByAggregateInput value,
          $Res Function(_$_UserMaxOrderByAggregateInput) then) =
      __$$_UserMaxOrderByAggregateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class __$$_UserMaxOrderByAggregateInputCopyWithImpl<$Res>
    extends _$UserMaxOrderByAggregateInputCopyWithImpl<$Res,
        _$_UserMaxOrderByAggregateInput>
    implements _$$_UserMaxOrderByAggregateInputCopyWith<$Res> {
  __$$_UserMaxOrderByAggregateInputCopyWithImpl(
      _$_UserMaxOrderByAggregateInput _value,
      $Res Function(_$_UserMaxOrderByAggregateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserMaxOrderByAggregateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserMaxOrderByAggregateInput implements _UserMaxOrderByAggregateInput {
  const _$_UserMaxOrderByAggregateInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserMaxOrderByAggregateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;
  @override
  @JsonKey(name: 'name')
  final SortOrder? name;
  @override
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;

  @override
  String toString() {
    return 'UserMaxOrderByAggregateInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserMaxOrderByAggregateInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserMaxOrderByAggregateInputCopyWith<_$_UserMaxOrderByAggregateInput>
      get copyWith => __$$_UserMaxOrderByAggregateInputCopyWithImpl<
          _$_UserMaxOrderByAggregateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserMaxOrderByAggregateInputToJson(
      this,
    );
  }
}

abstract class _UserMaxOrderByAggregateInput
    implements UserMaxOrderByAggregateInput {
  const factory _UserMaxOrderByAggregateInput(
          {@JsonKey(name: 'id') final SortOrder? id,
          @JsonKey(name: 'name') final SortOrder? name,
          @JsonKey(name: 'createdAt') final SortOrder? createdAt}) =
      _$_UserMaxOrderByAggregateInput;

  factory _UserMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =
      _$_UserMaxOrderByAggregateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(name: 'name')
  SortOrder? get name;
  @override
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserMaxOrderByAggregateInputCopyWith<_$_UserMaxOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserMinOrderByAggregateInput _$UserMinOrderByAggregateInputFromJson(
    Map<String, dynamic> json) {
  return _UserMinOrderByAggregateInput.fromJson(json);
}

/// @nodoc
mixin _$UserMinOrderByAggregateInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'name')
  SortOrder? get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserMinOrderByAggregateInputCopyWith<UserMinOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserMinOrderByAggregateInputCopyWith<$Res> {
  factory $UserMinOrderByAggregateInputCopyWith(
          UserMinOrderByAggregateInput value,
          $Res Function(UserMinOrderByAggregateInput) then) =
      _$UserMinOrderByAggregateInputCopyWithImpl<$Res,
          UserMinOrderByAggregateInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class _$UserMinOrderByAggregateInputCopyWithImpl<$Res,
        $Val extends UserMinOrderByAggregateInput>
    implements $UserMinOrderByAggregateInputCopyWith<$Res> {
  _$UserMinOrderByAggregateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserMinOrderByAggregateInputCopyWith<$Res>
    implements $UserMinOrderByAggregateInputCopyWith<$Res> {
  factory _$$_UserMinOrderByAggregateInputCopyWith(
          _$_UserMinOrderByAggregateInput value,
          $Res Function(_$_UserMinOrderByAggregateInput) then) =
      __$$_UserMinOrderByAggregateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'id') SortOrder? id,
      @JsonKey(name: 'name') SortOrder? name,
      @JsonKey(name: 'createdAt') SortOrder? createdAt});
}

/// @nodoc
class __$$_UserMinOrderByAggregateInputCopyWithImpl<$Res>
    extends _$UserMinOrderByAggregateInputCopyWithImpl<$Res,
        _$_UserMinOrderByAggregateInput>
    implements _$$_UserMinOrderByAggregateInputCopyWith<$Res> {
  __$$_UserMinOrderByAggregateInputCopyWithImpl(
      _$_UserMinOrderByAggregateInput _value,
      $Res Function(_$_UserMinOrderByAggregateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_UserMinOrderByAggregateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserMinOrderByAggregateInput implements _UserMinOrderByAggregateInput {
  const _$_UserMinOrderByAggregateInput(
      {@JsonKey(name: 'id') this.id,
      @JsonKey(name: 'name') this.name,
      @JsonKey(name: 'createdAt') this.createdAt});

  factory _$_UserMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserMinOrderByAggregateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;
  @override
  @JsonKey(name: 'name')
  final SortOrder? name;
  @override
  @JsonKey(name: 'createdAt')
  final SortOrder? createdAt;

  @override
  String toString() {
    return 'UserMinOrderByAggregateInput(id: $id, name: $name, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserMinOrderByAggregateInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserMinOrderByAggregateInputCopyWith<_$_UserMinOrderByAggregateInput>
      get copyWith => __$$_UserMinOrderByAggregateInputCopyWithImpl<
          _$_UserMinOrderByAggregateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserMinOrderByAggregateInputToJson(
      this,
    );
  }
}

abstract class _UserMinOrderByAggregateInput
    implements UserMinOrderByAggregateInput {
  const factory _UserMinOrderByAggregateInput(
          {@JsonKey(name: 'id') final SortOrder? id,
          @JsonKey(name: 'name') final SortOrder? name,
          @JsonKey(name: 'createdAt') final SortOrder? createdAt}) =
      _$_UserMinOrderByAggregateInput;

  factory _UserMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =
      _$_UserMinOrderByAggregateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(name: 'name')
  SortOrder? get name;
  @override
  @JsonKey(name: 'createdAt')
  SortOrder? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_UserMinOrderByAggregateInputCopyWith<_$_UserMinOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UserSumOrderByAggregateInput _$UserSumOrderByAggregateInputFromJson(
    Map<String, dynamic> json) {
  return _UserSumOrderByAggregateInput.fromJson(json);
}

/// @nodoc
mixin _$UserSumOrderByAggregateInput {
  @JsonKey(name: 'id')
  SortOrder? get id => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserSumOrderByAggregateInputCopyWith<UserSumOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserSumOrderByAggregateInputCopyWith<$Res> {
  factory $UserSumOrderByAggregateInputCopyWith(
          UserSumOrderByAggregateInput value,
          $Res Function(UserSumOrderByAggregateInput) then) =
      _$UserSumOrderByAggregateInputCopyWithImpl<$Res,
          UserSumOrderByAggregateInput>;
  @useResult
  $Res call({@JsonKey(name: 'id') SortOrder? id});
}

/// @nodoc
class _$UserSumOrderByAggregateInputCopyWithImpl<$Res,
        $Val extends UserSumOrderByAggregateInput>
    implements $UserSumOrderByAggregateInputCopyWith<$Res> {
  _$UserSumOrderByAggregateInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UserSumOrderByAggregateInputCopyWith<$Res>
    implements $UserSumOrderByAggregateInputCopyWith<$Res> {
  factory _$$_UserSumOrderByAggregateInputCopyWith(
          _$_UserSumOrderByAggregateInput value,
          $Res Function(_$_UserSumOrderByAggregateInput) then) =
      __$$_UserSumOrderByAggregateInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'id') SortOrder? id});
}

/// @nodoc
class __$$_UserSumOrderByAggregateInputCopyWithImpl<$Res>
    extends _$UserSumOrderByAggregateInputCopyWithImpl<$Res,
        _$_UserSumOrderByAggregateInput>
    implements _$$_UserSumOrderByAggregateInputCopyWith<$Res> {
  __$$_UserSumOrderByAggregateInputCopyWithImpl(
      _$_UserSumOrderByAggregateInput _value,
      $Res Function(_$_UserSumOrderByAggregateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$_UserSumOrderByAggregateInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as SortOrder?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UserSumOrderByAggregateInput implements _UserSumOrderByAggregateInput {
  const _$_UserSumOrderByAggregateInput({@JsonKey(name: 'id') this.id});

  factory _$_UserSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$$_UserSumOrderByAggregateInputFromJson(json);

  @override
  @JsonKey(name: 'id')
  final SortOrder? id;

  @override
  String toString() {
    return 'UserSumOrderByAggregateInput(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserSumOrderByAggregateInput &&
            (identical(other.id, id) || other.id == id));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserSumOrderByAggregateInputCopyWith<_$_UserSumOrderByAggregateInput>
      get copyWith => __$$_UserSumOrderByAggregateInputCopyWithImpl<
          _$_UserSumOrderByAggregateInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserSumOrderByAggregateInputToJson(
      this,
    );
  }
}

abstract class _UserSumOrderByAggregateInput
    implements UserSumOrderByAggregateInput {
  const factory _UserSumOrderByAggregateInput(
          {@JsonKey(name: 'id') final SortOrder? id}) =
      _$_UserSumOrderByAggregateInput;

  factory _UserSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =
      _$_UserSumOrderByAggregateInput.fromJson;

  @override
  @JsonKey(name: 'id')
  SortOrder? get id;
  @override
  @JsonKey(ignore: true)
  _$$_UserSumOrderByAggregateInputCopyWith<_$_UserSumOrderByAggregateInput>
      get copyWith => throw _privateConstructorUsedError;
}

IntWithAggregatesFilter_not _$IntWithAggregatesFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withInt':
      return IntWithAggregatesFilter_not_withInt.fromJson(json);
    case 'withNestedIntWithAggregatesFilter':
      return IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'IntWithAggregatesFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$IntWithAggregatesFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntWithAggregatesFilter_not_withInt value)
        withInt,
    required TResult Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntWithAggregatesFilter_not_withInt value)? withInt,
    TResult? Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntWithAggregatesFilter_not_withInt value)? withInt,
    TResult Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntWithAggregatesFilter_notCopyWith<$Res> {
  factory $IntWithAggregatesFilter_notCopyWith(
          IntWithAggregatesFilter_not value,
          $Res Function(IntWithAggregatesFilter_not) then) =
      _$IntWithAggregatesFilter_notCopyWithImpl<$Res,
          IntWithAggregatesFilter_not>;
}

/// @nodoc
class _$IntWithAggregatesFilter_notCopyWithImpl<$Res,
        $Val extends IntWithAggregatesFilter_not>
    implements $IntWithAggregatesFilter_notCopyWith<$Res> {
  _$IntWithAggregatesFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$IntWithAggregatesFilter_not_withIntCopyWith<$Res> {
  factory _$$IntWithAggregatesFilter_not_withIntCopyWith(
          _$IntWithAggregatesFilter_not_withInt value,
          $Res Function(_$IntWithAggregatesFilter_not_withInt) then) =
      __$$IntWithAggregatesFilter_not_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IntWithAggregatesFilter_not_withIntCopyWithImpl<$Res>
    extends _$IntWithAggregatesFilter_notCopyWithImpl<$Res,
        _$IntWithAggregatesFilter_not_withInt>
    implements _$$IntWithAggregatesFilter_not_withIntCopyWith<$Res> {
  __$$IntWithAggregatesFilter_not_withIntCopyWithImpl(
      _$IntWithAggregatesFilter_not_withInt _value,
      $Res Function(_$IntWithAggregatesFilter_not_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IntWithAggregatesFilter_not_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IntWithAggregatesFilter_not_withInt
    implements IntWithAggregatesFilter_not_withInt {
  const _$IntWithAggregatesFilter_not_withInt(this.value, {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$IntWithAggregatesFilter_not_withInt.fromJson(
          Map<String, dynamic> json) =>
      _$$IntWithAggregatesFilter_not_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntWithAggregatesFilter_not.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IntWithAggregatesFilter_not_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IntWithAggregatesFilter_not_withIntCopyWith<
          _$IntWithAggregatesFilter_not_withInt>
      get copyWith => __$$IntWithAggregatesFilter_not_withIntCopyWithImpl<
          _$IntWithAggregatesFilter_not_withInt>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntWithAggregatesFilter_not_withInt value)
        withInt,
    required TResult Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntWithAggregatesFilter_not_withInt value)? withInt,
    TResult? Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntWithAggregatesFilter_not_withInt value)? withInt,
    TResult Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IntWithAggregatesFilter_not_withIntToJson(
      this,
    );
  }
}

abstract class IntWithAggregatesFilter_not_withInt
    implements IntWithAggregatesFilter_not {
  const factory IntWithAggregatesFilter_not_withInt(final int value) =
      _$IntWithAggregatesFilter_not_withInt;

  factory IntWithAggregatesFilter_not_withInt.fromJson(
          Map<String, dynamic> json) =
      _$IntWithAggregatesFilter_not_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$IntWithAggregatesFilter_not_withIntCopyWith<
          _$IntWithAggregatesFilter_not_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith(
          _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter value,
          $Res Function(
                  _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter)
              then) =
      __$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({NestedIntWithAggregatesFilter value});

  $NestedIntWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$IntWithAggregatesFilter_notCopyWithImpl<$Res,
        _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>
    implements
        _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
            $Res> {
  __$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl(
      _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter _value,
      $Res Function(
              _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedIntWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntWithAggregatesFilterCopyWith<$Res> get value {
    return $NestedIntWithAggregatesFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
    implements IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter {
  const _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedIntWithAggregatesFilter';

  factory _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterFromJson(
          json);

  @override
  final NestedIntWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntWithAggregatesFilter_not.withNestedIntWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
          _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>
      get copyWith =>
          __$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl<
                  _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntWithAggregatesFilter != null) {
      return withNestedIntWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntWithAggregatesFilter_not_withInt value)
        withInt,
    required TResult Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntWithAggregatesFilter_not_withInt value)? withInt,
    TResult? Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntWithAggregatesFilter_not_withInt value)? withInt,
    TResult Function(
            IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntWithAggregatesFilter != null) {
      return withNestedIntWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
    implements IntWithAggregatesFilter_not {
  const factory IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter(
          final NestedIntWithAggregatesFilter value) =
      _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter;

  factory IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter.fromJson;

  @override
  NestedIntWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
          _$IntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

IntWithAggregatesFilter _$IntWithAggregatesFilterFromJson(
    Map<String, dynamic> json) {
  return _IntWithAggregatesFilter.fromJson(json);
}

/// @nodoc
mixin _$IntWithAggregatesFilter {
  @JsonKey(name: 'equals')
  int? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<int>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<int>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  int? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  int? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  int? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  int? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  IntWithAggregatesFilter_not? get not => throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count => throw _privateConstructorUsedError;
  @JsonKey(name: '_avg')
  NestedFloatFilter? get prisma__avg => throw _privateConstructorUsedError;
  @JsonKey(name: '_sum')
  NestedIntFilter? get prisma__sum => throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  NestedIntFilter? get prisma__min => throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  NestedIntFilter? get prisma__max => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IntWithAggregatesFilterCopyWith<IntWithAggregatesFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntWithAggregatesFilterCopyWith<$Res> {
  factory $IntWithAggregatesFilterCopyWith(IntWithAggregatesFilter value,
          $Res Function(IntWithAggregatesFilter) then) =
      _$IntWithAggregatesFilterCopyWithImpl<$Res, IntWithAggregatesFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') IntWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_avg') NestedFloatFilter? prisma__avg,
      @JsonKey(name: '_sum') NestedIntFilter? prisma__sum,
      @JsonKey(name: '_min') NestedIntFilter? prisma__min,
      @JsonKey(name: '_max') NestedIntFilter? prisma__max});

  $IntWithAggregatesFilter_notCopyWith<$Res>? get not;
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  $NestedFloatFilterCopyWith<$Res>? get prisma__avg;
  $NestedIntFilterCopyWith<$Res>? get prisma__sum;
  $NestedIntFilterCopyWith<$Res>? get prisma__min;
  $NestedIntFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class _$IntWithAggregatesFilterCopyWithImpl<$Res,
        $Val extends IntWithAggregatesFilter>
    implements $IntWithAggregatesFilterCopyWith<$Res> {
  _$IntWithAggregatesFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__avg = freezed,
    Object? prisma__sum = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as IntWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__avg: freezed == prisma__avg
          ? _value.prisma__avg
          : prisma__avg // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter?,
      prisma__sum: freezed == prisma__sum
          ? _value.prisma__sum
          : prisma__sum // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IntWithAggregatesFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $IntWithAggregatesFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__count!, (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedFloatFilterCopyWith<$Res>? get prisma__avg {
    if (_value.prisma__avg == null) {
      return null;
    }

    return $NestedFloatFilterCopyWith<$Res>(_value.prisma__avg!, (value) {
      return _then(_value.copyWith(prisma__avg: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__sum {
    if (_value.prisma__sum == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__sum!, (value) {
      return _then(_value.copyWith(prisma__sum: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__min!, (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__max!, (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IntWithAggregatesFilterCopyWith<$Res>
    implements $IntWithAggregatesFilterCopyWith<$Res> {
  factory _$$_IntWithAggregatesFilterCopyWith(_$_IntWithAggregatesFilter value,
          $Res Function(_$_IntWithAggregatesFilter) then) =
      __$$_IntWithAggregatesFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') IntWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_avg') NestedFloatFilter? prisma__avg,
      @JsonKey(name: '_sum') NestedIntFilter? prisma__sum,
      @JsonKey(name: '_min') NestedIntFilter? prisma__min,
      @JsonKey(name: '_max') NestedIntFilter? prisma__max});

  @override
  $IntWithAggregatesFilter_notCopyWith<$Res>? get not;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  @override
  $NestedFloatFilterCopyWith<$Res>? get prisma__avg;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__sum;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__min;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class __$$_IntWithAggregatesFilterCopyWithImpl<$Res>
    extends _$IntWithAggregatesFilterCopyWithImpl<$Res,
        _$_IntWithAggregatesFilter>
    implements _$$_IntWithAggregatesFilterCopyWith<$Res> {
  __$$_IntWithAggregatesFilterCopyWithImpl(_$_IntWithAggregatesFilter _value,
      $Res Function(_$_IntWithAggregatesFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__avg = freezed,
    Object? prisma__sum = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_$_IntWithAggregatesFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as IntWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__avg: freezed == prisma__avg
          ? _value.prisma__avg
          : prisma__avg // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter?,
      prisma__sum: freezed == prisma__sum
          ? _value.prisma__sum
          : prisma__sum // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IntWithAggregatesFilter implements _IntWithAggregatesFilter {
  const _$_IntWithAggregatesFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<int>? dart__in,
      @JsonKey(name: 'notIn') final List<int>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'not') this.not,
      @JsonKey(name: '_count') this.prisma__count,
      @JsonKey(name: '_avg') this.prisma__avg,
      @JsonKey(name: '_sum') this.prisma__sum,
      @JsonKey(name: '_min') this.prisma__min,
      @JsonKey(name: '_max') this.prisma__max})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_IntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$$_IntWithAggregatesFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final int? equals;
  final List<int>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final int? lt;
  @override
  @JsonKey(name: 'lte')
  final int? lte;
  @override
  @JsonKey(name: 'gt')
  final int? gt;
  @override
  @JsonKey(name: 'gte')
  final int? gte;
  @override
  @JsonKey(name: 'not')
  final IntWithAggregatesFilter_not? not;
  @override
  @JsonKey(name: '_count')
  final NestedIntFilter? prisma__count;
  @override
  @JsonKey(name: '_avg')
  final NestedFloatFilter? prisma__avg;
  @override
  @JsonKey(name: '_sum')
  final NestedIntFilter? prisma__sum;
  @override
  @JsonKey(name: '_min')
  final NestedIntFilter? prisma__min;
  @override
  @JsonKey(name: '_max')
  final NestedIntFilter? prisma__max;

  @override
  String toString() {
    return 'IntWithAggregatesFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not, prisma__count: $prisma__count, prisma__avg: $prisma__avg, prisma__sum: $prisma__sum, prisma__min: $prisma__min, prisma__max: $prisma__max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntWithAggregatesFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__avg, prisma__avg) ||
                other.prisma__avg == prisma__avg) &&
            (identical(other.prisma__sum, prisma__sum) ||
                other.prisma__sum == prisma__sum) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not,
      prisma__count,
      prisma__avg,
      prisma__sum,
      prisma__min,
      prisma__max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntWithAggregatesFilterCopyWith<_$_IntWithAggregatesFilter>
      get copyWith =>
          __$$_IntWithAggregatesFilterCopyWithImpl<_$_IntWithAggregatesFilter>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IntWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class _IntWithAggregatesFilter implements IntWithAggregatesFilter {
  const factory _IntWithAggregatesFilter(
          {@JsonKey(name: 'equals') final int? equals,
          @JsonKey(name: 'in') final List<int>? dart__in,
          @JsonKey(name: 'notIn') final List<int>? notIn,
          @JsonKey(name: 'lt') final int? lt,
          @JsonKey(name: 'lte') final int? lte,
          @JsonKey(name: 'gt') final int? gt,
          @JsonKey(name: 'gte') final int? gte,
          @JsonKey(name: 'not') final IntWithAggregatesFilter_not? not,
          @JsonKey(name: '_count') final NestedIntFilter? prisma__count,
          @JsonKey(name: '_avg') final NestedFloatFilter? prisma__avg,
          @JsonKey(name: '_sum') final NestedIntFilter? prisma__sum,
          @JsonKey(name: '_min') final NestedIntFilter? prisma__min,
          @JsonKey(name: '_max') final NestedIntFilter? prisma__max}) =
      _$_IntWithAggregatesFilter;

  factory _IntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =
      _$_IntWithAggregatesFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  int? get equals;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn;
  @override
  @JsonKey(name: 'lt')
  int? get lt;
  @override
  @JsonKey(name: 'lte')
  int? get lte;
  @override
  @JsonKey(name: 'gt')
  int? get gt;
  @override
  @JsonKey(name: 'gte')
  int? get gte;
  @override
  @JsonKey(name: 'not')
  IntWithAggregatesFilter_not? get not;
  @override
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count;
  @override
  @JsonKey(name: '_avg')
  NestedFloatFilter? get prisma__avg;
  @override
  @JsonKey(name: '_sum')
  NestedIntFilter? get prisma__sum;
  @override
  @JsonKey(name: '_min')
  NestedIntFilter? get prisma__min;
  @override
  @JsonKey(name: '_max')
  NestedIntFilter? get prisma__max;
  @override
  @JsonKey(ignore: true)
  _$$_IntWithAggregatesFilterCopyWith<_$_IntWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

StringWithAggregatesFilter_not _$StringWithAggregatesFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return StringWithAggregatesFilter_not_withString.fromJson(json);
    case 'withNestedStringWithAggregatesFilter':
      return StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'StringWithAggregatesFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$StringWithAggregatesFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringWithAggregatesFilter value)
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StringWithAggregatesFilter_not_withString value)
        withString,
    required TResult Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StringWithAggregatesFilter_not_withString value)?
        withString,
    TResult? Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StringWithAggregatesFilter_not_withString value)?
        withString,
    TResult Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringWithAggregatesFilter_notCopyWith<$Res> {
  factory $StringWithAggregatesFilter_notCopyWith(
          StringWithAggregatesFilter_not value,
          $Res Function(StringWithAggregatesFilter_not) then) =
      _$StringWithAggregatesFilter_notCopyWithImpl<$Res,
          StringWithAggregatesFilter_not>;
}

/// @nodoc
class _$StringWithAggregatesFilter_notCopyWithImpl<$Res,
        $Val extends StringWithAggregatesFilter_not>
    implements $StringWithAggregatesFilter_notCopyWith<$Res> {
  _$StringWithAggregatesFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StringWithAggregatesFilter_not_withStringCopyWith<$Res> {
  factory _$$StringWithAggregatesFilter_not_withStringCopyWith(
          _$StringWithAggregatesFilter_not_withString value,
          $Res Function(_$StringWithAggregatesFilter_not_withString) then) =
      __$$StringWithAggregatesFilter_not_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$StringWithAggregatesFilter_not_withStringCopyWithImpl<$Res>
    extends _$StringWithAggregatesFilter_notCopyWithImpl<$Res,
        _$StringWithAggregatesFilter_not_withString>
    implements _$$StringWithAggregatesFilter_not_withStringCopyWith<$Res> {
  __$$StringWithAggregatesFilter_not_withStringCopyWithImpl(
      _$StringWithAggregatesFilter_not_withString _value,
      $Res Function(_$StringWithAggregatesFilter_not_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$StringWithAggregatesFilter_not_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StringWithAggregatesFilter_not_withString
    implements StringWithAggregatesFilter_not_withString {
  const _$StringWithAggregatesFilter_not_withString(this.value,
      {final String? $type})
      : $type = $type ?? 'withString';

  factory _$StringWithAggregatesFilter_not_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$StringWithAggregatesFilter_not_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'StringWithAggregatesFilter_not.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StringWithAggregatesFilter_not_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StringWithAggregatesFilter_not_withStringCopyWith<
          _$StringWithAggregatesFilter_not_withString>
      get copyWith => __$$StringWithAggregatesFilter_not_withStringCopyWithImpl<
          _$StringWithAggregatesFilter_not_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringWithAggregatesFilter value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StringWithAggregatesFilter_not_withString value)
        withString,
    required TResult Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StringWithAggregatesFilter_not_withString value)?
        withString,
    TResult? Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StringWithAggregatesFilter_not_withString value)?
        withString,
    TResult Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StringWithAggregatesFilter_not_withStringToJson(
      this,
    );
  }
}

abstract class StringWithAggregatesFilter_not_withString
    implements StringWithAggregatesFilter_not {
  const factory StringWithAggregatesFilter_not_withString(final String value) =
      _$StringWithAggregatesFilter_not_withString;

  factory StringWithAggregatesFilter_not_withString.fromJson(
          Map<String, dynamic> json) =
      _$StringWithAggregatesFilter_not_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$StringWithAggregatesFilter_not_withStringCopyWith<
          _$StringWithAggregatesFilter_not_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith(
          _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
              value,
          $Res Function(
                  _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter)
              then) =
      __$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({NestedStringWithAggregatesFilter value});

  $NestedStringWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$StringWithAggregatesFilter_notCopyWithImpl<$Res,
        _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>
    implements
        _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
            $Res> {
  __$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl(
      _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
          _value,
      $Res Function(
              _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedStringWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringWithAggregatesFilterCopyWith<$Res> get value {
    return $NestedStringWithAggregatesFilterCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
    implements
        StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter {
  const _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedStringWithAggregatesFilter';

  factory _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterFromJson(
          json);

  @override
  final NestedStringWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'StringWithAggregatesFilter_not.withNestedStringWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
          _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>
      get copyWith =>
          __$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl<
                  _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringWithAggregatesFilter value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringWithAggregatesFilter != null) {
      return withNestedStringWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StringWithAggregatesFilter_not_withString value)
        withString,
    required TResult Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StringWithAggregatesFilter_not_withString value)?
        withString,
    TResult? Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StringWithAggregatesFilter_not_withString value)?
        withString,
    TResult Function(
            StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringWithAggregatesFilter != null) {
      return withNestedStringWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
    implements StringWithAggregatesFilter_not {
  const factory StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter(
          final NestedStringWithAggregatesFilter value) =
      _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter;

  factory StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
          .fromJson;

  @override
  NestedStringWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
          _$StringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

StringWithAggregatesFilter _$StringWithAggregatesFilterFromJson(
    Map<String, dynamic> json) {
  return _StringWithAggregatesFilter.fromJson(json);
}

/// @nodoc
mixin _$StringWithAggregatesFilter {
  @JsonKey(name: 'equals')
  String? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<String>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<String>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  String? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  String? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  String? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  String? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'contains')
  String? get contains => throw _privateConstructorUsedError;
  @JsonKey(name: 'startsWith')
  String? get startsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'endsWith')
  String? get endsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'mode')
  QueryMode? get mode => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  StringWithAggregatesFilter_not? get not => throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count => throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  NestedStringFilter? get prisma__min => throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  NestedStringFilter? get prisma__max => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringWithAggregatesFilterCopyWith<StringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringWithAggregatesFilterCopyWith<$Res> {
  factory $StringWithAggregatesFilterCopyWith(StringWithAggregatesFilter value,
          $Res Function(StringWithAggregatesFilter) then) =
      _$StringWithAggregatesFilterCopyWithImpl<$Res,
          StringWithAggregatesFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'mode') QueryMode? mode,
      @JsonKey(name: 'not') StringWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedStringFilter? prisma__min,
      @JsonKey(name: '_max') NestedStringFilter? prisma__max});

  $StringWithAggregatesFilter_notCopyWith<$Res>? get not;
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  $NestedStringFilterCopyWith<$Res>? get prisma__min;
  $NestedStringFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class _$StringWithAggregatesFilterCopyWithImpl<$Res,
        $Val extends StringWithAggregatesFilter>
    implements $StringWithAggregatesFilterCopyWith<$Res> {
  _$StringWithAggregatesFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? mode = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as QueryMode?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as StringWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $StringWithAggregatesFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $StringWithAggregatesFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__count!, (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilterCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $NestedStringFilterCopyWith<$Res>(_value.prisma__min!, (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilterCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $NestedStringFilterCopyWith<$Res>(_value.prisma__max!, (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_StringWithAggregatesFilterCopyWith<$Res>
    implements $StringWithAggregatesFilterCopyWith<$Res> {
  factory _$$_StringWithAggregatesFilterCopyWith(
          _$_StringWithAggregatesFilter value,
          $Res Function(_$_StringWithAggregatesFilter) then) =
      __$$_StringWithAggregatesFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'mode') QueryMode? mode,
      @JsonKey(name: 'not') StringWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedStringFilter? prisma__min,
      @JsonKey(name: '_max') NestedStringFilter? prisma__max});

  @override
  $StringWithAggregatesFilter_notCopyWith<$Res>? get not;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  @override
  $NestedStringFilterCopyWith<$Res>? get prisma__min;
  @override
  $NestedStringFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class __$$_StringWithAggregatesFilterCopyWithImpl<$Res>
    extends _$StringWithAggregatesFilterCopyWithImpl<$Res,
        _$_StringWithAggregatesFilter>
    implements _$$_StringWithAggregatesFilterCopyWith<$Res> {
  __$$_StringWithAggregatesFilterCopyWithImpl(
      _$_StringWithAggregatesFilter _value,
      $Res Function(_$_StringWithAggregatesFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? mode = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_$_StringWithAggregatesFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as QueryMode?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as StringWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StringWithAggregatesFilter implements _StringWithAggregatesFilter {
  const _$_StringWithAggregatesFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<String>? dart__in,
      @JsonKey(name: 'notIn') final List<String>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'contains') this.contains,
      @JsonKey(name: 'startsWith') this.startsWith,
      @JsonKey(name: 'endsWith') this.endsWith,
      @JsonKey(name: 'mode') this.mode,
      @JsonKey(name: 'not') this.not,
      @JsonKey(name: '_count') this.prisma__count,
      @JsonKey(name: '_min') this.prisma__min,
      @JsonKey(name: '_max') this.prisma__max})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_StringWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$$_StringWithAggregatesFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final String? equals;
  final List<String>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final String? lt;
  @override
  @JsonKey(name: 'lte')
  final String? lte;
  @override
  @JsonKey(name: 'gt')
  final String? gt;
  @override
  @JsonKey(name: 'gte')
  final String? gte;
  @override
  @JsonKey(name: 'contains')
  final String? contains;
  @override
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @override
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @override
  @JsonKey(name: 'mode')
  final QueryMode? mode;
  @override
  @JsonKey(name: 'not')
  final StringWithAggregatesFilter_not? not;
  @override
  @JsonKey(name: '_count')
  final NestedIntFilter? prisma__count;
  @override
  @JsonKey(name: '_min')
  final NestedStringFilter? prisma__min;
  @override
  @JsonKey(name: '_max')
  final NestedStringFilter? prisma__max;

  @override
  String toString() {
    return 'StringWithAggregatesFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, contains: $contains, startsWith: $startsWith, endsWith: $endsWith, mode: $mode, not: $not, prisma__count: $prisma__count, prisma__min: $prisma__min, prisma__max: $prisma__max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringWithAggregatesFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.contains, contains) ||
                other.contains == contains) &&
            (identical(other.startsWith, startsWith) ||
                other.startsWith == startsWith) &&
            (identical(other.endsWith, endsWith) ||
                other.endsWith == endsWith) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.not, not) || other.not == not) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      contains,
      startsWith,
      endsWith,
      mode,
      not,
      prisma__count,
      prisma__min,
      prisma__max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringWithAggregatesFilterCopyWith<_$_StringWithAggregatesFilter>
      get copyWith => __$$_StringWithAggregatesFilterCopyWithImpl<
          _$_StringWithAggregatesFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StringWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class _StringWithAggregatesFilter
    implements StringWithAggregatesFilter {
  const factory _StringWithAggregatesFilter(
          {@JsonKey(name: 'equals') final String? equals,
          @JsonKey(name: 'in') final List<String>? dart__in,
          @JsonKey(name: 'notIn') final List<String>? notIn,
          @JsonKey(name: 'lt') final String? lt,
          @JsonKey(name: 'lte') final String? lte,
          @JsonKey(name: 'gt') final String? gt,
          @JsonKey(name: 'gte') final String? gte,
          @JsonKey(name: 'contains') final String? contains,
          @JsonKey(name: 'startsWith') final String? startsWith,
          @JsonKey(name: 'endsWith') final String? endsWith,
          @JsonKey(name: 'mode') final QueryMode? mode,
          @JsonKey(name: 'not') final StringWithAggregatesFilter_not? not,
          @JsonKey(name: '_count') final NestedIntFilter? prisma__count,
          @JsonKey(name: '_min') final NestedStringFilter? prisma__min,
          @JsonKey(name: '_max') final NestedStringFilter? prisma__max}) =
      _$_StringWithAggregatesFilter;

  factory _StringWithAggregatesFilter.fromJson(Map<String, dynamic> json) =
      _$_StringWithAggregatesFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  String? get equals;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn;
  @override
  @JsonKey(name: 'lt')
  String? get lt;
  @override
  @JsonKey(name: 'lte')
  String? get lte;
  @override
  @JsonKey(name: 'gt')
  String? get gt;
  @override
  @JsonKey(name: 'gte')
  String? get gte;
  @override
  @JsonKey(name: 'contains')
  String? get contains;
  @override
  @JsonKey(name: 'startsWith')
  String? get startsWith;
  @override
  @JsonKey(name: 'endsWith')
  String? get endsWith;
  @override
  @JsonKey(name: 'mode')
  QueryMode? get mode;
  @override
  @JsonKey(name: 'not')
  StringWithAggregatesFilter_not? get not;
  @override
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count;
  @override
  @JsonKey(name: '_min')
  NestedStringFilter? get prisma__min;
  @override
  @JsonKey(name: '_max')
  NestedStringFilter? get prisma__max;
  @override
  @JsonKey(ignore: true)
  _$$_StringWithAggregatesFilterCopyWith<_$_StringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

DateTimeWithAggregatesFilter_not _$DateTimeWithAggregatesFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return DateTimeWithAggregatesFilter_not_withDateTime.fromJson(json);
    case 'withNestedDateTimeWithAggregatesFilter':
      return DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'DateTimeWithAggregatesFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$DateTimeWithAggregatesFilter_not {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeWithAggregatesFilter value)
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            DateTimeWithAggregatesFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeWithAggregatesFilter_notCopyWith<$Res> {
  factory $DateTimeWithAggregatesFilter_notCopyWith(
          DateTimeWithAggregatesFilter_not value,
          $Res Function(DateTimeWithAggregatesFilter_not) then) =
      _$DateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
          DateTimeWithAggregatesFilter_not>;
}

/// @nodoc
class _$DateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
        $Val extends DateTimeWithAggregatesFilter_not>
    implements $DateTimeWithAggregatesFilter_notCopyWith<$Res> {
  _$DateTimeWithAggregatesFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWith<$Res> {
  factory _$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWith(
          _$DateTimeWithAggregatesFilter_not_withDateTime value,
          $Res Function(_$DateTimeWithAggregatesFilter_not_withDateTime) then) =
      __$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl<$Res>
    extends _$DateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
        _$DateTimeWithAggregatesFilter_not_withDateTime>
    implements _$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWith<$Res> {
  __$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl(
      _$DateTimeWithAggregatesFilter_not_withDateTime _value,
      $Res Function(_$DateTimeWithAggregatesFilter_not_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$DateTimeWithAggregatesFilter_not_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DateTimeWithAggregatesFilter_not_withDateTime
    implements DateTimeWithAggregatesFilter_not_withDateTime {
  const _$DateTimeWithAggregatesFilter_not_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$DateTimeWithAggregatesFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$DateTimeWithAggregatesFilter_not_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'DateTimeWithAggregatesFilter_not.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DateTimeWithAggregatesFilter_not_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWith<
          _$DateTimeWithAggregatesFilter_not_withDateTime>
      get copyWith =>
          __$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl<
                  _$DateTimeWithAggregatesFilter_not_withDateTime>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeWithAggregatesFilter value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            DateTimeWithAggregatesFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DateTimeWithAggregatesFilter_not_withDateTimeToJson(
      this,
    );
  }
}

abstract class DateTimeWithAggregatesFilter_not_withDateTime
    implements DateTimeWithAggregatesFilter_not {
  const factory DateTimeWithAggregatesFilter_not_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$DateTimeWithAggregatesFilter_not_withDateTime;

  factory DateTimeWithAggregatesFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$DateTimeWithAggregatesFilter_not_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$DateTimeWithAggregatesFilter_not_withDateTimeCopyWith<
          _$DateTimeWithAggregatesFilter_not_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith(
          _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
              value,
          $Res Function(
                  _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter)
              then) =
      __$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({NestedDateTimeWithAggregatesFilter value});

  $NestedDateTimeWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$DateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
        _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>
    implements
        _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
            $Res> {
  __$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl(
      _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
          _value,
      $Res Function(
              _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeWithAggregatesFilterCopyWith<$Res> get value {
    return $NestedDateTimeWithAggregatesFilterCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
    implements
        DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter {
  const _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedDateTimeWithAggregatesFilter';

  factory _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterFromJson(
          json);

  @override
  final NestedDateTimeWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'DateTimeWithAggregatesFilter_not.withNestedDateTimeWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
          _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>
      get copyWith =>
          __$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl<
                  _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeWithAggregatesFilter value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeWithAggregatesFilter != null) {
      return withNestedDateTimeWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            DateTimeWithAggregatesFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult Function(
            DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeWithAggregatesFilter != null) {
      return withNestedDateTimeWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
    implements DateTimeWithAggregatesFilter_not {
  const factory DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter(
          final NestedDateTimeWithAggregatesFilter value) =
      _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter;

  factory DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
          .fromJson;

  @override
  NestedDateTimeWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
          _$DateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

DateTimeWithAggregatesFilter _$DateTimeWithAggregatesFilterFromJson(
    Map<String, dynamic> json) {
  return _DateTimeWithAggregatesFilter.fromJson(json);
}

/// @nodoc
mixin _$DateTimeWithAggregatesFilter {
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  DateTimeWithAggregatesFilter_not? get not =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count => throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  NestedDateTimeFilter? get prisma__min => throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  NestedDateTimeFilter? get prisma__max => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DateTimeWithAggregatesFilterCopyWith<DateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeWithAggregatesFilterCopyWith<$Res> {
  factory $DateTimeWithAggregatesFilterCopyWith(
          DateTimeWithAggregatesFilter value,
          $Res Function(DateTimeWithAggregatesFilter) then) =
      _$DateTimeWithAggregatesFilterCopyWithImpl<$Res,
          DateTimeWithAggregatesFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') DateTimeWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedDateTimeFilter? prisma__min,
      @JsonKey(name: '_max') NestedDateTimeFilter? prisma__max});

  $DateTimeWithAggregatesFilter_notCopyWith<$Res>? get not;
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__min;
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class _$DateTimeWithAggregatesFilterCopyWithImpl<$Res,
        $Val extends DateTimeWithAggregatesFilter>
    implements $DateTimeWithAggregatesFilterCopyWith<$Res> {
  _$DateTimeWithAggregatesFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as DateTimeWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DateTimeWithAggregatesFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $DateTimeWithAggregatesFilter_notCopyWith<$Res>(_value.not!,
        (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__count!, (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $NestedDateTimeFilterCopyWith<$Res>(_value.prisma__min!, (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $NestedDateTimeFilterCopyWith<$Res>(_value.prisma__max!, (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_DateTimeWithAggregatesFilterCopyWith<$Res>
    implements $DateTimeWithAggregatesFilterCopyWith<$Res> {
  factory _$$_DateTimeWithAggregatesFilterCopyWith(
          _$_DateTimeWithAggregatesFilter value,
          $Res Function(_$_DateTimeWithAggregatesFilter) then) =
      __$$_DateTimeWithAggregatesFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') DateTimeWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedDateTimeFilter? prisma__min,
      @JsonKey(name: '_max') NestedDateTimeFilter? prisma__max});

  @override
  $DateTimeWithAggregatesFilter_notCopyWith<$Res>? get not;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  @override
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__min;
  @override
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class __$$_DateTimeWithAggregatesFilterCopyWithImpl<$Res>
    extends _$DateTimeWithAggregatesFilterCopyWithImpl<$Res,
        _$_DateTimeWithAggregatesFilter>
    implements _$$_DateTimeWithAggregatesFilterCopyWith<$Res> {
  __$$_DateTimeWithAggregatesFilterCopyWithImpl(
      _$_DateTimeWithAggregatesFilter _value,
      $Res Function(_$_DateTimeWithAggregatesFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_$_DateTimeWithAggregatesFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as DateTimeWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DateTimeWithAggregatesFilter implements _DateTimeWithAggregatesFilter {
  const _$_DateTimeWithAggregatesFilter(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson)
          this.equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson)
          final List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson)
          final List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson)
          this.lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson)
          this.lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson)
          this.gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson)
          this.gte,
      @JsonKey(name: 'not')
          this.not,
      @JsonKey(name: '_count')
          this.prisma__count,
      @JsonKey(name: '_min')
          this.prisma__min,
      @JsonKey(name: '_max')
          this.prisma__max})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_DateTimeWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$$_DateTimeWithAggregatesFilterFromJson(json);

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  final DateTime? equals;
  final List<DateTime>? _dart__in;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<DateTime>? _notIn;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  final DateTime? lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  final DateTime? lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  final DateTime? gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  final DateTime? gte;
  @override
  @JsonKey(name: 'not')
  final DateTimeWithAggregatesFilter_not? not;
  @override
  @JsonKey(name: '_count')
  final NestedIntFilter? prisma__count;
  @override
  @JsonKey(name: '_min')
  final NestedDateTimeFilter? prisma__min;
  @override
  @JsonKey(name: '_max')
  final NestedDateTimeFilter? prisma__max;

  @override
  String toString() {
    return 'DateTimeWithAggregatesFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not, prisma__count: $prisma__count, prisma__min: $prisma__min, prisma__max: $prisma__max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DateTimeWithAggregatesFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not,
      prisma__count,
      prisma__min,
      prisma__max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DateTimeWithAggregatesFilterCopyWith<_$_DateTimeWithAggregatesFilter>
      get copyWith => __$$_DateTimeWithAggregatesFilterCopyWithImpl<
          _$_DateTimeWithAggregatesFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DateTimeWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class _DateTimeWithAggregatesFilter
    implements DateTimeWithAggregatesFilter {
  const factory _DateTimeWithAggregatesFilter(
          {@JsonKey(name: 'equals', toJson: dateTimeToJson)
              final DateTime? equals,
          @JsonKey(name: 'in', toJson: dateTimeToJson)
              final List<DateTime>? dart__in,
          @JsonKey(name: 'notIn', toJson: dateTimeToJson)
              final List<DateTime>? notIn,
          @JsonKey(name: 'lt', toJson: dateTimeToJson)
              final DateTime? lt,
          @JsonKey(name: 'lte', toJson: dateTimeToJson)
              final DateTime? lte,
          @JsonKey(name: 'gt', toJson: dateTimeToJson)
              final DateTime? gt,
          @JsonKey(name: 'gte', toJson: dateTimeToJson)
              final DateTime? gte,
          @JsonKey(name: 'not')
              final DateTimeWithAggregatesFilter_not? not,
          @JsonKey(name: '_count')
              final NestedIntFilter? prisma__count,
          @JsonKey(name: '_min')
              final NestedDateTimeFilter? prisma__min,
          @JsonKey(name: '_max')
              final NestedDateTimeFilter? prisma__max}) =
      _$_DateTimeWithAggregatesFilter;

  factory _DateTimeWithAggregatesFilter.fromJson(Map<String, dynamic> json) =
      _$_DateTimeWithAggregatesFilter.fromJson;

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn;
  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte;
  @override
  @JsonKey(name: 'not')
  DateTimeWithAggregatesFilter_not? get not;
  @override
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count;
  @override
  @JsonKey(name: '_min')
  NestedDateTimeFilter? get prisma__min;
  @override
  @JsonKey(name: '_max')
  NestedDateTimeFilter? get prisma__max;
  @override
  @JsonKey(ignore: true)
  _$$_DateTimeWithAggregatesFilterCopyWith<_$_DateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

StringFieldUpdateOperationsInput _$StringFieldUpdateOperationsInputFromJson(
    Map<String, dynamic> json) {
  return _StringFieldUpdateOperationsInput.fromJson(json);
}

/// @nodoc
mixin _$StringFieldUpdateOperationsInput {
  @JsonKey(name: 'set')
  String? get dart__set => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StringFieldUpdateOperationsInputCopyWith<StringFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringFieldUpdateOperationsInputCopyWith<$Res> {
  factory $StringFieldUpdateOperationsInputCopyWith(
          StringFieldUpdateOperationsInput value,
          $Res Function(StringFieldUpdateOperationsInput) then) =
      _$StringFieldUpdateOperationsInputCopyWithImpl<$Res,
          StringFieldUpdateOperationsInput>;
  @useResult
  $Res call({@JsonKey(name: 'set') String? dart__set});
}

/// @nodoc
class _$StringFieldUpdateOperationsInputCopyWithImpl<$Res,
        $Val extends StringFieldUpdateOperationsInput>
    implements $StringFieldUpdateOperationsInputCopyWith<$Res> {
  _$StringFieldUpdateOperationsInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dart__set = freezed,
  }) {
    return _then(_value.copyWith(
      dart__set: freezed == dart__set
          ? _value.dart__set
          : dart__set // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StringFieldUpdateOperationsInputCopyWith<$Res>
    implements $StringFieldUpdateOperationsInputCopyWith<$Res> {
  factory _$$_StringFieldUpdateOperationsInputCopyWith(
          _$_StringFieldUpdateOperationsInput value,
          $Res Function(_$_StringFieldUpdateOperationsInput) then) =
      __$$_StringFieldUpdateOperationsInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'set') String? dart__set});
}

/// @nodoc
class __$$_StringFieldUpdateOperationsInputCopyWithImpl<$Res>
    extends _$StringFieldUpdateOperationsInputCopyWithImpl<$Res,
        _$_StringFieldUpdateOperationsInput>
    implements _$$_StringFieldUpdateOperationsInputCopyWith<$Res> {
  __$$_StringFieldUpdateOperationsInputCopyWithImpl(
      _$_StringFieldUpdateOperationsInput _value,
      $Res Function(_$_StringFieldUpdateOperationsInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dart__set = freezed,
  }) {
    return _then(_$_StringFieldUpdateOperationsInput(
      dart__set: freezed == dart__set
          ? _value.dart__set
          : dart__set // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StringFieldUpdateOperationsInput
    implements _StringFieldUpdateOperationsInput {
  const _$_StringFieldUpdateOperationsInput(
      {@JsonKey(name: 'set') this.dart__set});

  factory _$_StringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_StringFieldUpdateOperationsInputFromJson(json);

  @override
  @JsonKey(name: 'set')
  final String? dart__set;

  @override
  String toString() {
    return 'StringFieldUpdateOperationsInput(dart__set: $dart__set)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringFieldUpdateOperationsInput &&
            (identical(other.dart__set, dart__set) ||
                other.dart__set == dart__set));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, dart__set);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringFieldUpdateOperationsInputCopyWith<
          _$_StringFieldUpdateOperationsInput>
      get copyWith => __$$_StringFieldUpdateOperationsInputCopyWithImpl<
          _$_StringFieldUpdateOperationsInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StringFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class _StringFieldUpdateOperationsInput
    implements StringFieldUpdateOperationsInput {
  const factory _StringFieldUpdateOperationsInput(
          {@JsonKey(name: 'set') final String? dart__set}) =
      _$_StringFieldUpdateOperationsInput;

  factory _StringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> json) = _$_StringFieldUpdateOperationsInput.fromJson;

  @override
  @JsonKey(name: 'set')
  String? get dart__set;
  @override
  @JsonKey(ignore: true)
  _$$_StringFieldUpdateOperationsInputCopyWith<
          _$_StringFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

DateTimeFieldUpdateOperationsInput _$DateTimeFieldUpdateOperationsInputFromJson(
    Map<String, dynamic> json) {
  return _DateTimeFieldUpdateOperationsInput.fromJson(json);
}

/// @nodoc
mixin _$DateTimeFieldUpdateOperationsInput {
  @JsonKey(name: 'set', toJson: dateTimeToJson)
  DateTime? get dart__set => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DateTimeFieldUpdateOperationsInputCopyWith<
          DateTimeFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateTimeFieldUpdateOperationsInputCopyWith<$Res> {
  factory $DateTimeFieldUpdateOperationsInputCopyWith(
          DateTimeFieldUpdateOperationsInput value,
          $Res Function(DateTimeFieldUpdateOperationsInput) then) =
      _$DateTimeFieldUpdateOperationsInputCopyWithImpl<$Res,
          DateTimeFieldUpdateOperationsInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'set', toJson: dateTimeToJson) DateTime? dart__set});
}

/// @nodoc
class _$DateTimeFieldUpdateOperationsInputCopyWithImpl<$Res,
        $Val extends DateTimeFieldUpdateOperationsInput>
    implements $DateTimeFieldUpdateOperationsInputCopyWith<$Res> {
  _$DateTimeFieldUpdateOperationsInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dart__set = freezed,
  }) {
    return _then(_value.copyWith(
      dart__set: freezed == dart__set
          ? _value.dart__set
          : dart__set // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DateTimeFieldUpdateOperationsInputCopyWith<$Res>
    implements $DateTimeFieldUpdateOperationsInputCopyWith<$Res> {
  factory _$$_DateTimeFieldUpdateOperationsInputCopyWith(
          _$_DateTimeFieldUpdateOperationsInput value,
          $Res Function(_$_DateTimeFieldUpdateOperationsInput) then) =
      __$$_DateTimeFieldUpdateOperationsInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'set', toJson: dateTimeToJson) DateTime? dart__set});
}

/// @nodoc
class __$$_DateTimeFieldUpdateOperationsInputCopyWithImpl<$Res>
    extends _$DateTimeFieldUpdateOperationsInputCopyWithImpl<$Res,
        _$_DateTimeFieldUpdateOperationsInput>
    implements _$$_DateTimeFieldUpdateOperationsInputCopyWith<$Res> {
  __$$_DateTimeFieldUpdateOperationsInputCopyWithImpl(
      _$_DateTimeFieldUpdateOperationsInput _value,
      $Res Function(_$_DateTimeFieldUpdateOperationsInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dart__set = freezed,
  }) {
    return _then(_$_DateTimeFieldUpdateOperationsInput(
      dart__set: freezed == dart__set
          ? _value.dart__set
          : dart__set // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DateTimeFieldUpdateOperationsInput
    implements _DateTimeFieldUpdateOperationsInput {
  const _$_DateTimeFieldUpdateOperationsInput(
      {@JsonKey(name: 'set', toJson: dateTimeToJson) this.dart__set});

  factory _$_DateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_DateTimeFieldUpdateOperationsInputFromJson(json);

  @override
  @JsonKey(name: 'set', toJson: dateTimeToJson)
  final DateTime? dart__set;

  @override
  String toString() {
    return 'DateTimeFieldUpdateOperationsInput(dart__set: $dart__set)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DateTimeFieldUpdateOperationsInput &&
            (identical(other.dart__set, dart__set) ||
                other.dart__set == dart__set));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, dart__set);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DateTimeFieldUpdateOperationsInputCopyWith<
          _$_DateTimeFieldUpdateOperationsInput>
      get copyWith => __$$_DateTimeFieldUpdateOperationsInputCopyWithImpl<
          _$_DateTimeFieldUpdateOperationsInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DateTimeFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class _DateTimeFieldUpdateOperationsInput
    implements DateTimeFieldUpdateOperationsInput {
  const factory _DateTimeFieldUpdateOperationsInput(
      {@JsonKey(name: 'set', toJson: dateTimeToJson)
          final DateTime? dart__set}) = _$_DateTimeFieldUpdateOperationsInput;

  factory _DateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =
      _$_DateTimeFieldUpdateOperationsInput.fromJson;

  @override
  @JsonKey(name: 'set', toJson: dateTimeToJson)
  DateTime? get dart__set;
  @override
  @JsonKey(ignore: true)
  _$$_DateTimeFieldUpdateOperationsInputCopyWith<
          _$_DateTimeFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

IntFieldUpdateOperationsInput _$IntFieldUpdateOperationsInputFromJson(
    Map<String, dynamic> json) {
  return _IntFieldUpdateOperationsInput.fromJson(json);
}

/// @nodoc
mixin _$IntFieldUpdateOperationsInput {
  @JsonKey(name: 'set')
  int? get dart__set => throw _privateConstructorUsedError;
  @JsonKey(name: 'increment')
  int? get increment => throw _privateConstructorUsedError;
  @JsonKey(name: 'decrement')
  int? get decrement => throw _privateConstructorUsedError;
  @JsonKey(name: 'multiply')
  int? get multiply => throw _privateConstructorUsedError;
  @JsonKey(name: 'divide')
  int? get divide => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IntFieldUpdateOperationsInputCopyWith<IntFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntFieldUpdateOperationsInputCopyWith<$Res> {
  factory $IntFieldUpdateOperationsInputCopyWith(
          IntFieldUpdateOperationsInput value,
          $Res Function(IntFieldUpdateOperationsInput) then) =
      _$IntFieldUpdateOperationsInputCopyWithImpl<$Res,
          IntFieldUpdateOperationsInput>;
  @useResult
  $Res call(
      {@JsonKey(name: 'set') int? dart__set,
      @JsonKey(name: 'increment') int? increment,
      @JsonKey(name: 'decrement') int? decrement,
      @JsonKey(name: 'multiply') int? multiply,
      @JsonKey(name: 'divide') int? divide});
}

/// @nodoc
class _$IntFieldUpdateOperationsInputCopyWithImpl<$Res,
        $Val extends IntFieldUpdateOperationsInput>
    implements $IntFieldUpdateOperationsInputCopyWith<$Res> {
  _$IntFieldUpdateOperationsInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dart__set = freezed,
    Object? increment = freezed,
    Object? decrement = freezed,
    Object? multiply = freezed,
    Object? divide = freezed,
  }) {
    return _then(_value.copyWith(
      dart__set: freezed == dart__set
          ? _value.dart__set
          : dart__set // ignore: cast_nullable_to_non_nullable
              as int?,
      increment: freezed == increment
          ? _value.increment
          : increment // ignore: cast_nullable_to_non_nullable
              as int?,
      decrement: freezed == decrement
          ? _value.decrement
          : decrement // ignore: cast_nullable_to_non_nullable
              as int?,
      multiply: freezed == multiply
          ? _value.multiply
          : multiply // ignore: cast_nullable_to_non_nullable
              as int?,
      divide: freezed == divide
          ? _value.divide
          : divide // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_IntFieldUpdateOperationsInputCopyWith<$Res>
    implements $IntFieldUpdateOperationsInputCopyWith<$Res> {
  factory _$$_IntFieldUpdateOperationsInputCopyWith(
          _$_IntFieldUpdateOperationsInput value,
          $Res Function(_$_IntFieldUpdateOperationsInput) then) =
      __$$_IntFieldUpdateOperationsInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'set') int? dart__set,
      @JsonKey(name: 'increment') int? increment,
      @JsonKey(name: 'decrement') int? decrement,
      @JsonKey(name: 'multiply') int? multiply,
      @JsonKey(name: 'divide') int? divide});
}

/// @nodoc
class __$$_IntFieldUpdateOperationsInputCopyWithImpl<$Res>
    extends _$IntFieldUpdateOperationsInputCopyWithImpl<$Res,
        _$_IntFieldUpdateOperationsInput>
    implements _$$_IntFieldUpdateOperationsInputCopyWith<$Res> {
  __$$_IntFieldUpdateOperationsInputCopyWithImpl(
      _$_IntFieldUpdateOperationsInput _value,
      $Res Function(_$_IntFieldUpdateOperationsInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dart__set = freezed,
    Object? increment = freezed,
    Object? decrement = freezed,
    Object? multiply = freezed,
    Object? divide = freezed,
  }) {
    return _then(_$_IntFieldUpdateOperationsInput(
      dart__set: freezed == dart__set
          ? _value.dart__set
          : dart__set // ignore: cast_nullable_to_non_nullable
              as int?,
      increment: freezed == increment
          ? _value.increment
          : increment // ignore: cast_nullable_to_non_nullable
              as int?,
      decrement: freezed == decrement
          ? _value.decrement
          : decrement // ignore: cast_nullable_to_non_nullable
              as int?,
      multiply: freezed == multiply
          ? _value.multiply
          : multiply // ignore: cast_nullable_to_non_nullable
              as int?,
      divide: freezed == divide
          ? _value.divide
          : divide // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IntFieldUpdateOperationsInput
    implements _IntFieldUpdateOperationsInput {
  const _$_IntFieldUpdateOperationsInput(
      {@JsonKey(name: 'set') this.dart__set,
      @JsonKey(name: 'increment') this.increment,
      @JsonKey(name: 'decrement') this.decrement,
      @JsonKey(name: 'multiply') this.multiply,
      @JsonKey(name: 'divide') this.divide});

  factory _$_IntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_IntFieldUpdateOperationsInputFromJson(json);

  @override
  @JsonKey(name: 'set')
  final int? dart__set;
  @override
  @JsonKey(name: 'increment')
  final int? increment;
  @override
  @JsonKey(name: 'decrement')
  final int? decrement;
  @override
  @JsonKey(name: 'multiply')
  final int? multiply;
  @override
  @JsonKey(name: 'divide')
  final int? divide;

  @override
  String toString() {
    return 'IntFieldUpdateOperationsInput(dart__set: $dart__set, increment: $increment, decrement: $decrement, multiply: $multiply, divide: $divide)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntFieldUpdateOperationsInput &&
            (identical(other.dart__set, dart__set) ||
                other.dart__set == dart__set) &&
            (identical(other.increment, increment) ||
                other.increment == increment) &&
            (identical(other.decrement, decrement) ||
                other.decrement == decrement) &&
            (identical(other.multiply, multiply) ||
                other.multiply == multiply) &&
            (identical(other.divide, divide) || other.divide == divide));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, dart__set, increment, decrement, multiply, divide);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntFieldUpdateOperationsInputCopyWith<_$_IntFieldUpdateOperationsInput>
      get copyWith => __$$_IntFieldUpdateOperationsInputCopyWithImpl<
          _$_IntFieldUpdateOperationsInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IntFieldUpdateOperationsInputToJson(
      this,
    );
  }
}

abstract class _IntFieldUpdateOperationsInput
    implements IntFieldUpdateOperationsInput {
  const factory _IntFieldUpdateOperationsInput(
          {@JsonKey(name: 'set') final int? dart__set,
          @JsonKey(name: 'increment') final int? increment,
          @JsonKey(name: 'decrement') final int? decrement,
          @JsonKey(name: 'multiply') final int? multiply,
          @JsonKey(name: 'divide') final int? divide}) =
      _$_IntFieldUpdateOperationsInput;

  factory _IntFieldUpdateOperationsInput.fromJson(Map<String, dynamic> json) =
      _$_IntFieldUpdateOperationsInput.fromJson;

  @override
  @JsonKey(name: 'set')
  int? get dart__set;
  @override
  @JsonKey(name: 'increment')
  int? get increment;
  @override
  @JsonKey(name: 'decrement')
  int? get decrement;
  @override
  @JsonKey(name: 'multiply')
  int? get multiply;
  @override
  @JsonKey(name: 'divide')
  int? get divide;
  @override
  @JsonKey(ignore: true)
  _$$_IntFieldUpdateOperationsInputCopyWith<_$_IntFieldUpdateOperationsInput>
      get copyWith => throw _privateConstructorUsedError;
}

NestedIntFilter_not _$NestedIntFilter_notFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withInt':
      return NestedIntFilter_not_withInt.fromJson(json);
    case 'withNestedIntFilter':
      return NestedIntFilter_not_withNestedIntFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'NestedIntFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedIntFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntFilter value) withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntFilter value)? withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntFilter value)? withNestedIntFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedIntFilter_not_withInt value) withInt,
    required TResult Function(NestedIntFilter_not_withNestedIntFilter value)
        withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedIntFilter_not_withInt value)? withInt,
    TResult? Function(NestedIntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedIntFilter_not_withInt value)? withInt,
    TResult Function(NestedIntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedIntFilter_notCopyWith<$Res> {
  factory $NestedIntFilter_notCopyWith(
          NestedIntFilter_not value, $Res Function(NestedIntFilter_not) then) =
      _$NestedIntFilter_notCopyWithImpl<$Res, NestedIntFilter_not>;
}

/// @nodoc
class _$NestedIntFilter_notCopyWithImpl<$Res, $Val extends NestedIntFilter_not>
    implements $NestedIntFilter_notCopyWith<$Res> {
  _$NestedIntFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedIntFilter_not_withIntCopyWith<$Res> {
  factory _$$NestedIntFilter_not_withIntCopyWith(
          _$NestedIntFilter_not_withInt value,
          $Res Function(_$NestedIntFilter_not_withInt) then) =
      __$$NestedIntFilter_not_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$NestedIntFilter_not_withIntCopyWithImpl<$Res>
    extends _$NestedIntFilter_notCopyWithImpl<$Res,
        _$NestedIntFilter_not_withInt>
    implements _$$NestedIntFilter_not_withIntCopyWith<$Res> {
  __$$NestedIntFilter_not_withIntCopyWithImpl(
      _$NestedIntFilter_not_withInt _value,
      $Res Function(_$NestedIntFilter_not_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedIntFilter_not_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedIntFilter_not_withInt implements NestedIntFilter_not_withInt {
  const _$NestedIntFilter_not_withInt(this.value, {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$NestedIntFilter_not_withInt.fromJson(Map<String, dynamic> json) =>
      _$$NestedIntFilter_not_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedIntFilter_not.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedIntFilter_not_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedIntFilter_not_withIntCopyWith<_$NestedIntFilter_not_withInt>
      get copyWith => __$$NestedIntFilter_not_withIntCopyWithImpl<
          _$NestedIntFilter_not_withInt>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntFilter value) withNestedIntFilter,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntFilter value)? withNestedIntFilter,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntFilter value)? withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedIntFilter_not_withInt value) withInt,
    required TResult Function(NestedIntFilter_not_withNestedIntFilter value)
        withNestedIntFilter,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedIntFilter_not_withInt value)? withInt,
    TResult? Function(NestedIntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedIntFilter_not_withInt value)? withInt,
    TResult Function(NestedIntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedIntFilter_not_withIntToJson(
      this,
    );
  }
}

abstract class NestedIntFilter_not_withInt implements NestedIntFilter_not {
  const factory NestedIntFilter_not_withInt(final int value) =
      _$NestedIntFilter_not_withInt;

  factory NestedIntFilter_not_withInt.fromJson(Map<String, dynamic> json) =
      _$NestedIntFilter_not_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$NestedIntFilter_not_withIntCopyWith<_$NestedIntFilter_not_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedIntFilter_not_withNestedIntFilterCopyWith<$Res> {
  factory _$$NestedIntFilter_not_withNestedIntFilterCopyWith(
          _$NestedIntFilter_not_withNestedIntFilter value,
          $Res Function(_$NestedIntFilter_not_withNestedIntFilter) then) =
      __$$NestedIntFilter_not_withNestedIntFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedIntFilter value});

  $NestedIntFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedIntFilter_not_withNestedIntFilterCopyWithImpl<$Res>
    extends _$NestedIntFilter_notCopyWithImpl<$Res,
        _$NestedIntFilter_not_withNestedIntFilter>
    implements _$$NestedIntFilter_not_withNestedIntFilterCopyWith<$Res> {
  __$$NestedIntFilter_not_withNestedIntFilterCopyWithImpl(
      _$NestedIntFilter_not_withNestedIntFilter _value,
      $Res Function(_$NestedIntFilter_not_withNestedIntFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedIntFilter_not_withNestedIntFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res> get value {
    return $NestedIntFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedIntFilter_not_withNestedIntFilter
    implements NestedIntFilter_not_withNestedIntFilter {
  const _$NestedIntFilter_not_withNestedIntFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedIntFilter';

  factory _$NestedIntFilter_not_withNestedIntFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedIntFilter_not_withNestedIntFilterFromJson(json);

  @override
  final NestedIntFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedIntFilter_not.withNestedIntFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedIntFilter_not_withNestedIntFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedIntFilter_not_withNestedIntFilterCopyWith<
          _$NestedIntFilter_not_withNestedIntFilter>
      get copyWith => __$$NestedIntFilter_not_withNestedIntFilterCopyWithImpl<
          _$NestedIntFilter_not_withNestedIntFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntFilter value) withNestedIntFilter,
  }) {
    return withNestedIntFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntFilter value)? withNestedIntFilter,
  }) {
    return withNestedIntFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntFilter value)? withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntFilter != null) {
      return withNestedIntFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedIntFilter_not_withInt value) withInt,
    required TResult Function(NestedIntFilter_not_withNestedIntFilter value)
        withNestedIntFilter,
  }) {
    return withNestedIntFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedIntFilter_not_withInt value)? withInt,
    TResult? Function(NestedIntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
  }) {
    return withNestedIntFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedIntFilter_not_withInt value)? withInt,
    TResult Function(NestedIntFilter_not_withNestedIntFilter value)?
        withNestedIntFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntFilter != null) {
      return withNestedIntFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedIntFilter_not_withNestedIntFilterToJson(
      this,
    );
  }
}

abstract class NestedIntFilter_not_withNestedIntFilter
    implements NestedIntFilter_not {
  const factory NestedIntFilter_not_withNestedIntFilter(
      final NestedIntFilter value) = _$NestedIntFilter_not_withNestedIntFilter;

  factory NestedIntFilter_not_withNestedIntFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedIntFilter_not_withNestedIntFilter.fromJson;

  @override
  NestedIntFilter get value;
  @JsonKey(ignore: true)
  _$$NestedIntFilter_not_withNestedIntFilterCopyWith<
          _$NestedIntFilter_not_withNestedIntFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedIntFilter _$NestedIntFilterFromJson(Map<String, dynamic> json) {
  return _NestedIntFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedIntFilter {
  @JsonKey(name: 'equals')
  int? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<int>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<int>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  int? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  int? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  int? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  int? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedIntFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedIntFilterCopyWith<NestedIntFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedIntFilterCopyWith<$Res> {
  factory $NestedIntFilterCopyWith(
          NestedIntFilter value, $Res Function(NestedIntFilter) then) =
      _$NestedIntFilterCopyWithImpl<$Res, NestedIntFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') NestedIntFilter_not? not});

  $NestedIntFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$NestedIntFilterCopyWithImpl<$Res, $Val extends NestedIntFilter>
    implements $NestedIntFilterCopyWith<$Res> {
  _$NestedIntFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedIntFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedIntFilterCopyWith<$Res>
    implements $NestedIntFilterCopyWith<$Res> {
  factory _$$_NestedIntFilterCopyWith(
          _$_NestedIntFilter value, $Res Function(_$_NestedIntFilter) then) =
      __$$_NestedIntFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') NestedIntFilter_not? not});

  @override
  $NestedIntFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_NestedIntFilterCopyWithImpl<$Res>
    extends _$NestedIntFilterCopyWithImpl<$Res, _$_NestedIntFilter>
    implements _$$_NestedIntFilterCopyWith<$Res> {
  __$$_NestedIntFilterCopyWithImpl(
      _$_NestedIntFilter _value, $Res Function(_$_NestedIntFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_NestedIntFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedIntFilter implements _NestedIntFilter {
  const _$_NestedIntFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<int>? dart__in,
      @JsonKey(name: 'notIn') final List<int>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'not') this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedIntFilter.fromJson(Map<String, dynamic> json) =>
      _$$_NestedIntFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final int? equals;
  final List<int>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final int? lt;
  @override
  @JsonKey(name: 'lte')
  final int? lte;
  @override
  @JsonKey(name: 'gt')
  final int? gt;
  @override
  @JsonKey(name: 'gte')
  final int? gte;
  @override
  @JsonKey(name: 'not')
  final NestedIntFilter_not? not;

  @override
  String toString() {
    return 'NestedIntFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedIntFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedIntFilterCopyWith<_$_NestedIntFilter> get copyWith =>
      __$$_NestedIntFilterCopyWithImpl<_$_NestedIntFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedIntFilterToJson(
      this,
    );
  }
}

abstract class _NestedIntFilter implements NestedIntFilter {
  const factory _NestedIntFilter(
          {@JsonKey(name: 'equals') final int? equals,
          @JsonKey(name: 'in') final List<int>? dart__in,
          @JsonKey(name: 'notIn') final List<int>? notIn,
          @JsonKey(name: 'lt') final int? lt,
          @JsonKey(name: 'lte') final int? lte,
          @JsonKey(name: 'gt') final int? gt,
          @JsonKey(name: 'gte') final int? gte,
          @JsonKey(name: 'not') final NestedIntFilter_not? not}) =
      _$_NestedIntFilter;

  factory _NestedIntFilter.fromJson(Map<String, dynamic> json) =
      _$_NestedIntFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  int? get equals;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn;
  @override
  @JsonKey(name: 'lt')
  int? get lt;
  @override
  @JsonKey(name: 'lte')
  int? get lte;
  @override
  @JsonKey(name: 'gt')
  int? get gt;
  @override
  @JsonKey(name: 'gte')
  int? get gte;
  @override
  @JsonKey(name: 'not')
  NestedIntFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_NestedIntFilterCopyWith<_$_NestedIntFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

NestedStringFilter_not _$NestedStringFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return NestedStringFilter_not_withString.fromJson(json);
    case 'withNestedStringFilter':
      return NestedStringFilter_not_withNestedStringFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'NestedStringFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedStringFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringFilter value) withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringFilter value)? withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringFilter value)? withNestedStringFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedStringFilter_not_withString value)
        withString,
    required TResult Function(
            NestedStringFilter_not_withNestedStringFilter value)
        withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedStringFilter_not_withString value)? withString,
    TResult? Function(NestedStringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedStringFilter_not_withString value)? withString,
    TResult Function(NestedStringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedStringFilter_notCopyWith<$Res> {
  factory $NestedStringFilter_notCopyWith(NestedStringFilter_not value,
          $Res Function(NestedStringFilter_not) then) =
      _$NestedStringFilter_notCopyWithImpl<$Res, NestedStringFilter_not>;
}

/// @nodoc
class _$NestedStringFilter_notCopyWithImpl<$Res,
        $Val extends NestedStringFilter_not>
    implements $NestedStringFilter_notCopyWith<$Res> {
  _$NestedStringFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedStringFilter_not_withStringCopyWith<$Res> {
  factory _$$NestedStringFilter_not_withStringCopyWith(
          _$NestedStringFilter_not_withString value,
          $Res Function(_$NestedStringFilter_not_withString) then) =
      __$$NestedStringFilter_not_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$NestedStringFilter_not_withStringCopyWithImpl<$Res>
    extends _$NestedStringFilter_notCopyWithImpl<$Res,
        _$NestedStringFilter_not_withString>
    implements _$$NestedStringFilter_not_withStringCopyWith<$Res> {
  __$$NestedStringFilter_not_withStringCopyWithImpl(
      _$NestedStringFilter_not_withString _value,
      $Res Function(_$NestedStringFilter_not_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedStringFilter_not_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedStringFilter_not_withString
    implements NestedStringFilter_not_withString {
  const _$NestedStringFilter_not_withString(this.value, {final String? $type})
      : $type = $type ?? 'withString';

  factory _$NestedStringFilter_not_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedStringFilter_not_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedStringFilter_not.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedStringFilter_not_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedStringFilter_not_withStringCopyWith<
          _$NestedStringFilter_not_withString>
      get copyWith => __$$NestedStringFilter_not_withStringCopyWithImpl<
          _$NestedStringFilter_not_withString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringFilter value) withNestedStringFilter,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringFilter value)? withNestedStringFilter,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringFilter value)? withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedStringFilter_not_withString value)
        withString,
    required TResult Function(
            NestedStringFilter_not_withNestedStringFilter value)
        withNestedStringFilter,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedStringFilter_not_withString value)? withString,
    TResult? Function(NestedStringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedStringFilter_not_withString value)? withString,
    TResult Function(NestedStringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedStringFilter_not_withStringToJson(
      this,
    );
  }
}

abstract class NestedStringFilter_not_withString
    implements NestedStringFilter_not {
  const factory NestedStringFilter_not_withString(final String value) =
      _$NestedStringFilter_not_withString;

  factory NestedStringFilter_not_withString.fromJson(
      Map<String, dynamic> json) = _$NestedStringFilter_not_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$NestedStringFilter_not_withStringCopyWith<
          _$NestedStringFilter_not_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedStringFilter_not_withNestedStringFilterCopyWith<$Res> {
  factory _$$NestedStringFilter_not_withNestedStringFilterCopyWith(
          _$NestedStringFilter_not_withNestedStringFilter value,
          $Res Function(_$NestedStringFilter_not_withNestedStringFilter) then) =
      __$$NestedStringFilter_not_withNestedStringFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedStringFilter value});

  $NestedStringFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedStringFilter_not_withNestedStringFilterCopyWithImpl<$Res>
    extends _$NestedStringFilter_notCopyWithImpl<$Res,
        _$NestedStringFilter_not_withNestedStringFilter>
    implements _$$NestedStringFilter_not_withNestedStringFilterCopyWith<$Res> {
  __$$NestedStringFilter_not_withNestedStringFilterCopyWithImpl(
      _$NestedStringFilter_not_withNestedStringFilter _value,
      $Res Function(_$NestedStringFilter_not_withNestedStringFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedStringFilter_not_withNestedStringFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilterCopyWith<$Res> get value {
    return $NestedStringFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedStringFilter_not_withNestedStringFilter
    implements NestedStringFilter_not_withNestedStringFilter {
  const _$NestedStringFilter_not_withNestedStringFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedStringFilter';

  factory _$NestedStringFilter_not_withNestedStringFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedStringFilter_not_withNestedStringFilterFromJson(json);

  @override
  final NestedStringFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedStringFilter_not.withNestedStringFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedStringFilter_not_withNestedStringFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedStringFilter_not_withNestedStringFilterCopyWith<
          _$NestedStringFilter_not_withNestedStringFilter>
      get copyWith =>
          __$$NestedStringFilter_not_withNestedStringFilterCopyWithImpl<
                  _$NestedStringFilter_not_withNestedStringFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringFilter value) withNestedStringFilter,
  }) {
    return withNestedStringFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringFilter value)? withNestedStringFilter,
  }) {
    return withNestedStringFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringFilter value)? withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringFilter != null) {
      return withNestedStringFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedStringFilter_not_withString value)
        withString,
    required TResult Function(
            NestedStringFilter_not_withNestedStringFilter value)
        withNestedStringFilter,
  }) {
    return withNestedStringFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedStringFilter_not_withString value)? withString,
    TResult? Function(NestedStringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
  }) {
    return withNestedStringFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedStringFilter_not_withString value)? withString,
    TResult Function(NestedStringFilter_not_withNestedStringFilter value)?
        withNestedStringFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringFilter != null) {
      return withNestedStringFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedStringFilter_not_withNestedStringFilterToJson(
      this,
    );
  }
}

abstract class NestedStringFilter_not_withNestedStringFilter
    implements NestedStringFilter_not {
  const factory NestedStringFilter_not_withNestedStringFilter(
          final NestedStringFilter value) =
      _$NestedStringFilter_not_withNestedStringFilter;

  factory NestedStringFilter_not_withNestedStringFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedStringFilter_not_withNestedStringFilter.fromJson;

  @override
  NestedStringFilter get value;
  @JsonKey(ignore: true)
  _$$NestedStringFilter_not_withNestedStringFilterCopyWith<
          _$NestedStringFilter_not_withNestedStringFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedStringFilter _$NestedStringFilterFromJson(Map<String, dynamic> json) {
  return _NestedStringFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedStringFilter {
  @JsonKey(name: 'equals')
  String? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<String>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<String>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  String? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  String? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  String? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  String? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'contains')
  String? get contains => throw _privateConstructorUsedError;
  @JsonKey(name: 'startsWith')
  String? get startsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'endsWith')
  String? get endsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedStringFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedStringFilterCopyWith<NestedStringFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedStringFilterCopyWith<$Res> {
  factory $NestedStringFilterCopyWith(
          NestedStringFilter value, $Res Function(NestedStringFilter) then) =
      _$NestedStringFilterCopyWithImpl<$Res, NestedStringFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'not') NestedStringFilter_not? not});

  $NestedStringFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$NestedStringFilterCopyWithImpl<$Res, $Val extends NestedStringFilter>
    implements $NestedStringFilterCopyWith<$Res> {
  _$NestedStringFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedStringFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedStringFilterCopyWith<$Res>
    implements $NestedStringFilterCopyWith<$Res> {
  factory _$$_NestedStringFilterCopyWith(_$_NestedStringFilter value,
          $Res Function(_$_NestedStringFilter) then) =
      __$$_NestedStringFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'not') NestedStringFilter_not? not});

  @override
  $NestedStringFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_NestedStringFilterCopyWithImpl<$Res>
    extends _$NestedStringFilterCopyWithImpl<$Res, _$_NestedStringFilter>
    implements _$$_NestedStringFilterCopyWith<$Res> {
  __$$_NestedStringFilterCopyWithImpl(
      _$_NestedStringFilter _value, $Res Function(_$_NestedStringFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_NestedStringFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedStringFilter implements _NestedStringFilter {
  const _$_NestedStringFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<String>? dart__in,
      @JsonKey(name: 'notIn') final List<String>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'contains') this.contains,
      @JsonKey(name: 'startsWith') this.startsWith,
      @JsonKey(name: 'endsWith') this.endsWith,
      @JsonKey(name: 'not') this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedStringFilter.fromJson(Map<String, dynamic> json) =>
      _$$_NestedStringFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final String? equals;
  final List<String>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final String? lt;
  @override
  @JsonKey(name: 'lte')
  final String? lte;
  @override
  @JsonKey(name: 'gt')
  final String? gt;
  @override
  @JsonKey(name: 'gte')
  final String? gte;
  @override
  @JsonKey(name: 'contains')
  final String? contains;
  @override
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @override
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @override
  @JsonKey(name: 'not')
  final NestedStringFilter_not? not;

  @override
  String toString() {
    return 'NestedStringFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, contains: $contains, startsWith: $startsWith, endsWith: $endsWith, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedStringFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.contains, contains) ||
                other.contains == contains) &&
            (identical(other.startsWith, startsWith) ||
                other.startsWith == startsWith) &&
            (identical(other.endsWith, endsWith) ||
                other.endsWith == endsWith) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      contains,
      startsWith,
      endsWith,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedStringFilterCopyWith<_$_NestedStringFilter> get copyWith =>
      __$$_NestedStringFilterCopyWithImpl<_$_NestedStringFilter>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedStringFilterToJson(
      this,
    );
  }
}

abstract class _NestedStringFilter implements NestedStringFilter {
  const factory _NestedStringFilter(
          {@JsonKey(name: 'equals') final String? equals,
          @JsonKey(name: 'in') final List<String>? dart__in,
          @JsonKey(name: 'notIn') final List<String>? notIn,
          @JsonKey(name: 'lt') final String? lt,
          @JsonKey(name: 'lte') final String? lte,
          @JsonKey(name: 'gt') final String? gt,
          @JsonKey(name: 'gte') final String? gte,
          @JsonKey(name: 'contains') final String? contains,
          @JsonKey(name: 'startsWith') final String? startsWith,
          @JsonKey(name: 'endsWith') final String? endsWith,
          @JsonKey(name: 'not') final NestedStringFilter_not? not}) =
      _$_NestedStringFilter;

  factory _NestedStringFilter.fromJson(Map<String, dynamic> json) =
      _$_NestedStringFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  String? get equals;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn;
  @override
  @JsonKey(name: 'lt')
  String? get lt;
  @override
  @JsonKey(name: 'lte')
  String? get lte;
  @override
  @JsonKey(name: 'gt')
  String? get gt;
  @override
  @JsonKey(name: 'gte')
  String? get gte;
  @override
  @JsonKey(name: 'contains')
  String? get contains;
  @override
  @JsonKey(name: 'startsWith')
  String? get startsWith;
  @override
  @JsonKey(name: 'endsWith')
  String? get endsWith;
  @override
  @JsonKey(name: 'not')
  NestedStringFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_NestedStringFilterCopyWith<_$_NestedStringFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

NestedDateTimeFilter_not _$NestedDateTimeFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return NestedDateTimeFilter_not_withDateTime.fromJson(json);
    case 'withNestedDateTimeFilter':
      return NestedDateTimeFilter_not_withNestedDateTimeFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'NestedDateTimeFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedDateTimeFilter_not {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedDateTimeFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            NestedDateTimeFilter_not_withNestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedDateTimeFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedDateTimeFilter_not_withDateTime value)? withDateTime,
    TResult Function(NestedDateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedDateTimeFilter_notCopyWith<$Res> {
  factory $NestedDateTimeFilter_notCopyWith(NestedDateTimeFilter_not value,
          $Res Function(NestedDateTimeFilter_not) then) =
      _$NestedDateTimeFilter_notCopyWithImpl<$Res, NestedDateTimeFilter_not>;
}

/// @nodoc
class _$NestedDateTimeFilter_notCopyWithImpl<$Res,
        $Val extends NestedDateTimeFilter_not>
    implements $NestedDateTimeFilter_notCopyWith<$Res> {
  _$NestedDateTimeFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedDateTimeFilter_not_withDateTimeCopyWith<$Res> {
  factory _$$NestedDateTimeFilter_not_withDateTimeCopyWith(
          _$NestedDateTimeFilter_not_withDateTime value,
          $Res Function(_$NestedDateTimeFilter_not_withDateTime) then) =
      __$$NestedDateTimeFilter_not_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$NestedDateTimeFilter_not_withDateTimeCopyWithImpl<$Res>
    extends _$NestedDateTimeFilter_notCopyWithImpl<$Res,
        _$NestedDateTimeFilter_not_withDateTime>
    implements _$$NestedDateTimeFilter_not_withDateTimeCopyWith<$Res> {
  __$$NestedDateTimeFilter_not_withDateTimeCopyWithImpl(
      _$NestedDateTimeFilter_not_withDateTime _value,
      $Res Function(_$NestedDateTimeFilter_not_withDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedDateTimeFilter_not_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedDateTimeFilter_not_withDateTime
    implements NestedDateTimeFilter_not_withDateTime {
  const _$NestedDateTimeFilter_not_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$NestedDateTimeFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedDateTimeFilter_not_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedDateTimeFilter_not.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedDateTimeFilter_not_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedDateTimeFilter_not_withDateTimeCopyWith<
          _$NestedDateTimeFilter_not_withDateTime>
      get copyWith => __$$NestedDateTimeFilter_not_withDateTimeCopyWithImpl<
          _$NestedDateTimeFilter_not_withDateTime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedDateTimeFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            NestedDateTimeFilter_not_withNestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedDateTimeFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedDateTimeFilter_not_withDateTime value)? withDateTime,
    TResult Function(NestedDateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedDateTimeFilter_not_withDateTimeToJson(
      this,
    );
  }
}

abstract class NestedDateTimeFilter_not_withDateTime
    implements NestedDateTimeFilter_not {
  const factory NestedDateTimeFilter_not_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$NestedDateTimeFilter_not_withDateTime;

  factory NestedDateTimeFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$NestedDateTimeFilter_not_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$NestedDateTimeFilter_not_withDateTimeCopyWith<
          _$NestedDateTimeFilter_not_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWith<
    $Res> {
  factory _$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWith(
          _$NestedDateTimeFilter_not_withNestedDateTimeFilter value,
          $Res Function(_$NestedDateTimeFilter_not_withNestedDateTimeFilter)
              then) =
      __$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedDateTimeFilter value});

  $NestedDateTimeFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl<$Res>
    extends _$NestedDateTimeFilter_notCopyWithImpl<$Res,
        _$NestedDateTimeFilter_not_withNestedDateTimeFilter>
    implements
        _$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWith<$Res> {
  __$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl(
      _$NestedDateTimeFilter_not_withNestedDateTimeFilter _value,
      $Res Function(_$NestedDateTimeFilter_not_withNestedDateTimeFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedDateTimeFilter_not_withNestedDateTimeFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilterCopyWith<$Res> get value {
    return $NestedDateTimeFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedDateTimeFilter_not_withNestedDateTimeFilter
    implements NestedDateTimeFilter_not_withNestedDateTimeFilter {
  const _$NestedDateTimeFilter_not_withNestedDateTimeFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedDateTimeFilter';

  factory _$NestedDateTimeFilter_not_withNestedDateTimeFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedDateTimeFilter_not_withNestedDateTimeFilterFromJson(json);

  @override
  final NestedDateTimeFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedDateTimeFilter_not.withNestedDateTimeFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedDateTimeFilter_not_withNestedDateTimeFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWith<
          _$NestedDateTimeFilter_not_withNestedDateTimeFilter>
      get copyWith =>
          __$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWithImpl<
                  _$NestedDateTimeFilter_not_withNestedDateTimeFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeFilter value)? withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeFilter != null) {
      return withNestedDateTimeFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedDateTimeFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            NestedDateTimeFilter_not_withNestedDateTimeFilter value)
        withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedDateTimeFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
  }) {
    return withNestedDateTimeFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedDateTimeFilter_not_withDateTime value)? withDateTime,
    TResult Function(NestedDateTimeFilter_not_withNestedDateTimeFilter value)?
        withNestedDateTimeFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeFilter != null) {
      return withNestedDateTimeFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedDateTimeFilter_not_withNestedDateTimeFilterToJson(
      this,
    );
  }
}

abstract class NestedDateTimeFilter_not_withNestedDateTimeFilter
    implements NestedDateTimeFilter_not {
  const factory NestedDateTimeFilter_not_withNestedDateTimeFilter(
          final NestedDateTimeFilter value) =
      _$NestedDateTimeFilter_not_withNestedDateTimeFilter;

  factory NestedDateTimeFilter_not_withNestedDateTimeFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedDateTimeFilter_not_withNestedDateTimeFilter.fromJson;

  @override
  NestedDateTimeFilter get value;
  @JsonKey(ignore: true)
  _$$NestedDateTimeFilter_not_withNestedDateTimeFilterCopyWith<
          _$NestedDateTimeFilter_not_withNestedDateTimeFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedDateTimeFilter _$NestedDateTimeFilterFromJson(Map<String, dynamic> json) {
  return _NestedDateTimeFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedDateTimeFilter {
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedDateTimeFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedDateTimeFilterCopyWith<NestedDateTimeFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedDateTimeFilterCopyWith<$Res> {
  factory $NestedDateTimeFilterCopyWith(NestedDateTimeFilter value,
          $Res Function(NestedDateTimeFilter) then) =
      _$NestedDateTimeFilterCopyWithImpl<$Res, NestedDateTimeFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') NestedDateTimeFilter_not? not});

  $NestedDateTimeFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$NestedDateTimeFilterCopyWithImpl<$Res,
        $Val extends NestedDateTimeFilter>
    implements $NestedDateTimeFilterCopyWith<$Res> {
  _$NestedDateTimeFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedDateTimeFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedDateTimeFilterCopyWith<$Res>
    implements $NestedDateTimeFilterCopyWith<$Res> {
  factory _$$_NestedDateTimeFilterCopyWith(_$_NestedDateTimeFilter value,
          $Res Function(_$_NestedDateTimeFilter) then) =
      __$$_NestedDateTimeFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') NestedDateTimeFilter_not? not});

  @override
  $NestedDateTimeFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_NestedDateTimeFilterCopyWithImpl<$Res>
    extends _$NestedDateTimeFilterCopyWithImpl<$Res, _$_NestedDateTimeFilter>
    implements _$$_NestedDateTimeFilterCopyWith<$Res> {
  __$$_NestedDateTimeFilterCopyWithImpl(_$_NestedDateTimeFilter _value,
      $Res Function(_$_NestedDateTimeFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_NestedDateTimeFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedDateTimeFilter implements _NestedDateTimeFilter {
  const _$_NestedDateTimeFilter(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson)
          this.equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson)
          final List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson)
          final List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson)
          this.lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson)
          this.lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson)
          this.gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson)
          this.gte,
      @JsonKey(name: 'not')
          this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedDateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$$_NestedDateTimeFilterFromJson(json);

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  final DateTime? equals;
  final List<DateTime>? _dart__in;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<DateTime>? _notIn;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  final DateTime? lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  final DateTime? lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  final DateTime? gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  final DateTime? gte;
  @override
  @JsonKey(name: 'not')
  final NestedDateTimeFilter_not? not;

  @override
  String toString() {
    return 'NestedDateTimeFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedDateTimeFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedDateTimeFilterCopyWith<_$_NestedDateTimeFilter> get copyWith =>
      __$$_NestedDateTimeFilterCopyWithImpl<_$_NestedDateTimeFilter>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedDateTimeFilterToJson(
      this,
    );
  }
}

abstract class _NestedDateTimeFilter implements NestedDateTimeFilter {
  const factory _NestedDateTimeFilter(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson)
          final DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson)
          final List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson)
          final List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson)
          final DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson)
          final DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson)
          final DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson)
          final DateTime? gte,
      @JsonKey(name: 'not')
          final NestedDateTimeFilter_not? not}) = _$_NestedDateTimeFilter;

  factory _NestedDateTimeFilter.fromJson(Map<String, dynamic> json) =
      _$_NestedDateTimeFilter.fromJson;

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn;
  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte;
  @override
  @JsonKey(name: 'not')
  NestedDateTimeFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_NestedDateTimeFilterCopyWith<_$_NestedDateTimeFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

NestedIntWithAggregatesFilter_not _$NestedIntWithAggregatesFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withInt':
      return NestedIntWithAggregatesFilter_not_withInt.fromJson(json);
    case 'withNestedIntWithAggregatesFilter':
      return NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'NestedIntWithAggregatesFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedIntWithAggregatesFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedIntWithAggregatesFilter_not_withInt value)
        withInt,
    required TResult Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedIntWithAggregatesFilter_not_withInt value)? withInt,
    TResult? Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedIntWithAggregatesFilter_not_withInt value)? withInt,
    TResult Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedIntWithAggregatesFilter_notCopyWith<$Res> {
  factory $NestedIntWithAggregatesFilter_notCopyWith(
          NestedIntWithAggregatesFilter_not value,
          $Res Function(NestedIntWithAggregatesFilter_not) then) =
      _$NestedIntWithAggregatesFilter_notCopyWithImpl<$Res,
          NestedIntWithAggregatesFilter_not>;
}

/// @nodoc
class _$NestedIntWithAggregatesFilter_notCopyWithImpl<$Res,
        $Val extends NestedIntWithAggregatesFilter_not>
    implements $NestedIntWithAggregatesFilter_notCopyWith<$Res> {
  _$NestedIntWithAggregatesFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedIntWithAggregatesFilter_not_withIntCopyWith<$Res> {
  factory _$$NestedIntWithAggregatesFilter_not_withIntCopyWith(
          _$NestedIntWithAggregatesFilter_not_withInt value,
          $Res Function(_$NestedIntWithAggregatesFilter_not_withInt) then) =
      __$$NestedIntWithAggregatesFilter_not_withIntCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$NestedIntWithAggregatesFilter_not_withIntCopyWithImpl<$Res>
    extends _$NestedIntWithAggregatesFilter_notCopyWithImpl<$Res,
        _$NestedIntWithAggregatesFilter_not_withInt>
    implements _$$NestedIntWithAggregatesFilter_not_withIntCopyWith<$Res> {
  __$$NestedIntWithAggregatesFilter_not_withIntCopyWithImpl(
      _$NestedIntWithAggregatesFilter_not_withInt _value,
      $Res Function(_$NestedIntWithAggregatesFilter_not_withInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedIntWithAggregatesFilter_not_withInt(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedIntWithAggregatesFilter_not_withInt
    implements NestedIntWithAggregatesFilter_not_withInt {
  const _$NestedIntWithAggregatesFilter_not_withInt(this.value,
      {final String? $type})
      : $type = $type ?? 'withInt';

  factory _$NestedIntWithAggregatesFilter_not_withInt.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedIntWithAggregatesFilter_not_withIntFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedIntWithAggregatesFilter_not.withInt(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedIntWithAggregatesFilter_not_withInt &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedIntWithAggregatesFilter_not_withIntCopyWith<
          _$NestedIntWithAggregatesFilter_not_withInt>
      get copyWith => __$$NestedIntWithAggregatesFilter_not_withIntCopyWithImpl<
          _$NestedIntWithAggregatesFilter_not_withInt>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedIntWithAggregatesFilter_not_withInt value)
        withInt,
    required TResult Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedIntWithAggregatesFilter_not_withInt value)? withInt,
    TResult? Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedIntWithAggregatesFilter_not_withInt value)? withInt,
    TResult Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withInt != null) {
      return withInt(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedIntWithAggregatesFilter_not_withIntToJson(
      this,
    );
  }
}

abstract class NestedIntWithAggregatesFilter_not_withInt
    implements NestedIntWithAggregatesFilter_not {
  const factory NestedIntWithAggregatesFilter_not_withInt(final int value) =
      _$NestedIntWithAggregatesFilter_not_withInt;

  factory NestedIntWithAggregatesFilter_not_withInt.fromJson(
          Map<String, dynamic> json) =
      _$NestedIntWithAggregatesFilter_not_withInt.fromJson;

  @override
  int get value;
  @JsonKey(ignore: true)
  _$$NestedIntWithAggregatesFilter_not_withIntCopyWith<
          _$NestedIntWithAggregatesFilter_not_withInt>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith(
          _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
              value,
          $Res Function(
                  _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter)
              then) =
      __$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({NestedIntWithAggregatesFilter value});

  $NestedIntWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$NestedIntWithAggregatesFilter_notCopyWithImpl<$Res,
        _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>
    implements
        _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
            $Res> {
  __$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl(
      _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
          _value,
      $Res Function(
              _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedIntWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntWithAggregatesFilterCopyWith<$Res> get value {
    return $NestedIntWithAggregatesFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
    implements
        NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter {
  const _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedIntWithAggregatesFilter';

  factory _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterFromJson(
          json);

  @override
  final NestedIntWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedIntWithAggregatesFilter_not.withNestedIntWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
          _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>
      get copyWith =>
          __$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWithImpl<
                  _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) withInt,
    required TResult Function(NestedIntWithAggregatesFilter value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? withInt,
    TResult? Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? withInt,
    TResult Function(NestedIntWithAggregatesFilter value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntWithAggregatesFilter != null) {
      return withNestedIntWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedIntWithAggregatesFilter_not_withInt value)
        withInt,
    required TResult Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedIntWithAggregatesFilter_not_withInt value)? withInt,
    TResult? Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
  }) {
    return withNestedIntWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedIntWithAggregatesFilter_not_withInt value)? withInt,
    TResult Function(
            NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
                value)?
        withNestedIntWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedIntWithAggregatesFilter != null) {
      return withNestedIntWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
    implements NestedIntWithAggregatesFilter_not {
  const factory NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter(
          final NestedIntWithAggregatesFilter value) =
      _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter;

  factory NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter
          .fromJson;

  @override
  NestedIntWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilterCopyWith<
          _$NestedIntWithAggregatesFilter_not_withNestedIntWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedIntWithAggregatesFilter _$NestedIntWithAggregatesFilterFromJson(
    Map<String, dynamic> json) {
  return _NestedIntWithAggregatesFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedIntWithAggregatesFilter {
  @JsonKey(name: 'equals')
  int? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<int>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<int>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  int? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  int? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  int? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  int? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedIntWithAggregatesFilter_not? get not =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count => throw _privateConstructorUsedError;
  @JsonKey(name: '_avg')
  NestedFloatFilter? get prisma__avg => throw _privateConstructorUsedError;
  @JsonKey(name: '_sum')
  NestedIntFilter? get prisma__sum => throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  NestedIntFilter? get prisma__min => throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  NestedIntFilter? get prisma__max => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedIntWithAggregatesFilterCopyWith<NestedIntWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedIntWithAggregatesFilterCopyWith<$Res> {
  factory $NestedIntWithAggregatesFilterCopyWith(
          NestedIntWithAggregatesFilter value,
          $Res Function(NestedIntWithAggregatesFilter) then) =
      _$NestedIntWithAggregatesFilterCopyWithImpl<$Res,
          NestedIntWithAggregatesFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') NestedIntWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_avg') NestedFloatFilter? prisma__avg,
      @JsonKey(name: '_sum') NestedIntFilter? prisma__sum,
      @JsonKey(name: '_min') NestedIntFilter? prisma__min,
      @JsonKey(name: '_max') NestedIntFilter? prisma__max});

  $NestedIntWithAggregatesFilter_notCopyWith<$Res>? get not;
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  $NestedFloatFilterCopyWith<$Res>? get prisma__avg;
  $NestedIntFilterCopyWith<$Res>? get prisma__sum;
  $NestedIntFilterCopyWith<$Res>? get prisma__min;
  $NestedIntFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class _$NestedIntWithAggregatesFilterCopyWithImpl<$Res,
        $Val extends NestedIntWithAggregatesFilter>
    implements $NestedIntWithAggregatesFilterCopyWith<$Res> {
  _$NestedIntWithAggregatesFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__avg = freezed,
    Object? prisma__sum = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedIntWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__avg: freezed == prisma__avg
          ? _value.prisma__avg
          : prisma__avg // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter?,
      prisma__sum: freezed == prisma__sum
          ? _value.prisma__sum
          : prisma__sum // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntWithAggregatesFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedIntWithAggregatesFilter_notCopyWith<$Res>(_value.not!,
        (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__count!, (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedFloatFilterCopyWith<$Res>? get prisma__avg {
    if (_value.prisma__avg == null) {
      return null;
    }

    return $NestedFloatFilterCopyWith<$Res>(_value.prisma__avg!, (value) {
      return _then(_value.copyWith(prisma__avg: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__sum {
    if (_value.prisma__sum == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__sum!, (value) {
      return _then(_value.copyWith(prisma__sum: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__min!, (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__max!, (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedIntWithAggregatesFilterCopyWith<$Res>
    implements $NestedIntWithAggregatesFilterCopyWith<$Res> {
  factory _$$_NestedIntWithAggregatesFilterCopyWith(
          _$_NestedIntWithAggregatesFilter value,
          $Res Function(_$_NestedIntWithAggregatesFilter) then) =
      __$$_NestedIntWithAggregatesFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') int? equals,
      @JsonKey(name: 'in') List<int>? dart__in,
      @JsonKey(name: 'notIn') List<int>? notIn,
      @JsonKey(name: 'lt') int? lt,
      @JsonKey(name: 'lte') int? lte,
      @JsonKey(name: 'gt') int? gt,
      @JsonKey(name: 'gte') int? gte,
      @JsonKey(name: 'not') NestedIntWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_avg') NestedFloatFilter? prisma__avg,
      @JsonKey(name: '_sum') NestedIntFilter? prisma__sum,
      @JsonKey(name: '_min') NestedIntFilter? prisma__min,
      @JsonKey(name: '_max') NestedIntFilter? prisma__max});

  @override
  $NestedIntWithAggregatesFilter_notCopyWith<$Res>? get not;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  @override
  $NestedFloatFilterCopyWith<$Res>? get prisma__avg;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__sum;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__min;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class __$$_NestedIntWithAggregatesFilterCopyWithImpl<$Res>
    extends _$NestedIntWithAggregatesFilterCopyWithImpl<$Res,
        _$_NestedIntWithAggregatesFilter>
    implements _$$_NestedIntWithAggregatesFilterCopyWith<$Res> {
  __$$_NestedIntWithAggregatesFilterCopyWithImpl(
      _$_NestedIntWithAggregatesFilter _value,
      $Res Function(_$_NestedIntWithAggregatesFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__avg = freezed,
    Object? prisma__sum = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_$_NestedIntWithAggregatesFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as int?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as int?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as int?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as int?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as int?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedIntWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__avg: freezed == prisma__avg
          ? _value.prisma__avg
          : prisma__avg // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter?,
      prisma__sum: freezed == prisma__sum
          ? _value.prisma__sum
          : prisma__sum // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedIntWithAggregatesFilter
    implements _NestedIntWithAggregatesFilter {
  const _$_NestedIntWithAggregatesFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<int>? dart__in,
      @JsonKey(name: 'notIn') final List<int>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'not') this.not,
      @JsonKey(name: '_count') this.prisma__count,
      @JsonKey(name: '_avg') this.prisma__avg,
      @JsonKey(name: '_sum') this.prisma__sum,
      @JsonKey(name: '_min') this.prisma__min,
      @JsonKey(name: '_max') this.prisma__max})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$_NestedIntWithAggregatesFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final int? equals;
  final List<int>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<int>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final int? lt;
  @override
  @JsonKey(name: 'lte')
  final int? lte;
  @override
  @JsonKey(name: 'gt')
  final int? gt;
  @override
  @JsonKey(name: 'gte')
  final int? gte;
  @override
  @JsonKey(name: 'not')
  final NestedIntWithAggregatesFilter_not? not;
  @override
  @JsonKey(name: '_count')
  final NestedIntFilter? prisma__count;
  @override
  @JsonKey(name: '_avg')
  final NestedFloatFilter? prisma__avg;
  @override
  @JsonKey(name: '_sum')
  final NestedIntFilter? prisma__sum;
  @override
  @JsonKey(name: '_min')
  final NestedIntFilter? prisma__min;
  @override
  @JsonKey(name: '_max')
  final NestedIntFilter? prisma__max;

  @override
  String toString() {
    return 'NestedIntWithAggregatesFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not, prisma__count: $prisma__count, prisma__avg: $prisma__avg, prisma__sum: $prisma__sum, prisma__min: $prisma__min, prisma__max: $prisma__max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedIntWithAggregatesFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__avg, prisma__avg) ||
                other.prisma__avg == prisma__avg) &&
            (identical(other.prisma__sum, prisma__sum) ||
                other.prisma__sum == prisma__sum) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not,
      prisma__count,
      prisma__avg,
      prisma__sum,
      prisma__min,
      prisma__max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedIntWithAggregatesFilterCopyWith<_$_NestedIntWithAggregatesFilter>
      get copyWith => __$$_NestedIntWithAggregatesFilterCopyWithImpl<
          _$_NestedIntWithAggregatesFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedIntWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class _NestedIntWithAggregatesFilter
    implements NestedIntWithAggregatesFilter {
  const factory _NestedIntWithAggregatesFilter(
          {@JsonKey(name: 'equals') final int? equals,
          @JsonKey(name: 'in') final List<int>? dart__in,
          @JsonKey(name: 'notIn') final List<int>? notIn,
          @JsonKey(name: 'lt') final int? lt,
          @JsonKey(name: 'lte') final int? lte,
          @JsonKey(name: 'gt') final int? gt,
          @JsonKey(name: 'gte') final int? gte,
          @JsonKey(name: 'not') final NestedIntWithAggregatesFilter_not? not,
          @JsonKey(name: '_count') final NestedIntFilter? prisma__count,
          @JsonKey(name: '_avg') final NestedFloatFilter? prisma__avg,
          @JsonKey(name: '_sum') final NestedIntFilter? prisma__sum,
          @JsonKey(name: '_min') final NestedIntFilter? prisma__min,
          @JsonKey(name: '_max') final NestedIntFilter? prisma__max}) =
      _$_NestedIntWithAggregatesFilter;

  factory _NestedIntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =
      _$_NestedIntWithAggregatesFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  int? get equals;
  @override
  @JsonKey(name: 'in')
  List<int>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<int>? get notIn;
  @override
  @JsonKey(name: 'lt')
  int? get lt;
  @override
  @JsonKey(name: 'lte')
  int? get lte;
  @override
  @JsonKey(name: 'gt')
  int? get gt;
  @override
  @JsonKey(name: 'gte')
  int? get gte;
  @override
  @JsonKey(name: 'not')
  NestedIntWithAggregatesFilter_not? get not;
  @override
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count;
  @override
  @JsonKey(name: '_avg')
  NestedFloatFilter? get prisma__avg;
  @override
  @JsonKey(name: '_sum')
  NestedIntFilter? get prisma__sum;
  @override
  @JsonKey(name: '_min')
  NestedIntFilter? get prisma__min;
  @override
  @JsonKey(name: '_max')
  NestedIntFilter? get prisma__max;
  @override
  @JsonKey(ignore: true)
  _$$_NestedIntWithAggregatesFilterCopyWith<_$_NestedIntWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedFloatFilter_not _$NestedFloatFilter_notFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withFloat':
      return NestedFloatFilter_not_withFloat.fromJson(json);
    case 'withNestedFloatFilter':
      return NestedFloatFilter_not_withNestedFloatFilter.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'NestedFloatFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedFloatFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double value) withFloat,
    required TResult Function(NestedFloatFilter value) withNestedFloatFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double value)? withFloat,
    TResult? Function(NestedFloatFilter value)? withNestedFloatFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double value)? withFloat,
    TResult Function(NestedFloatFilter value)? withNestedFloatFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedFloatFilter_not_withFloat value) withFloat,
    required TResult Function(NestedFloatFilter_not_withNestedFloatFilter value)
        withNestedFloatFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedFloatFilter_not_withFloat value)? withFloat,
    TResult? Function(NestedFloatFilter_not_withNestedFloatFilter value)?
        withNestedFloatFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedFloatFilter_not_withFloat value)? withFloat,
    TResult Function(NestedFloatFilter_not_withNestedFloatFilter value)?
        withNestedFloatFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedFloatFilter_notCopyWith<$Res> {
  factory $NestedFloatFilter_notCopyWith(NestedFloatFilter_not value,
          $Res Function(NestedFloatFilter_not) then) =
      _$NestedFloatFilter_notCopyWithImpl<$Res, NestedFloatFilter_not>;
}

/// @nodoc
class _$NestedFloatFilter_notCopyWithImpl<$Res,
        $Val extends NestedFloatFilter_not>
    implements $NestedFloatFilter_notCopyWith<$Res> {
  _$NestedFloatFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedFloatFilter_not_withFloatCopyWith<$Res> {
  factory _$$NestedFloatFilter_not_withFloatCopyWith(
          _$NestedFloatFilter_not_withFloat value,
          $Res Function(_$NestedFloatFilter_not_withFloat) then) =
      __$$NestedFloatFilter_not_withFloatCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$NestedFloatFilter_not_withFloatCopyWithImpl<$Res>
    extends _$NestedFloatFilter_notCopyWithImpl<$Res,
        _$NestedFloatFilter_not_withFloat>
    implements _$$NestedFloatFilter_not_withFloatCopyWith<$Res> {
  __$$NestedFloatFilter_not_withFloatCopyWithImpl(
      _$NestedFloatFilter_not_withFloat _value,
      $Res Function(_$NestedFloatFilter_not_withFloat) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedFloatFilter_not_withFloat(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedFloatFilter_not_withFloat
    implements NestedFloatFilter_not_withFloat {
  const _$NestedFloatFilter_not_withFloat(this.value, {final String? $type})
      : $type = $type ?? 'withFloat';

  factory _$NestedFloatFilter_not_withFloat.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedFloatFilter_not_withFloatFromJson(json);

  @override
  final double value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedFloatFilter_not.withFloat(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedFloatFilter_not_withFloat &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedFloatFilter_not_withFloatCopyWith<_$NestedFloatFilter_not_withFloat>
      get copyWith => __$$NestedFloatFilter_not_withFloatCopyWithImpl<
          _$NestedFloatFilter_not_withFloat>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double value) withFloat,
    required TResult Function(NestedFloatFilter value) withNestedFloatFilter,
  }) {
    return withFloat(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double value)? withFloat,
    TResult? Function(NestedFloatFilter value)? withNestedFloatFilter,
  }) {
    return withFloat?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double value)? withFloat,
    TResult Function(NestedFloatFilter value)? withNestedFloatFilter,
    required TResult orElse(),
  }) {
    if (withFloat != null) {
      return withFloat(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedFloatFilter_not_withFloat value) withFloat,
    required TResult Function(NestedFloatFilter_not_withNestedFloatFilter value)
        withNestedFloatFilter,
  }) {
    return withFloat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedFloatFilter_not_withFloat value)? withFloat,
    TResult? Function(NestedFloatFilter_not_withNestedFloatFilter value)?
        withNestedFloatFilter,
  }) {
    return withFloat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedFloatFilter_not_withFloat value)? withFloat,
    TResult Function(NestedFloatFilter_not_withNestedFloatFilter value)?
        withNestedFloatFilter,
    required TResult orElse(),
  }) {
    if (withFloat != null) {
      return withFloat(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedFloatFilter_not_withFloatToJson(
      this,
    );
  }
}

abstract class NestedFloatFilter_not_withFloat
    implements NestedFloatFilter_not {
  const factory NestedFloatFilter_not_withFloat(final double value) =
      _$NestedFloatFilter_not_withFloat;

  factory NestedFloatFilter_not_withFloat.fromJson(Map<String, dynamic> json) =
      _$NestedFloatFilter_not_withFloat.fromJson;

  @override
  double get value;
  @JsonKey(ignore: true)
  _$$NestedFloatFilter_not_withFloatCopyWith<_$NestedFloatFilter_not_withFloat>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedFloatFilter_not_withNestedFloatFilterCopyWith<$Res> {
  factory _$$NestedFloatFilter_not_withNestedFloatFilterCopyWith(
          _$NestedFloatFilter_not_withNestedFloatFilter value,
          $Res Function(_$NestedFloatFilter_not_withNestedFloatFilter) then) =
      __$$NestedFloatFilter_not_withNestedFloatFilterCopyWithImpl<$Res>;
  @useResult
  $Res call({NestedFloatFilter value});

  $NestedFloatFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedFloatFilter_not_withNestedFloatFilterCopyWithImpl<$Res>
    extends _$NestedFloatFilter_notCopyWithImpl<$Res,
        _$NestedFloatFilter_not_withNestedFloatFilter>
    implements _$$NestedFloatFilter_not_withNestedFloatFilterCopyWith<$Res> {
  __$$NestedFloatFilter_not_withNestedFloatFilterCopyWithImpl(
      _$NestedFloatFilter_not_withNestedFloatFilter _value,
      $Res Function(_$NestedFloatFilter_not_withNestedFloatFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedFloatFilter_not_withNestedFloatFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedFloatFilterCopyWith<$Res> get value {
    return $NestedFloatFilterCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedFloatFilter_not_withNestedFloatFilter
    implements NestedFloatFilter_not_withNestedFloatFilter {
  const _$NestedFloatFilter_not_withNestedFloatFilter(this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedFloatFilter';

  factory _$NestedFloatFilter_not_withNestedFloatFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedFloatFilter_not_withNestedFloatFilterFromJson(json);

  @override
  final NestedFloatFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedFloatFilter_not.withNestedFloatFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedFloatFilter_not_withNestedFloatFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedFloatFilter_not_withNestedFloatFilterCopyWith<
          _$NestedFloatFilter_not_withNestedFloatFilter>
      get copyWith =>
          __$$NestedFloatFilter_not_withNestedFloatFilterCopyWithImpl<
              _$NestedFloatFilter_not_withNestedFloatFilter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double value) withFloat,
    required TResult Function(NestedFloatFilter value) withNestedFloatFilter,
  }) {
    return withNestedFloatFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(double value)? withFloat,
    TResult? Function(NestedFloatFilter value)? withNestedFloatFilter,
  }) {
    return withNestedFloatFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double value)? withFloat,
    TResult Function(NestedFloatFilter value)? withNestedFloatFilter,
    required TResult orElse(),
  }) {
    if (withNestedFloatFilter != null) {
      return withNestedFloatFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NestedFloatFilter_not_withFloat value) withFloat,
    required TResult Function(NestedFloatFilter_not_withNestedFloatFilter value)
        withNestedFloatFilter,
  }) {
    return withNestedFloatFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedFloatFilter_not_withFloat value)? withFloat,
    TResult? Function(NestedFloatFilter_not_withNestedFloatFilter value)?
        withNestedFloatFilter,
  }) {
    return withNestedFloatFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedFloatFilter_not_withFloat value)? withFloat,
    TResult Function(NestedFloatFilter_not_withNestedFloatFilter value)?
        withNestedFloatFilter,
    required TResult orElse(),
  }) {
    if (withNestedFloatFilter != null) {
      return withNestedFloatFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedFloatFilter_not_withNestedFloatFilterToJson(
      this,
    );
  }
}

abstract class NestedFloatFilter_not_withNestedFloatFilter
    implements NestedFloatFilter_not {
  const factory NestedFloatFilter_not_withNestedFloatFilter(
          final NestedFloatFilter value) =
      _$NestedFloatFilter_not_withNestedFloatFilter;

  factory NestedFloatFilter_not_withNestedFloatFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedFloatFilter_not_withNestedFloatFilter.fromJson;

  @override
  NestedFloatFilter get value;
  @JsonKey(ignore: true)
  _$$NestedFloatFilter_not_withNestedFloatFilterCopyWith<
          _$NestedFloatFilter_not_withNestedFloatFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedFloatFilter _$NestedFloatFilterFromJson(Map<String, dynamic> json) {
  return _NestedFloatFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedFloatFilter {
  @JsonKey(name: 'equals')
  double? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<double>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<double>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  double? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  double? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  double? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  double? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedFloatFilter_not? get not => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedFloatFilterCopyWith<NestedFloatFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedFloatFilterCopyWith<$Res> {
  factory $NestedFloatFilterCopyWith(
          NestedFloatFilter value, $Res Function(NestedFloatFilter) then) =
      _$NestedFloatFilterCopyWithImpl<$Res, NestedFloatFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') double? equals,
      @JsonKey(name: 'in') List<double>? dart__in,
      @JsonKey(name: 'notIn') List<double>? notIn,
      @JsonKey(name: 'lt') double? lt,
      @JsonKey(name: 'lte') double? lte,
      @JsonKey(name: 'gt') double? gt,
      @JsonKey(name: 'gte') double? gte,
      @JsonKey(name: 'not') NestedFloatFilter_not? not});

  $NestedFloatFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class _$NestedFloatFilterCopyWithImpl<$Res, $Val extends NestedFloatFilter>
    implements $NestedFloatFilterCopyWith<$Res> {
  _$NestedFloatFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as double?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<double>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<double>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as double?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as double?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as double?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as double?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter_not?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedFloatFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedFloatFilter_notCopyWith<$Res>(_value.not!, (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedFloatFilterCopyWith<$Res>
    implements $NestedFloatFilterCopyWith<$Res> {
  factory _$$_NestedFloatFilterCopyWith(_$_NestedFloatFilter value,
          $Res Function(_$_NestedFloatFilter) then) =
      __$$_NestedFloatFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') double? equals,
      @JsonKey(name: 'in') List<double>? dart__in,
      @JsonKey(name: 'notIn') List<double>? notIn,
      @JsonKey(name: 'lt') double? lt,
      @JsonKey(name: 'lte') double? lte,
      @JsonKey(name: 'gt') double? gt,
      @JsonKey(name: 'gte') double? gte,
      @JsonKey(name: 'not') NestedFloatFilter_not? not});

  @override
  $NestedFloatFilter_notCopyWith<$Res>? get not;
}

/// @nodoc
class __$$_NestedFloatFilterCopyWithImpl<$Res>
    extends _$NestedFloatFilterCopyWithImpl<$Res, _$_NestedFloatFilter>
    implements _$$_NestedFloatFilterCopyWith<$Res> {
  __$$_NestedFloatFilterCopyWithImpl(
      _$_NestedFloatFilter _value, $Res Function(_$_NestedFloatFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
  }) {
    return _then(_$_NestedFloatFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as double?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<double>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<double>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as double?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as double?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as double?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as double?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedFloatFilter_not?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedFloatFilter implements _NestedFloatFilter {
  const _$_NestedFloatFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<double>? dart__in,
      @JsonKey(name: 'notIn') final List<double>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'not') this.not})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedFloatFilter.fromJson(Map<String, dynamic> json) =>
      _$$_NestedFloatFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final double? equals;
  final List<double>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<double>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<double>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<double>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final double? lt;
  @override
  @JsonKey(name: 'lte')
  final double? lte;
  @override
  @JsonKey(name: 'gt')
  final double? gt;
  @override
  @JsonKey(name: 'gte')
  final double? gte;
  @override
  @JsonKey(name: 'not')
  final NestedFloatFilter_not? not;

  @override
  String toString() {
    return 'NestedFloatFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedFloatFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedFloatFilterCopyWith<_$_NestedFloatFilter> get copyWith =>
      __$$_NestedFloatFilterCopyWithImpl<_$_NestedFloatFilter>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedFloatFilterToJson(
      this,
    );
  }
}

abstract class _NestedFloatFilter implements NestedFloatFilter {
  const factory _NestedFloatFilter(
          {@JsonKey(name: 'equals') final double? equals,
          @JsonKey(name: 'in') final List<double>? dart__in,
          @JsonKey(name: 'notIn') final List<double>? notIn,
          @JsonKey(name: 'lt') final double? lt,
          @JsonKey(name: 'lte') final double? lte,
          @JsonKey(name: 'gt') final double? gt,
          @JsonKey(name: 'gte') final double? gte,
          @JsonKey(name: 'not') final NestedFloatFilter_not? not}) =
      _$_NestedFloatFilter;

  factory _NestedFloatFilter.fromJson(Map<String, dynamic> json) =
      _$_NestedFloatFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  double? get equals;
  @override
  @JsonKey(name: 'in')
  List<double>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<double>? get notIn;
  @override
  @JsonKey(name: 'lt')
  double? get lt;
  @override
  @JsonKey(name: 'lte')
  double? get lte;
  @override
  @JsonKey(name: 'gt')
  double? get gt;
  @override
  @JsonKey(name: 'gte')
  double? get gte;
  @override
  @JsonKey(name: 'not')
  NestedFloatFilter_not? get not;
  @override
  @JsonKey(ignore: true)
  _$$_NestedFloatFilterCopyWith<_$_NestedFloatFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

NestedStringWithAggregatesFilter_not
    _$NestedStringWithAggregatesFilter_notFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withString':
      return NestedStringWithAggregatesFilter_not_withString.fromJson(json);
    case 'withNestedStringWithAggregatesFilter':
      return NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'NestedStringWithAggregatesFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedStringWithAggregatesFilter_not {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringWithAggregatesFilter value)
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            NestedStringWithAggregatesFilter_not_withString value)
        withString,
    required TResult Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedStringWithAggregatesFilter_not_withString value)?
        withString,
    TResult? Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedStringWithAggregatesFilter_not_withString value)?
        withString,
    TResult Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedStringWithAggregatesFilter_notCopyWith<$Res> {
  factory $NestedStringWithAggregatesFilter_notCopyWith(
          NestedStringWithAggregatesFilter_not value,
          $Res Function(NestedStringWithAggregatesFilter_not) then) =
      _$NestedStringWithAggregatesFilter_notCopyWithImpl<$Res,
          NestedStringWithAggregatesFilter_not>;
}

/// @nodoc
class _$NestedStringWithAggregatesFilter_notCopyWithImpl<$Res,
        $Val extends NestedStringWithAggregatesFilter_not>
    implements $NestedStringWithAggregatesFilter_notCopyWith<$Res> {
  _$NestedStringWithAggregatesFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedStringWithAggregatesFilter_not_withStringCopyWith<
    $Res> {
  factory _$$NestedStringWithAggregatesFilter_not_withStringCopyWith(
          _$NestedStringWithAggregatesFilter_not_withString value,
          $Res Function(_$NestedStringWithAggregatesFilter_not_withString)
              then) =
      __$$NestedStringWithAggregatesFilter_not_withStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$NestedStringWithAggregatesFilter_not_withStringCopyWithImpl<$Res>
    extends _$NestedStringWithAggregatesFilter_notCopyWithImpl<$Res,
        _$NestedStringWithAggregatesFilter_not_withString>
    implements
        _$$NestedStringWithAggregatesFilter_not_withStringCopyWith<$Res> {
  __$$NestedStringWithAggregatesFilter_not_withStringCopyWithImpl(
      _$NestedStringWithAggregatesFilter_not_withString _value,
      $Res Function(_$NestedStringWithAggregatesFilter_not_withString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedStringWithAggregatesFilter_not_withString(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedStringWithAggregatesFilter_not_withString
    implements NestedStringWithAggregatesFilter_not_withString {
  const _$NestedStringWithAggregatesFilter_not_withString(this.value,
      {final String? $type})
      : $type = $type ?? 'withString';

  factory _$NestedStringWithAggregatesFilter_not_withString.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedStringWithAggregatesFilter_not_withStringFromJson(json);

  @override
  final String value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedStringWithAggregatesFilter_not.withString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedStringWithAggregatesFilter_not_withString &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedStringWithAggregatesFilter_not_withStringCopyWith<
          _$NestedStringWithAggregatesFilter_not_withString>
      get copyWith =>
          __$$NestedStringWithAggregatesFilter_not_withStringCopyWithImpl<
                  _$NestedStringWithAggregatesFilter_not_withString>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringWithAggregatesFilter value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            NestedStringWithAggregatesFilter_not_withString value)
        withString,
    required TResult Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedStringWithAggregatesFilter_not_withString value)?
        withString,
    TResult? Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedStringWithAggregatesFilter_not_withString value)?
        withString,
    TResult Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withString != null) {
      return withString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedStringWithAggregatesFilter_not_withStringToJson(
      this,
    );
  }
}

abstract class NestedStringWithAggregatesFilter_not_withString
    implements NestedStringWithAggregatesFilter_not {
  const factory NestedStringWithAggregatesFilter_not_withString(
      final String value) = _$NestedStringWithAggregatesFilter_not_withString;

  factory NestedStringWithAggregatesFilter_not_withString.fromJson(
          Map<String, dynamic> json) =
      _$NestedStringWithAggregatesFilter_not_withString.fromJson;

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$NestedStringWithAggregatesFilter_not_withStringCopyWith<
          _$NestedStringWithAggregatesFilter_not_withString>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith(
          _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
              value,
          $Res Function(
                  _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter)
              then) =
      __$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({NestedStringWithAggregatesFilter value});

  $NestedStringWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$NestedStringWithAggregatesFilter_notCopyWithImpl<$Res,
        _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>
    implements
        _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
            $Res> {
  __$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl(
      _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
          _value,
      $Res Function(
              _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedStringWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringWithAggregatesFilterCopyWith<$Res> get value {
    return $NestedStringWithAggregatesFilterCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
    implements
        NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter {
  const _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedStringWithAggregatesFilter';

  factory _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterFromJson(
          json);

  @override
  final NestedStringWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedStringWithAggregatesFilter_not.withNestedStringWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
          _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>
      get copyWith =>
          __$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWithImpl<
                  _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) withString,
    required TResult Function(NestedStringWithAggregatesFilter value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? withString,
    TResult? Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? withString,
    TResult Function(NestedStringWithAggregatesFilter value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringWithAggregatesFilter != null) {
      return withNestedStringWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            NestedStringWithAggregatesFilter_not_withString value)
        withString,
    required TResult Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NestedStringWithAggregatesFilter_not_withString value)?
        withString,
    TResult? Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
  }) {
    return withNestedStringWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedStringWithAggregatesFilter_not_withString value)?
        withString,
    TResult Function(
            NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
                value)?
        withNestedStringWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedStringWithAggregatesFilter != null) {
      return withNestedStringWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
    implements NestedStringWithAggregatesFilter_not {
  const factory NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter(
          final NestedStringWithAggregatesFilter value) =
      _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter;

  factory NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter
          .fromJson;

  @override
  NestedStringWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilterCopyWith<
          _$NestedStringWithAggregatesFilter_not_withNestedStringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedStringWithAggregatesFilter _$NestedStringWithAggregatesFilterFromJson(
    Map<String, dynamic> json) {
  return _NestedStringWithAggregatesFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedStringWithAggregatesFilter {
  @JsonKey(name: 'equals')
  String? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  List<String>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn')
  List<String>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt')
  String? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte')
  String? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt')
  String? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte')
  String? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'contains')
  String? get contains => throw _privateConstructorUsedError;
  @JsonKey(name: 'startsWith')
  String? get startsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'endsWith')
  String? get endsWith => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedStringWithAggregatesFilter_not? get not =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count => throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  NestedStringFilter? get prisma__min => throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  NestedStringFilter? get prisma__max => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedStringWithAggregatesFilterCopyWith<NestedStringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedStringWithAggregatesFilterCopyWith<$Res> {
  factory $NestedStringWithAggregatesFilterCopyWith(
          NestedStringWithAggregatesFilter value,
          $Res Function(NestedStringWithAggregatesFilter) then) =
      _$NestedStringWithAggregatesFilterCopyWithImpl<$Res,
          NestedStringWithAggregatesFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'not') NestedStringWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedStringFilter? prisma__min,
      @JsonKey(name: '_max') NestedStringFilter? prisma__max});

  $NestedStringWithAggregatesFilter_notCopyWith<$Res>? get not;
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  $NestedStringFilterCopyWith<$Res>? get prisma__min;
  $NestedStringFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class _$NestedStringWithAggregatesFilterCopyWithImpl<$Res,
        $Val extends NestedStringWithAggregatesFilter>
    implements $NestedStringWithAggregatesFilterCopyWith<$Res> {
  _$NestedStringWithAggregatesFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedStringWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringWithAggregatesFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedStringWithAggregatesFilter_notCopyWith<$Res>(_value.not!,
        (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__count!, (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilterCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $NestedStringFilterCopyWith<$Res>(_value.prisma__min!, (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedStringFilterCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $NestedStringFilterCopyWith<$Res>(_value.prisma__max!, (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedStringWithAggregatesFilterCopyWith<$Res>
    implements $NestedStringWithAggregatesFilterCopyWith<$Res> {
  factory _$$_NestedStringWithAggregatesFilterCopyWith(
          _$_NestedStringWithAggregatesFilter value,
          $Res Function(_$_NestedStringWithAggregatesFilter) then) =
      __$$_NestedStringWithAggregatesFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals') String? equals,
      @JsonKey(name: 'in') List<String>? dart__in,
      @JsonKey(name: 'notIn') List<String>? notIn,
      @JsonKey(name: 'lt') String? lt,
      @JsonKey(name: 'lte') String? lte,
      @JsonKey(name: 'gt') String? gt,
      @JsonKey(name: 'gte') String? gte,
      @JsonKey(name: 'contains') String? contains,
      @JsonKey(name: 'startsWith') String? startsWith,
      @JsonKey(name: 'endsWith') String? endsWith,
      @JsonKey(name: 'not') NestedStringWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedStringFilter? prisma__min,
      @JsonKey(name: '_max') NestedStringFilter? prisma__max});

  @override
  $NestedStringWithAggregatesFilter_notCopyWith<$Res>? get not;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  @override
  $NestedStringFilterCopyWith<$Res>? get prisma__min;
  @override
  $NestedStringFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class __$$_NestedStringWithAggregatesFilterCopyWithImpl<$Res>
    extends _$NestedStringWithAggregatesFilterCopyWithImpl<$Res,
        _$_NestedStringWithAggregatesFilter>
    implements _$$_NestedStringWithAggregatesFilterCopyWith<$Res> {
  __$$_NestedStringWithAggregatesFilterCopyWithImpl(
      _$_NestedStringWithAggregatesFilter _value,
      $Res Function(_$_NestedStringWithAggregatesFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? contains = freezed,
    Object? startsWith = freezed,
    Object? endsWith = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_$_NestedStringWithAggregatesFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as String?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as String?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as String?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as String?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as String?,
      contains: freezed == contains
          ? _value.contains
          : contains // ignore: cast_nullable_to_non_nullable
              as String?,
      startsWith: freezed == startsWith
          ? _value.startsWith
          : startsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      endsWith: freezed == endsWith
          ? _value.endsWith
          : endsWith // ignore: cast_nullable_to_non_nullable
              as String?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedStringWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedStringFilter?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedStringWithAggregatesFilter
    implements _NestedStringWithAggregatesFilter {
  const _$_NestedStringWithAggregatesFilter(
      {@JsonKey(name: 'equals') this.equals,
      @JsonKey(name: 'in') final List<String>? dart__in,
      @JsonKey(name: 'notIn') final List<String>? notIn,
      @JsonKey(name: 'lt') this.lt,
      @JsonKey(name: 'lte') this.lte,
      @JsonKey(name: 'gt') this.gt,
      @JsonKey(name: 'gte') this.gte,
      @JsonKey(name: 'contains') this.contains,
      @JsonKey(name: 'startsWith') this.startsWith,
      @JsonKey(name: 'endsWith') this.endsWith,
      @JsonKey(name: 'not') this.not,
      @JsonKey(name: '_count') this.prisma__count,
      @JsonKey(name: '_min') this.prisma__min,
      @JsonKey(name: '_max') this.prisma__max})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$_NestedStringWithAggregatesFilterFromJson(json);

  @override
  @JsonKey(name: 'equals')
  final String? equals;
  final List<String>? _dart__in;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _notIn;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt')
  final String? lt;
  @override
  @JsonKey(name: 'lte')
  final String? lte;
  @override
  @JsonKey(name: 'gt')
  final String? gt;
  @override
  @JsonKey(name: 'gte')
  final String? gte;
  @override
  @JsonKey(name: 'contains')
  final String? contains;
  @override
  @JsonKey(name: 'startsWith')
  final String? startsWith;
  @override
  @JsonKey(name: 'endsWith')
  final String? endsWith;
  @override
  @JsonKey(name: 'not')
  final NestedStringWithAggregatesFilter_not? not;
  @override
  @JsonKey(name: '_count')
  final NestedIntFilter? prisma__count;
  @override
  @JsonKey(name: '_min')
  final NestedStringFilter? prisma__min;
  @override
  @JsonKey(name: '_max')
  final NestedStringFilter? prisma__max;

  @override
  String toString() {
    return 'NestedStringWithAggregatesFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, contains: $contains, startsWith: $startsWith, endsWith: $endsWith, not: $not, prisma__count: $prisma__count, prisma__min: $prisma__min, prisma__max: $prisma__max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedStringWithAggregatesFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.contains, contains) ||
                other.contains == contains) &&
            (identical(other.startsWith, startsWith) ||
                other.startsWith == startsWith) &&
            (identical(other.endsWith, endsWith) ||
                other.endsWith == endsWith) &&
            (identical(other.not, not) || other.not == not) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      contains,
      startsWith,
      endsWith,
      not,
      prisma__count,
      prisma__min,
      prisma__max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedStringWithAggregatesFilterCopyWith<
          _$_NestedStringWithAggregatesFilter>
      get copyWith => __$$_NestedStringWithAggregatesFilterCopyWithImpl<
          _$_NestedStringWithAggregatesFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedStringWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class _NestedStringWithAggregatesFilter
    implements NestedStringWithAggregatesFilter {
  const factory _NestedStringWithAggregatesFilter(
          {@JsonKey(name: 'equals') final String? equals,
          @JsonKey(name: 'in') final List<String>? dart__in,
          @JsonKey(name: 'notIn') final List<String>? notIn,
          @JsonKey(name: 'lt') final String? lt,
          @JsonKey(name: 'lte') final String? lte,
          @JsonKey(name: 'gt') final String? gt,
          @JsonKey(name: 'gte') final String? gte,
          @JsonKey(name: 'contains') final String? contains,
          @JsonKey(name: 'startsWith') final String? startsWith,
          @JsonKey(name: 'endsWith') final String? endsWith,
          @JsonKey(name: 'not') final NestedStringWithAggregatesFilter_not? not,
          @JsonKey(name: '_count') final NestedIntFilter? prisma__count,
          @JsonKey(name: '_min') final NestedStringFilter? prisma__min,
          @JsonKey(name: '_max') final NestedStringFilter? prisma__max}) =
      _$_NestedStringWithAggregatesFilter;

  factory _NestedStringWithAggregatesFilter.fromJson(
      Map<String, dynamic> json) = _$_NestedStringWithAggregatesFilter.fromJson;

  @override
  @JsonKey(name: 'equals')
  String? get equals;
  @override
  @JsonKey(name: 'in')
  List<String>? get dart__in;
  @override
  @JsonKey(name: 'notIn')
  List<String>? get notIn;
  @override
  @JsonKey(name: 'lt')
  String? get lt;
  @override
  @JsonKey(name: 'lte')
  String? get lte;
  @override
  @JsonKey(name: 'gt')
  String? get gt;
  @override
  @JsonKey(name: 'gte')
  String? get gte;
  @override
  @JsonKey(name: 'contains')
  String? get contains;
  @override
  @JsonKey(name: 'startsWith')
  String? get startsWith;
  @override
  @JsonKey(name: 'endsWith')
  String? get endsWith;
  @override
  @JsonKey(name: 'not')
  NestedStringWithAggregatesFilter_not? get not;
  @override
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count;
  @override
  @JsonKey(name: '_min')
  NestedStringFilter? get prisma__min;
  @override
  @JsonKey(name: '_max')
  NestedStringFilter? get prisma__max;
  @override
  @JsonKey(ignore: true)
  _$$_NestedStringWithAggregatesFilterCopyWith<
          _$_NestedStringWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedDateTimeWithAggregatesFilter_not
    _$NestedDateTimeWithAggregatesFilter_notFromJson(
        Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withDateTime':
      return NestedDateTimeWithAggregatesFilter_not_withDateTime.fromJson(json);
    case 'withNestedDateTimeWithAggregatesFilter':
      return NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'NestedDateTimeWithAggregatesFilter_not',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$NestedDateTimeWithAggregatesFilter_not {
  @JsonKey(toJson: dateTimeToJson)
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeWithAggregatesFilter value)
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            NestedDateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedDateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedDateTimeWithAggregatesFilter_notCopyWith<$Res> {
  factory $NestedDateTimeWithAggregatesFilter_notCopyWith(
          NestedDateTimeWithAggregatesFilter_not value,
          $Res Function(NestedDateTimeWithAggregatesFilter_not) then) =
      _$NestedDateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
          NestedDateTimeWithAggregatesFilter_not>;
}

/// @nodoc
class _$NestedDateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
        $Val extends NestedDateTimeWithAggregatesFilter_not>
    implements $NestedDateTimeWithAggregatesFilter_notCopyWith<$Res> {
  _$NestedDateTimeWithAggregatesFilter_notCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWith<
    $Res> {
  factory _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWith(
          _$NestedDateTimeWithAggregatesFilter_not_withDateTime value,
          $Res Function(_$NestedDateTimeWithAggregatesFilter_not_withDateTime)
              then) =
      __$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(toJson: dateTimeToJson) DateTime value});
}

/// @nodoc
class __$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl<$Res>
    extends _$NestedDateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
        _$NestedDateTimeWithAggregatesFilter_not_withDateTime>
    implements
        _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWith<$Res> {
  __$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl(
      _$NestedDateTimeWithAggregatesFilter_not_withDateTime _value,
      $Res Function(_$NestedDateTimeWithAggregatesFilter_not_withDateTime)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$NestedDateTimeWithAggregatesFilter_not_withDateTime(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedDateTimeWithAggregatesFilter_not_withDateTime
    implements NestedDateTimeWithAggregatesFilter_not_withDateTime {
  const _$NestedDateTimeWithAggregatesFilter_not_withDateTime(
      @JsonKey(toJson: dateTimeToJson) this.value,
      {final String? $type})
      : $type = $type ?? 'withDateTime';

  factory _$NestedDateTimeWithAggregatesFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeFromJson(json);

  @override
  @JsonKey(toJson: dateTimeToJson)
  final DateTime value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedDateTimeWithAggregatesFilter_not.withDateTime(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NestedDateTimeWithAggregatesFilter_not_withDateTime &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWith<
          _$NestedDateTimeWithAggregatesFilter_not_withDateTime>
      get copyWith =>
          __$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWithImpl<
                  _$NestedDateTimeWithAggregatesFilter_not_withDateTime>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeWithAggregatesFilter value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            NestedDateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedDateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withDateTime != null) {
      return withDateTime(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeToJson(
      this,
    );
  }
}

abstract class NestedDateTimeWithAggregatesFilter_not_withDateTime
    implements NestedDateTimeWithAggregatesFilter_not {
  const factory NestedDateTimeWithAggregatesFilter_not_withDateTime(
          @JsonKey(toJson: dateTimeToJson) final DateTime value) =
      _$NestedDateTimeWithAggregatesFilter_not_withDateTime;

  factory NestedDateTimeWithAggregatesFilter_not_withDateTime.fromJson(
          Map<String, dynamic> json) =
      _$NestedDateTimeWithAggregatesFilter_not_withDateTime.fromJson;

  @override
  @JsonKey(toJson: dateTimeToJson)
  DateTime get value;
  @JsonKey(ignore: true)
  _$$NestedDateTimeWithAggregatesFilter_not_withDateTimeCopyWith<
          _$NestedDateTimeWithAggregatesFilter_not_withDateTime>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
    $Res> {
  factory _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith(
          _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
              value,
          $Res Function(
                  _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter)
              then) =
      __$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl<
          $Res>;
  @useResult
  $Res call({NestedDateTimeWithAggregatesFilter value});

  $NestedDateTimeWithAggregatesFilterCopyWith<$Res> get value;
}

/// @nodoc
class __$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl<
        $Res>
    extends _$NestedDateTimeWithAggregatesFilter_notCopyWithImpl<$Res,
        _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>
    implements
        _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
            $Res> {
  __$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl(
      _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
          _value,
      $Res Function(
              _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeWithAggregatesFilter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeWithAggregatesFilterCopyWith<$Res> get value {
    return $NestedDateTimeWithAggregatesFilterCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
    implements
        NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter {
  const _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withNestedDateTimeWithAggregatesFilter';

  factory _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterFromJson(
          json);

  @override
  final NestedDateTimeWithAggregatesFilter value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'NestedDateTimeWithAggregatesFilter_not.withNestedDateTimeWithAggregatesFilter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
          _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>
      get copyWith =>
          __$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWithImpl<
                  _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)
        withDateTime,
    required TResult Function(NestedDateTimeWithAggregatesFilter value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult? Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(@JsonKey(toJson: dateTimeToJson) DateTime value)?
        withDateTime,
    TResult Function(NestedDateTimeWithAggregatesFilter value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeWithAggregatesFilter != null) {
      return withNestedDateTimeWithAggregatesFilter(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withDateTime value)
        withDateTime,
    required TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            NestedDateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult? Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
  }) {
    return withNestedDateTimeWithAggregatesFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NestedDateTimeWithAggregatesFilter_not_withDateTime value)?
        withDateTime,
    TResult Function(
            NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
                value)?
        withNestedDateTimeWithAggregatesFilter,
    required TResult orElse(),
  }) {
    if (withNestedDateTimeWithAggregatesFilter != null) {
      return withNestedDateTimeWithAggregatesFilter(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
    implements NestedDateTimeWithAggregatesFilter_not {
  const factory NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter(
          final NestedDateTimeWithAggregatesFilter value) =
      _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter;

  factory NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter
          .fromJson;

  @override
  NestedDateTimeWithAggregatesFilter get value;
  @JsonKey(ignore: true)
  _$$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilterCopyWith<
          _$NestedDateTimeWithAggregatesFilter_not_withNestedDateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

NestedDateTimeWithAggregatesFilter _$NestedDateTimeWithAggregatesFilterFromJson(
    Map<String, dynamic> json) {
  return _NestedDateTimeWithAggregatesFilter.fromJson(json);
}

/// @nodoc
mixin _$NestedDateTimeWithAggregatesFilter {
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals => throw _privateConstructorUsedError;
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in => throw _privateConstructorUsedError;
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn => throw _privateConstructorUsedError;
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt => throw _privateConstructorUsedError;
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte => throw _privateConstructorUsedError;
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt => throw _privateConstructorUsedError;
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte => throw _privateConstructorUsedError;
  @JsonKey(name: 'not')
  NestedDateTimeWithAggregatesFilter_not? get not =>
      throw _privateConstructorUsedError;
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count => throw _privateConstructorUsedError;
  @JsonKey(name: '_min')
  NestedDateTimeFilter? get prisma__min => throw _privateConstructorUsedError;
  @JsonKey(name: '_max')
  NestedDateTimeFilter? get prisma__max => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NestedDateTimeWithAggregatesFilterCopyWith<
          NestedDateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NestedDateTimeWithAggregatesFilterCopyWith<$Res> {
  factory $NestedDateTimeWithAggregatesFilterCopyWith(
          NestedDateTimeWithAggregatesFilter value,
          $Res Function(NestedDateTimeWithAggregatesFilter) then) =
      _$NestedDateTimeWithAggregatesFilterCopyWithImpl<$Res,
          NestedDateTimeWithAggregatesFilter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') NestedDateTimeWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedDateTimeFilter? prisma__min,
      @JsonKey(name: '_max') NestedDateTimeFilter? prisma__max});

  $NestedDateTimeWithAggregatesFilter_notCopyWith<$Res>? get not;
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__min;
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class _$NestedDateTimeWithAggregatesFilterCopyWithImpl<$Res,
        $Val extends NestedDateTimeWithAggregatesFilter>
    implements $NestedDateTimeWithAggregatesFilterCopyWith<$Res> {
  _$NestedDateTimeWithAggregatesFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_value.copyWith(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value.dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value.notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeWithAggregatesFilter_notCopyWith<$Res>? get not {
    if (_value.not == null) {
      return null;
    }

    return $NestedDateTimeWithAggregatesFilter_notCopyWith<$Res>(_value.not!,
        (value) {
      return _then(_value.copyWith(not: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedIntFilterCopyWith<$Res>? get prisma__count {
    if (_value.prisma__count == null) {
      return null;
    }

    return $NestedIntFilterCopyWith<$Res>(_value.prisma__count!, (value) {
      return _then(_value.copyWith(prisma__count: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__min {
    if (_value.prisma__min == null) {
      return null;
    }

    return $NestedDateTimeFilterCopyWith<$Res>(_value.prisma__min!, (value) {
      return _then(_value.copyWith(prisma__min: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__max {
    if (_value.prisma__max == null) {
      return null;
    }

    return $NestedDateTimeFilterCopyWith<$Res>(_value.prisma__max!, (value) {
      return _then(_value.copyWith(prisma__max: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NestedDateTimeWithAggregatesFilterCopyWith<$Res>
    implements $NestedDateTimeWithAggregatesFilterCopyWith<$Res> {
  factory _$$_NestedDateTimeWithAggregatesFilterCopyWith(
          _$_NestedDateTimeWithAggregatesFilter value,
          $Res Function(_$_NestedDateTimeWithAggregatesFilter) then) =
      __$$_NestedDateTimeWithAggregatesFilterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson) DateTime? equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson) List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson) List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson) DateTime? lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson) DateTime? lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson) DateTime? gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson) DateTime? gte,
      @JsonKey(name: 'not') NestedDateTimeWithAggregatesFilter_not? not,
      @JsonKey(name: '_count') NestedIntFilter? prisma__count,
      @JsonKey(name: '_min') NestedDateTimeFilter? prisma__min,
      @JsonKey(name: '_max') NestedDateTimeFilter? prisma__max});

  @override
  $NestedDateTimeWithAggregatesFilter_notCopyWith<$Res>? get not;
  @override
  $NestedIntFilterCopyWith<$Res>? get prisma__count;
  @override
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__min;
  @override
  $NestedDateTimeFilterCopyWith<$Res>? get prisma__max;
}

/// @nodoc
class __$$_NestedDateTimeWithAggregatesFilterCopyWithImpl<$Res>
    extends _$NestedDateTimeWithAggregatesFilterCopyWithImpl<$Res,
        _$_NestedDateTimeWithAggregatesFilter>
    implements _$$_NestedDateTimeWithAggregatesFilterCopyWith<$Res> {
  __$$_NestedDateTimeWithAggregatesFilterCopyWithImpl(
      _$_NestedDateTimeWithAggregatesFilter _value,
      $Res Function(_$_NestedDateTimeWithAggregatesFilter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? equals = freezed,
    Object? dart__in = freezed,
    Object? notIn = freezed,
    Object? lt = freezed,
    Object? lte = freezed,
    Object? gt = freezed,
    Object? gte = freezed,
    Object? not = freezed,
    Object? prisma__count = freezed,
    Object? prisma__min = freezed,
    Object? prisma__max = freezed,
  }) {
    return _then(_$_NestedDateTimeWithAggregatesFilter(
      equals: freezed == equals
          ? _value.equals
          : equals // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dart__in: freezed == dart__in
          ? _value._dart__in
          : dart__in // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      notIn: freezed == notIn
          ? _value._notIn
          : notIn // ignore: cast_nullable_to_non_nullable
              as List<DateTime>?,
      lt: freezed == lt
          ? _value.lt
          : lt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lte: freezed == lte
          ? _value.lte
          : lte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gt: freezed == gt
          ? _value.gt
          : gt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      gte: freezed == gte
          ? _value.gte
          : gte // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      not: freezed == not
          ? _value.not
          : not // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeWithAggregatesFilter_not?,
      prisma__count: freezed == prisma__count
          ? _value.prisma__count
          : prisma__count // ignore: cast_nullable_to_non_nullable
              as NestedIntFilter?,
      prisma__min: freezed == prisma__min
          ? _value.prisma__min
          : prisma__min // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
      prisma__max: freezed == prisma__max
          ? _value.prisma__max
          : prisma__max // ignore: cast_nullable_to_non_nullable
              as NestedDateTimeFilter?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NestedDateTimeWithAggregatesFilter
    implements _NestedDateTimeWithAggregatesFilter {
  const _$_NestedDateTimeWithAggregatesFilter(
      {@JsonKey(name: 'equals', toJson: dateTimeToJson)
          this.equals,
      @JsonKey(name: 'in', toJson: dateTimeToJson)
          final List<DateTime>? dart__in,
      @JsonKey(name: 'notIn', toJson: dateTimeToJson)
          final List<DateTime>? notIn,
      @JsonKey(name: 'lt', toJson: dateTimeToJson)
          this.lt,
      @JsonKey(name: 'lte', toJson: dateTimeToJson)
          this.lte,
      @JsonKey(name: 'gt', toJson: dateTimeToJson)
          this.gt,
      @JsonKey(name: 'gte', toJson: dateTimeToJson)
          this.gte,
      @JsonKey(name: 'not')
          this.not,
      @JsonKey(name: '_count')
          this.prisma__count,
      @JsonKey(name: '_min')
          this.prisma__min,
      @JsonKey(name: '_max')
          this.prisma__max})
      : _dart__in = dart__in,
        _notIn = notIn;

  factory _$_NestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$$_NestedDateTimeWithAggregatesFilterFromJson(json);

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  final DateTime? equals;
  final List<DateTime>? _dart__in;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in {
    final value = _dart__in;
    if (value == null) return null;
    if (_dart__in is EqualUnmodifiableListView) return _dart__in;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<DateTime>? _notIn;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn {
    final value = _notIn;
    if (value == null) return null;
    if (_notIn is EqualUnmodifiableListView) return _notIn;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  final DateTime? lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  final DateTime? lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  final DateTime? gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  final DateTime? gte;
  @override
  @JsonKey(name: 'not')
  final NestedDateTimeWithAggregatesFilter_not? not;
  @override
  @JsonKey(name: '_count')
  final NestedIntFilter? prisma__count;
  @override
  @JsonKey(name: '_min')
  final NestedDateTimeFilter? prisma__min;
  @override
  @JsonKey(name: '_max')
  final NestedDateTimeFilter? prisma__max;

  @override
  String toString() {
    return 'NestedDateTimeWithAggregatesFilter(equals: $equals, dart__in: $dart__in, notIn: $notIn, lt: $lt, lte: $lte, gt: $gt, gte: $gte, not: $not, prisma__count: $prisma__count, prisma__min: $prisma__min, prisma__max: $prisma__max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NestedDateTimeWithAggregatesFilter &&
            (identical(other.equals, equals) || other.equals == equals) &&
            const DeepCollectionEquality().equals(other._dart__in, _dart__in) &&
            const DeepCollectionEquality().equals(other._notIn, _notIn) &&
            (identical(other.lt, lt) || other.lt == lt) &&
            (identical(other.lte, lte) || other.lte == lte) &&
            (identical(other.gt, gt) || other.gt == gt) &&
            (identical(other.gte, gte) || other.gte == gte) &&
            (identical(other.not, not) || other.not == not) &&
            (identical(other.prisma__count, prisma__count) ||
                other.prisma__count == prisma__count) &&
            (identical(other.prisma__min, prisma__min) ||
                other.prisma__min == prisma__min) &&
            (identical(other.prisma__max, prisma__max) ||
                other.prisma__max == prisma__max));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      equals,
      const DeepCollectionEquality().hash(_dart__in),
      const DeepCollectionEquality().hash(_notIn),
      lt,
      lte,
      gt,
      gte,
      not,
      prisma__count,
      prisma__min,
      prisma__max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NestedDateTimeWithAggregatesFilterCopyWith<
          _$_NestedDateTimeWithAggregatesFilter>
      get copyWith => __$$_NestedDateTimeWithAggregatesFilterCopyWithImpl<
          _$_NestedDateTimeWithAggregatesFilter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NestedDateTimeWithAggregatesFilterToJson(
      this,
    );
  }
}

abstract class _NestedDateTimeWithAggregatesFilter
    implements NestedDateTimeWithAggregatesFilter {
  const factory _NestedDateTimeWithAggregatesFilter(
          {@JsonKey(name: 'equals', toJson: dateTimeToJson)
              final DateTime? equals,
          @JsonKey(name: 'in', toJson: dateTimeToJson)
              final List<DateTime>? dart__in,
          @JsonKey(name: 'notIn', toJson: dateTimeToJson)
              final List<DateTime>? notIn,
          @JsonKey(name: 'lt', toJson: dateTimeToJson)
              final DateTime? lt,
          @JsonKey(name: 'lte', toJson: dateTimeToJson)
              final DateTime? lte,
          @JsonKey(name: 'gt', toJson: dateTimeToJson)
              final DateTime? gt,
          @JsonKey(name: 'gte', toJson: dateTimeToJson)
              final DateTime? gte,
          @JsonKey(name: 'not')
              final NestedDateTimeWithAggregatesFilter_not? not,
          @JsonKey(name: '_count')
              final NestedIntFilter? prisma__count,
          @JsonKey(name: '_min')
              final NestedDateTimeFilter? prisma__min,
          @JsonKey(name: '_max')
              final NestedDateTimeFilter? prisma__max}) =
      _$_NestedDateTimeWithAggregatesFilter;

  factory _NestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =
      _$_NestedDateTimeWithAggregatesFilter.fromJson;

  @override
  @JsonKey(name: 'equals', toJson: dateTimeToJson)
  DateTime? get equals;
  @override
  @JsonKey(name: 'in', toJson: dateTimeToJson)
  List<DateTime>? get dart__in;
  @override
  @JsonKey(name: 'notIn', toJson: dateTimeToJson)
  List<DateTime>? get notIn;
  @override
  @JsonKey(name: 'lt', toJson: dateTimeToJson)
  DateTime? get lt;
  @override
  @JsonKey(name: 'lte', toJson: dateTimeToJson)
  DateTime? get lte;
  @override
  @JsonKey(name: 'gt', toJson: dateTimeToJson)
  DateTime? get gt;
  @override
  @JsonKey(name: 'gte', toJson: dateTimeToJson)
  DateTime? get gte;
  @override
  @JsonKey(name: 'not')
  NestedDateTimeWithAggregatesFilter_not? get not;
  @override
  @JsonKey(name: '_count')
  NestedIntFilter? get prisma__count;
  @override
  @JsonKey(name: '_min')
  NestedDateTimeFilter? get prisma__min;
  @override
  @JsonKey(name: '_max')
  NestedDateTimeFilter? get prisma__max;
  @override
  @JsonKey(ignore: true)
  _$$_NestedDateTimeWithAggregatesFilterCopyWith<
          _$_NestedDateTimeWithAggregatesFilter>
      get copyWith => throw _privateConstructorUsedError;
}

FindFirstUserOrderBy _$FindFirstUserOrderByFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserOrderByWithRelationInputList':
      return _FindFirstUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          json);
    case 'withUserOrderByWithRelationInput':
      return _FindFirstUserOrderByWithUserOrderByWithRelationInput.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'FindFirstUserOrderBy',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FindFirstUserOrderBy {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FindFirstUserOrderByCopyWith<$Res> {
  factory $FindFirstUserOrderByCopyWith(FindFirstUserOrderBy value,
          $Res Function(FindFirstUserOrderBy) then) =
      _$FindFirstUserOrderByCopyWithImpl<$Res, FindFirstUserOrderBy>;
}

/// @nodoc
class _$FindFirstUserOrderByCopyWithImpl<$Res,
        $Val extends FindFirstUserOrderBy>
    implements $FindFirstUserOrderByCopyWith<$Res> {
  _$FindFirstUserOrderByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWith<
    $Res> {
  factory _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWith(
          _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList value,
          $Res Function(
                  _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList)
              then) =
      __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserOrderByWithRelationInput> value});
}

/// @nodoc
class __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
        $Res>
    extends _$FindFirstUserOrderByCopyWithImpl<$Res,
        _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList>
    implements
        _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWith<
            $Res> {
  __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl(
      _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList _value,
      $Res Function(_$_FindFirstUserOrderByWithUserOrderByWithRelationInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_FindFirstUserOrderByWithUserOrderByWithRelationInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserOrderByWithRelationInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList
    implements _FindFirstUserOrderByWithUserOrderByWithRelationInputList {
  const _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList(
      final List<UserOrderByWithRelationInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserOrderByWithRelationInputList';

  factory _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListFromJson(
          json);

  final List<UserOrderByWithRelationInput> _value;
  @override
  List<UserOrderByWithRelationInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FindFirstUserOrderBy.withUserOrderByWithRelationInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList>
      get copyWith =>
          __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
                  _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListToJson(
      this,
    );
  }
}

abstract class _FindFirstUserOrderByWithUserOrderByWithRelationInputList
    implements FindFirstUserOrderBy {
  const factory _FindFirstUserOrderByWithUserOrderByWithRelationInputList(
          final List<UserOrderByWithRelationInput> value) =
      _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList;

  factory _FindFirstUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =
      _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList.fromJson;

  @override
  List<UserOrderByWithRelationInput> get value;
  @JsonKey(ignore: true)
  _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_FindFirstUserOrderByWithUserOrderByWithRelationInputList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWith<
    $Res> {
  factory _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWith(
          _$_FindFirstUserOrderByWithUserOrderByWithRelationInput value,
          $Res Function(_$_FindFirstUserOrderByWithUserOrderByWithRelationInput)
              then) =
      __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserOrderByWithRelationInput value});

  $UserOrderByWithRelationInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
        $Res>
    extends _$FindFirstUserOrderByCopyWithImpl<$Res,
        _$_FindFirstUserOrderByWithUserOrderByWithRelationInput>
    implements
        _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWith<$Res> {
  __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWithImpl(
      _$_FindFirstUserOrderByWithUserOrderByWithRelationInput _value,
      $Res Function(_$_FindFirstUserOrderByWithUserOrderByWithRelationInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_FindFirstUserOrderByWithUserOrderByWithRelationInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserOrderByWithRelationInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserOrderByWithRelationInputCopyWith<$Res> get value {
    return $UserOrderByWithRelationInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_FindFirstUserOrderByWithUserOrderByWithRelationInput
    implements _FindFirstUserOrderByWithUserOrderByWithRelationInput {
  const _$_FindFirstUserOrderByWithUserOrderByWithRelationInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserOrderByWithRelationInput';

  factory _$_FindFirstUserOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputFromJson(json);

  @override
  final UserOrderByWithRelationInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FindFirstUserOrderBy.withUserOrderByWithRelationInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FindFirstUserOrderByWithUserOrderByWithRelationInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_FindFirstUserOrderByWithUserOrderByWithRelationInput>
      get copyWith =>
          __$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
                  _$_FindFirstUserOrderByWithUserOrderByWithRelationInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindFirstUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputToJson(
      this,
    );
  }
}

abstract class _FindFirstUserOrderByWithUserOrderByWithRelationInput
    implements FindFirstUserOrderBy {
  const factory _FindFirstUserOrderByWithUserOrderByWithRelationInput(
          final UserOrderByWithRelationInput value) =
      _$_FindFirstUserOrderByWithUserOrderByWithRelationInput;

  factory _FindFirstUserOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =
      _$_FindFirstUserOrderByWithUserOrderByWithRelationInput.fromJson;

  @override
  UserOrderByWithRelationInput get value;
  @JsonKey(ignore: true)
  _$$_FindFirstUserOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_FindFirstUserOrderByWithUserOrderByWithRelationInput>
      get copyWith => throw _privateConstructorUsedError;
}

FindFirstUserOrThrowOrderBy _$FindFirstUserOrThrowOrderByFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserOrderByWithRelationInputList':
      return _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
          .fromJson(json);
    case 'withUserOrderByWithRelationInput':
      return _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput
          .fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'FindFirstUserOrThrowOrderBy',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FindFirstUserOrThrowOrderBy {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FindFirstUserOrThrowOrderByCopyWith<$Res> {
  factory $FindFirstUserOrThrowOrderByCopyWith(
          FindFirstUserOrThrowOrderBy value,
          $Res Function(FindFirstUserOrThrowOrderBy) then) =
      _$FindFirstUserOrThrowOrderByCopyWithImpl<$Res,
          FindFirstUserOrThrowOrderBy>;
}

/// @nodoc
class _$FindFirstUserOrThrowOrderByCopyWithImpl<$Res,
        $Val extends FindFirstUserOrThrowOrderBy>
    implements $FindFirstUserOrThrowOrderByCopyWith<$Res> {
  _$FindFirstUserOrThrowOrderByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWith<
    $Res> {
  factory _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWith(
          _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList value,
          $Res Function(
                  _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList)
              then) =
      __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserOrderByWithRelationInput> value});
}

/// @nodoc
class __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
        $Res>
    extends _$FindFirstUserOrThrowOrderByCopyWithImpl<$Res,
        _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList>
    implements
        _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWith<
            $Res> {
  __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWithImpl(
      _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList _value,
      $Res Function(
              _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(
        _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserOrderByWithRelationInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
    implements
        _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList {
  const _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList(
      final List<UserOrderByWithRelationInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserOrderByWithRelationInputList';

  factory _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListFromJson(
          json);

  final List<UserOrderByWithRelationInput> _value;
  @override
  List<UserOrderByWithRelationInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FindFirstUserOrThrowOrderBy.withUserOrderByWithRelationInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList>
      get copyWith =>
          __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
                  _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListToJson(
      this,
    );
  }
}

abstract class _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
    implements FindFirstUserOrThrowOrderBy {
  const factory _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList(
          final List<UserOrderByWithRelationInput> value) =
      _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList;

  factory _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =
      _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
          .fromJson;

  @override
  List<UserOrderByWithRelationInput> get value;
  @JsonKey(ignore: true)
  _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWith<
    $Res> {
  factory _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWith(
          _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value,
          $Res Function(
                  _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput)
              then) =
      __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserOrderByWithRelationInput value});

  $UserOrderByWithRelationInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWithImpl<
        $Res>
    extends _$FindFirstUserOrThrowOrderByCopyWithImpl<$Res,
        _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput>
    implements
        _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWith<
            $Res> {
  __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWithImpl(
      _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput _value,
      $Res Function(
              _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserOrderByWithRelationInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserOrderByWithRelationInputCopyWith<$Res> get value {
    return $UserOrderByWithRelationInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput
    implements _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput {
  const _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput(
      this.value,
      {final String? $type})
      : $type = $type ?? 'withUserOrderByWithRelationInput';

  factory _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputFromJson(
          json);

  @override
  final UserOrderByWithRelationInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FindFirstUserOrThrowOrderBy.withUserOrderByWithRelationInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput>
      get copyWith =>
          __$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWithImpl<
                  _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputList
                value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputToJson(
      this,
    );
  }
}

abstract class _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput
    implements FindFirstUserOrThrowOrderBy {
  const factory _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput(
          final UserOrderByWithRelationInput value) =
      _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput;

  factory _FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =
      _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput.fromJson;

  @override
  UserOrderByWithRelationInput get value;
  @JsonKey(ignore: true)
  _$$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_FindFirstUserOrThrowOrderByWithUserOrderByWithRelationInput>
      get copyWith => throw _privateConstructorUsedError;
}

FindManyUserOrderBy _$FindManyUserOrderByFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserOrderByWithRelationInputList':
      return _FindManyUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          json);
    case 'withUserOrderByWithRelationInput':
      return _FindManyUserOrderByWithUserOrderByWithRelationInput.fromJson(
          json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'FindManyUserOrderBy',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$FindManyUserOrderBy {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FindManyUserOrderByCopyWith<$Res> {
  factory $FindManyUserOrderByCopyWith(
          FindManyUserOrderBy value, $Res Function(FindManyUserOrderBy) then) =
      _$FindManyUserOrderByCopyWithImpl<$Res, FindManyUserOrderBy>;
}

/// @nodoc
class _$FindManyUserOrderByCopyWithImpl<$Res, $Val extends FindManyUserOrderBy>
    implements $FindManyUserOrderByCopyWith<$Res> {
  _$FindManyUserOrderByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWith<
    $Res> {
  factory _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWith(
          _$_FindManyUserOrderByWithUserOrderByWithRelationInputList value,
          $Res Function(
                  _$_FindManyUserOrderByWithUserOrderByWithRelationInputList)
              then) =
      __$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserOrderByWithRelationInput> value});
}

/// @nodoc
class __$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
        $Res>
    extends _$FindManyUserOrderByCopyWithImpl<$Res,
        _$_FindManyUserOrderByWithUserOrderByWithRelationInputList>
    implements
        _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWith<
            $Res> {
  __$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl(
      _$_FindManyUserOrderByWithUserOrderByWithRelationInputList _value,
      $Res Function(_$_FindManyUserOrderByWithUserOrderByWithRelationInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_FindManyUserOrderByWithUserOrderByWithRelationInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserOrderByWithRelationInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FindManyUserOrderByWithUserOrderByWithRelationInputList
    implements _FindManyUserOrderByWithUserOrderByWithRelationInputList {
  const _$_FindManyUserOrderByWithUserOrderByWithRelationInputList(
      final List<UserOrderByWithRelationInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserOrderByWithRelationInputList';

  factory _$_FindManyUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListFromJson(json);

  final List<UserOrderByWithRelationInput> _value;
  @override
  List<UserOrderByWithRelationInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FindManyUserOrderBy.withUserOrderByWithRelationInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_FindManyUserOrderByWithUserOrderByWithRelationInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_FindManyUserOrderByWithUserOrderByWithRelationInputList>
      get copyWith =>
          __$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
                  _$_FindManyUserOrderByWithUserOrderByWithRelationInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListToJson(
      this,
    );
  }
}

abstract class _FindManyUserOrderByWithUserOrderByWithRelationInputList
    implements FindManyUserOrderBy {
  const factory _FindManyUserOrderByWithUserOrderByWithRelationInputList(
          final List<UserOrderByWithRelationInput> value) =
      _$_FindManyUserOrderByWithUserOrderByWithRelationInputList;

  factory _FindManyUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =
      _$_FindManyUserOrderByWithUserOrderByWithRelationInputList.fromJson;

  @override
  List<UserOrderByWithRelationInput> get value;
  @JsonKey(ignore: true)
  _$$_FindManyUserOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_FindManyUserOrderByWithUserOrderByWithRelationInputList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWith<
    $Res> {
  factory _$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWith(
          _$_FindManyUserOrderByWithUserOrderByWithRelationInput value,
          $Res Function(_$_FindManyUserOrderByWithUserOrderByWithRelationInput)
              then) =
      __$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserOrderByWithRelationInput value});

  $UserOrderByWithRelationInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<$Res>
    extends _$FindManyUserOrderByCopyWithImpl<$Res,
        _$_FindManyUserOrderByWithUserOrderByWithRelationInput>
    implements
        _$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWith<$Res> {
  __$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWithImpl(
      _$_FindManyUserOrderByWithUserOrderByWithRelationInput _value,
      $Res Function(_$_FindManyUserOrderByWithUserOrderByWithRelationInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_FindManyUserOrderByWithUserOrderByWithRelationInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserOrderByWithRelationInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserOrderByWithRelationInputCopyWith<$Res> get value {
    return $UserOrderByWithRelationInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_FindManyUserOrderByWithUserOrderByWithRelationInput
    implements _FindManyUserOrderByWithUserOrderByWithRelationInput {
  const _$_FindManyUserOrderByWithUserOrderByWithRelationInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserOrderByWithRelationInput';

  factory _$_FindManyUserOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_FindManyUserOrderByWithUserOrderByWithRelationInputFromJson(json);

  @override
  final UserOrderByWithRelationInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'FindManyUserOrderBy.withUserOrderByWithRelationInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FindManyUserOrderByWithUserOrderByWithRelationInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_FindManyUserOrderByWithUserOrderByWithRelationInput>
      get copyWith =>
          __$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
                  _$_FindManyUserOrderByWithUserOrderByWithRelationInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _FindManyUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_FindManyUserOrderByWithUserOrderByWithRelationInputToJson(
      this,
    );
  }
}

abstract class _FindManyUserOrderByWithUserOrderByWithRelationInput
    implements FindManyUserOrderBy {
  const factory _FindManyUserOrderByWithUserOrderByWithRelationInput(
          final UserOrderByWithRelationInput value) =
      _$_FindManyUserOrderByWithUserOrderByWithRelationInput;

  factory _FindManyUserOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =
      _$_FindManyUserOrderByWithUserOrderByWithRelationInput.fromJson;

  @override
  UserOrderByWithRelationInput get value;
  @JsonKey(ignore: true)
  _$$_FindManyUserOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_FindManyUserOrderByWithUserOrderByWithRelationInput>
      get copyWith => throw _privateConstructorUsedError;
}

CreateOneUserData _$CreateOneUserDataFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserCreateInput':
      return _CreateOneUserDataWithUserCreateInput.fromJson(json);
    case 'withUserUncheckedCreateInput':
      return _CreateOneUserDataWithUserUncheckedCreateInput.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'CreateOneUserData',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$CreateOneUserData {
  _i1.JsonSerializable get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserCreateInput value) withUserCreateInput,
    required TResult Function(UserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserCreateInput value)? withUserCreateInput,
    TResult? Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserCreateInput value)? withUserCreateInput,
    TResult Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateOneUserDataWithUserCreateInput value)
        withUserCreateInput,
    required TResult Function(
            _CreateOneUserDataWithUserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateOneUserDataWithUserCreateInput value)?
        withUserCreateInput,
    TResult? Function(_CreateOneUserDataWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateOneUserDataWithUserCreateInput value)?
        withUserCreateInput,
    TResult Function(_CreateOneUserDataWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateOneUserDataCopyWith<$Res> {
  factory $CreateOneUserDataCopyWith(
          CreateOneUserData value, $Res Function(CreateOneUserData) then) =
      _$CreateOneUserDataCopyWithImpl<$Res, CreateOneUserData>;
}

/// @nodoc
class _$CreateOneUserDataCopyWithImpl<$Res, $Val extends CreateOneUserData>
    implements $CreateOneUserDataCopyWith<$Res> {
  _$CreateOneUserDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_CreateOneUserDataWithUserCreateInputCopyWith<$Res> {
  factory _$$_CreateOneUserDataWithUserCreateInputCopyWith(
          _$_CreateOneUserDataWithUserCreateInput value,
          $Res Function(_$_CreateOneUserDataWithUserCreateInput) then) =
      __$$_CreateOneUserDataWithUserCreateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserCreateInput value});

  $UserCreateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_CreateOneUserDataWithUserCreateInputCopyWithImpl<$Res>
    extends _$CreateOneUserDataCopyWithImpl<$Res,
        _$_CreateOneUserDataWithUserCreateInput>
    implements _$$_CreateOneUserDataWithUserCreateInputCopyWith<$Res> {
  __$$_CreateOneUserDataWithUserCreateInputCopyWithImpl(
      _$_CreateOneUserDataWithUserCreateInput _value,
      $Res Function(_$_CreateOneUserDataWithUserCreateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_CreateOneUserDataWithUserCreateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserCreateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCreateInputCopyWith<$Res> get value {
    return $UserCreateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_CreateOneUserDataWithUserCreateInput
    implements _CreateOneUserDataWithUserCreateInput {
  const _$_CreateOneUserDataWithUserCreateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserCreateInput';

  factory _$_CreateOneUserDataWithUserCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_CreateOneUserDataWithUserCreateInputFromJson(json);

  @override
  final UserCreateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateOneUserData.withUserCreateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CreateOneUserDataWithUserCreateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CreateOneUserDataWithUserCreateInputCopyWith<
          _$_CreateOneUserDataWithUserCreateInput>
      get copyWith => __$$_CreateOneUserDataWithUserCreateInputCopyWithImpl<
          _$_CreateOneUserDataWithUserCreateInput>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserCreateInput value) withUserCreateInput,
    required TResult Function(UserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserCreateInput value)? withUserCreateInput,
    TResult? Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserCreateInput value)? withUserCreateInput,
    TResult Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserCreateInput != null) {
      return withUserCreateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateOneUserDataWithUserCreateInput value)
        withUserCreateInput,
    required TResult Function(
            _CreateOneUserDataWithUserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateOneUserDataWithUserCreateInput value)?
        withUserCreateInput,
    TResult? Function(_CreateOneUserDataWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateOneUserDataWithUserCreateInput value)?
        withUserCreateInput,
    TResult Function(_CreateOneUserDataWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserCreateInput != null) {
      return withUserCreateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_CreateOneUserDataWithUserCreateInputToJson(
      this,
    );
  }
}

abstract class _CreateOneUserDataWithUserCreateInput
    implements CreateOneUserData {
  const factory _CreateOneUserDataWithUserCreateInput(
      final UserCreateInput value) = _$_CreateOneUserDataWithUserCreateInput;

  factory _CreateOneUserDataWithUserCreateInput.fromJson(
          Map<String, dynamic> json) =
      _$_CreateOneUserDataWithUserCreateInput.fromJson;

  @override
  UserCreateInput get value;
  @JsonKey(ignore: true)
  _$$_CreateOneUserDataWithUserCreateInputCopyWith<
          _$_CreateOneUserDataWithUserCreateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWith<$Res> {
  factory _$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWith(
          _$_CreateOneUserDataWithUserUncheckedCreateInput value,
          $Res Function(_$_CreateOneUserDataWithUserUncheckedCreateInput)
              then) =
      __$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUncheckedCreateInput value});

  $UserUncheckedCreateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWithImpl<$Res>
    extends _$CreateOneUserDataCopyWithImpl<$Res,
        _$_CreateOneUserDataWithUserUncheckedCreateInput>
    implements _$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWith<$Res> {
  __$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWithImpl(
      _$_CreateOneUserDataWithUserUncheckedCreateInput _value,
      $Res Function(_$_CreateOneUserDataWithUserUncheckedCreateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_CreateOneUserDataWithUserUncheckedCreateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUncheckedCreateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedCreateInputCopyWith<$Res> get value {
    return $UserUncheckedCreateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_CreateOneUserDataWithUserUncheckedCreateInput
    implements _CreateOneUserDataWithUserUncheckedCreateInput {
  const _$_CreateOneUserDataWithUserUncheckedCreateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUncheckedCreateInput';

  factory _$_CreateOneUserDataWithUserUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_CreateOneUserDataWithUserUncheckedCreateInputFromJson(json);

  @override
  final UserUncheckedCreateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'CreateOneUserData.withUserUncheckedCreateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CreateOneUserDataWithUserUncheckedCreateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWith<
          _$_CreateOneUserDataWithUserUncheckedCreateInput>
      get copyWith =>
          __$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWithImpl<
                  _$_CreateOneUserDataWithUserUncheckedCreateInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserCreateInput value) withUserCreateInput,
    required TResult Function(UserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserCreateInput value)? withUserCreateInput,
    TResult? Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserCreateInput value)? withUserCreateInput,
    TResult Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedCreateInput != null) {
      return withUserUncheckedCreateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateOneUserDataWithUserCreateInput value)
        withUserCreateInput,
    required TResult Function(
            _CreateOneUserDataWithUserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateOneUserDataWithUserCreateInput value)?
        withUserCreateInput,
    TResult? Function(_CreateOneUserDataWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateOneUserDataWithUserCreateInput value)?
        withUserCreateInput,
    TResult Function(_CreateOneUserDataWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedCreateInput != null) {
      return withUserUncheckedCreateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_CreateOneUserDataWithUserUncheckedCreateInputToJson(
      this,
    );
  }
}

abstract class _CreateOneUserDataWithUserUncheckedCreateInput
    implements CreateOneUserData {
  const factory _CreateOneUserDataWithUserUncheckedCreateInput(
          final UserUncheckedCreateInput value) =
      _$_CreateOneUserDataWithUserUncheckedCreateInput;

  factory _CreateOneUserDataWithUserUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =
      _$_CreateOneUserDataWithUserUncheckedCreateInput.fromJson;

  @override
  UserUncheckedCreateInput get value;
  @JsonKey(ignore: true)
  _$$_CreateOneUserDataWithUserUncheckedCreateInputCopyWith<
          _$_CreateOneUserDataWithUserUncheckedCreateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UpdateOneUserData _$UpdateOneUserDataFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserUpdateInput':
      return _UpdateOneUserDataWithUserUpdateInput.fromJson(json);
    case 'withUserUncheckedUpdateInput':
      return _UpdateOneUserDataWithUserUncheckedUpdateInput.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UpdateOneUserData',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UpdateOneUserData {
  _i1.JsonSerializable get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateInput value) withUserUpdateInput,
    required TResult Function(UserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput value)? withUserUpdateInput,
    TResult? Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateInput value)? withUserUpdateInput,
    TResult Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateOneUserDataWithUserUpdateInput value)
        withUserUpdateInput,
    required TResult Function(
            _UpdateOneUserDataWithUserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateOneUserDataWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult? Function(_UpdateOneUserDataWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateOneUserDataWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult Function(_UpdateOneUserDataWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateOneUserDataCopyWith<$Res> {
  factory $UpdateOneUserDataCopyWith(
          UpdateOneUserData value, $Res Function(UpdateOneUserData) then) =
      _$UpdateOneUserDataCopyWithImpl<$Res, UpdateOneUserData>;
}

/// @nodoc
class _$UpdateOneUserDataCopyWithImpl<$Res, $Val extends UpdateOneUserData>
    implements $UpdateOneUserDataCopyWith<$Res> {
  _$UpdateOneUserDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpdateOneUserDataWithUserUpdateInputCopyWith<$Res> {
  factory _$$_UpdateOneUserDataWithUserUpdateInputCopyWith(
          _$_UpdateOneUserDataWithUserUpdateInput value,
          $Res Function(_$_UpdateOneUserDataWithUserUpdateInput) then) =
      __$$_UpdateOneUserDataWithUserUpdateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUpdateInput value});

  $UserUpdateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpdateOneUserDataWithUserUpdateInputCopyWithImpl<$Res>
    extends _$UpdateOneUserDataCopyWithImpl<$Res,
        _$_UpdateOneUserDataWithUserUpdateInput>
    implements _$$_UpdateOneUserDataWithUserUpdateInputCopyWith<$Res> {
  __$$_UpdateOneUserDataWithUserUpdateInputCopyWithImpl(
      _$_UpdateOneUserDataWithUserUpdateInput _value,
      $Res Function(_$_UpdateOneUserDataWithUserUpdateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateOneUserDataWithUserUpdateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUpdateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateInputCopyWith<$Res> get value {
    return $UserUpdateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpdateOneUserDataWithUserUpdateInput
    implements _UpdateOneUserDataWithUserUpdateInput {
  const _$_UpdateOneUserDataWithUserUpdateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUpdateInput';

  factory _$_UpdateOneUserDataWithUserUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpdateOneUserDataWithUserUpdateInputFromJson(json);

  @override
  final UserUpdateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpdateOneUserData.withUserUpdateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateOneUserDataWithUserUpdateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateOneUserDataWithUserUpdateInputCopyWith<
          _$_UpdateOneUserDataWithUserUpdateInput>
      get copyWith => __$$_UpdateOneUserDataWithUserUpdateInputCopyWithImpl<
          _$_UpdateOneUserDataWithUserUpdateInput>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateInput value) withUserUpdateInput,
    required TResult Function(UserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput value)? withUserUpdateInput,
    TResult? Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateInput value)? withUserUpdateInput,
    TResult Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUpdateInput != null) {
      return withUserUpdateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateOneUserDataWithUserUpdateInput value)
        withUserUpdateInput,
    required TResult Function(
            _UpdateOneUserDataWithUserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateOneUserDataWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult? Function(_UpdateOneUserDataWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateOneUserDataWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult Function(_UpdateOneUserDataWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUpdateInput != null) {
      return withUserUpdateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpdateOneUserDataWithUserUpdateInputToJson(
      this,
    );
  }
}

abstract class _UpdateOneUserDataWithUserUpdateInput
    implements UpdateOneUserData {
  const factory _UpdateOneUserDataWithUserUpdateInput(
      final UserUpdateInput value) = _$_UpdateOneUserDataWithUserUpdateInput;

  factory _UpdateOneUserDataWithUserUpdateInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpdateOneUserDataWithUserUpdateInput.fromJson;

  @override
  UserUpdateInput get value;
  @JsonKey(ignore: true)
  _$$_UpdateOneUserDataWithUserUpdateInputCopyWith<
          _$_UpdateOneUserDataWithUserUpdateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWith<$Res> {
  factory _$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWith(
          _$_UpdateOneUserDataWithUserUncheckedUpdateInput value,
          $Res Function(_$_UpdateOneUserDataWithUserUncheckedUpdateInput)
              then) =
      __$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUncheckedUpdateInput value});

  $UserUncheckedUpdateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWithImpl<$Res>
    extends _$UpdateOneUserDataCopyWithImpl<$Res,
        _$_UpdateOneUserDataWithUserUncheckedUpdateInput>
    implements _$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWith<$Res> {
  __$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWithImpl(
      _$_UpdateOneUserDataWithUserUncheckedUpdateInput _value,
      $Res Function(_$_UpdateOneUserDataWithUserUncheckedUpdateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateOneUserDataWithUserUncheckedUpdateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateInputCopyWith<$Res> get value {
    return $UserUncheckedUpdateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpdateOneUserDataWithUserUncheckedUpdateInput
    implements _UpdateOneUserDataWithUserUncheckedUpdateInput {
  const _$_UpdateOneUserDataWithUserUncheckedUpdateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUncheckedUpdateInput';

  factory _$_UpdateOneUserDataWithUserUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpdateOneUserDataWithUserUncheckedUpdateInputFromJson(json);

  @override
  final UserUncheckedUpdateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpdateOneUserData.withUserUncheckedUpdateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateOneUserDataWithUserUncheckedUpdateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWith<
          _$_UpdateOneUserDataWithUserUncheckedUpdateInput>
      get copyWith =>
          __$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWithImpl<
                  _$_UpdateOneUserDataWithUserUncheckedUpdateInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateInput value) withUserUpdateInput,
    required TResult Function(UserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput value)? withUserUpdateInput,
    TResult? Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateInput value)? withUserUpdateInput,
    TResult Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedUpdateInput != null) {
      return withUserUncheckedUpdateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateOneUserDataWithUserUpdateInput value)
        withUserUpdateInput,
    required TResult Function(
            _UpdateOneUserDataWithUserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateOneUserDataWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult? Function(_UpdateOneUserDataWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateOneUserDataWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult Function(_UpdateOneUserDataWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedUpdateInput != null) {
      return withUserUncheckedUpdateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpdateOneUserDataWithUserUncheckedUpdateInputToJson(
      this,
    );
  }
}

abstract class _UpdateOneUserDataWithUserUncheckedUpdateInput
    implements UpdateOneUserData {
  const factory _UpdateOneUserDataWithUserUncheckedUpdateInput(
          final UserUncheckedUpdateInput value) =
      _$_UpdateOneUserDataWithUserUncheckedUpdateInput;

  factory _UpdateOneUserDataWithUserUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpdateOneUserDataWithUserUncheckedUpdateInput.fromJson;

  @override
  UserUncheckedUpdateInput get value;
  @JsonKey(ignore: true)
  _$$_UpdateOneUserDataWithUserUncheckedUpdateInputCopyWith<
          _$_UpdateOneUserDataWithUserUncheckedUpdateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UpdateManyUserData _$UpdateManyUserDataFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserUpdateManyMutationInput':
      return _UpdateManyUserDataWithUserUpdateManyMutationInput.fromJson(json);
    case 'withUserUncheckedUpdateManyInput':
      return _UpdateManyUserDataWithUserUncheckedUpdateManyInput.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UpdateManyUserData',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UpdateManyUserData {
  _i1.JsonSerializable get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateManyMutationInput value)
        withUserUpdateManyMutationInput,
    required TResult Function(UserUncheckedUpdateManyInput value)
        withUserUncheckedUpdateManyInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult? Function(UserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult Function(UserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _UpdateManyUserDataWithUserUpdateManyMutationInput value)
        withUserUpdateManyMutationInput,
    required TResult Function(
            _UpdateManyUserDataWithUserUncheckedUpdateManyInput value)
        withUserUncheckedUpdateManyInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateManyUserDataWithUserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult? Function(
            _UpdateManyUserDataWithUserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateManyUserDataWithUserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult Function(_UpdateManyUserDataWithUserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateManyUserDataCopyWith<$Res> {
  factory $UpdateManyUserDataCopyWith(
          UpdateManyUserData value, $Res Function(UpdateManyUserData) then) =
      _$UpdateManyUserDataCopyWithImpl<$Res, UpdateManyUserData>;
}

/// @nodoc
class _$UpdateManyUserDataCopyWithImpl<$Res, $Val extends UpdateManyUserData>
    implements $UpdateManyUserDataCopyWith<$Res> {
  _$UpdateManyUserDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWith<
    $Res> {
  factory _$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWith(
          _$_UpdateManyUserDataWithUserUpdateManyMutationInput value,
          $Res Function(_$_UpdateManyUserDataWithUserUpdateManyMutationInput)
              then) =
      __$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUpdateManyMutationInput value});

  $UserUpdateManyMutationInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWithImpl<$Res>
    extends _$UpdateManyUserDataCopyWithImpl<$Res,
        _$_UpdateManyUserDataWithUserUpdateManyMutationInput>
    implements
        _$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWith<$Res> {
  __$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWithImpl(
      _$_UpdateManyUserDataWithUserUpdateManyMutationInput _value,
      $Res Function(_$_UpdateManyUserDataWithUserUpdateManyMutationInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateManyUserDataWithUserUpdateManyMutationInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUpdateManyMutationInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateManyMutationInputCopyWith<$Res> get value {
    return $UserUpdateManyMutationInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpdateManyUserDataWithUserUpdateManyMutationInput
    implements _UpdateManyUserDataWithUserUpdateManyMutationInput {
  const _$_UpdateManyUserDataWithUserUpdateManyMutationInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUpdateManyMutationInput';

  factory _$_UpdateManyUserDataWithUserUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpdateManyUserDataWithUserUpdateManyMutationInputFromJson(json);

  @override
  final UserUpdateManyMutationInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpdateManyUserData.withUserUpdateManyMutationInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateManyUserDataWithUserUpdateManyMutationInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWith<
          _$_UpdateManyUserDataWithUserUpdateManyMutationInput>
      get copyWith =>
          __$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWithImpl<
                  _$_UpdateManyUserDataWithUserUpdateManyMutationInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateManyMutationInput value)
        withUserUpdateManyMutationInput,
    required TResult Function(UserUncheckedUpdateManyInput value)
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUpdateManyMutationInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult? Function(UserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUpdateManyMutationInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult Function(UserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
    required TResult orElse(),
  }) {
    if (withUserUpdateManyMutationInput != null) {
      return withUserUpdateManyMutationInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _UpdateManyUserDataWithUserUpdateManyMutationInput value)
        withUserUpdateManyMutationInput,
    required TResult Function(
            _UpdateManyUserDataWithUserUncheckedUpdateManyInput value)
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUpdateManyMutationInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateManyUserDataWithUserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult? Function(
            _UpdateManyUserDataWithUserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUpdateManyMutationInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateManyUserDataWithUserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult Function(_UpdateManyUserDataWithUserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
    required TResult orElse(),
  }) {
    if (withUserUpdateManyMutationInput != null) {
      return withUserUpdateManyMutationInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpdateManyUserDataWithUserUpdateManyMutationInputToJson(
      this,
    );
  }
}

abstract class _UpdateManyUserDataWithUserUpdateManyMutationInput
    implements UpdateManyUserData {
  const factory _UpdateManyUserDataWithUserUpdateManyMutationInput(
          final UserUpdateManyMutationInput value) =
      _$_UpdateManyUserDataWithUserUpdateManyMutationInput;

  factory _UpdateManyUserDataWithUserUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpdateManyUserDataWithUserUpdateManyMutationInput.fromJson;

  @override
  UserUpdateManyMutationInput get value;
  @JsonKey(ignore: true)
  _$$_UpdateManyUserDataWithUserUpdateManyMutationInputCopyWith<
          _$_UpdateManyUserDataWithUserUpdateManyMutationInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWith<
    $Res> {
  factory _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWith(
          _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput value,
          $Res Function(_$_UpdateManyUserDataWithUserUncheckedUpdateManyInput)
              then) =
      __$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUncheckedUpdateManyInput value});

  $UserUncheckedUpdateManyInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWithImpl<$Res>
    extends _$UpdateManyUserDataCopyWithImpl<$Res,
        _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput>
    implements
        _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWith<$Res> {
  __$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWithImpl(
      _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput _value,
      $Res Function(_$_UpdateManyUserDataWithUserUncheckedUpdateManyInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateManyUserDataWithUserUncheckedUpdateManyInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateManyInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateManyInputCopyWith<$Res> get value {
    return $UserUncheckedUpdateManyInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput
    implements _UpdateManyUserDataWithUserUncheckedUpdateManyInput {
  const _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUncheckedUpdateManyInput';

  factory _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputFromJson(json);

  @override
  final UserUncheckedUpdateManyInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpdateManyUserData.withUserUncheckedUpdateManyInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWith<
          _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput>
      get copyWith =>
          __$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWithImpl<
                  _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateManyMutationInput value)
        withUserUpdateManyMutationInput,
    required TResult Function(UserUncheckedUpdateManyInput value)
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUncheckedUpdateManyInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult? Function(UserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUncheckedUpdateManyInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult Function(UserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedUpdateManyInput != null) {
      return withUserUncheckedUpdateManyInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _UpdateManyUserDataWithUserUpdateManyMutationInput value)
        withUserUpdateManyMutationInput,
    required TResult Function(
            _UpdateManyUserDataWithUserUncheckedUpdateManyInput value)
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUncheckedUpdateManyInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateManyUserDataWithUserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult? Function(
            _UpdateManyUserDataWithUserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
  }) {
    return withUserUncheckedUpdateManyInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateManyUserDataWithUserUpdateManyMutationInput value)?
        withUserUpdateManyMutationInput,
    TResult Function(_UpdateManyUserDataWithUserUncheckedUpdateManyInput value)?
        withUserUncheckedUpdateManyInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedUpdateManyInput != null) {
      return withUserUncheckedUpdateManyInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputToJson(
      this,
    );
  }
}

abstract class _UpdateManyUserDataWithUserUncheckedUpdateManyInput
    implements UpdateManyUserData {
  const factory _UpdateManyUserDataWithUserUncheckedUpdateManyInput(
          final UserUncheckedUpdateManyInput value) =
      _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput;

  factory _UpdateManyUserDataWithUserUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput.fromJson;

  @override
  UserUncheckedUpdateManyInput get value;
  @JsonKey(ignore: true)
  _$$_UpdateManyUserDataWithUserUncheckedUpdateManyInputCopyWith<
          _$_UpdateManyUserDataWithUserUncheckedUpdateManyInput>
      get copyWith => throw _privateConstructorUsedError;
}

UpsertOneUserCreate _$UpsertOneUserCreateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserCreateInput':
      return _UpsertOneUserCreateWithUserCreateInput.fromJson(json);
    case 'withUserUncheckedCreateInput':
      return _UpsertOneUserCreateWithUserUncheckedCreateInput.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UpsertOneUserCreate',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UpsertOneUserCreate {
  _i1.JsonSerializable get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserCreateInput value) withUserCreateInput,
    required TResult Function(UserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserCreateInput value)? withUserCreateInput,
    TResult? Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserCreateInput value)? withUserCreateInput,
    TResult Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpsertOneUserCreateWithUserCreateInput value)
        withUserCreateInput,
    required TResult Function(
            _UpsertOneUserCreateWithUserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpsertOneUserCreateWithUserCreateInput value)?
        withUserCreateInput,
    TResult? Function(_UpsertOneUserCreateWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpsertOneUserCreateWithUserCreateInput value)?
        withUserCreateInput,
    TResult Function(_UpsertOneUserCreateWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpsertOneUserCreateCopyWith<$Res> {
  factory $UpsertOneUserCreateCopyWith(
          UpsertOneUserCreate value, $Res Function(UpsertOneUserCreate) then) =
      _$UpsertOneUserCreateCopyWithImpl<$Res, UpsertOneUserCreate>;
}

/// @nodoc
class _$UpsertOneUserCreateCopyWithImpl<$Res, $Val extends UpsertOneUserCreate>
    implements $UpsertOneUserCreateCopyWith<$Res> {
  _$UpsertOneUserCreateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpsertOneUserCreateWithUserCreateInputCopyWith<$Res> {
  factory _$$_UpsertOneUserCreateWithUserCreateInputCopyWith(
          _$_UpsertOneUserCreateWithUserCreateInput value,
          $Res Function(_$_UpsertOneUserCreateWithUserCreateInput) then) =
      __$$_UpsertOneUserCreateWithUserCreateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserCreateInput value});

  $UserCreateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpsertOneUserCreateWithUserCreateInputCopyWithImpl<$Res>
    extends _$UpsertOneUserCreateCopyWithImpl<$Res,
        _$_UpsertOneUserCreateWithUserCreateInput>
    implements _$$_UpsertOneUserCreateWithUserCreateInputCopyWith<$Res> {
  __$$_UpsertOneUserCreateWithUserCreateInputCopyWithImpl(
      _$_UpsertOneUserCreateWithUserCreateInput _value,
      $Res Function(_$_UpsertOneUserCreateWithUserCreateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpsertOneUserCreateWithUserCreateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserCreateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCreateInputCopyWith<$Res> get value {
    return $UserCreateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpsertOneUserCreateWithUserCreateInput
    implements _UpsertOneUserCreateWithUserCreateInput {
  const _$_UpsertOneUserCreateWithUserCreateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserCreateInput';

  factory _$_UpsertOneUserCreateWithUserCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpsertOneUserCreateWithUserCreateInputFromJson(json);

  @override
  final UserCreateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpsertOneUserCreate.withUserCreateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpsertOneUserCreateWithUserCreateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpsertOneUserCreateWithUserCreateInputCopyWith<
          _$_UpsertOneUserCreateWithUserCreateInput>
      get copyWith => __$$_UpsertOneUserCreateWithUserCreateInputCopyWithImpl<
          _$_UpsertOneUserCreateWithUserCreateInput>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserCreateInput value) withUserCreateInput,
    required TResult Function(UserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserCreateInput value)? withUserCreateInput,
    TResult? Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserCreateInput value)? withUserCreateInput,
    TResult Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserCreateInput != null) {
      return withUserCreateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpsertOneUserCreateWithUserCreateInput value)
        withUserCreateInput,
    required TResult Function(
            _UpsertOneUserCreateWithUserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpsertOneUserCreateWithUserCreateInput value)?
        withUserCreateInput,
    TResult? Function(_UpsertOneUserCreateWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserCreateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpsertOneUserCreateWithUserCreateInput value)?
        withUserCreateInput,
    TResult Function(_UpsertOneUserCreateWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserCreateInput != null) {
      return withUserCreateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpsertOneUserCreateWithUserCreateInputToJson(
      this,
    );
  }
}

abstract class _UpsertOneUserCreateWithUserCreateInput
    implements UpsertOneUserCreate {
  const factory _UpsertOneUserCreateWithUserCreateInput(
      final UserCreateInput value) = _$_UpsertOneUserCreateWithUserCreateInput;

  factory _UpsertOneUserCreateWithUserCreateInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpsertOneUserCreateWithUserCreateInput.fromJson;

  @override
  UserCreateInput get value;
  @JsonKey(ignore: true)
  _$$_UpsertOneUserCreateWithUserCreateInputCopyWith<
          _$_UpsertOneUserCreateWithUserCreateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWith<
    $Res> {
  factory _$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWith(
          _$_UpsertOneUserCreateWithUserUncheckedCreateInput value,
          $Res Function(_$_UpsertOneUserCreateWithUserUncheckedCreateInput)
              then) =
      __$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUncheckedCreateInput value});

  $UserUncheckedCreateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWithImpl<$Res>
    extends _$UpsertOneUserCreateCopyWithImpl<$Res,
        _$_UpsertOneUserCreateWithUserUncheckedCreateInput>
    implements
        _$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWith<$Res> {
  __$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWithImpl(
      _$_UpsertOneUserCreateWithUserUncheckedCreateInput _value,
      $Res Function(_$_UpsertOneUserCreateWithUserUncheckedCreateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpsertOneUserCreateWithUserUncheckedCreateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUncheckedCreateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedCreateInputCopyWith<$Res> get value {
    return $UserUncheckedCreateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpsertOneUserCreateWithUserUncheckedCreateInput
    implements _UpsertOneUserCreateWithUserUncheckedCreateInput {
  const _$_UpsertOneUserCreateWithUserUncheckedCreateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUncheckedCreateInput';

  factory _$_UpsertOneUserCreateWithUserUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpsertOneUserCreateWithUserUncheckedCreateInputFromJson(json);

  @override
  final UserUncheckedCreateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpsertOneUserCreate.withUserUncheckedCreateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpsertOneUserCreateWithUserUncheckedCreateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWith<
          _$_UpsertOneUserCreateWithUserUncheckedCreateInput>
      get copyWith =>
          __$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWithImpl<
                  _$_UpsertOneUserCreateWithUserUncheckedCreateInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserCreateInput value) withUserCreateInput,
    required TResult Function(UserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserCreateInput value)? withUserCreateInput,
    TResult? Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserCreateInput value)? withUserCreateInput,
    TResult Function(UserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedCreateInput != null) {
      return withUserUncheckedCreateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpsertOneUserCreateWithUserCreateInput value)
        withUserCreateInput,
    required TResult Function(
            _UpsertOneUserCreateWithUserUncheckedCreateInput value)
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpsertOneUserCreateWithUserCreateInput value)?
        withUserCreateInput,
    TResult? Function(_UpsertOneUserCreateWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
  }) {
    return withUserUncheckedCreateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpsertOneUserCreateWithUserCreateInput value)?
        withUserCreateInput,
    TResult Function(_UpsertOneUserCreateWithUserUncheckedCreateInput value)?
        withUserUncheckedCreateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedCreateInput != null) {
      return withUserUncheckedCreateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpsertOneUserCreateWithUserUncheckedCreateInputToJson(
      this,
    );
  }
}

abstract class _UpsertOneUserCreateWithUserUncheckedCreateInput
    implements UpsertOneUserCreate {
  const factory _UpsertOneUserCreateWithUserUncheckedCreateInput(
          final UserUncheckedCreateInput value) =
      _$_UpsertOneUserCreateWithUserUncheckedCreateInput;

  factory _UpsertOneUserCreateWithUserUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpsertOneUserCreateWithUserUncheckedCreateInput.fromJson;

  @override
  UserUncheckedCreateInput get value;
  @JsonKey(ignore: true)
  _$$_UpsertOneUserCreateWithUserUncheckedCreateInputCopyWith<
          _$_UpsertOneUserCreateWithUserUncheckedCreateInput>
      get copyWith => throw _privateConstructorUsedError;
}

UpsertOneUserUpdate _$UpsertOneUserUpdateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserUpdateInput':
      return _UpsertOneUserUpdateWithUserUpdateInput.fromJson(json);
    case 'withUserUncheckedUpdateInput':
      return _UpsertOneUserUpdateWithUserUncheckedUpdateInput.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'UpsertOneUserUpdate',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$UpsertOneUserUpdate {
  _i1.JsonSerializable get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateInput value) withUserUpdateInput,
    required TResult Function(UserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput value)? withUserUpdateInput,
    TResult? Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateInput value)? withUserUpdateInput,
    TResult Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpsertOneUserUpdateWithUserUpdateInput value)
        withUserUpdateInput,
    required TResult Function(
            _UpsertOneUserUpdateWithUserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpsertOneUserUpdateWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult? Function(_UpsertOneUserUpdateWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpsertOneUserUpdateWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult Function(_UpsertOneUserUpdateWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpsertOneUserUpdateCopyWith<$Res> {
  factory $UpsertOneUserUpdateCopyWith(
          UpsertOneUserUpdate value, $Res Function(UpsertOneUserUpdate) then) =
      _$UpsertOneUserUpdateCopyWithImpl<$Res, UpsertOneUserUpdate>;
}

/// @nodoc
class _$UpsertOneUserUpdateCopyWithImpl<$Res, $Val extends UpsertOneUserUpdate>
    implements $UpsertOneUserUpdateCopyWith<$Res> {
  _$UpsertOneUserUpdateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpsertOneUserUpdateWithUserUpdateInputCopyWith<$Res> {
  factory _$$_UpsertOneUserUpdateWithUserUpdateInputCopyWith(
          _$_UpsertOneUserUpdateWithUserUpdateInput value,
          $Res Function(_$_UpsertOneUserUpdateWithUserUpdateInput) then) =
      __$$_UpsertOneUserUpdateWithUserUpdateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUpdateInput value});

  $UserUpdateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpsertOneUserUpdateWithUserUpdateInputCopyWithImpl<$Res>
    extends _$UpsertOneUserUpdateCopyWithImpl<$Res,
        _$_UpsertOneUserUpdateWithUserUpdateInput>
    implements _$$_UpsertOneUserUpdateWithUserUpdateInputCopyWith<$Res> {
  __$$_UpsertOneUserUpdateWithUserUpdateInputCopyWithImpl(
      _$_UpsertOneUserUpdateWithUserUpdateInput _value,
      $Res Function(_$_UpsertOneUserUpdateWithUserUpdateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpsertOneUserUpdateWithUserUpdateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUpdateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUpdateInputCopyWith<$Res> get value {
    return $UserUpdateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpsertOneUserUpdateWithUserUpdateInput
    implements _UpsertOneUserUpdateWithUserUpdateInput {
  const _$_UpsertOneUserUpdateWithUserUpdateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUpdateInput';

  factory _$_UpsertOneUserUpdateWithUserUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpsertOneUserUpdateWithUserUpdateInputFromJson(json);

  @override
  final UserUpdateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpsertOneUserUpdate.withUserUpdateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpsertOneUserUpdateWithUserUpdateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpsertOneUserUpdateWithUserUpdateInputCopyWith<
          _$_UpsertOneUserUpdateWithUserUpdateInput>
      get copyWith => __$$_UpsertOneUserUpdateWithUserUpdateInputCopyWithImpl<
          _$_UpsertOneUserUpdateWithUserUpdateInput>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateInput value) withUserUpdateInput,
    required TResult Function(UserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput value)? withUserUpdateInput,
    TResult? Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateInput value)? withUserUpdateInput,
    TResult Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUpdateInput != null) {
      return withUserUpdateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpsertOneUserUpdateWithUserUpdateInput value)
        withUserUpdateInput,
    required TResult Function(
            _UpsertOneUserUpdateWithUserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpsertOneUserUpdateWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult? Function(_UpsertOneUserUpdateWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUpdateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpsertOneUserUpdateWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult Function(_UpsertOneUserUpdateWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUpdateInput != null) {
      return withUserUpdateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpsertOneUserUpdateWithUserUpdateInputToJson(
      this,
    );
  }
}

abstract class _UpsertOneUserUpdateWithUserUpdateInput
    implements UpsertOneUserUpdate {
  const factory _UpsertOneUserUpdateWithUserUpdateInput(
      final UserUpdateInput value) = _$_UpsertOneUserUpdateWithUserUpdateInput;

  factory _UpsertOneUserUpdateWithUserUpdateInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpsertOneUserUpdateWithUserUpdateInput.fromJson;

  @override
  UserUpdateInput get value;
  @JsonKey(ignore: true)
  _$$_UpsertOneUserUpdateWithUserUpdateInputCopyWith<
          _$_UpsertOneUserUpdateWithUserUpdateInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWith<
    $Res> {
  factory _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWith(
          _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput value,
          $Res Function(_$_UpsertOneUserUpdateWithUserUncheckedUpdateInput)
              then) =
      __$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWithImpl<$Res>;
  @useResult
  $Res call({UserUncheckedUpdateInput value});

  $UserUncheckedUpdateInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWithImpl<$Res>
    extends _$UpsertOneUserUpdateCopyWithImpl<$Res,
        _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput>
    implements
        _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWith<$Res> {
  __$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWithImpl(
      _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput _value,
      $Res Function(_$_UpsertOneUserUpdateWithUserUncheckedUpdateInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpsertOneUserUpdateWithUserUncheckedUpdateInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserUncheckedUpdateInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserUncheckedUpdateInputCopyWith<$Res> get value {
    return $UserUncheckedUpdateInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput
    implements _UpsertOneUserUpdateWithUserUncheckedUpdateInput {
  const _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserUncheckedUpdateInput';

  factory _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputFromJson(json);

  @override
  final UserUncheckedUpdateInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'UpsertOneUserUpdate.withUserUncheckedUpdateInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWith<
          _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput>
      get copyWith =>
          __$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWithImpl<
                  _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(UserUpdateInput value) withUserUpdateInput,
    required TResult Function(UserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(UserUpdateInput value)? withUserUpdateInput,
    TResult? Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(UserUpdateInput value)? withUserUpdateInput,
    TResult Function(UserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedUpdateInput != null) {
      return withUserUncheckedUpdateInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpsertOneUserUpdateWithUserUpdateInput value)
        withUserUpdateInput,
    required TResult Function(
            _UpsertOneUserUpdateWithUserUncheckedUpdateInput value)
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpsertOneUserUpdateWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult? Function(_UpsertOneUserUpdateWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
  }) {
    return withUserUncheckedUpdateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpsertOneUserUpdateWithUserUpdateInput value)?
        withUserUpdateInput,
    TResult Function(_UpsertOneUserUpdateWithUserUncheckedUpdateInput value)?
        withUserUncheckedUpdateInput,
    required TResult orElse(),
  }) {
    if (withUserUncheckedUpdateInput != null) {
      return withUserUncheckedUpdateInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputToJson(
      this,
    );
  }
}

abstract class _UpsertOneUserUpdateWithUserUncheckedUpdateInput
    implements UpsertOneUserUpdate {
  const factory _UpsertOneUserUpdateWithUserUncheckedUpdateInput(
          final UserUncheckedUpdateInput value) =
      _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput;

  factory _UpsertOneUserUpdateWithUserUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =
      _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput.fromJson;

  @override
  UserUncheckedUpdateInput get value;
  @JsonKey(ignore: true)
  _$$_UpsertOneUserUpdateWithUserUncheckedUpdateInputCopyWith<
          _$_UpsertOneUserUpdateWithUserUncheckedUpdateInput>
      get copyWith => throw _privateConstructorUsedError;
}

AggregateUserOrderBy _$AggregateUserOrderByFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserOrderByWithRelationInputList':
      return _AggregateUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          json);
    case 'withUserOrderByWithRelationInput':
      return _AggregateUserOrderByWithUserOrderByWithRelationInput.fromJson(
          json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'AggregateUserOrderBy',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$AggregateUserOrderBy {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AggregateUserOrderByCopyWith<$Res> {
  factory $AggregateUserOrderByCopyWith(AggregateUserOrderBy value,
          $Res Function(AggregateUserOrderBy) then) =
      _$AggregateUserOrderByCopyWithImpl<$Res, AggregateUserOrderBy>;
}

/// @nodoc
class _$AggregateUserOrderByCopyWithImpl<$Res,
        $Val extends AggregateUserOrderBy>
    implements $AggregateUserOrderByCopyWith<$Res> {
  _$AggregateUserOrderByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWith<
    $Res> {
  factory _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWith(
          _$_AggregateUserOrderByWithUserOrderByWithRelationInputList value,
          $Res Function(
                  _$_AggregateUserOrderByWithUserOrderByWithRelationInputList)
              then) =
      __$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserOrderByWithRelationInput> value});
}

/// @nodoc
class __$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
        $Res>
    extends _$AggregateUserOrderByCopyWithImpl<$Res,
        _$_AggregateUserOrderByWithUserOrderByWithRelationInputList>
    implements
        _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWith<
            $Res> {
  __$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl(
      _$_AggregateUserOrderByWithUserOrderByWithRelationInputList _value,
      $Res Function(_$_AggregateUserOrderByWithUserOrderByWithRelationInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_AggregateUserOrderByWithUserOrderByWithRelationInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserOrderByWithRelationInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AggregateUserOrderByWithUserOrderByWithRelationInputList
    implements _AggregateUserOrderByWithUserOrderByWithRelationInputList {
  const _$_AggregateUserOrderByWithUserOrderByWithRelationInputList(
      final List<UserOrderByWithRelationInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserOrderByWithRelationInputList';

  factory _$_AggregateUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListFromJson(
          json);

  final List<UserOrderByWithRelationInput> _value;
  @override
  List<UserOrderByWithRelationInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AggregateUserOrderBy.withUserOrderByWithRelationInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_AggregateUserOrderByWithUserOrderByWithRelationInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_AggregateUserOrderByWithUserOrderByWithRelationInputList>
      get copyWith =>
          __$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWithImpl<
                  _$_AggregateUserOrderByWithUserOrderByWithRelationInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInputList != null) {
      return withUserOrderByWithRelationInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListToJson(
      this,
    );
  }
}

abstract class _AggregateUserOrderByWithUserOrderByWithRelationInputList
    implements AggregateUserOrderBy {
  const factory _AggregateUserOrderByWithUserOrderByWithRelationInputList(
          final List<UserOrderByWithRelationInput> value) =
      _$_AggregateUserOrderByWithUserOrderByWithRelationInputList;

  factory _AggregateUserOrderByWithUserOrderByWithRelationInputList.fromJson(
          Map<String, dynamic> json) =
      _$_AggregateUserOrderByWithUserOrderByWithRelationInputList.fromJson;

  @override
  List<UserOrderByWithRelationInput> get value;
  @JsonKey(ignore: true)
  _$$_AggregateUserOrderByWithUserOrderByWithRelationInputListCopyWith<
          _$_AggregateUserOrderByWithUserOrderByWithRelationInputList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWith<
    $Res> {
  factory _$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWith(
          _$_AggregateUserOrderByWithUserOrderByWithRelationInput value,
          $Res Function(_$_AggregateUserOrderByWithUserOrderByWithRelationInput)
              then) =
      __$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserOrderByWithRelationInput value});

  $UserOrderByWithRelationInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
        $Res>
    extends _$AggregateUserOrderByCopyWithImpl<$Res,
        _$_AggregateUserOrderByWithUserOrderByWithRelationInput>
    implements
        _$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWith<$Res> {
  __$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWithImpl(
      _$_AggregateUserOrderByWithUserOrderByWithRelationInput _value,
      $Res Function(_$_AggregateUserOrderByWithUserOrderByWithRelationInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_AggregateUserOrderByWithUserOrderByWithRelationInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserOrderByWithRelationInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserOrderByWithRelationInputCopyWith<$Res> get value {
    return $UserOrderByWithRelationInputCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_AggregateUserOrderByWithUserOrderByWithRelationInput
    implements _AggregateUserOrderByWithUserOrderByWithRelationInput {
  const _$_AggregateUserOrderByWithUserOrderByWithRelationInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserOrderByWithRelationInput';

  factory _$_AggregateUserOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_AggregateUserOrderByWithUserOrderByWithRelationInputFromJson(json);

  @override
  final UserOrderByWithRelationInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AggregateUserOrderBy.withUserOrderByWithRelationInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AggregateUserOrderByWithUserOrderByWithRelationInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_AggregateUserOrderByWithUserOrderByWithRelationInput>
      get copyWith =>
          __$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWithImpl<
                  _$_AggregateUserOrderByWithUserOrderByWithRelationInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithRelationInput> value)
        withUserOrderByWithRelationInputList,
    required TResult Function(UserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithRelationInput> value)?
        withUserOrderByWithRelationInputList,
    TResult Function(UserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)
        withUserOrderByWithRelationInputList,
    required TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult? Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
  }) {
    return withUserOrderByWithRelationInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInputList value)?
        withUserOrderByWithRelationInputList,
    TResult Function(
            _AggregateUserOrderByWithUserOrderByWithRelationInput value)?
        withUserOrderByWithRelationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithRelationInput != null) {
      return withUserOrderByWithRelationInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_AggregateUserOrderByWithUserOrderByWithRelationInputToJson(
      this,
    );
  }
}

abstract class _AggregateUserOrderByWithUserOrderByWithRelationInput
    implements AggregateUserOrderBy {
  const factory _AggregateUserOrderByWithUserOrderByWithRelationInput(
          final UserOrderByWithRelationInput value) =
      _$_AggregateUserOrderByWithUserOrderByWithRelationInput;

  factory _AggregateUserOrderByWithUserOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =
      _$_AggregateUserOrderByWithUserOrderByWithRelationInput.fromJson;

  @override
  UserOrderByWithRelationInput get value;
  @JsonKey(ignore: true)
  _$$_AggregateUserOrderByWithUserOrderByWithRelationInputCopyWith<
          _$_AggregateUserOrderByWithUserOrderByWithRelationInput>
      get copyWith => throw _privateConstructorUsedError;
}

GroupByUserOrderBy _$GroupByUserOrderByFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserOrderByWithAggregationInputList':
      return _GroupByUserOrderByWithUserOrderByWithAggregationInputList
          .fromJson(json);
    case 'withUserOrderByWithAggregationInput':
      return _GroupByUserOrderByWithUserOrderByWithAggregationInput.fromJson(
          json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'GroupByUserOrderBy',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$GroupByUserOrderBy {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithAggregationInput> value)
        withUserOrderByWithAggregationInputList,
    required TResult Function(UserOrderByWithAggregationInput value)
        withUserOrderByWithAggregationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithAggregationInput> value)?
        withUserOrderByWithAggregationInputList,
    TResult? Function(UserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithAggregationInput> value)?
        withUserOrderByWithAggregationInputList,
    TResult Function(UserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)
        withUserOrderByWithAggregationInputList,
    required TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)
        withUserOrderByWithAggregationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)?
        withUserOrderByWithAggregationInputList,
    TResult? Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)?
        withUserOrderByWithAggregationInputList,
    TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupByUserOrderByCopyWith<$Res> {
  factory $GroupByUserOrderByCopyWith(
          GroupByUserOrderBy value, $Res Function(GroupByUserOrderBy) then) =
      _$GroupByUserOrderByCopyWithImpl<$Res, GroupByUserOrderBy>;
}

/// @nodoc
class _$GroupByUserOrderByCopyWithImpl<$Res, $Val extends GroupByUserOrderBy>
    implements $GroupByUserOrderByCopyWith<$Res> {
  _$GroupByUserOrderByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWith<
    $Res> {
  factory _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWith(
          _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList value,
          $Res Function(
                  _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList)
              then) =
      __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWithImpl<
          $Res>;
  @useResult
  $Res call({List<UserOrderByWithAggregationInput> value});
}

/// @nodoc
class __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWithImpl<
        $Res>
    extends _$GroupByUserOrderByCopyWithImpl<$Res,
        _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList>
    implements
        _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWith<
            $Res> {
  __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWithImpl(
      _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList _value,
      $Res Function(
              _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_GroupByUserOrderByWithUserOrderByWithAggregationInputList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserOrderByWithAggregationInput>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList
    implements _GroupByUserOrderByWithUserOrderByWithAggregationInputList {
  const _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList(
      final List<UserOrderByWithAggregationInput> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserOrderByWithAggregationInputList';

  factory _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList.fromJson(
          Map<String, dynamic> json) =>
      _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListFromJson(
          json);

  final List<UserOrderByWithAggregationInput> _value;
  @override
  List<UserOrderByWithAggregationInput> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'GroupByUserOrderBy.withUserOrderByWithAggregationInputList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWith<
          _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList>
      get copyWith =>
          __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWithImpl<
                  _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithAggregationInput> value)
        withUserOrderByWithAggregationInputList,
    required TResult Function(UserOrderByWithAggregationInput value)
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInputList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithAggregationInput> value)?
        withUserOrderByWithAggregationInputList,
    TResult? Function(UserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInputList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithAggregationInput> value)?
        withUserOrderByWithAggregationInputList,
    TResult Function(UserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithAggregationInputList != null) {
      return withUserOrderByWithAggregationInputList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)
        withUserOrderByWithAggregationInputList,
    required TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInputList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)?
        withUserOrderByWithAggregationInputList,
    TResult? Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInputList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)?
        withUserOrderByWithAggregationInputList,
    TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithAggregationInputList != null) {
      return withUserOrderByWithAggregationInputList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListToJson(
      this,
    );
  }
}

abstract class _GroupByUserOrderByWithUserOrderByWithAggregationInputList
    implements GroupByUserOrderBy {
  const factory _GroupByUserOrderByWithUserOrderByWithAggregationInputList(
          final List<UserOrderByWithAggregationInput> value) =
      _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList;

  factory _GroupByUserOrderByWithUserOrderByWithAggregationInputList.fromJson(
          Map<String, dynamic> json) =
      _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList.fromJson;

  @override
  List<UserOrderByWithAggregationInput> get value;
  @JsonKey(ignore: true)
  _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputListCopyWith<
          _$_GroupByUserOrderByWithUserOrderByWithAggregationInputList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWith<
    $Res> {
  factory _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWith(
          _$_GroupByUserOrderByWithUserOrderByWithAggregationInput value,
          $Res Function(
                  _$_GroupByUserOrderByWithUserOrderByWithAggregationInput)
              then) =
      __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWithImpl<
          $Res>;
  @useResult
  $Res call({UserOrderByWithAggregationInput value});

  $UserOrderByWithAggregationInputCopyWith<$Res> get value;
}

/// @nodoc
class __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWithImpl<
        $Res>
    extends _$GroupByUserOrderByCopyWithImpl<$Res,
        _$_GroupByUserOrderByWithUserOrderByWithAggregationInput>
    implements
        _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWith<
            $Res> {
  __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWithImpl(
      _$_GroupByUserOrderByWithUserOrderByWithAggregationInput _value,
      $Res Function(_$_GroupByUserOrderByWithUserOrderByWithAggregationInput)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_GroupByUserOrderByWithUserOrderByWithAggregationInput(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserOrderByWithAggregationInput,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserOrderByWithAggregationInputCopyWith<$Res> get value {
    return $UserOrderByWithAggregationInputCopyWith<$Res>(_value.value,
        (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_GroupByUserOrderByWithUserOrderByWithAggregationInput
    implements _GroupByUserOrderByWithUserOrderByWithAggregationInput {
  const _$_GroupByUserOrderByWithUserOrderByWithAggregationInput(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserOrderByWithAggregationInput';

  factory _$_GroupByUserOrderByWithUserOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputFromJson(json);

  @override
  final UserOrderByWithAggregationInput value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'GroupByUserOrderBy.withUserOrderByWithAggregationInput(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GroupByUserOrderByWithUserOrderByWithAggregationInput &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWith<
          _$_GroupByUserOrderByWithUserOrderByWithAggregationInput>
      get copyWith =>
          __$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWithImpl<
                  _$_GroupByUserOrderByWithUserOrderByWithAggregationInput>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserOrderByWithAggregationInput> value)
        withUserOrderByWithAggregationInputList,
    required TResult Function(UserOrderByWithAggregationInput value)
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInput(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserOrderByWithAggregationInput> value)?
        withUserOrderByWithAggregationInputList,
    TResult? Function(UserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInput?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserOrderByWithAggregationInput> value)?
        withUserOrderByWithAggregationInputList,
    TResult Function(UserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithAggregationInput != null) {
      return withUserOrderByWithAggregationInput(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)
        withUserOrderByWithAggregationInputList,
    required TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)?
        withUserOrderByWithAggregationInputList,
    TResult? Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
  }) {
    return withUserOrderByWithAggregationInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInputList value)?
        withUserOrderByWithAggregationInputList,
    TResult Function(
            _GroupByUserOrderByWithUserOrderByWithAggregationInput value)?
        withUserOrderByWithAggregationInput,
    required TResult orElse(),
  }) {
    if (withUserOrderByWithAggregationInput != null) {
      return withUserOrderByWithAggregationInput(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputToJson(
      this,
    );
  }
}

abstract class _GroupByUserOrderByWithUserOrderByWithAggregationInput
    implements GroupByUserOrderBy {
  const factory _GroupByUserOrderByWithUserOrderByWithAggregationInput(
          final UserOrderByWithAggregationInput value) =
      _$_GroupByUserOrderByWithUserOrderByWithAggregationInput;

  factory _GroupByUserOrderByWithUserOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =
      _$_GroupByUserOrderByWithUserOrderByWithAggregationInput.fromJson;

  @override
  UserOrderByWithAggregationInput get value;
  @JsonKey(ignore: true)
  _$$_GroupByUserOrderByWithUserOrderByWithAggregationInputCopyWith<
          _$_GroupByUserOrderByWithUserOrderByWithAggregationInput>
      get copyWith => throw _privateConstructorUsedError;
}

GroupByUserBy _$GroupByUserByFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'withUserScalarFieldEnumList':
      return _GroupByUserByWithUserScalarFieldEnumList.fromJson(json);
    case 'withUserScalarFieldEnum':
      return _GroupByUserByWithUserScalarFieldEnum.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'GroupByUserBy',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$GroupByUserBy {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserScalarFieldEnum> value)
        withUserScalarFieldEnumList,
    required TResult Function(UserScalarFieldEnum value)
        withUserScalarFieldEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserScalarFieldEnum> value)?
        withUserScalarFieldEnumList,
    TResult? Function(UserScalarFieldEnum value)? withUserScalarFieldEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserScalarFieldEnum> value)?
        withUserScalarFieldEnumList,
    TResult Function(UserScalarFieldEnum value)? withUserScalarFieldEnum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupByUserByWithUserScalarFieldEnumList value)
        withUserScalarFieldEnumList,
    required TResult Function(_GroupByUserByWithUserScalarFieldEnum value)
        withUserScalarFieldEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupByUserByWithUserScalarFieldEnumList value)?
        withUserScalarFieldEnumList,
    TResult? Function(_GroupByUserByWithUserScalarFieldEnum value)?
        withUserScalarFieldEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupByUserByWithUserScalarFieldEnumList value)?
        withUserScalarFieldEnumList,
    TResult Function(_GroupByUserByWithUserScalarFieldEnum value)?
        withUserScalarFieldEnum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupByUserByCopyWith<$Res> {
  factory $GroupByUserByCopyWith(
          GroupByUserBy value, $Res Function(GroupByUserBy) then) =
      _$GroupByUserByCopyWithImpl<$Res, GroupByUserBy>;
}

/// @nodoc
class _$GroupByUserByCopyWithImpl<$Res, $Val extends GroupByUserBy>
    implements $GroupByUserByCopyWith<$Res> {
  _$GroupByUserByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_GroupByUserByWithUserScalarFieldEnumListCopyWith<$Res> {
  factory _$$_GroupByUserByWithUserScalarFieldEnumListCopyWith(
          _$_GroupByUserByWithUserScalarFieldEnumList value,
          $Res Function(_$_GroupByUserByWithUserScalarFieldEnumList) then) =
      __$$_GroupByUserByWithUserScalarFieldEnumListCopyWithImpl<$Res>;
  @useResult
  $Res call({List<UserScalarFieldEnum> value});
}

/// @nodoc
class __$$_GroupByUserByWithUserScalarFieldEnumListCopyWithImpl<$Res>
    extends _$GroupByUserByCopyWithImpl<$Res,
        _$_GroupByUserByWithUserScalarFieldEnumList>
    implements _$$_GroupByUserByWithUserScalarFieldEnumListCopyWith<$Res> {
  __$$_GroupByUserByWithUserScalarFieldEnumListCopyWithImpl(
      _$_GroupByUserByWithUserScalarFieldEnumList _value,
      $Res Function(_$_GroupByUserByWithUserScalarFieldEnumList) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_GroupByUserByWithUserScalarFieldEnumList(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<UserScalarFieldEnum>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GroupByUserByWithUserScalarFieldEnumList
    implements _GroupByUserByWithUserScalarFieldEnumList {
  const _$_GroupByUserByWithUserScalarFieldEnumList(
      final List<UserScalarFieldEnum> value,
      {final String? $type})
      : _value = value,
        $type = $type ?? 'withUserScalarFieldEnumList';

  factory _$_GroupByUserByWithUserScalarFieldEnumList.fromJson(
          Map<String, dynamic> json) =>
      _$$_GroupByUserByWithUserScalarFieldEnumListFromJson(json);

  final List<UserScalarFieldEnum> _value;
  @override
  List<UserScalarFieldEnum> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'GroupByUserBy.withUserScalarFieldEnumList(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GroupByUserByWithUserScalarFieldEnumList &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GroupByUserByWithUserScalarFieldEnumListCopyWith<
          _$_GroupByUserByWithUserScalarFieldEnumList>
      get copyWith => __$$_GroupByUserByWithUserScalarFieldEnumListCopyWithImpl<
          _$_GroupByUserByWithUserScalarFieldEnumList>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserScalarFieldEnum> value)
        withUserScalarFieldEnumList,
    required TResult Function(UserScalarFieldEnum value)
        withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnumList(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserScalarFieldEnum> value)?
        withUserScalarFieldEnumList,
    TResult? Function(UserScalarFieldEnum value)? withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnumList?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserScalarFieldEnum> value)?
        withUserScalarFieldEnumList,
    TResult Function(UserScalarFieldEnum value)? withUserScalarFieldEnum,
    required TResult orElse(),
  }) {
    if (withUserScalarFieldEnumList != null) {
      return withUserScalarFieldEnumList(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupByUserByWithUserScalarFieldEnumList value)
        withUserScalarFieldEnumList,
    required TResult Function(_GroupByUserByWithUserScalarFieldEnum value)
        withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnumList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupByUserByWithUserScalarFieldEnumList value)?
        withUserScalarFieldEnumList,
    TResult? Function(_GroupByUserByWithUserScalarFieldEnum value)?
        withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnumList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupByUserByWithUserScalarFieldEnumList value)?
        withUserScalarFieldEnumList,
    TResult Function(_GroupByUserByWithUserScalarFieldEnum value)?
        withUserScalarFieldEnum,
    required TResult orElse(),
  }) {
    if (withUserScalarFieldEnumList != null) {
      return withUserScalarFieldEnumList(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroupByUserByWithUserScalarFieldEnumListToJson(
      this,
    );
  }
}

abstract class _GroupByUserByWithUserScalarFieldEnumList
    implements GroupByUserBy {
  const factory _GroupByUserByWithUserScalarFieldEnumList(
          final List<UserScalarFieldEnum> value) =
      _$_GroupByUserByWithUserScalarFieldEnumList;

  factory _GroupByUserByWithUserScalarFieldEnumList.fromJson(
          Map<String, dynamic> json) =
      _$_GroupByUserByWithUserScalarFieldEnumList.fromJson;

  @override
  List<UserScalarFieldEnum> get value;
  @JsonKey(ignore: true)
  _$$_GroupByUserByWithUserScalarFieldEnumListCopyWith<
          _$_GroupByUserByWithUserScalarFieldEnumList>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_GroupByUserByWithUserScalarFieldEnumCopyWith<$Res> {
  factory _$$_GroupByUserByWithUserScalarFieldEnumCopyWith(
          _$_GroupByUserByWithUserScalarFieldEnum value,
          $Res Function(_$_GroupByUserByWithUserScalarFieldEnum) then) =
      __$$_GroupByUserByWithUserScalarFieldEnumCopyWithImpl<$Res>;
  @useResult
  $Res call({UserScalarFieldEnum value});
}

/// @nodoc
class __$$_GroupByUserByWithUserScalarFieldEnumCopyWithImpl<$Res>
    extends _$GroupByUserByCopyWithImpl<$Res,
        _$_GroupByUserByWithUserScalarFieldEnum>
    implements _$$_GroupByUserByWithUserScalarFieldEnumCopyWith<$Res> {
  __$$_GroupByUserByWithUserScalarFieldEnumCopyWithImpl(
      _$_GroupByUserByWithUserScalarFieldEnum _value,
      $Res Function(_$_GroupByUserByWithUserScalarFieldEnum) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_GroupByUserByWithUserScalarFieldEnum(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as UserScalarFieldEnum,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GroupByUserByWithUserScalarFieldEnum
    implements _GroupByUserByWithUserScalarFieldEnum {
  const _$_GroupByUserByWithUserScalarFieldEnum(this.value,
      {final String? $type})
      : $type = $type ?? 'withUserScalarFieldEnum';

  factory _$_GroupByUserByWithUserScalarFieldEnum.fromJson(
          Map<String, dynamic> json) =>
      _$$_GroupByUserByWithUserScalarFieldEnumFromJson(json);

  @override
  final UserScalarFieldEnum value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'GroupByUserBy.withUserScalarFieldEnum(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GroupByUserByWithUserScalarFieldEnum &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GroupByUserByWithUserScalarFieldEnumCopyWith<
          _$_GroupByUserByWithUserScalarFieldEnum>
      get copyWith => __$$_GroupByUserByWithUserScalarFieldEnumCopyWithImpl<
          _$_GroupByUserByWithUserScalarFieldEnum>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<UserScalarFieldEnum> value)
        withUserScalarFieldEnumList,
    required TResult Function(UserScalarFieldEnum value)
        withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnum(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<UserScalarFieldEnum> value)?
        withUserScalarFieldEnumList,
    TResult? Function(UserScalarFieldEnum value)? withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnum?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<UserScalarFieldEnum> value)?
        withUserScalarFieldEnumList,
    TResult Function(UserScalarFieldEnum value)? withUserScalarFieldEnum,
    required TResult orElse(),
  }) {
    if (withUserScalarFieldEnum != null) {
      return withUserScalarFieldEnum(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GroupByUserByWithUserScalarFieldEnumList value)
        withUserScalarFieldEnumList,
    required TResult Function(_GroupByUserByWithUserScalarFieldEnum value)
        withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GroupByUserByWithUserScalarFieldEnumList value)?
        withUserScalarFieldEnumList,
    TResult? Function(_GroupByUserByWithUserScalarFieldEnum value)?
        withUserScalarFieldEnum,
  }) {
    return withUserScalarFieldEnum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GroupByUserByWithUserScalarFieldEnumList value)?
        withUserScalarFieldEnumList,
    TResult Function(_GroupByUserByWithUserScalarFieldEnum value)?
        withUserScalarFieldEnum,
    required TResult orElse(),
  }) {
    if (withUserScalarFieldEnum != null) {
      return withUserScalarFieldEnum(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_GroupByUserByWithUserScalarFieldEnumToJson(
      this,
    );
  }
}

abstract class _GroupByUserByWithUserScalarFieldEnum implements GroupByUserBy {
  const factory _GroupByUserByWithUserScalarFieldEnum(
          final UserScalarFieldEnum value) =
      _$_GroupByUserByWithUserScalarFieldEnum;

  factory _GroupByUserByWithUserScalarFieldEnum.fromJson(
          Map<String, dynamic> json) =
      _$_GroupByUserByWithUserScalarFieldEnum.fromJson;

  @override
  UserScalarFieldEnum get value;
  @JsonKey(ignore: true)
  _$$_GroupByUserByWithUserScalarFieldEnumCopyWith<
          _$_GroupByUserByWithUserScalarFieldEnum>
      get copyWith => throw _privateConstructorUsedError;
}
