// ignore_for_file: non_constant_identifier_names

library prisma.namespace.prisma; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'package:orm/orm.dart' as _i1;

import 'model.dart' as _i3;
import 'prisma.dart' as _i2;

class TipoModuloContrattoCountOutputType {
  const TipoModuloContrattoCountOutputType({this.moduloContratto});

  factory TipoModuloContrattoCountOutputType.fromJson(Map json) =>
      TipoModuloContrattoCountOutputType(
          moduloContratto: json['ModuloContratto']);

  final int? moduloContratto;
}

class ModuloContrattoCountOutputType {
  const ModuloContrattoCountOutputType({
    this.serviziEwoCollegabili,
    this.contratti,
  });

  factory ModuloContrattoCountOutputType.fromJson(Map json) =>
      ModuloContrattoCountOutputType(
        serviziEwoCollegabili: json['serviziEwoCollegabili'],
        contratti: json['contratti'],
      );

  final int? serviziEwoCollegabili;

  final int? contratti;
}

class ProduttoreCountOutputType {
  const ProduttoreCountOutputType({this.prodotti});

  factory ProduttoreCountOutputType.fromJson(Map json) =>
      ProduttoreCountOutputType(prodotti: json['prodotti']);

  final int? prodotti;
}

class StatoOrdineCountOutputType {
  const StatoOrdineCountOutputType({this.ordini});

  factory StatoOrdineCountOutputType.fromJson(Map json) =>
      StatoOrdineCountOutputType(ordini: json['ordini']);

  final int? ordini;
}

class TipoPraticaCountOutputType {
  const TipoPraticaCountOutputType({
    this.serviziEwo,
    this.pratiche,
  });

  factory TipoPraticaCountOutputType.fromJson(Map json) =>
      TipoPraticaCountOutputType(
        serviziEwo: json['serviziEwo'],
        pratiche: json['pratiche'],
      );

  final int? serviziEwo;

  final int? pratiche;
}

class StatoPraticaCountOutputType {
  const StatoPraticaCountOutputType({
    this.pratiche,
    this.serviziEwo,
  });

  factory StatoPraticaCountOutputType.fromJson(Map json) =>
      StatoPraticaCountOutputType(
        pratiche: json['pratiche'],
        serviziEwo: json['serviziEwo'],
      );

  final int? pratiche;

  final int? serviziEwo;
}

class PraticaCountOutputType {
  const PraticaCountOutputType({this.contratto});

  factory PraticaCountOutputType.fromJson(Map json) =>
      PraticaCountOutputType(contratto: json['contratto']);

  final int? contratto;
}

class ZonaNegozioCountOutputType {
  const ZonaNegozioCountOutputType({this.negozi});

  factory ZonaNegozioCountOutputType.fromJson(Map json) =>
      ZonaNegozioCountOutputType(negozi: json['negozi']);

  final int? negozi;
}

class NegozioCountOutputType {
  const NegozioCountOutputType({
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  factory NegozioCountOutputType.fromJson(Map json) => NegozioCountOutputType(
        pratiche: json['pratiche'],
        utenti: json['utenti'],
        contratti: json['contratti'],
        soggetti: json['soggetti'],
        ingressi: json['ingressi'],
        leads: json['leads'],
        ordine: json['Ordine'],
      );

  final int? pratiche;

  final int? utenti;

  final int? contratti;

  final int? soggetti;

  final int? ingressi;

  final int? leads;

  final int? ordine;
}

class UtenteCountOutputType {
  const UtenteCountOutputType({
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  factory UtenteCountOutputType.fromJson(Map json) => UtenteCountOutputType(
        contratti: json['contratti'],
        pratiche: json['pratiche'],
        ingressi: json['ingressi'],
        leadsGestiti: json['leadsGestiti'],
        leadsAssegnati: json['leadsAssegnati'],
        opportunitaGestite: json['opportunitaGestite'],
        opportunitaAssegnate: json['opportunitaAssegnate'],
        ordini: json['ordini'],
        history: json['history'],
      );

  final int? contratti;

  final int? pratiche;

  final int? ingressi;

  final int? leadsGestiti;

  final int? leadsAssegnati;

  final int? opportunitaGestite;

  final int? opportunitaAssegnate;

  final int? ordini;

  final int? history;
}

class OpportunitaCountOutputType {
  const OpportunitaCountOutputType({
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  factory OpportunitaCountOutputType.fromJson(Map json) =>
      OpportunitaCountOutputType(
        leads: json['leads'],
        gestoriLead: json['gestoriLead'],
        agenti: json['agenti'],
      );

  final int? leads;

  final int? gestoriLead;

  final int? agenti;
}

class StatoOpportunitaCountOutputType {
  const StatoOpportunitaCountOutputType({this.leads});

  factory StatoOpportunitaCountOutputType.fromJson(Map json) =>
      StatoOpportunitaCountOutputType(leads: json['leads']);

  final int? leads;
}

class LeadCountOutputType {
  const LeadCountOutputType({
    this.ordine,
    this.history,
  });

  factory LeadCountOutputType.fromJson(Map json) => LeadCountOutputType(
        ordine: json['ordine'],
        history: json['history'],
      );

  final int? ordine;

  final int? history;
}

class OrdineCountOutputType {
  const OrdineCountOutputType({this.prodotti});

  factory OrdineCountOutputType.fromJson(Map json) =>
      OrdineCountOutputType(prodotti: json['prodotti']);

  final int? prodotti;
}

class TipoProdottoCountOutputType {
  const TipoProdottoCountOutputType({this.prodotti});

  factory TipoProdottoCountOutputType.fromJson(Map json) =>
      TipoProdottoCountOutputType(prodotti: json['prodotti']);

  final int? prodotti;
}

class ProdottoCountOutputType {
  const ProdottoCountOutputType({this.prodottiOrdinati});

  factory ProdottoCountOutputType.fromJson(Map json) =>
      ProdottoCountOutputType(prodottiOrdinati: json['prodottiOrdinati']);

  final int? prodottiOrdinati;
}

class FornitoreCountOutputType {
  const FornitoreCountOutputType({
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  factory FornitoreCountOutputType.fromJson(Map json) =>
      FornitoreCountOutputType(
        serviziEwo: json['serviziEwo'],
        moduliContratto: json['moduliContratto'],
        prodotti: json['prodotti'],
      );

  final int? serviziEwo;

  final int? moduliContratto;

  final int? prodotti;
}

class ClasseMisuratoreGasCountOutputType {
  const ClasseMisuratoreGasCountOutputType({this.fornituraGas});

  factory ClasseMisuratoreGasCountOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasCountOutputType(fornituraGas: json['fornituraGas']);

  final int? fornituraGas;
}

class FornituraGasCountOutputType {
  const FornituraGasCountOutputType({this.contrattiEnelGas});

  factory FornituraGasCountOutputType.fromJson(Map json) =>
      FornituraGasCountOutputType(contrattiEnelGas: json['contrattiEnelGas']);

  final int? contrattiEnelGas;
}

class OffertaCountOutputType {
  const OffertaCountOutputType({
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  factory OffertaCountOutputType.fromJson(Map json) => OffertaCountOutputType(
        contrattiEnelLuce: json['contrattiEnelLuce'],
        contrattiEnelGas: json['contrattiEnelGas'],
        contrattiEnelFibra: json['contrattiEnelFibra'],
        contrattiEnelXAssicurazione: json['contrattiEnelXAssicurazione'],
        offerteIncluse: json['offerteIncluse'],
        inclusaInOfferte: json['inclusaInOfferte'],
      );

  final int? contrattiEnelLuce;

  final int? contrattiEnelGas;

  final int? contrattiEnelFibra;

  final int? contrattiEnelXAssicurazione;

  final int? offerteIncluse;

  final int? inclusaInOfferte;
}

class ServizioEwoCountOutputType {
  const ServizioEwoCountOutputType({
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  factory ServizioEwoCountOutputType.fromJson(Map json) =>
      ServizioEwoCountOutputType(
        tipiPratiche: json['tipiPratiche'],
        forniture: json['forniture'],
        statiPossibiliPratiche: json['statiPossibiliPratiche'],
        statiPossibiliContratti: json['statiPossibiliContratti'],
        offerte: json['offerte'],
        moduliContratto: json['moduliContratto'],
      );

  final int? tipiPratiche;

  final int? forniture;

  final int? statiPossibiliPratiche;

  final int? statiPossibiliContratti;

  final int? offerte;

  final int? moduliContratto;
}

class FornituraLuceCountOutputType {
  const FornituraLuceCountOutputType({this.contrattiEnelLuce});

  factory FornituraLuceCountOutputType.fromJson(Map json) =>
      FornituraLuceCountOutputType(
          contrattiEnelLuce: json['contrattiEnelLuce']);

  final int? contrattiEnelLuce;
}

class ContrattoCountOutputType {
  const ContrattoCountOutputType({
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  factory ContrattoCountOutputType.fromJson(Map json) =>
      ContrattoCountOutputType(
        contrattiEnelLuce: json['contrattiEnelLuce'],
        contrattiEnelGas: json['contrattiEnelGas'],
        contrattiEnelFibra: json['contrattiEnelFibra'],
        contrattiEnelXAssicurazione: json['contrattiEnelXAssicurazione'],
      );

  final int? contrattiEnelLuce;

  final int? contrattiEnelGas;

  final int? contrattiEnelFibra;

  final int? contrattiEnelXAssicurazione;
}

class StatoContrattoCountOutputType {
  const StatoContrattoCountOutputType({
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  factory StatoContrattoCountOutputType.fromJson(Map json) =>
      StatoContrattoCountOutputType(
        contratti: json['contratti'],
        serviziEwo: json['serviziEwo'],
        contrattiEnelLuce: json['contrattiEnelLuce'],
        contrattiEnelGas: json['contrattiEnelGas'],
        contrattiEnelFibra: json['contrattiEnelFibra'],
        contrattiEnelXAssicurazione: json['contrattiEnelXAssicurazione'],
      );

  final int? contratti;

  final int? serviziEwo;

  final int? contrattiEnelLuce;

  final int? contrattiEnelGas;

  final int? contrattiEnelFibra;

  final int? contrattiEnelXAssicurazione;
}

class DomicilioCountOutputType {
  const DomicilioCountOutputType({
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  factory DomicilioCountOutputType.fromJson(Map json) =>
      DomicilioCountOutputType(
        contrattiEnelXAssicurazione: json['contrattiEnelXAssicurazione'],
        forniture: json['forniture'],
        contrattiEnelFibra: json['contrattiEnelFibra'],
        prodottiOrdinati: json['prodottiOrdinati'],
        leads: json['leads'],
      );

  final int? contrattiEnelXAssicurazione;

  final int? forniture;

  final int? contrattiEnelFibra;

  final int? prodottiOrdinati;

  final int? leads;
}

class SoggettoCountOutputType {
  const SoggettoCountOutputType({
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
  });

  factory SoggettoCountOutputType.fromJson(Map json) => SoggettoCountOutputType(
        domicili: json['domicili'],
        praticheIntestate: json['praticheIntestate'],
        contratti: json['contratti'],
        indirizziEmail: json['indirizziEmail'],
        numeriTelefono: json['numeriTelefono'],
        prodottiOrdinati: json['prodottiOrdinati'],
        leads: json['leads'],
      );

  final int? domicili;

  final int? praticheIntestate;

  final int? contratti;

  final int? indirizziEmail;

  final int? numeriTelefono;

  final int? prodottiOrdinati;

  final int? leads;
}

class NestedStringFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<String, _i2.NestedStringFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
      };
}

class StringFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<String, _i2.NestedStringFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
      };
}

class NestedStringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
      };
}

class StringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
      };
}

class NestedEnumTipoSoggettoFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoSoggettoFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoSoggetto, _i1.Reference<_i3.TipoSoggetto>>?
      equals;

  final Iterable<_i3.TipoSoggetto>? $in;

  final Iterable<_i3.TipoSoggetto>? notIn;

  final _i1.PrismaUnion<_i3.TipoSoggetto, _i2.NestedEnumTipoSoggettoFilter>?
      not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumTipoSoggettoFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoSoggettoFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoSoggetto, _i1.Reference<_i3.TipoSoggetto>>?
      equals;

  final Iterable<_i3.TipoSoggetto>? $in;

  final Iterable<_i3.TipoSoggetto>? notIn;

  final _i1.PrismaUnion<_i3.TipoSoggetto, _i2.NestedEnumTipoSoggettoFilter>?
      not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class SoggettoNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class IndirizzoEmailWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput,
      Iterable<_i2.IndirizzoEmailWhereInput>>? AND;

  final Iterable<_i2.IndirizzoEmailWhereInput>? OR;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput,
      Iterable<_i2.IndirizzoEmailWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referenteUuid;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.ReferenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>>? referente;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteNullableRelationFilter,
          _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>>?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class SoggettoBusinessInfoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.SoggettoBusinessInfoWhereInput? $is;

  final _i2.SoggettoBusinessInfoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ReferenteWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1
      .PrismaUnion<_i2.ReferenteWhereInput, Iterable<_i2.ReferenteWhereInput>>?
      AND;

  final Iterable<_i2.ReferenteWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ReferenteWhereInput, Iterable<_i2.ReferenteWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? cognome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoBusinessInfoUuid;

  final _i1.PrismaUnion<_i2.NumeroTelefonoNullableRelationFilter,
          _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput, _i1.PrismaNull>>?
      numeroTelefono;

  final _i1.PrismaUnion<_i2.IndirizzoEmailNullableRelationFilter,
          _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput, _i1.PrismaNull>>?
      indirizzoEmail;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoRelationFilter,
      _i2.SoggettoBusinessInfoWhereInput>? soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NumeroTelefonoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput,
      Iterable<_i2.NumeroTelefonoWhereInput>>? AND;

  final Iterable<_i2.NumeroTelefonoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput,
      Iterable<_i2.NumeroTelefonoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? numero;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referenteUuid;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteNullableRelationFilter,
          _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>>?
      legaleRappresentate;

  final _i1.PrismaUnion<_i2.ReferenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>>? referente;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class NumeroTelefonoNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class LegaleRappresentanteWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput,
      Iterable<_i2.LegaleRappresentanteWhereInput>>? AND;

  final Iterable<_i2.LegaleRappresentanteWhereInput>? OR;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput,
      Iterable<_i2.LegaleRappresentanteWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? cognome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoBusinessInfoUuid;

  final _i1.PrismaUnion<_i2.NumeroTelefonoNullableRelationFilter,
          _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput, _i1.PrismaNull>>?
      numeroTelefono;

  final _i1.PrismaUnion<_i2.IndirizzoEmailNullableRelationFilter,
          _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput, _i1.PrismaNull>>?
      indirizzoEmail;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoRelationFilter,
      _i2.SoggettoBusinessInfoWhereInput>? soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>?
      $is;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>?
      isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class SoggettoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.SoggettoWhereInput? $is;

  final _i2.SoggettoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class SoggettoBusinessInfoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.legaleRappresentante,
    this.referente,
    this.soggetto,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput,
      Iterable<_i2.SoggettoBusinessInfoWhereInput>>? AND;

  final Iterable<_i2.SoggettoBusinessInfoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput,
      Iterable<_i2.SoggettoBusinessInfoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<_i2.StringFilter, String>? partitaIVA;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteNullableRelationFilter,
          _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>>?
      legaleRappresentante;

  final _i1.PrismaUnion<_i2.ReferenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>>? referente;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput, _i1.PrismaNull>?
      $is;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput, _i1.PrismaNull>?
      isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NestedDateTimeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DateTimeFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedDateTimeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DateTimeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedBoolNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolNullableFilter({
    this.equals,
    this.not,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class BoolNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolNullableFilter({
    this.equals,
    this.not,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class NestedBoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolFilter({
    this.equals,
    this.not,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class BoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFilter({
    this.equals,
    this.not,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class NestedIntNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int,
      _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class IntNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int,
      _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedFloatNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i1.Reference<double>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i2.NestedFloatNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class FloatNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i1.Reference<double>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i2.NestedFloatNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedFloatFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double, _i1.Reference<double>>? equals;

  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class FloatFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double, _i1.Reference<double>>? equals;

  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class ConsumoAnnuoLuceWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.fornituraLuce,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput,
      Iterable<_i2.ConsumoAnnuoLuceWhereInput>>? AND;

  final Iterable<_i2.ConsumoAnnuoLuceWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput,
      Iterable<_i2.ConsumoAnnuoLuceWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? consumo;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraLuceUuid;

  final _i1.PrismaUnion<_i2.FornituraLuceRelationFilter,
      _i2.FornituraLuceWhereInput>? fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
        'fornituraLuce': fornituraLuce,
      };
}

class ConsumoAnnuoLuceNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class DomicilioRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.DomicilioWhereInput? $is;

  final _i2.DomicilioWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NestedEnumTipoServizioEwoFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoServizioEwoFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1
      .PrismaUnion<_i3.TipoServizioEwo, _i1.Reference<_i3.TipoServizioEwo>>?
      equals;

  final Iterable<_i3.TipoServizioEwo>? $in;

  final Iterable<_i3.TipoServizioEwo>? notIn;

  final _i1
      .PrismaUnion<_i3.TipoServizioEwo, _i2.NestedEnumTipoServizioEwoFilter>?
      not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumTipoServizioEwoFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoServizioEwoFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1
      .PrismaUnion<_i3.TipoServizioEwo, _i1.Reference<_i3.TipoServizioEwo>>?
      equals;

  final Iterable<_i3.TipoServizioEwo>? $in;

  final Iterable<_i3.TipoServizioEwo>? notIn;

  final _i1
      .PrismaUnion<_i3.TipoServizioEwo, _i2.NestedEnumTipoServizioEwoFilter>?
      not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class ServizioEwoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ServizioEwoWhereInput? every;

  final _i2.ServizioEwoWhereInput? some;

  final _i2.ServizioEwoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class NestedEnumCanaleFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumCanaleFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.Canale, _i1.Reference<_i3.Canale>>? equals;

  final Iterable<_i3.Canale>? $in;

  final Iterable<_i3.Canale>? notIn;

  final _i1.PrismaUnion<_i3.Canale, _i2.NestedEnumCanaleFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumCanaleFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumCanaleFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.Canale, _i1.Reference<_i3.Canale>>? equals;

  final Iterable<_i3.Canale>? $in;

  final Iterable<_i3.Canale>? notIn;

  final _i1.PrismaUnion<_i3.Canale, _i2.NestedEnumCanaleFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class NestedIntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class IntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class TipoModuloContrattoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.moduloContratto,
  });

  final _i1.PrismaUnion<_i2.TipoModuloContrattoWhereInput,
      Iterable<_i2.TipoModuloContrattoWhereInput>>? AND;

  final Iterable<_i2.TipoModuloContrattoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoModuloContrattoWhereInput,
      Iterable<_i2.TipoModuloContrattoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.IntFilter, int>? numeroOfferteCollegabili;

  final _i2.ModuloContrattoListRelationFilter? moduloContratto;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
      };
}

class TipoModuloContrattoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.TipoModuloContrattoWhereInput? $is;

  final _i2.TipoModuloContrattoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ModuloContrattoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereInput,
      Iterable<_i2.ModuloContrattoWhereInput>>? AND;

  final Iterable<_i2.ModuloContrattoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereInput,
      Iterable<_i2.ModuloContrattoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoSoggettoFilter, _i3.TipoSoggetto>?
      clienteTarget;

  final _i1.PrismaUnion<_i2.EnumCanaleFilter, _i3.Canale>? canale;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoModuloContrattoId;

  final _i2.ServizioEwoListRelationFilter? serviziEwoCollegabili;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i1.PrismaUnion<_i2.FornitoreRelationFilter, _i2.FornitoreWhereInput>?
      fornitore;

  final _i1.PrismaUnion<_i2.TipoModuloContrattoRelationFilter,
      _i2.TipoModuloContrattoWhereInput>? tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ModuloContrattoWhereInput? every;

  final _i2.ModuloContrattoWhereInput? some;

  final _i2.ModuloContrattoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ProduttoreWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.prodotti,
  });

  final _i1.PrismaUnion<_i2.ProduttoreWhereInput,
      Iterable<_i2.ProduttoreWhereInput>>? AND;

  final Iterable<_i2.ProduttoreWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProduttoreWhereInput,
      Iterable<_i2.ProduttoreWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.ProdottoListRelationFilter? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProduttoreRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.ProduttoreWhereInput? $is;

  final _i2.ProduttoreWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class DomicilioNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NestedEnumTipoStatoFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoStatoFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoStato, _i1.Reference<_i3.TipoStato>>? equals;

  final Iterable<_i3.TipoStato>? $in;

  final Iterable<_i3.TipoStato>? notIn;

  final _i1.PrismaUnion<_i3.TipoStato, _i2.NestedEnumTipoStatoFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumTipoStatoFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoStatoFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoStato, _i1.Reference<_i3.TipoStato>>? equals;

  final Iterable<_i3.TipoStato>? $in;

  final Iterable<_i3.TipoStato>? notIn;

  final _i1.PrismaUnion<_i3.TipoStato, _i2.NestedEnumTipoStatoFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class StatoOrdineWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.ordini,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineWhereInput,
      Iterable<_i2.StatoOrdineWhereInput>>? AND;

  final Iterable<_i2.StatoOrdineWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoOrdineWhereInput,
      Iterable<_i2.StatoOrdineWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.EnumTipoStatoFilter, _i3.TipoStato>? tipoStato;

  final _i1.PrismaUnion<_i2.IntFilter, int>? ordine;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i2.OrdineListRelationFilter? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
      };
}

class StatoOrdineNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.StatoOrdineWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class LeadListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.LeadWhereInput? every;

  final _i2.LeadWhereInput? some;

  final _i2.LeadWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class NestedEnumRuoloUtenteFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumRuoloUtenteFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.RuoloUtente, _i1.Reference<_i3.RuoloUtente>>?
      equals;

  final Iterable<_i3.RuoloUtente>? $in;

  final Iterable<_i3.RuoloUtente>? notIn;

  final _i1.PrismaUnion<_i3.RuoloUtente, _i2.NestedEnumRuoloUtenteFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumRuoloUtenteFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumRuoloUtenteFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.RuoloUtente, _i1.Reference<_i3.RuoloUtente>>?
      equals;

  final Iterable<_i3.RuoloUtente>? $in;

  final Iterable<_i3.RuoloUtente>? notIn;

  final _i1.PrismaUnion<_i3.RuoloUtente, _i2.NestedEnumRuoloUtenteFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class TipoPraticaWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.serviziEwo,
    this.pratiche,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaWhereInput,
      Iterable<_i2.TipoPraticaWhereInput>>? AND;

  final Iterable<_i2.TipoPraticaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereInput,
      Iterable<_i2.TipoPraticaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  final _i2.PraticaListRelationFilter? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

class TipoPraticaRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.TipoPraticaWhereInput? $is;

  final _i2.TipoPraticaWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class UtenteNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class StatoPraticaWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.pratiche,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaWhereInput,
      Iterable<_i2.StatoPraticaWhereInput>>? AND;

  final Iterable<_i2.StatoPraticaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereInput,
      Iterable<_i2.StatoPraticaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.PraticaListRelationFilter? pratiche;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class PraticaWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final _i1.PrismaUnion<_i2.PraticaWhereInput, Iterable<_i2.PraticaWhereInput>>?
      AND;

  final Iterable<_i2.PraticaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PraticaWhereInput, Iterable<_i2.PraticaWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoPraticaId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1
      .PrismaUnion<_i2.TipoPraticaRelationFilter, _i2.TipoPraticaWhereInput>?
      tipoPratica;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i1.PrismaUnion<_i2.StatoPraticaNullableRelationFilter,
      _i1.PrismaUnion<_i2.StatoPraticaWhereInput, _i1.PrismaNull>>? stato;

  final _i2.ContrattoListRelationFilter? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.PraticaWhereInput? every;

  final _i2.PraticaWhereInput? some;

  final _i2.PraticaWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class SoggettoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.SoggettoWhereInput? every;

  final _i2.SoggettoWhereInput? some;

  final _i2.SoggettoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class NegozioListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.NegozioWhereInput? every;

  final _i2.NegozioWhereInput? some;

  final _i2.NegozioWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ZonaNegozioWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.negozi,
  });

  final _i1.PrismaUnion<_i2.ZonaNegozioWhereInput,
      Iterable<_i2.ZonaNegozioWhereInput>>? AND;

  final Iterable<_i2.ZonaNegozioWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ZonaNegozioWhereInput,
      Iterable<_i2.ZonaNegozioWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.NegozioListRelationFilter? negozi;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'negozi': negozi,
      };
}

class ZonaNegozioRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.ZonaNegozioWhereInput? $is;

  final _i2.ZonaNegozioWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class UtenteRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.UtenteWhereInput? $is;

  final _i2.UtenteWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NegozioRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.NegozioWhereInput? $is;

  final _i2.NegozioWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class IngressiWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.utente,
    this.negozio,
  });

  final _i1
      .PrismaUnion<_i2.IngressiWhereInput, Iterable<_i2.IngressiWhereInput>>?
      AND;

  final Iterable<_i2.IngressiWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.IngressiWhereInput, Iterable<_i2.IngressiWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? data;

  final _i1.PrismaUnion<_i2.IntFilter, int>? clienti;

  final _i1.PrismaUnion<_i2.IntFilter, int>? nonClienti;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? negozioCodice;

  final _i1.PrismaUnion<_i2.UtenteRelationFilter, _i2.UtenteWhereInput>? utente;

  final _i1.PrismaUnion<_i2.NegozioRelationFilter, _i2.NegozioWhereInput>?
      negozio;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'utente': utente,
        'negozio': negozio,
      };
}

class IngressiListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.IngressiWhereInput? every;

  final _i2.IngressiWhereInput? some;

  final _i2.IngressiWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class NegozioWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<_i2.NegozioWhereInput, Iterable<_i2.NegozioWhereInput>>?
      AND;

  final Iterable<_i2.NegozioWhereInput>? OR;

  final _i1.PrismaUnion<_i2.NegozioWhereInput, Iterable<_i2.NegozioWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? zonaNegozioId;

  final _i2.PraticaListRelationFilter? pratiche;

  final _i2.UtenteListRelationFilter? utenti;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.SoggettoListRelationFilter? soggetti;

  final _i1
      .PrismaUnion<_i2.ZonaNegozioRelationFilter, _i2.ZonaNegozioWhereInput>?
      zonaNegozio;

  final _i2.IngressiListRelationFilter? ingressi;

  final _i2.LeadListRelationFilter? leads;

  final _i2.OrdineListRelationFilter? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class OpportunitaListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.OpportunitaWhereInput? every;

  final _i2.OpportunitaWhereInput? some;

  final _i2.OpportunitaWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class HistoryRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.HistoryWhereInput? $is;

  final _i2.HistoryWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class HistoryCommentWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.comment,
    this.historyUuid,
    this.history,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentWhereInput,
      Iterable<_i2.HistoryCommentWhereInput>>? AND;

  final Iterable<_i2.HistoryCommentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryCommentWhereInput,
      Iterable<_i2.HistoryCommentWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? comment;

  final _i1.PrismaUnion<_i2.StringFilter, String>? historyUuid;

  final _i1.PrismaUnion<_i2.HistoryRelationFilter, _i2.HistoryWhereInput>?
      history;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'comment': comment,
        'historyUuid': historyUuid,
        'History': history,
      };
}

class HistoryCommentNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.HistoryCommentWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class HistoryAttachmentWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.url,
    this.name,
    this.historyUuid,
    this.history,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput,
      Iterable<_i2.HistoryAttachmentWhereInput>>? AND;

  final Iterable<_i2.HistoryAttachmentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput,
      Iterable<_i2.HistoryAttachmentWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? url;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringFilter, String>? historyUuid;

  final _i1.PrismaUnion<_i2.HistoryRelationFilter, _i2.HistoryWhereInput>?
      history;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
        'History': history,
      };
}

class HistoryAttachmentNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class HistoryWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.comment,
    this.attachment,
    this.utente,
    this.lead,
  });

  final _i1.PrismaUnion<_i2.HistoryWhereInput, Iterable<_i2.HistoryWhereInput>>?
      AND;

  final Iterable<_i2.HistoryWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryWhereInput, Iterable<_i2.HistoryWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? timestamp;

  final _i1.PrismaUnion<_i2.StringFilter, String>? event;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<_i2.HistoryCommentNullableRelationFilter,
      _i1.PrismaUnion<_i2.HistoryCommentWhereInput, _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<_i2.HistoryAttachmentNullableRelationFilter,
          _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput, _i1.PrismaNull>>?
      attachment;

  final _i1.PrismaUnion<_i2.UtenteRelationFilter, _i2.UtenteWhereInput>? utente;

  final _i1.PrismaUnion<_i2.LeadNullableRelationFilter,
      _i1.PrismaUnion<_i2.LeadWhereInput, _i1.PrismaNull>>? lead;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.HistoryWhereInput? every;

  final _i2.HistoryWhereInput? some;

  final _i2.HistoryWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class UtenteWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<_i2.UtenteWhereInput, Iterable<_i2.UtenteWhereInput>>?
      AND;

  final Iterable<_i2.UtenteWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UtenteWhereInput, Iterable<_i2.UtenteWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? email;

  final _i1.PrismaUnion<_i2.EnumRuoloUtenteFilter, _i3.RuoloUtente>? ruolo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nomeVisualizzato;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.PraticaListRelationFilter? pratiche;

  final _i2.IngressiListRelationFilter? ingressi;

  final _i2.LeadListRelationFilter? leadsGestiti;

  final _i2.LeadListRelationFilter? leadsAssegnati;

  final _i2.OpportunitaListRelationFilter? opportunitaGestite;

  final _i2.OpportunitaListRelationFilter? opportunitaAssegnate;

  final _i2.OrdineListRelationFilter? ordini;

  final _i2.HistoryListRelationFilter? history;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.UtenteWhereInput? every;

  final _i2.UtenteWhereInput? some;

  final _i2.UtenteWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class OpportunitaWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final _i1.PrismaUnion<_i2.OpportunitaWhereInput,
      Iterable<_i2.OpportunitaWhereInput>>? AND;

  final Iterable<_i2.OpportunitaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OpportunitaWhereInput,
      Iterable<_i2.OpportunitaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  final _i2.LeadListRelationFilter? leads;

  final _i2.UtenteListRelationFilter? gestoriLead;

  final _i2.UtenteListRelationFilter? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.OpportunitaWhereInput? $is;

  final _i2.OpportunitaWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class NestedEnumTipoStatoNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoStatoNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoStato,
      _i1.PrismaUnion<_i1.Reference<_i3.TipoStato>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1
      .PrismaUnion<_i2.NestedEnumTipoStatoNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumTipoStatoNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoStatoNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoStato,
      _i1.PrismaUnion<_i1.Reference<_i3.TipoStato>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1
      .PrismaUnion<_i2.NestedEnumTipoStatoNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class StatoOpportunitaWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.leads,
  });

  final _i1.PrismaUnion<_i2.StatoOpportunitaWhereInput,
      Iterable<_i2.StatoOpportunitaWhereInput>>? AND;

  final Iterable<_i2.StatoOpportunitaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoOpportunitaWhereInput,
      Iterable<_i2.StatoOpportunitaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.EnumTipoStatoNullableFilter,
      _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>>? tipoStato;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      ordine;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? opportunitaUuid;

  final _i2.LeadListRelationFilter? leads;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
      };
}

class StatoOpportunitaRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.StatoOpportunitaWhereInput? $is;

  final _i2.StatoOpportunitaWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class LeadWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<_i2.LeadWhereInput, Iterable<_i2.LeadWhereInput>>? AND;

  final Iterable<_i2.LeadWhereInput>? OR;

  final _i1.PrismaUnion<_i2.LeadWhereInput, Iterable<_i2.LeadWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? opportunitaUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoOpportunitaUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  final _i1
      .PrismaUnion<_i2.OpportunitaRelationFilter, _i2.OpportunitaWhereInput>?
      opportunita;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  final _i1.PrismaUnion<_i2.DomicilioNullableRelationFilter,
      _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>>? domicilio;

  final _i1.PrismaUnion<_i2.StatoOpportunitaRelationFilter,
      _i2.StatoOpportunitaWhereInput>? statoOpportunita;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? agente;

  final _i2.OrdineListRelationFilter? ordine;

  final _i2.HistoryListRelationFilter? history;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.LeadWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.LeadWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class OrdineWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<_i2.OrdineWhereInput, Iterable<_i2.OrdineWhereInput>>?
      AND;

  final Iterable<_i2.OrdineWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrdineWhereInput, Iterable<_i2.OrdineWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? valore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoListRelationFilter? prodotti;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  final _i1.PrismaUnion<_i2.DomicilioNullableRelationFilter,
      _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>>? domicilio;

  final _i1.PrismaUnion<_i2.StatoOrdineNullableRelationFilter,
      _i1.PrismaUnion<_i2.StatoOrdineWhereInput, _i1.PrismaNull>>? statoOrdine;

  final _i1.PrismaUnion<_i2.LeadNullableRelationFilter,
      _i1.PrismaUnion<_i2.LeadWhereInput, _i1.PrismaNull>>? lead;

  final _i1.PrismaUnion<_i2.UtenteRelationFilter, _i2.UtenteWhereInput>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.OrdineWhereInput? every;

  final _i2.OrdineWhereInput? some;

  final _i2.OrdineWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class TipoProdottoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.prodotti,
  });

  final _i1.PrismaUnion<_i2.TipoProdottoWhereInput,
      Iterable<_i2.TipoProdottoWhereInput>>? AND;

  final Iterable<_i2.TipoProdottoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoProdottoWhereInput,
      Iterable<_i2.TipoProdottoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.ProdottoListRelationFilter? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class TipoProdottoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.TipoProdottoWhereInput? $is;

  final _i2.TipoProdottoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ProdottoWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
  });

  final _i1
      .PrismaUnion<_i2.ProdottoWhereInput, Iterable<_i2.ProdottoWhereInput>>?
      AND;

  final Iterable<_i2.ProdottoWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ProdottoWhereInput, Iterable<_i2.ProdottoWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? modello;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<_i2.StringFilter, String>? produttoreId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoProdottoId;

  final _i1.PrismaUnion<_i2.ProduttoreRelationFilter, _i2.ProduttoreWhereInput>?
      produttore;

  final _i2.OrdineListRelationFilter? prodottiOrdinati;

  final _i1.PrismaUnion<_i2.FornitoreRelationFilter, _i2.FornitoreWhereInput>?
      fornitore;

  final _i1
      .PrismaUnion<_i2.TipoProdottoRelationFilter, _i2.TipoProdottoWhereInput>?
      tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ProdottoWhereInput? every;

  final _i2.ProdottoWhereInput? some;

  final _i2.ProdottoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class FornitoreWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final _i1
      .PrismaUnion<_i2.FornitoreWhereInput, Iterable<_i2.FornitoreWhereInput>>?
      AND;

  final Iterable<_i2.FornitoreWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.FornitoreWhereInput, Iterable<_i2.FornitoreWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  final _i2.ModuloContrattoListRelationFilter? moduliContratto;

  final _i2.ProdottoListRelationFilter? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.FornitoreWhereInput? $is;

  final _i2.FornitoreWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class TipoPraticaListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.TipoPraticaWhereInput? every;

  final _i2.TipoPraticaWhereInput? some;

  final _i2.TipoPraticaWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class FornituraListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.FornituraWhereInput? every;

  final _i2.FornituraWhereInput? some;

  final _i2.FornituraWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class StatoPraticaListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.StatoPraticaWhereInput? every;

  final _i2.StatoPraticaWhereInput? some;

  final _i2.StatoPraticaWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class StatoContrattoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.StatoContrattoWhereInput? every;

  final _i2.StatoContrattoWhereInput? some;

  final _i2.StatoContrattoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class FornituraGasListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.FornituraGasWhereInput? every;

  final _i2.FornituraGasWhereInput? some;

  final _i2.FornituraGasWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ClasseMisuratoreGasWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput,
      Iterable<_i2.ClasseMisuratoreGasWhereInput>>? AND;

  final Iterable<_i2.ClasseMisuratoreGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput,
      Iterable<_i2.ClasseMisuratoreGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? portataMin;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? portataNominale;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? portataMax;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? classe;

  final _i2.FornituraGasListRelationFilter? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
      };
}

class ClasseMisuratoreGasNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput, _i1.PrismaNull>?
      isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ConsumoAnnuoGasWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput,
      Iterable<_i2.ConsumoAnnuoGasWhereInput>>? AND;

  final Iterable<_i2.ConsumoAnnuoGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput,
      Iterable<_i2.ConsumoAnnuoGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? consumo;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraGasUuid;

  final _i1
      .PrismaUnion<_i2.FornituraGasRelationFilter, _i2.FornituraGasWhereInput>?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
        'fornituraGas': fornituraGas,
      };
}

class ConsumoAnnuoGasNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class FornituraGasWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
  });

  final _i1.PrismaUnion<_i2.FornituraGasWhereInput,
      Iterable<_i2.FornituraGasWhereInput>>? AND;

  final Iterable<_i2.FornituraGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraGasWhereInput,
      Iterable<_i2.FornituraGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? pdr;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? remi;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasNullableRelationFilter,
          _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput, _i1.PrismaNull>>?
      classeMisuratore;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasNullableRelationFilter,
          _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput, _i1.PrismaNull>>?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i1.PrismaUnion<_i2.FornituraRelationFilter, _i2.FornituraWhereInput>?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.FornituraGasWhereInput? $is;

  final _i2.FornituraGasWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ContrattoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.ContrattoWhereInput? $is;

  final _i2.ContrattoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class OffertaNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ContrattoEnelGasWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraGas,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereInput,
      Iterable<_i2.ContrattoEnelGasWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereInput,
      Iterable<_i2.ContrattoEnelGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraGasUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1
      .PrismaUnion<_i2.FornituraGasRelationFilter, _i2.FornituraGasWhereInput>?
      fornituraGas;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ContrattoEnelGasWhereInput? every;

  final _i2.ContrattoEnelGasWhereInput? some;

  final _i2.ContrattoEnelGasWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class NestedEnumServizioContrattoEnelFibraFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumServizioContrattoEnelFibraFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i1.Reference<_i3.ServizioContrattoEnelFibra>>? equals;

  final Iterable<_i3.ServizioContrattoEnelFibra>? $in;

  final Iterable<_i3.ServizioContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i2.NestedEnumServizioContrattoEnelFibraFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumServizioContrattoEnelFibraFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumServizioContrattoEnelFibraFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i1.Reference<_i3.ServizioContrattoEnelFibra>>? equals;

  final Iterable<_i3.ServizioContrattoEnelFibra>? $in;

  final Iterable<_i3.ServizioContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i2.NestedEnumServizioContrattoEnelFibraFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class NestedEnumTipoContrattoEnelFibraFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoContrattoEnelFibraFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i1.Reference<_i3.TipoContrattoEnelFibra>>? equals;

  final Iterable<_i3.TipoContrattoEnelFibra>? $in;

  final Iterable<_i3.TipoContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i2.NestedEnumTipoContrattoEnelFibraFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumTipoContrattoEnelFibraFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoContrattoEnelFibraFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i1.Reference<_i3.TipoContrattoEnelFibra>>? equals;

  final Iterable<_i3.TipoContrattoEnelFibra>? $in;

  final Iterable<_i3.TipoContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i2.NestedEnumTipoContrattoEnelFibraFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class NestedEnumTecnologiaContrattoEnelFibraFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTecnologiaContrattoEnelFibraFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i1.Reference<_i3.TecnologiaContrattoEnelFibra>>? equals;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? $in;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i2.NestedEnumTecnologiaContrattoEnelFibraFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class EnumTecnologiaContrattoEnelFibraFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTecnologiaContrattoEnelFibraFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i1.Reference<_i3.TecnologiaContrattoEnelFibra>>? equals;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? $in;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i2.NestedEnumTecnologiaContrattoEnelFibraFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
      };
}

class ContrattoEnelFibraWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.offerta,
    this.domicilio,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereInput,
      Iterable<_i2.ContrattoEnelFibraWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelFibraWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereInput,
      Iterable<_i2.ContrattoEnelFibraWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.EnumServizioContrattoEnelFibraFilter,
      _i3.ServizioContrattoEnelFibra>? servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTipoContrattoEnelFibraFilter,
      _i3.TipoContrattoEnelFibra>? tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTecnologiaContrattoEnelFibraFilter,
      _i3.TecnologiaContrattoEnelFibra>? tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  final _i1.PrismaUnion<_i2.DomicilioNullableRelationFilter,
      _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>>? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ContrattoEnelFibraWhereInput? every;

  final _i2.ContrattoEnelFibraWhereInput? some;

  final _i2.ContrattoEnelFibraWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class OffertaWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<_i2.OffertaWhereInput, Iterable<_i2.OffertaWhereInput>>?
      AND;

  final Iterable<_i2.OffertaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OffertaWhereInput, Iterable<_i2.OffertaWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataFineOfferta;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInizioOfferta;

  final _i1.PrismaUnion<_i2.StringFilter, String>? servizioEwoId;

  final _i1
      .PrismaUnion<_i2.ServizioEwoRelationFilter, _i2.ServizioEwoWhereInput>?
      servizioEwo;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  final _i2.OffertaListRelationFilter? offerteIncluse;

  final _i2.OffertaListRelationFilter? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.OffertaWhereInput? every;

  final _i2.OffertaWhereInput? some;

  final _i2.OffertaWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class ServizioEwoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoWhereInput,
      Iterable<_i2.ServizioEwoWhereInput>>? AND;

  final Iterable<_i2.ServizioEwoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereInput,
      Iterable<_i2.ServizioEwoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoServizioEwoFilter, _i3.TipoServizioEwo>?
      tipoServizioEwo;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? icona;

  final _i1.PrismaUnion<_i2.FornitoreRelationFilter, _i2.FornitoreWhereInput>?
      fornitore;

  final _i2.TipoPraticaListRelationFilter? tipiPratiche;

  final _i2.FornituraListRelationFilter? forniture;

  final _i2.StatoPraticaListRelationFilter? statiPossibiliPratiche;

  final _i2.StatoContrattoListRelationFilter? statiPossibiliContratti;

  final _i2.OffertaListRelationFilter? offerte;

  final _i2.ModuloContrattoListRelationFilter? moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.ServizioEwoWhereInput? $is;

  final _i2.ServizioEwoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class FornituraLuceNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.FornituraLuceWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class FornituraGasNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.FornituraGasWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.FornituraGasWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class FornituraWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1
      .PrismaUnion<_i2.FornituraWhereInput, Iterable<_i2.FornituraWhereInput>>?
      AND;

  final Iterable<_i2.FornituraWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.FornituraWhereInput, Iterable<_i2.FornituraWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? servizioEwoId;

  final _i1.PrismaUnion<_i2.DomicilioRelationFilter, _i2.DomicilioWhereInput>?
      domicilio;

  final _i1
      .PrismaUnion<_i2.ServizioEwoRelationFilter, _i2.ServizioEwoWhereInput>?
      servizioEwo;

  final _i1.PrismaUnion<_i2.FornituraLuceNullableRelationFilter,
          _i1.PrismaUnion<_i2.FornituraLuceWhereInput, _i1.PrismaNull>>?
      fornituraLuce;

  final _i1.PrismaUnion<_i2.FornituraGasNullableRelationFilter,
          _i1.PrismaUnion<_i2.FornituraGasWhereInput, _i1.PrismaNull>>?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.FornituraWhereInput? $is;

  final _i2.FornituraWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class FornituraLuceWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    this.fornitura,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceWhereInput,
      Iterable<_i2.FornituraLuceWhereInput>>? AND;

  final Iterable<_i2.FornituraLuceWhereInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraLuceWhereInput,
      Iterable<_i2.FornituraLuceWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? pod;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraUuid;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? tensione;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceNullableRelationFilter,
          _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput, _i1.PrismaNull>>?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i1.PrismaUnion<_i2.FornituraRelationFilter, _i2.FornituraWhereInput>?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.FornituraLuceWhereInput? $is;

  final _i2.FornituraLuceWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ContrattoEnelLuceWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereInput,
      Iterable<_i2.ContrattoEnelLuceWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelLuceWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereInput,
      Iterable<_i2.ContrattoEnelLuceWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraLuceUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.FornituraLuceRelationFilter,
      _i2.FornituraLuceWhereInput>? fornituraLuce;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ContrattoEnelLuceWhereInput? every;

  final _i2.ContrattoEnelLuceWhereInput? some;

  final _i2.ContrattoEnelLuceWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class PraticaNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.PraticaWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.PraticaWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ModuloContrattoNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ContrattoWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1
      .PrismaUnion<_i2.ContrattoWhereInput, Iterable<_i2.ContrattoWhereInput>>?
      AND;

  final Iterable<_i2.ContrattoWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ContrattoWhereInput, Iterable<_i2.ContrattoWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketingEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketingGruppoEnel;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? profilazioneEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? bollettaWeb;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? rid;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataCessazione;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      mesiDurata;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i1.PrismaUnion<_i2.PraticaNullableRelationFilter,
      _i1.PrismaUnion<_i2.PraticaWhereInput, _i1.PrismaNull>>? pratica;

  final _i1.PrismaUnion<_i2.ModuloContrattoNullableRelationFilter,
      _i1.PrismaUnion<_i2.ModuloContrattoWhereInput, _i1.PrismaNull>>? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ContrattoWhereInput? every;

  final _i2.ContrattoWhereInput? some;

  final _i2.ContrattoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class StatoContrattoWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoWhereInput,
      Iterable<_i2.StatoContrattoWhereInput>>? AND;

  final Iterable<_i2.StatoContrattoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereInput,
      Iterable<_i2.StatoContrattoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i2.StatoContrattoWhereInput? $is;

  final _i2.StatoContrattoWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class ContrattoEnelXAssicurazioneWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.domicilio,
    this.offerta,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelXAssicurazioneWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.DomicilioRelationFilter, _i2.DomicilioWhereInput>?
      domicilio;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereInput? every;

  final _i2.ContrattoEnelXAssicurazioneWhereInput? some;

  final _i2.ContrattoEnelXAssicurazioneWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class DomicilioWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1
      .PrismaUnion<_i2.DomicilioWhereInput, Iterable<_i2.DomicilioWhereInput>>?
      AND;

  final Iterable<_i2.DomicilioWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.DomicilioWhereInput, Iterable<_i2.DomicilioWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  final _i2.FornituraListRelationFilter? forniture;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.OrdineListRelationFilter? prodottiOrdinati;

  final _i2.LeadListRelationFilter? leads;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.DomicilioWhereInput? every;

  final _i2.DomicilioWhereInput? some;

  final _i2.DomicilioWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class IndirizzoEmailListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.IndirizzoEmailWhereInput? every;

  final _i2.IndirizzoEmailWhereInput? some;

  final _i2.IndirizzoEmailWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class NumeroTelefonoListRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  final _i2.NumeroTelefonoWhereInput? every;

  final _i2.NumeroTelefonoWhereInput? some;

  final _i2.NumeroTelefonoWhereInput? none;

  @override
  Map<String, dynamic> toJson() => {
        'every': every,
        'some': some,
        'none': none,
      };
}

class PrivacyWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.soggetto,
  });

  final _i1.PrismaUnion<_i2.PrivacyWhereInput, Iterable<_i2.PrivacyWhereInput>>?
      AND;

  final Iterable<_i2.PrivacyWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PrivacyWhereInput, Iterable<_i2.PrivacyWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? trattamento;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? comunicazione;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? profilazione;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
      };
}

class PrivacyNullableRelationFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyNullableRelationFilter({
    this.$is,
    this.isNot,
  });

  final _i1.PrismaUnion<_i2.PrivacyWhereInput, _i1.PrismaNull>? $is;

  final _i1.PrismaUnion<_i2.PrivacyWhereInput, _i1.PrismaNull>? isNot;

  @override
  Map<String, dynamic> toJson() => {
        'is': $is,
        'isNot': isNot,
      };
}

class SoggettoWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1
      .PrismaUnion<_i2.SoggettoWhereInput, Iterable<_i2.SoggettoWhereInput>>?
      AND;

  final Iterable<_i2.SoggettoWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.SoggettoWhereInput, Iterable<_i2.SoggettoWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? ragioneSociale;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i2.EnumTipoSoggettoFilter, _i3.TipoSoggetto>? tipo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoNullableRelationFilter,
          _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput, _i1.PrismaNull>>?
      soggettoBusinessInfo;

  final _i2.DomicilioListRelationFilter? domicili;

  final _i2.PraticaListRelationFilter? praticheIntestate;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.IndirizzoEmailListRelationFilter? indirizziEmail;

  final _i2.NumeroTelefonoListRelationFilter? numeriTelefono;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozioPreferito;

  final _i2.OrdineListRelationFilter? prodottiOrdinati;

  final _i2.LeadListRelationFilter? leads;

  final _i1.PrismaUnion<_i2.PrivacyNullableRelationFilter,
      _i1.PrismaUnion<_i2.PrivacyWhereInput, _i1.PrismaNull>>? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoWhereUniqueInput({
    this.uuid,
    this.codiceFiscale,
    this.AND,
    this.OR,
    this.NOT,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String? codiceFiscale;

  final _i1
      .PrismaUnion<_i2.SoggettoWhereInput, Iterable<_i2.SoggettoWhereInput>>?
      AND;

  final Iterable<_i2.SoggettoWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.SoggettoWhereInput, Iterable<_i2.SoggettoWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? ragioneSociale;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i2.EnumTipoSoggettoFilter, _i3.TipoSoggetto>? tipo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoNullableRelationFilter,
          _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput, _i1.PrismaNull>>?
      soggettoBusinessInfo;

  final _i2.DomicilioListRelationFilter? domicili;

  final _i2.PraticaListRelationFilter? praticheIntestate;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.IndirizzoEmailListRelationFilter? indirizziEmail;

  final _i2.NumeroTelefonoListRelationFilter? numeriTelefono;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozioPreferito;

  final _i2.OrdineListRelationFilter? prodottiOrdinati;

  final _i2.LeadListRelationFilter? leads;

  final _i1.PrismaUnion<_i2.PrivacyNullableRelationFilter,
      _i1.PrismaUnion<_i2.PrivacyWhereInput, _i1.PrismaNull>>? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codiceFiscale': codiceFiscale,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class NumeroTelefonoSoggettoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoSoggettoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.SoggettoWhereInput? where;

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class NumeroTelefonoLegaleRappresentateArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoLegaleRappresentateArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.LegaleRappresentanteWhereInput? where;

  final _i2.LegaleRappresentanteSelect? select;

  final _i2.LegaleRappresentanteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ReferenteNumeroTelefonoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteNumeroTelefonoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NumeroTelefonoWhereInput? where;

  final _i2.NumeroTelefonoSelect? select;

  final _i2.NumeroTelefonoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class IndirizzoEmailSoggettoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailSoggettoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.SoggettoWhereInput? where;

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class IndirizzoEmailReferenteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailReferenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ReferenteWhereInput? where;

  final _i2.ReferenteSelect? select;

  final _i2.ReferenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class IndirizzoEmailLegaleRappresentanteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailLegaleRappresentanteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.LegaleRappresentanteWhereInput? where;

  final _i2.LegaleRappresentanteSelect? select;

  final _i2.LegaleRappresentanteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class IndirizzoEmailInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailInclude({
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
  });

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailReferenteArgs>? referente;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailLegaleRappresentanteArgs>?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class ReferenteIndirizzoEmailArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteIndirizzoEmailArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.IndirizzoEmailWhereInput? where;

  final _i2.IndirizzoEmailSelect? select;

  final _i2.IndirizzoEmailInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ReferenteSoggettoBusinessInfoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteSoggettoBusinessInfoArgs({
    this.select,
    this.include,
  });

  final _i2.SoggettoBusinessInfoSelect? select;

  final _i2.SoggettoBusinessInfoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ReferenteInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteInclude({
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<bool, _i2.ReferenteNumeroTelefonoArgs>? numeroTelefono;

  final _i1.PrismaUnion<bool, _i2.ReferenteIndirizzoEmailArgs>? indirizzoEmail;

  final _i1.PrismaUnion<bool, _i2.ReferenteSoggettoBusinessInfoArgs>?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class IndirizzoEmailSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailSelect({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
  });

  final bool? uuid;

  final bool? indirizzo;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentanteUuid;

  final bool? referenteUuid;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailReferenteArgs>? referente;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailLegaleRappresentanteArgs>?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class ReferenteSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  final _i1.PrismaUnion<bool, _i2.ReferenteNumeroTelefonoArgs>? numeroTelefono;

  final _i1.PrismaUnion<bool, _i2.ReferenteIndirizzoEmailArgs>? indirizzoEmail;

  final _i1.PrismaUnion<bool, _i2.ReferenteSoggettoBusinessInfoArgs>?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class NumeroTelefonoReferenteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoReferenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ReferenteWhereInput? where;

  final _i2.ReferenteSelect? select;

  final _i2.ReferenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class NumeroTelefonoInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoInclude({
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
  });

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoLegaleRappresentateArgs>?
      legaleRappresentate;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoReferenteArgs>? referente;

  @override
  Map<String, dynamic> toJson() => {
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class LegaleRappresentanteNumeroTelefonoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteNumeroTelefonoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NumeroTelefonoWhereInput? where;

  final _i2.NumeroTelefonoSelect? select;

  final _i2.NumeroTelefonoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class LegaleRappresentanteIndirizzoEmailArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteIndirizzoEmailArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.IndirizzoEmailWhereInput? where;

  final _i2.IndirizzoEmailSelect? select;

  final _i2.IndirizzoEmailInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class LegaleRappresentanteSoggettoBusinessInfoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteSoggettoBusinessInfoArgs({
    this.select,
    this.include,
  });

  final _i2.SoggettoBusinessInfoSelect? select;

  final _i2.SoggettoBusinessInfoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class LegaleRappresentanteInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteInclude({
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteNumeroTelefonoArgs>?
      numeroTelefono;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteIndirizzoEmailArgs>?
      indirizzoEmail;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteSoggettoBusinessInfoArgs>?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class SoggettoBusinessInfoLegaleRappresentanteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoLegaleRappresentanteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.LegaleRappresentanteWhereInput? where;

  final _i2.LegaleRappresentanteSelect? select;

  final _i2.LegaleRappresentanteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class SoggettoBusinessInfoReferenteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoReferenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ReferenteWhereInput? where;

  final _i2.ReferenteSelect? select;

  final _i2.ReferenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class SoggettoBusinessInfoSoggettoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoSoggettoArgs({
    this.select,
    this.include,
  });

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class SoggettoBusinessInfoInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoInclude({
    this.legaleRappresentante,
    this.referente,
    this.soggetto,
  });

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoLegaleRappresentanteArgs>?
      legaleRappresentante;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoReferenteArgs>? referente;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoSoggettoArgs>? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoSoggettoBusinessInfoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoSoggettoBusinessInfoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.SoggettoBusinessInfoWhereInput? where;

  final _i2.SoggettoBusinessInfoSelect? select;

  final _i2.SoggettoBusinessInfoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class DomicilioSoggettoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioSoggettoArgs({
    this.select,
    this.include,
  });

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelLuceStatoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceStatoArgs({
    this.select,
    this.include,
  });

  final _i2.StatoContrattoSelect? select;

  final _i2.StatoContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ConsumoAnnuoLuceFornituraLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceFornituraLuceArgs({
    this.select,
    this.include,
  });

  final _i2.FornituraLuceSelect? select;

  final _i2.FornituraLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ConsumoAnnuoLuceInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceInclude({this.fornituraLuce});

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceFornituraLuceArgs>?
      fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {'fornituraLuce': fornituraLuce};
}

class FornituraLuceConsumoAnnuoLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceConsumoAnnuoLuceArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ConsumoAnnuoLuceWhereInput? where;

  final _i2.ConsumoAnnuoLuceSelect? select;

  final _i2.ConsumoAnnuoLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

enum SortOrder implements _i1.PrismaEnum {
  asc._('asc'),
  desc._('desc');

  const SortOrder._(this.name);

  @override
  final String name;
}

enum NullsOrder implements _i1.PrismaEnum {
  first._('first'),
  last._('last');

  const NullsOrder._(this.name);

  @override
  final String name;
}

class SortOrderInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SortOrderInput({
    required this.sort,
    this.nulls,
  });

  final _i2.SortOrder sort;

  final _i2.NullsOrder? nulls;

  @override
  Map<String, dynamic> toJson() => {
        'sort': sort,
        'nulls': nulls,
      };
}

class ContrattoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ServizioEwoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ContrattoEnelLuceOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ContrattoEnelGasOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ContrattoEnelFibraOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ContrattoEnelXAssicurazioneOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum StatoContrattoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const StatoContrattoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class StatoContrattoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoOrderByRelevanceFieldEnum,
      Iterable<_i2.StatoContrattoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class StatoContrattoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ContrattoOrderByRelationAggregateInput? contratti;

  final _i2.ServizioEwoOrderByRelationAggregateInput? serviziEwo;

  final _i2.ContrattoEnelLuceOrderByRelationAggregateInput? contrattiEnelLuce;

  final _i2.ContrattoEnelGasOrderByRelationAggregateInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraOrderByRelationAggregateInput? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneOrderByRelationAggregateInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        '_relevance': $relevance,
      };
}

enum ConsumoAnnuoLuceOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  fornituraLuceUuid._('fornituraLuceUuid');

  const ConsumoAnnuoLuceOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ConsumoAnnuoLuceOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceOrderByRelevanceFieldEnum,
      Iterable<_i2.ConsumoAnnuoLuceOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ConsumoAnnuoLuceOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.fornituraLuce,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.FornituraLuceOrderByWithRelationAndSearchRelevanceInput?
      fornituraLuce;

  final _i2.ConsumoAnnuoLuceOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
        'fornituraLuce': fornituraLuce,
        '_relevance': $relevance,
      };
}

enum IndirizzoEmailOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  indirizzo._('indirizzo'),
  etichetta._('etichetta'),
  soggettoUuid._('soggettoUuid'),
  legaleRappresentanteUuid._('legaleRappresentanteUuid'),
  referenteUuid._('referenteUuid');

  const IndirizzoEmailOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class IndirizzoEmailOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailOrderByRelevanceFieldEnum,
      Iterable<_i2.IndirizzoEmailOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class IndirizzoEmailOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? indirizzo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      legaleRappresentanteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? referenteUuid;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.ReferenteOrderByWithRelationAndSearchRelevanceInput? referente;

  final _i2.LegaleRappresentanteOrderByWithRelationAndSearchRelevanceInput?
      legaleRappresentante;

  final _i2.IndirizzoEmailOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
        '_relevance': $relevance,
      };
}

enum ReferenteOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  nome._('nome'),
  cognome._('cognome'),
  soggettoBusinessInfoUuid._('soggettoBusinessInfoUuid');

  const ReferenteOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ReferenteOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ReferenteOrderByRelevanceFieldEnum,
      Iterable<_i2.ReferenteOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ReferenteOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  final _i2.NumeroTelefonoOrderByWithRelationAndSearchRelevanceInput?
      numeroTelefono;

  final _i2.IndirizzoEmailOrderByWithRelationAndSearchRelevanceInput?
      indirizzoEmail;

  final _i2.SoggettoBusinessInfoOrderByWithRelationAndSearchRelevanceInput?
      soggettoBusinessInfo;

  final _i2.ReferenteOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        '_relevance': $relevance,
      };
}

enum NumeroTelefonoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  numero._('numero'),
  etichetta._('etichetta'),
  soggettoUuid._('soggettoUuid'),
  legaleRappresentateUuid._('legaleRappresentateUuid'),
  referenteUuid._('referenteUuid');

  const NumeroTelefonoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class NumeroTelefonoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoOrderByRelevanceFieldEnum,
      Iterable<_i2.NumeroTelefonoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class NumeroTelefonoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? numero;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      legaleRappresentateUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? referenteUuid;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.LegaleRappresentanteOrderByWithRelationAndSearchRelevanceInput?
      legaleRappresentate;

  final _i2.ReferenteOrderByWithRelationAndSearchRelevanceInput? referente;

  final _i2.NumeroTelefonoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
        '_relevance': $relevance,
      };
}

enum LegaleRappresentanteOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  nome._('nome'),
  cognome._('cognome'),
  soggettoBusinessInfoUuid._('soggettoBusinessInfoUuid');

  const LegaleRappresentanteOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class LegaleRappresentanteOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.LegaleRappresentanteOrderByRelevanceFieldEnum,
      Iterable<_i2.LegaleRappresentanteOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class LegaleRappresentanteOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  final _i2.NumeroTelefonoOrderByWithRelationAndSearchRelevanceInput?
      numeroTelefono;

  final _i2.IndirizzoEmailOrderByWithRelationAndSearchRelevanceInput?
      indirizzoEmail;

  final _i2.SoggettoBusinessInfoOrderByWithRelationAndSearchRelevanceInput?
      soggettoBusinessInfo;

  final _i2.LegaleRappresentanteOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        '_relevance': $relevance,
      };
}

enum SoggettoBusinessInfoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  rea._('rea'),
  partitaIVA._('partitaIVA'),
  sdi._('sdi'),
  soggettoUuid._('soggettoUuid');

  const SoggettoBusinessInfoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class SoggettoBusinessInfoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoOrderByRelevanceFieldEnum,
      Iterable<_i2.SoggettoBusinessInfoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class SoggettoBusinessInfoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.legaleRappresentante,
    this.referente,
    this.soggetto,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rea;

  final _i2.SortOrder? partitaIVA;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sdi;

  final _i2.SortOrder? soggettoUuid;

  final _i2.LegaleRappresentanteOrderByWithRelationAndSearchRelevanceInput?
      legaleRappresentante;

  final _i2.ReferenteOrderByWithRelationAndSearchRelevanceInput? referente;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.SoggettoBusinessInfoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
        '_relevance': $relevance,
      };
}

class DomicilioOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class PraticaOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class IndirizzoEmailOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class NumeroTelefonoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class UtenteOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class SoggettoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class NegozioOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum ZonaNegozioOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const ZonaNegozioOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ZonaNegozioOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ZonaNegozioOrderByRelevanceFieldEnum,
      Iterable<_i2.ZonaNegozioOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ZonaNegozioOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.negozi,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.NegozioOrderByRelationAggregateInput? negozi;

  final _i2.ZonaNegozioOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'negozi': negozi,
        '_relevance': $relevance,
      };
}

class IngressiOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class LeadOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class OrdineOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum NegozioOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  codice._('codice'),
  nome._('nome'),
  zonaNegozioId._('zonaNegozioId');

  const NegozioOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class NegozioOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.NegozioOrderByRelevanceFieldEnum,
      Iterable<_i2.NegozioOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class NegozioOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioOrderByWithRelationAndSearchRelevanceInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
    this.$relevance,
  });

  final _i2.SortOrder? codice;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? zonaNegozioId;

  final _i2.PraticaOrderByRelationAggregateInput? pratiche;

  final _i2.UtenteOrderByRelationAggregateInput? utenti;

  final _i2.ContrattoOrderByRelationAggregateInput? contratti;

  final _i2.SoggettoOrderByRelationAggregateInput? soggetti;

  final _i2.ZonaNegozioOrderByWithRelationAndSearchRelevanceInput? zonaNegozio;

  final _i2.IngressiOrderByRelationAggregateInput? ingressi;

  final _i2.LeadOrderByRelationAggregateInput? leads;

  final _i2.OrdineOrderByRelationAggregateInput? ordine;

  final _i2.NegozioOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
        '_relevance': $relevance,
      };
}

enum PrivacyOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  soggettoUuid._('soggettoUuid');

  const PrivacyOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class PrivacyOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.PrivacyOrderByRelevanceFieldEnum,
      Iterable<_i2.PrivacyOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class PrivacyOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.soggetto,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? trattamento;

  final _i2.SortOrder? comunicazione;

  final _i2.SortOrder? profilazione;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.PrivacyOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        '_relevance': $relevance,
      };
}

enum SoggettoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  ragioneSociale._('ragioneSociale'),
  iban._('iban'),
  negozioPreferitoUuid._('negozioPreferitoUuid'),
  codiceFiscale._('codiceFiscale'),
  note._('note');

  const SoggettoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class SoggettoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.SoggettoOrderByRelevanceFieldEnum,
      Iterable<_i2.SoggettoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class SoggettoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? ragioneSociale;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? iban;

  final _i2.SortOrder? tipo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      negozioPreferitoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? codiceFiscale;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? note;

  final _i2.SoggettoBusinessInfoOrderByWithRelationAndSearchRelevanceInput?
      soggettoBusinessInfo;

  final _i2.DomicilioOrderByRelationAggregateInput? domicili;

  final _i2.PraticaOrderByRelationAggregateInput? praticheIntestate;

  final _i2.ContrattoOrderByRelationAggregateInput? contratti;

  final _i2.IndirizzoEmailOrderByRelationAggregateInput? indirizziEmail;

  final _i2.NumeroTelefonoOrderByRelationAggregateInput? numeriTelefono;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozioPreferito;

  final _i2.OrdineOrderByRelationAggregateInput? prodottiOrdinati;

  final _i2.LeadOrderByRelationAggregateInput? leads;

  final _i2.PrivacyOrderByWithRelationAndSearchRelevanceInput? privacy;

  final _i2.SoggettoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
        '_relevance': $relevance,
      };
}

class FornituraOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum DomicilioOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  etichetta._('etichetta'),
  indirizzo._('indirizzo'),
  numeroCivico._('numeroCivico'),
  citta._('citta'),
  cap._('cap'),
  provincia._('provincia'),
  soggettoUuid._('soggettoUuid');

  const DomicilioOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class DomicilioOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.DomicilioOrderByRelevanceFieldEnum,
      Iterable<_i2.DomicilioOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class DomicilioOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? indirizzo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? numeroCivico;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? citta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? cap;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? provincia;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.ContrattoEnelXAssicurazioneOrderByRelationAggregateInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraOrderByRelationAggregateInput? forniture;

  final _i2.ContrattoEnelFibraOrderByRelationAggregateInput? contrattiEnelFibra;

  final _i2.OrdineOrderByRelationAggregateInput? prodottiOrdinati;

  final _i2.LeadOrderByRelationAggregateInput? leads;

  final _i2.DomicilioOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        '_relevance': $relevance,
      };
}

class ModuloContrattoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class ProdottoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum FornitoreOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const FornitoreOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class FornitoreOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.FornitoreOrderByRelevanceFieldEnum,
      Iterable<_i2.FornitoreOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class FornitoreOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ServizioEwoOrderByRelationAggregateInput? serviziEwo;

  final _i2.ModuloContrattoOrderByRelationAggregateInput? moduliContratto;

  final _i2.ProdottoOrderByRelationAggregateInput? prodotti;

  final _i2.FornitoreOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
        '_relevance': $relevance,
      };
}

class TipoPraticaOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class StatoPraticaOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class StatoContrattoOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class OffertaOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum ServizioEwoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome'),
  fornitoreId._('fornitoreId'),
  colore._('colore'),
  icona._('icona');

  const ServizioEwoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ServizioEwoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoOrderByRelevanceFieldEnum,
      Iterable<_i2.ServizioEwoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ServizioEwoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoServizioEwo;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? icona;

  final _i2.FornitoreOrderByWithRelationAndSearchRelevanceInput? fornitore;

  final _i2.TipoPraticaOrderByRelationAggregateInput? tipiPratiche;

  final _i2.FornituraOrderByRelationAggregateInput? forniture;

  final _i2.StatoPraticaOrderByRelationAggregateInput? statiPossibiliPratiche;

  final _i2.StatoContrattoOrderByRelationAggregateInput?
      statiPossibiliContratti;

  final _i2.OffertaOrderByRelationAggregateInput? offerte;

  final _i2.ModuloContrattoOrderByRelationAggregateInput? moduliContratto;

  final _i2.ServizioEwoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
        '_relevance': $relevance,
      };
}

class FornituraGasOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum ClasseMisuratoreGasOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  classe._('classe');

  const ClasseMisuratoreGasOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ClasseMisuratoreGasOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasOrderByRelevanceFieldEnum,
      Iterable<_i2.ClasseMisuratoreGasOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ClasseMisuratoreGasOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasOrderByWithRelationAndSearchRelevanceInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.fornituraGas,
    this.$relevance,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  final _i2.SortOrder? id;

  final _i2.SortOrder? classe;

  final _i2.FornituraGasOrderByRelationAggregateInput? fornituraGas;

  final _i2.ClasseMisuratoreGasOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
        '_relevance': $relevance,
      };
}

enum ConsumoAnnuoGasOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  fornituraGasUuid._('fornituraGasUuid');

  const ConsumoAnnuoGasOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ConsumoAnnuoGasOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasOrderByRelevanceFieldEnum,
      Iterable<_i2.ConsumoAnnuoGasOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ConsumoAnnuoGasOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.fornituraGas,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.FornituraGasOrderByWithRelationAndSearchRelevanceInput?
      fornituraGas;

  final _i2.ConsumoAnnuoGasOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
        'fornituraGas': fornituraGas,
        '_relevance': $relevance,
      };
}

enum FornituraGasOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  pdr._('pdr'),
  fornituraUuid._('fornituraUuid'),
  classeMisuratoreGasId._('classeMisuratoreGasId'),
  matricolaContatore._('matricolaContatore'),
  remi._('remi');

  const FornituraGasOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class FornituraGasOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.FornituraGasOrderByRelevanceFieldEnum,
      Iterable<_i2.FornituraGasOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class FornituraGasOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pdr;

  final _i2.SortOrder? fornituraUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      classeMisuratoreGasId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? matricolaContatore;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? remi;

  final _i2.ClasseMisuratoreGasOrderByWithRelationAndSearchRelevanceInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasOrderByWithRelationAndSearchRelevanceInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasOrderByRelationAggregateInput? contrattiEnelGas;

  final _i2.FornituraOrderByWithRelationAndSearchRelevanceInput? fornitura;

  final _i2.FornituraGasOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
        '_relevance': $relevance,
      };
}

enum FornituraOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  etichetta._('etichetta'),
  domicilioUuid._('domicilioUuid'),
  servizioEwoId._('servizioEwoId');

  const FornituraOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class FornituraOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.FornituraOrderByRelevanceFieldEnum,
      Iterable<_i2.FornituraOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class FornituraOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? servizioEwoId;

  final _i2.DomicilioOrderByWithRelationAndSearchRelevanceInput? domicilio;

  final _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput? servizioEwo;

  final _i2.FornituraLuceOrderByWithRelationAndSearchRelevanceInput?
      fornituraLuce;

  final _i2.FornituraGasOrderByWithRelationAndSearchRelevanceInput?
      fornituraGas;

  final _i2.FornituraOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
        '_relevance': $relevance,
      };
}

enum FornituraLuceOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  pod._('pod'),
  fornituraUuid._('fornituraUuid');

  const FornituraLuceOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class FornituraLuceOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceOrderByRelevanceFieldEnum,
      Iterable<_i2.FornituraLuceOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class FornituraLuceOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    this.fornitura,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pod;

  final _i2.SortOrder? fornituraUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? potenza;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tensione;

  final _i2.ConsumoAnnuoLuceOrderByWithRelationAndSearchRelevanceInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceOrderByRelationAggregateInput? contrattiEnelLuce;

  final _i2.FornituraOrderByWithRelationAndSearchRelevanceInput? fornitura;

  final _i2.FornituraLuceOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
        '_relevance': $relevance,
      };
}

class OpportunitaOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

class HistoryOrderByRelationAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryOrderByRelationAggregateInput({this.$count});

  final _i2.SortOrder? $count;

  @override
  Map<String, dynamic> toJson() => {'_count': $count};
}

enum UtenteOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  firebaseUid._('firebaseUid'),
  email._('email'),
  photoUrl._('photoUrl'),
  negozioCodice._('negozioCodice'),
  nomeVisualizzato._('nomeVisualizzato');

  const UtenteOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class UtenteOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.UtenteOrderByRelevanceFieldEnum,
      Iterable<_i2.UtenteOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class UtenteOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? firebaseUid;

  final _i2.SortOrder? email;

  final _i2.SortOrder? ruolo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? photoUrl;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i2.SortOrder? nomeVisualizzato;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozio;

  final _i2.ContrattoOrderByRelationAggregateInput? contratti;

  final _i2.PraticaOrderByRelationAggregateInput? pratiche;

  final _i2.IngressiOrderByRelationAggregateInput? ingressi;

  final _i2.LeadOrderByRelationAggregateInput? leadsGestiti;

  final _i2.LeadOrderByRelationAggregateInput? leadsAssegnati;

  final _i2.OpportunitaOrderByRelationAggregateInput? opportunitaGestite;

  final _i2.OpportunitaOrderByRelationAggregateInput? opportunitaAssegnate;

  final _i2.OrdineOrderByRelationAggregateInput? ordini;

  final _i2.HistoryOrderByRelationAggregateInput? history;

  final _i2.UtenteOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
        '_relevance': $relevance,
      };
}

enum TipoPraticaOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const TipoPraticaOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class TipoPraticaOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaOrderByRelevanceFieldEnum,
      Iterable<_i2.TipoPraticaOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class TipoPraticaOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.pratiche,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ServizioEwoOrderByRelationAggregateInput? serviziEwo;

  final _i2.PraticaOrderByRelationAggregateInput? pratiche;

  final _i2.TipoPraticaOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
        '_relevance': $relevance,
      };
}

enum StatoPraticaOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const StatoPraticaOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class StatoPraticaOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaOrderByRelevanceFieldEnum,
      Iterable<_i2.StatoPraticaOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class StatoPraticaOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.pratiche,
    this.serviziEwo,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.PraticaOrderByRelationAggregateInput? pratiche;

  final _i2.ServizioEwoOrderByRelationAggregateInput? serviziEwo;

  final _i2.StatoPraticaOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
        '_relevance': $relevance,
      };
}

enum PraticaOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  codice._('codice'),
  tipoPraticaId._('tipoPraticaId'),
  soggettoUuid._('soggettoUuid'),
  utenteUuid._('utenteUuid'),
  negozioCodice._('negozioCodice'),
  statoPraticaId._('statoPraticaId');

  const PraticaOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class PraticaOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.PraticaOrderByRelevanceFieldEnum,
      Iterable<_i2.PraticaOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class PraticaOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? tipoPraticaId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? statoPraticaId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      ultimoAggiornamentoStato;

  final _i2.TipoPraticaOrderByWithRelationAndSearchRelevanceInput? tipoPratica;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? utente;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozio;

  final _i2.StatoPraticaOrderByWithRelationAndSearchRelevanceInput? stato;

  final _i2.ContrattoOrderByRelationAggregateInput? contratto;

  final _i2.PraticaOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
        '_relevance': $relevance,
      };
}

enum TipoModuloContrattoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const TipoModuloContrattoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class TipoModuloContrattoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.TipoModuloContrattoOrderByRelevanceFieldEnum,
      Iterable<_i2.TipoModuloContrattoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class TipoModuloContrattoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.moduloContratto,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? numeroOfferteCollegabili;

  final _i2.ModuloContrattoOrderByRelationAggregateInput? moduloContratto;

  final _i2.TipoModuloContrattoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
        '_relevance': $relevance,
      };
}

enum ModuloContrattoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome'),
  fornitoreId._('fornitoreId'),
  tipoModuloContrattoId._('tipoModuloContrattoId');

  const ModuloContrattoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ModuloContrattoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoOrderByRelevanceFieldEnum,
      Iterable<_i2.ModuloContrattoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ModuloContrattoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? clienteTarget;

  final _i2.SortOrder? canale;

  final _i2.SortOrder? tipoModuloContrattoId;

  final _i2.ServizioEwoOrderByRelationAggregateInput? serviziEwoCollegabili;

  final _i2.ContrattoOrderByRelationAggregateInput? contratti;

  final _i2.FornitoreOrderByWithRelationAndSearchRelevanceInput? fornitore;

  final _i2.TipoModuloContrattoOrderByWithRelationAndSearchRelevanceInput?
      tipoModulo;

  final _i2.ModuloContrattoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
        '_relevance': $relevance,
      };
}

enum ContrattoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  codice._('codice'),
  nota._('nota'),
  offertaUuid._('offertaUuid'),
  statoContrattoId._('statoContrattoId'),
  soggettoUuid._('soggettoUuid'),
  utenteUuid._('utenteUuid'),
  negozioCodice._('negozioCodice'),
  praticaUuid._('praticaUuid'),
  moduloContrattoId._('moduloContrattoId');

  const ContrattoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ContrattoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ContrattoOrderByRelevanceFieldEnum,
      Iterable<_i2.ContrattoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ContrattoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataAttivazione;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      ultimoAggiornamentoStato;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? trend;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? nota;

  final _i2.SortOrder? marketingEnelEnergia;

  final _i2.SortOrder? marketingGruppoEnel;

  final _i2.SortOrder? profilazioneEnelEnergia;

  final _i2.SortOrder? bollettaWeb;

  final _i2.SortOrder? rid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataCessazione;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? mesiDurata;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.SortOrder? statoContrattoId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? praticaUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduloContrattoId;

  final _i2.ContrattoEnelLuceOrderByRelationAggregateInput? contrattiEnelLuce;

  final _i2.ContrattoEnelGasOrderByRelationAggregateInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraOrderByRelationAggregateInput? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneOrderByRelationAggregateInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput? stato;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? utente;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozio;

  final _i2.PraticaOrderByWithRelationAndSearchRelevanceInput? pratica;

  final _i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput? modulo;

  final _i2.ContrattoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
        '_relevance': $relevance,
      };
}

enum OffertaOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  nome._('nome'),
  servizioEwoId._('servizioEwoId');

  const OffertaOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class OffertaOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.OffertaOrderByRelevanceFieldEnum,
      Iterable<_i2.OffertaOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class OffertaOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataFineOfferta;

  final _i2.SortOrder? dataInizioOfferta;

  final _i2.SortOrder? servizioEwoId;

  final _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput? servizioEwo;

  final _i2.ContrattoEnelLuceOrderByRelationAggregateInput? contrattiEnelLuce;

  final _i2.ContrattoEnelGasOrderByRelationAggregateInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraOrderByRelationAggregateInput? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneOrderByRelationAggregateInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaOrderByRelationAggregateInput? offerteIncluse;

  final _i2.OffertaOrderByRelationAggregateInput? inclusaInOfferte;

  final _i2.OffertaOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
        '_relevance': $relevance,
      };
}

enum ContrattoEnelLuceOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  statoContrattoId._('statoContrattoId'),
  fornituraLuceUuid._('fornituraLuceUuid'),
  contrattoUuid._('contrattoUuid'),
  offertaUuid._('offertaUuid');

  const ContrattoEnelLuceOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ContrattoEnelLuceOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceOrderByRelevanceFieldEnum,
      Iterable<_i2.ContrattoEnelLuceOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput? stato;

  final _i2.FornituraLuceOrderByWithRelationAndSearchRelevanceInput?
      fornituraLuce;

  final _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput? contratto;

  final _i2.OffertaOrderByWithRelationAndSearchRelevanceInput? offerta;

  final _i2.ContrattoEnelLuceOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
        '_relevance': $relevance,
      };
}

class ContrattoEnelLuceWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereInput,
      Iterable<_i2.ContrattoEnelLuceWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelLuceWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereInput,
      Iterable<_i2.ContrattoEnelLuceWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraLuceUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.FornituraLuceRelationFilter,
      _i2.FornituraLuceWhereInput>? fornituraLuce;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

enum ContrattoEnelLuceScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'ContrattoEnelLuce'),
  statoContrattoId<String>('statoContrattoId', 'ContrattoEnelLuce'),
  fornituraLuceUuid<String>('fornituraLuceUuid', 'ContrattoEnelLuce'),
  contrattoUuid<String>('contrattoUuid', 'ContrattoEnelLuce'),
  offertaUuid<String>('offertaUuid', 'ContrattoEnelLuce');

  const ContrattoEnelLuceScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornituraLuceContrattiEnelLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceContrattiEnelLuceArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelLuceWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelLuceWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalar,
      Iterable<_i2.ContrattoEnelLuceScalar>>? distinct;

  final _i2.ContrattoEnelLuceSelect? select;

  final _i2.ContrattoEnelLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelXAssicurazioneStatoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneStatoArgs({
    this.select,
    this.include,
  });

  final _i2.StatoContrattoSelect? select;

  final _i2.StatoContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelXAssicurazioneContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneContrattoArgs({
    this.select,
    this.include,
  });

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelXAssicurazioneDomicilioArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneDomicilioArgs({
    this.select,
    this.include,
  });

  final _i2.DomicilioSelect? select;

  final _i2.DomicilioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ServizioEwoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String? id;

  final String? nome;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereInput,
      Iterable<_i2.ServizioEwoWhereInput>>? AND;

  final Iterable<_i2.ServizioEwoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereInput,
      Iterable<_i2.ServizioEwoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoServizioEwoFilter, _i3.TipoServizioEwo>?
      tipoServizioEwo;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? icona;

  final _i1.PrismaUnion<_i2.FornitoreRelationFilter, _i2.FornitoreWhereInput>?
      fornitore;

  final _i2.TipoPraticaListRelationFilter? tipiPratiche;

  final _i2.FornituraListRelationFilter? forniture;

  final _i2.StatoPraticaListRelationFilter? statiPossibiliPratiche;

  final _i2.StatoContrattoListRelationFilter? statiPossibiliContratti;

  final _i2.OffertaListRelationFilter? offerte;

  final _i2.ModuloContrattoListRelationFilter? moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

enum ServizioEwoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ServizioEwo'),
  nome<String>('nome', 'ServizioEwo'),
  fornitoreId<String>('fornitoreId', 'ServizioEwo'),
  tipoServizioEwo<_i3.TipoServizioEwo>('tipoServizioEwo', 'ServizioEwo'),
  colore<String>('colore', 'ServizioEwo'),
  icona<String>('icona', 'ServizioEwo');

  const ServizioEwoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornitoreServiziEwoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreServiziEwoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ServizioEwoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ServizioEwoScalar, Iterable<_i2.ServizioEwoScalar>>?
      distinct;

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ModuloContrattoServiziEwoCollegabiliArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoServiziEwoCollegabiliArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ServizioEwoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ServizioEwoScalar, Iterable<_i2.ServizioEwoScalar>>?
      distinct;

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoWhereUniqueInput({
    this.uuid,
    this.codice,
    this.AND,
    this.OR,
    this.NOT,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String? codice;

  final _i1
      .PrismaUnion<_i2.ContrattoWhereInput, Iterable<_i2.ContrattoWhereInput>>?
      AND;

  final Iterable<_i2.ContrattoWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ContrattoWhereInput, Iterable<_i2.ContrattoWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketingEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketingGruppoEnel;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? profilazioneEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? bollettaWeb;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? rid;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataCessazione;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      mesiDurata;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i1.PrismaUnion<_i2.PraticaNullableRelationFilter,
      _i1.PrismaUnion<_i2.PraticaWhereInput, _i1.PrismaNull>>? pratica;

  final _i1.PrismaUnion<_i2.ModuloContrattoNullableRelationFilter,
      _i1.PrismaUnion<_i2.ModuloContrattoWhereInput, _i1.PrismaNull>>? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

enum ContrattoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Contratto'),
  codice<String>('codice', 'Contratto'),
  dataInserimento<DateTime>('dataInserimento', 'Contratto'),
  dataAttivazione<DateTime>('dataAttivazione', 'Contratto'),
  ultimoAggiornamentoStato<DateTime>('ultimoAggiornamentoStato', 'Contratto'),
  trend<bool>('trend', 'Contratto'),
  nota<String>('nota', 'Contratto'),
  marketingEnelEnergia<bool>('marketingEnelEnergia', 'Contratto'),
  marketingGruppoEnel<bool>('marketingGruppoEnel', 'Contratto'),
  profilazioneEnelEnergia<bool>('profilazioneEnelEnergia', 'Contratto'),
  bollettaWeb<bool>('bollettaWeb', 'Contratto'),
  rid<bool>('rid', 'Contratto'),
  dataCessazione<DateTime>('dataCessazione', 'Contratto'),
  mesiDurata<int>('mesiDurata', 'Contratto'),
  offertaUuid<String>('offertaUuid', 'Contratto'),
  statoContrattoId<String>('statoContrattoId', 'Contratto'),
  soggettoUuid<String>('soggettoUuid', 'Contratto'),
  utenteUuid<String>('utenteUuid', 'Contratto'),
  negozioCodice<String>('negozioCodice', 'Contratto'),
  praticaUuid<String>('praticaUuid', 'Contratto'),
  moduloContrattoId<String>('moduloContrattoId', 'Contratto');

  const ContrattoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ModuloContrattoContrattiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoContrattiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoScalar, Iterable<_i2.ContrattoScalar>>?
      distinct;

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ModuloContrattoFornitoreArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoFornitoreArgs({
    this.select,
    this.include,
  });

  final _i2.FornitoreSelect? select;

  final _i2.FornitoreInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ModuloContrattoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
  });

  final String? id;

  final String? nome;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereInput,
      Iterable<_i2.ModuloContrattoWhereInput>>? AND;

  final Iterable<_i2.ModuloContrattoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereInput,
      Iterable<_i2.ModuloContrattoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoSoggettoFilter, _i3.TipoSoggetto>?
      clienteTarget;

  final _i1.PrismaUnion<_i2.EnumCanaleFilter, _i3.Canale>? canale;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoModuloContrattoId;

  final _i2.ServizioEwoListRelationFilter? serviziEwoCollegabili;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i1.PrismaUnion<_i2.FornitoreRelationFilter, _i2.FornitoreWhereInput>?
      fornitore;

  final _i1.PrismaUnion<_i2.TipoModuloContrattoRelationFilter,
      _i2.TipoModuloContrattoWhereInput>? tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

enum ModuloContrattoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ModuloContratto'),
  nome<String>('nome', 'ModuloContratto'),
  fornitoreId<String>('fornitoreId', 'ModuloContratto'),
  clienteTarget<_i3.TipoSoggetto>('clienteTarget', 'ModuloContratto'),
  canale<_i3.Canale>('canale', 'ModuloContratto'),
  tipoModuloContrattoId<String>('tipoModuloContrattoId', 'ModuloContratto');

  const ModuloContrattoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class TipoModuloContrattoModuloContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoModuloContrattoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ModuloContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ModuloContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalar,
      Iterable<_i2.ModuloContrattoScalar>>? distinct;

  final _i2.ModuloContrattoSelect? select;

  final _i2.ModuloContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class TipoModuloContrattoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCountOutputTypeSelect({this.moduloContratto});

  final bool? moduloContratto;

  @override
  Map<String, dynamic> toJson() => {'ModuloContratto': moduloContratto};
}

class TipoModuloContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCountArgs({this.select});

  final _i2.TipoModuloContrattoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoModuloContrattoInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoInclude({
    this.moduloContratto,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoModuloContrattoArgs>?
      moduloContratto;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'ModuloContratto': moduloContratto,
        '_count': $count,
      };
}

class ModuloContrattoTipoModuloArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoTipoModuloArgs({
    this.select,
    this.include,
  });

  final _i2.TipoModuloContrattoSelect? select;

  final _i2.TipoModuloContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ModuloContrattoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCountOutputTypeSelect({
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final bool? serviziEwoCollegabili;

  final bool? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCountArgs({this.select});

  final _i2.ModuloContrattoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModuloContrattoInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoInclude({
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoServiziEwoCollegabiliArgs>?
      serviziEwoCollegabili;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoFornitoreArgs>? fornitore;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoTipoModuloArgs>? tipoModulo;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
        '_count': $count,
      };
}

class TipoModuloContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoSelect({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.moduloContratto,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final bool? numeroOfferteCollegabili;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoModuloContrattoArgs>?
      moduloContratto;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
        '_count': $count,
      };
}

class ModuloContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? clienteTarget;

  final bool? canale;

  final bool? tipoModuloContrattoId;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoServiziEwoCollegabiliArgs>?
      serviziEwoCollegabili;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoFornitoreArgs>? fornitore;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoTipoModuloArgs>? tipoModulo;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
        '_count': $count,
      };
}

class FornitoreModuliContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreModuliContrattoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ModuloContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ModuloContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalar,
      Iterable<_i2.ModuloContrattoScalar>>? distinct;

  final _i2.ModuloContrattoSelect? select;

  final _i2.ModuloContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

enum ProduttoreOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const ProduttoreOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ProduttoreOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ProduttoreOrderByRelevanceFieldEnum,
      Iterable<_i2.ProduttoreOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ProduttoreOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.prodotti,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ProdottoOrderByRelationAggregateInput? prodotti;

  final _i2.ProduttoreOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
        '_relevance': $relevance,
      };
}

enum TipoProdottoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome');

  const TipoProdottoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class TipoProdottoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.TipoProdottoOrderByRelevanceFieldEnum,
      Iterable<_i2.TipoProdottoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class TipoProdottoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.prodotti,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ProdottoOrderByRelationAggregateInput? prodotti;

  final _i2.TipoProdottoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
        '_relevance': $relevance,
      };
}

enum ProdottoOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  modello._('modello'),
  produttoreId._('produttoreId'),
  fornitoreId._('fornitoreId'),
  tipoProdottoId._('tipoProdottoId');

  const ProdottoOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ProdottoOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ProdottoOrderByRelevanceFieldEnum,
      Iterable<_i2.ProdottoOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ProdottoOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? modello;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prezzo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendibileDal;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendibileAl;

  final _i2.SortOrder? produttoreId;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoProdottoId;

  final _i2.ProduttoreOrderByWithRelationAndSearchRelevanceInput? produttore;

  final _i2.OrdineOrderByRelationAggregateInput? prodottiOrdinati;

  final _i2.FornitoreOrderByWithRelationAndSearchRelevanceInput? fornitore;

  final _i2.TipoProdottoOrderByWithRelationAndSearchRelevanceInput?
      tipoProdotto;

  final _i2.ProdottoOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
        '_relevance': $relevance,
      };
}

class ProdottoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
  });

  final String? uuid;

  final _i1
      .PrismaUnion<_i2.ProdottoWhereInput, Iterable<_i2.ProdottoWhereInput>>?
      AND;

  final Iterable<_i2.ProdottoWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ProdottoWhereInput, Iterable<_i2.ProdottoWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? modello;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<_i2.StringFilter, String>? produttoreId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoProdottoId;

  final _i1.PrismaUnion<_i2.ProduttoreRelationFilter, _i2.ProduttoreWhereInput>?
      produttore;

  final _i2.OrdineListRelationFilter? prodottiOrdinati;

  final _i1.PrismaUnion<_i2.FornitoreRelationFilter, _i2.FornitoreWhereInput>?
      fornitore;

  final _i1
      .PrismaUnion<_i2.TipoProdottoRelationFilter, _i2.TipoProdottoWhereInput>?
      tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

enum ProdottoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Prodotto'),
  modello<String>('modello', 'Prodotto'),
  prezzo<double>('prezzo', 'Prodotto'),
  vendibileDal<DateTime>('vendibileDal', 'Prodotto'),
  vendibileAl<DateTime>('vendibileAl', 'Prodotto'),
  produttoreId<String>('produttoreId', 'Prodotto'),
  fornitoreId<String>('fornitoreId', 'Prodotto'),
  tipoProdottoId<String>('tipoProdottoId', 'Prodotto');

  const ProdottoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProduttoreProdottiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreProdottiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProdottoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ProdottoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProdottoScalar, Iterable<_i2.ProdottoScalar>>?
      distinct;

  final _i2.ProdottoSelect? select;

  final _i2.ProdottoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ProduttoreCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCountOutputTypeSelect({this.prodotti});

  final bool? prodotti;

  @override
  Map<String, dynamic> toJson() => {'prodotti': prodotti};
}

class ProduttoreCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCountArgs({this.select});

  final _i2.ProduttoreCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProduttoreInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreInclude({
    this.prodotti,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ProduttoreProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.ProduttoreCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'prodotti': prodotti,
        '_count': $count,
      };
}

class ProdottoProduttoreArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoProduttoreArgs({
    this.select,
    this.include,
  });

  final _i2.ProduttoreSelect? select;

  final _i2.ProduttoreInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrdineProdottiArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineProdottiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProdottoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ProdottoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProdottoScalar, Iterable<_i2.ProdottoScalar>>?
      distinct;

  final _i2.ProdottoSelect? select;

  final _i2.ProdottoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OrdineSoggettoArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineSoggettoArgs({
    this.select,
    this.include,
  });

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrdineDomicilioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineDomicilioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.DomicilioWhereInput? where;

  final _i2.DomicilioSelect? select;

  final _i2.DomicilioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

enum StatoOrdineOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  id._('id'),
  nome._('nome'),
  colore._('colore');

  const StatoOrdineOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class StatoOrdineOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineOrderByRelevanceFieldEnum,
      Iterable<_i2.StatoOrdineOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class StatoOrdineOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineOrderByWithRelationAndSearchRelevanceInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.ordini,
    this.$relevance,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  final _i2.OrdineOrderByRelationAggregateInput? ordini;

  final _i2.StatoOrdineOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
        '_relevance': $relevance,
      };
}

enum OpportunitaOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  nome._('nome'),
  form._('form');

  const OpportunitaOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class OpportunitaOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.OpportunitaOrderByRelevanceFieldEnum,
      Iterable<_i2.OpportunitaOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class OpportunitaOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataInizio;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataFine;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? form;

  final _i2.LeadOrderByRelationAggregateInput? leads;

  final _i2.UtenteOrderByRelationAggregateInput? gestoriLead;

  final _i2.UtenteOrderByRelationAggregateInput? agenti;

  final _i2.OpportunitaOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
        '_relevance': $relevance,
      };
}

enum StatoOpportunitaOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  nome._('nome'),
  colore._('colore'),
  opportunitaUuid._('opportunitaUuid');

  const StatoOpportunitaOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class StatoOpportunitaOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.StatoOpportunitaOrderByRelevanceFieldEnum,
      Iterable<_i2.StatoOpportunitaOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class StatoOpportunitaOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.leads,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tipoStato;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? ordine;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.LeadOrderByRelationAggregateInput? leads;

  final _i2.StatoOpportunitaOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
        '_relevance': $relevance,
      };
}

enum LeadOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  opportunitaUuid._('opportunitaUuid'),
  soggettoUuid._('soggettoUuid'),
  domicilioUuid._('domicilioUuid'),
  statoOpportunitaUuid._('statoOpportunitaUuid'),
  utenteUuid._('utenteUuid'),
  negozioCodice._('negozioCodice'),
  agenteUuid._('agenteUuid'),
  appuntamenti._('appuntamenti'),
  form._('form'),
  nota._('nota');

  const LeadOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class LeadOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.LeadOrderByRelevanceFieldEnum,
      Iterable<_i2.LeadOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class LeadOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.SortOrder? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? domicilioUuid;

  final _i2.SortOrder? statoOpportunitaUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? agenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? appuntamenti;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? form;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataInserimento;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataScadenza;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataAppuntamento;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? nota;

  final _i2.OpportunitaOrderByWithRelationAndSearchRelevanceInput? opportunita;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.DomicilioOrderByWithRelationAndSearchRelevanceInput? domicilio;

  final _i2.StatoOpportunitaOrderByWithRelationAndSearchRelevanceInput?
      statoOpportunita;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? utente;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozio;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? agente;

  final _i2.OrdineOrderByRelationAggregateInput? ordine;

  final _i2.HistoryOrderByRelationAggregateInput? history;

  final _i2.LeadOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
        '_relevance': $relevance,
      };
}

enum OrdineOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  codice._('codice'),
  soggettoUuid._('soggettoUuid'),
  domicilioUuid._('domicilioUuid'),
  statoOrdineId._('statoOrdineId'),
  leadUuid._('leadUuid'),
  utenteUuid._('utenteUuid'),
  negozioCodice._('negozioCodice');

  const OrdineOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class OrdineOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.OrdineOrderByRelevanceFieldEnum,
      Iterable<_i2.OrdineOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class OrdineOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? valore;

  final _i2.SortOrder? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? domicilioUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? statoOrdineId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? leadUuid;

  final _i2.SortOrder? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i2.ProdottoOrderByRelationAggregateInput? prodotti;

  final _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput? soggetto;

  final _i2.DomicilioOrderByWithRelationAndSearchRelevanceInput? domicilio;

  final _i2.StatoOrdineOrderByWithRelationAndSearchRelevanceInput? statoOrdine;

  final _i2.LeadOrderByWithRelationAndSearchRelevanceInput? lead;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? utente;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozio;

  final _i2.OrdineOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
        '_relevance': $relevance,
      };
}

class OrdineWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineWhereUniqueInput({
    this.uuid,
    this.codice,
    this.AND,
    this.OR,
    this.NOT,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
  });

  final String? uuid;

  final String? codice;

  final _i1.PrismaUnion<_i2.OrdineWhereInput, Iterable<_i2.OrdineWhereInput>>?
      AND;

  final Iterable<_i2.OrdineWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrdineWhereInput, Iterable<_i2.OrdineWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? valore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoListRelationFilter? prodotti;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  final _i1.PrismaUnion<_i2.DomicilioNullableRelationFilter,
      _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>>? domicilio;

  final _i1.PrismaUnion<_i2.StatoOrdineNullableRelationFilter,
      _i1.PrismaUnion<_i2.StatoOrdineWhereInput, _i1.PrismaNull>>? statoOrdine;

  final _i1.PrismaUnion<_i2.LeadNullableRelationFilter,
      _i1.PrismaUnion<_i2.LeadWhereInput, _i1.PrismaNull>>? lead;

  final _i1.PrismaUnion<_i2.UtenteRelationFilter, _i2.UtenteWhereInput>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

enum OrdineScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Ordine'),
  codice<String>('codice', 'Ordine'),
  dataInserimento<DateTime>('dataInserimento', 'Ordine'),
  valore<double>('valore', 'Ordine'),
  soggettoUuid<String>('soggettoUuid', 'Ordine'),
  domicilioUuid<String>('domicilioUuid', 'Ordine'),
  statoOrdineId<String>('statoOrdineId', 'Ordine'),
  leadUuid<String>('leadUuid', 'Ordine'),
  utenteUuid<String>('utenteUuid', 'Ordine'),
  negozioCodice<String>('negozioCodice', 'Ordine');

  const OrdineScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class StatoOrdineOrdiniArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineOrdiniArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoOrdineCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCountOutputTypeSelect({this.ordini});

  final bool? ordini;

  @override
  Map<String, dynamic> toJson() => {'ordini': ordini};
}

class StatoOrdineCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCountArgs({this.select});

  final _i2.StatoOrdineCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOrdineInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineInclude({
    this.ordini,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.StatoOrdineOrdiniArgs>? ordini;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'ordini': ordini,
        '_count': $count,
      };
}

class OrdineStatoOrdineArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineStatoOrdineArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.StatoOrdineWhereInput? where;

  final _i2.StatoOrdineSelect? select;

  final _i2.StatoOrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class LeadWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.LeadWhereInput, Iterable<_i2.LeadWhereInput>>? AND;

  final Iterable<_i2.LeadWhereInput>? OR;

  final _i1.PrismaUnion<_i2.LeadWhereInput, Iterable<_i2.LeadWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? opportunitaUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoOpportunitaUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  final _i1
      .PrismaUnion<_i2.OpportunitaRelationFilter, _i2.OpportunitaWhereInput>?
      opportunita;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  final _i1.PrismaUnion<_i2.DomicilioNullableRelationFilter,
      _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>>? domicilio;

  final _i1.PrismaUnion<_i2.StatoOpportunitaRelationFilter,
      _i2.StatoOpportunitaWhereInput>? statoOpportunita;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? agente;

  final _i2.OrdineListRelationFilter? ordine;

  final _i2.HistoryListRelationFilter? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

enum LeadScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Lead'),
  opportunitaUuid<String>('opportunitaUuid', 'Lead'),
  soggettoUuid<String>('soggettoUuid', 'Lead'),
  domicilioUuid<String>('domicilioUuid', 'Lead'),
  statoOpportunitaUuid<String>('statoOpportunitaUuid', 'Lead'),
  utenteUuid<String>('utenteUuid', 'Lead'),
  negozioCodice<String>('negozioCodice', 'Lead'),
  agenteUuid<String>('agenteUuid', 'Lead'),
  appuntamenti<String>('appuntamenti', 'Lead'),
  form<String>('form', 'Lead'),
  dataInserimento<DateTime>('dataInserimento', 'Lead'),
  dataScadenza<DateTime>('dataScadenza', 'Lead'),
  dataAppuntamento<DateTime>('dataAppuntamento', 'Lead'),
  nota<String>('nota', 'Lead');

  const LeadScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OpportunitaLeadsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaLeadsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class TipoPraticaServiziEwoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaServiziEwoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ServizioEwoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ServizioEwoScalar, Iterable<_i2.ServizioEwoScalar>>?
      distinct;

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class PraticaCodicePraticaTipoPraticaCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCodicePraticaTipoPraticaCompoundUniqueInput({
    required this.codice,
    required this.tipoPraticaId,
  });

  final String codice;

  final String tipoPraticaId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'tipoPraticaId': tipoPraticaId,
      };
}

class PraticaWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaWhereUniqueInput({
    this.uuid,
    this.codicePraticaTipoPratica,
    this.AND,
    this.OR,
    this.NOT,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final String? uuid;

  final _i2.PraticaCodicePraticaTipoPraticaCompoundUniqueInput?
      codicePraticaTipoPratica;

  final _i1.PrismaUnion<_i2.PraticaWhereInput, Iterable<_i2.PraticaWhereInput>>?
      AND;

  final Iterable<_i2.PraticaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PraticaWhereInput, Iterable<_i2.PraticaWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoPraticaId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1
      .PrismaUnion<_i2.TipoPraticaRelationFilter, _i2.TipoPraticaWhereInput>?
      tipoPratica;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.UtenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.UtenteWhereInput, _i1.PrismaNull>>? utente;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i1.PrismaUnion<_i2.StatoPraticaNullableRelationFilter,
      _i1.PrismaUnion<_i2.StatoPraticaWhereInput, _i1.PrismaNull>>? stato;

  final _i2.ContrattoListRelationFilter? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codicePratica_tipoPratica': codicePraticaTipoPratica,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

enum PraticaScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Pratica'),
  codice<String>('codice', 'Pratica'),
  dataInserimento<DateTime>('dataInserimento', 'Pratica'),
  tipoPraticaId<String>('tipoPraticaId', 'Pratica'),
  soggettoUuid<String>('soggettoUuid', 'Pratica'),
  utenteUuid<String>('utenteUuid', 'Pratica'),
  negozioCodice<String>('negozioCodice', 'Pratica'),
  statoPraticaId<String>('statoPraticaId', 'Pratica'),
  ultimoAggiornamentoStato<DateTime>('ultimoAggiornamentoStato', 'Pratica');

  const PraticaScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class TipoPraticaPraticheArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaPraticheArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.PraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.PraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.PraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PraticaScalar, Iterable<_i2.PraticaScalar>>?
      distinct;

  final _i2.PraticaSelect? select;

  final _i2.PraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class TipoPraticaCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCountOutputTypeSelect({
    this.serviziEwo,
    this.pratiche,
  });

  final bool? serviziEwo;

  final bool? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

class TipoPraticaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCountArgs({this.select});

  final _i2.TipoPraticaCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoPraticaInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaInclude({
    this.serviziEwo,
    this.pratiche,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.TipoPraticaServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaPraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
        '_count': $count,
      };
}

class PraticaTipoPraticaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaTipoPraticaArgs({
    this.select,
    this.include,
  });

  final _i2.TipoPraticaSelect? select;

  final _i2.TipoPraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class PraticaSoggettoArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaSoggettoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.SoggettoWhereInput? where;

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class NegozioPraticheArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioPraticheArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.PraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.PraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.PraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PraticaScalar, Iterable<_i2.PraticaScalar>>?
      distinct;

  final _i2.PraticaSelect? select;

  final _i2.PraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteWhereUniqueInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.AND,
    this.OR,
    this.NOT,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final String? firebaseUid;

  final String? email;

  final _i1.PrismaUnion<_i2.UtenteWhereInput, Iterable<_i2.UtenteWhereInput>>?
      AND;

  final Iterable<_i2.UtenteWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UtenteWhereInput, Iterable<_i2.UtenteWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.EnumRuoloUtenteFilter, _i3.RuoloUtente>? ruolo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nomeVisualizzato;

  final _i1.PrismaUnion<_i2.NegozioNullableRelationFilter,
      _i1.PrismaUnion<_i2.NegozioWhereInput, _i1.PrismaNull>>? negozio;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.PraticaListRelationFilter? pratiche;

  final _i2.IngressiListRelationFilter? ingressi;

  final _i2.LeadListRelationFilter? leadsGestiti;

  final _i2.LeadListRelationFilter? leadsAssegnati;

  final _i2.OpportunitaListRelationFilter? opportunitaGestite;

  final _i2.OpportunitaListRelationFilter? opportunitaAssegnate;

  final _i2.OrdineListRelationFilter? ordini;

  final _i2.HistoryListRelationFilter? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

enum UtenteScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Utente'),
  firebaseUid<String>('firebaseUid', 'Utente'),
  email<String>('email', 'Utente'),
  ruolo<_i3.RuoloUtente>('ruolo', 'Utente'),
  photoUrl<String>('photoUrl', 'Utente'),
  negozioCodice<String>('negozioCodice', 'Utente'),
  nomeVisualizzato<String>('nomeVisualizzato', 'Utente');

  const UtenteScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class NegozioUtentiArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUtentiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.UtenteOrderByWithRelationAndSearchRelevanceInput>,
      _i2.UtenteOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.UtenteWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.UtenteScalar, Iterable<_i2.UtenteScalar>>? distinct;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class NegozioContrattiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioContrattiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoScalar, Iterable<_i2.ContrattoScalar>>?
      distinct;

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

enum SoggettoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Soggetto'),
  ragioneSociale<String>('ragioneSociale', 'Soggetto'),
  iban<String>('iban', 'Soggetto'),
  tipo<_i3.TipoSoggetto>('tipo', 'Soggetto'),
  negozioPreferitoUuid<String>('negozioPreferitoUuid', 'Soggetto'),
  codiceFiscale<String>('codiceFiscale', 'Soggetto'),
  note<String>('note', 'Soggetto');

  const SoggettoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class NegozioSoggettiArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioSoggettiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.SoggettoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.SoggettoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.SoggettoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.SoggettoScalar, Iterable<_i2.SoggettoScalar>>?
      distinct;

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class NegozioWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioWhereUniqueInput({
    this.codice,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String? codice;

  final String? nome;

  final _i1.PrismaUnion<_i2.NegozioWhereInput, Iterable<_i2.NegozioWhereInput>>?
      AND;

  final Iterable<_i2.NegozioWhereInput>? OR;

  final _i1.PrismaUnion<_i2.NegozioWhereInput, Iterable<_i2.NegozioWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? zonaNegozioId;

  final _i2.PraticaListRelationFilter? pratiche;

  final _i2.UtenteListRelationFilter? utenti;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.SoggettoListRelationFilter? soggetti;

  final _i1
      .PrismaUnion<_i2.ZonaNegozioRelationFilter, _i2.ZonaNegozioWhereInput>?
      zonaNegozio;

  final _i2.IngressiListRelationFilter? ingressi;

  final _i2.LeadListRelationFilter? leads;

  final _i2.OrdineListRelationFilter? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

enum NegozioScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  codice<String>('codice', 'Negozio'),
  nome<String>('nome', 'Negozio'),
  zonaNegozioId<String>('zonaNegozioId', 'Negozio');

  const NegozioScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ZonaNegozioNegoziArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioNegoziArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.NegozioOrderByWithRelationAndSearchRelevanceInput>,
      _i2.NegozioOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.NegozioWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.NegozioScalar, Iterable<_i2.NegozioScalar>>?
      distinct;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ZonaNegozioCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCountOutputTypeSelect({this.negozi});

  final bool? negozi;

  @override
  Map<String, dynamic> toJson() => {'negozi': negozi};
}

class ZonaNegozioCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCountArgs({this.select});

  final _i2.ZonaNegozioCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonaNegozioSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioSelect({
    this.id,
    this.nome,
    this.negozi,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioNegoziArgs>? negozi;

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'negozi': negozi,
        '_count': $count,
      };
}

class ZonaNegozioInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioInclude({
    this.negozi,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioNegoziArgs>? negozi;

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'negozi': negozi,
        '_count': $count,
      };
}

class NegozioZonaNegozioArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioZonaNegozioArgs({
    this.select,
    this.include,
  });

  final _i2.ZonaNegozioSelect? select;

  final _i2.ZonaNegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class IngressiUtenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUtenteArgs({
    this.select,
    this.include,
  });

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class IngressiNegozioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiNegozioArgs({
    this.select,
    this.include,
  });

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class IngressiSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiSelect({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.utente,
    this.negozio,
  });

  final bool? uuid;

  final bool? data;

  final bool? clienti;

  final bool? nonClienti;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final _i1.PrismaUnion<bool, _i2.IngressiUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.IngressiNegozioArgs>? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'utente': utente,
        'negozio': negozio,
      };
}

class IngressiInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiInclude({
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<bool, _i2.IngressiUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.IngressiNegozioArgs>? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'utente': utente,
        'negozio': negozio,
      };
}

enum IngressiOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  utenteUuid._('utenteUuid'),
  negozioCodice._('negozioCodice');

  const IngressiOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class IngressiOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.IngressiOrderByRelevanceFieldEnum,
      Iterable<_i2.IngressiOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class IngressiOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.utente,
    this.negozio,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? data;

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? utente;

  final _i2.NegozioOrderByWithRelationAndSearchRelevanceInput? negozio;

  final _i2.IngressiOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'utente': utente,
        'negozio': negozio,
        '_relevance': $relevance,
      };
}

class IngressiWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.utente,
    this.negozio,
  });

  final String? uuid;

  final _i1
      .PrismaUnion<_i2.IngressiWhereInput, Iterable<_i2.IngressiWhereInput>>?
      AND;

  final Iterable<_i2.IngressiWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.IngressiWhereInput, Iterable<_i2.IngressiWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? data;

  final _i1.PrismaUnion<_i2.IntFilter, int>? clienti;

  final _i1.PrismaUnion<_i2.IntFilter, int>? nonClienti;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? negozioCodice;

  final _i1.PrismaUnion<_i2.UtenteRelationFilter, _i2.UtenteWhereInput>? utente;

  final _i1.PrismaUnion<_i2.NegozioRelationFilter, _i2.NegozioWhereInput>?
      negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'utente': utente,
        'negozio': negozio,
      };
}

enum IngressiScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Ingressi'),
  data<DateTime>('data', 'Ingressi'),
  clienti<int>('clienti', 'Ingressi'),
  nonClienti<int>('nonClienti', 'Ingressi'),
  utenteUuid<String>('utenteUuid', 'Ingressi'),
  negozioCodice<String>('negozioCodice', 'Ingressi');

  const IngressiScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class NegozioIngressiArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioIngressiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.IngressiWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.IngressiOrderByWithRelationAndSearchRelevanceInput>,
      _i2.IngressiOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.IngressiWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.IngressiScalar, Iterable<_i2.IngressiScalar>>?
      distinct;

  final _i2.IngressiSelect? select;

  final _i2.IngressiInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class NegozioLeadsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioLeadsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class NegozioOrdineArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioOrdineArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class NegozioCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCountOutputTypeSelect({
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final bool? pratiche;

  final bool? utenti;

  final bool? contratti;

  final bool? soggetti;

  final bool? ingressi;

  final bool? leads;

  final bool? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCountArgs({this.select});

  final _i2.NegozioCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NegozioInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioInclude({
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.NegozioPraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.NegozioUtentiArgs>? utenti;

  final _i1.PrismaUnion<bool, _i2.NegozioContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.NegozioSoggettiArgs>? soggetti;

  final _i1.PrismaUnion<bool, _i2.NegozioZonaNegozioArgs>? zonaNegozio;

  final _i1.PrismaUnion<bool, _i2.NegozioIngressiArgs>? ingressi;

  final _i1.PrismaUnion<bool, _i2.NegozioLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.NegozioOrdineArgs>? ordine;

  final _i1.PrismaUnion<bool, _i2.NegozioCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
        '_count': $count,
      };
}

class UtenteNegozioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteNegozioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class UtenteContrattiArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteContrattiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoScalar, Iterable<_i2.ContrattoScalar>>?
      distinct;

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtentePraticheArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtentePraticheArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.PraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.PraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.PraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PraticaScalar, Iterable<_i2.PraticaScalar>>?
      distinct;

  final _i2.PraticaSelect? select;

  final _i2.PraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteIngressiArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteIngressiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.IngressiWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.IngressiOrderByWithRelationAndSearchRelevanceInput>,
      _i2.IngressiOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.IngressiWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.IngressiScalar, Iterable<_i2.IngressiScalar>>?
      distinct;

  final _i2.IngressiSelect? select;

  final _i2.IngressiInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteLeadsGestitiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteLeadsGestitiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteLeadsAssegnatiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteLeadsAssegnatiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OpportunitaWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.OpportunitaWhereInput,
      Iterable<_i2.OpportunitaWhereInput>>? AND;

  final Iterable<_i2.OpportunitaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OpportunitaWhereInput,
      Iterable<_i2.OpportunitaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  final _i2.LeadListRelationFilter? leads;

  final _i2.UtenteListRelationFilter? gestoriLead;

  final _i2.UtenteListRelationFilter? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

enum OpportunitaScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Opportunita'),
  nome<String>('nome', 'Opportunita'),
  dataInizio<DateTime>('dataInizio', 'Opportunita'),
  dataFine<DateTime>('dataFine', 'Opportunita'),
  form<String>('form', 'Opportunita');

  const OpportunitaScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UtenteOpportunitaGestiteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOpportunitaGestiteArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OpportunitaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OpportunitaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OpportunitaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OpportunitaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OpportunitaScalar, Iterable<_i2.OpportunitaScalar>>?
      distinct;

  final _i2.OpportunitaSelect? select;

  final _i2.OpportunitaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteOpportunitaAssegnateArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOpportunitaAssegnateArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OpportunitaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OpportunitaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OpportunitaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OpportunitaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OpportunitaScalar, Iterable<_i2.OpportunitaScalar>>?
      distinct;

  final _i2.OpportunitaSelect? select;

  final _i2.OpportunitaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteOrdiniArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOrdiniArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class HistoryCommentHistoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentHistoryArgs({
    this.select,
    this.include,
  });

  final _i2.HistorySelect? select;

  final _i2.HistoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class HistoryCommentInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentInclude({this.history});

  final _i1.PrismaUnion<bool, _i2.HistoryCommentHistoryArgs>? history;

  @override
  Map<String, dynamic> toJson() => {'History': history};
}

class HistoryCommentArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.HistoryCommentWhereInput? where;

  final _i2.HistoryCommentSelect? select;

  final _i2.HistoryCommentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class HistoryAttachmentHistoryArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentHistoryArgs({
    this.select,
    this.include,
  });

  final _i2.HistorySelect? select;

  final _i2.HistoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class HistoryAttachmentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentSelect({
    this.url,
    this.name,
    this.historyUuid,
    this.history,
  });

  final bool? url;

  final bool? name;

  final bool? historyUuid;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentHistoryArgs>? history;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
        'History': history,
      };
}

class HistoryAttachmentInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentInclude({this.history});

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentHistoryArgs>? history;

  @override
  Map<String, dynamic> toJson() => {'History': history};
}

class HistoryAttachmentArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.HistoryAttachmentWhereInput? where;

  final _i2.HistoryAttachmentSelect? select;

  final _i2.HistoryAttachmentInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class HistoryUtenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUtenteArgs({
    this.select,
    this.include,
  });

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class HistoryLeadArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryLeadArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class HistoryInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryInclude({
    this.comment,
    this.attachment,
    this.utente,
    this.lead,
  });

  final _i1.PrismaUnion<bool, _i2.HistoryCommentArgs>? comment;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentArgs>? attachment;

  final _i1.PrismaUnion<bool, _i2.HistoryUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.HistoryLeadArgs>? lead;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryCommentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentSelect({
    this.comment,
    this.historyUuid,
    this.history,
  });

  final bool? comment;

  final bool? historyUuid;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentHistoryArgs>? history;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
        'History': history,
      };
}

class HistorySelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistorySelect({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.comment,
    this.attachment,
    this.utente,
    this.lead,
  });

  final bool? uuid;

  final bool? timestamp;

  final bool? event;

  final bool? utenteUuid;

  final bool? leadUuid;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentArgs>? comment;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentArgs>? attachment;

  final _i1.PrismaUnion<bool, _i2.HistoryUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.HistoryLeadArgs>? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

enum HistoryCommentOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  comment._('comment'),
  historyUuid._('historyUuid');

  const HistoryCommentOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class HistoryCommentOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentOrderByRelevanceFieldEnum,
      Iterable<_i2.HistoryCommentOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class HistoryCommentOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentOrderByWithRelationAndSearchRelevanceInput({
    this.comment,
    this.historyUuid,
    this.history,
    this.$relevance,
  });

  final _i2.SortOrder? comment;

  final _i2.SortOrder? historyUuid;

  final _i2.HistoryOrderByWithRelationAndSearchRelevanceInput? history;

  final _i2.HistoryCommentOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
        'History': history,
        '_relevance': $relevance,
      };
}

enum HistoryAttachmentOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  url._('url'),
  name$._('name'),
  historyUuid._('historyUuid');

  const HistoryAttachmentOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class HistoryAttachmentOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentOrderByRelevanceFieldEnum,
      Iterable<_i2.HistoryAttachmentOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class HistoryAttachmentOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentOrderByWithRelationAndSearchRelevanceInput({
    this.url,
    this.name,
    this.historyUuid,
    this.history,
    this.$relevance,
  });

  final _i2.SortOrder? url;

  final _i2.SortOrder? name;

  final _i2.SortOrder? historyUuid;

  final _i2.HistoryOrderByWithRelationAndSearchRelevanceInput? history;

  final _i2.HistoryAttachmentOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
        'History': history,
        '_relevance': $relevance,
      };
}

enum HistoryOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  event._('event'),
  utenteUuid._('utenteUuid'),
  leadUuid._('leadUuid');

  const HistoryOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class HistoryOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.HistoryOrderByRelevanceFieldEnum,
      Iterable<_i2.HistoryOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class HistoryOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.comment,
    this.attachment,
    this.utente,
    this.lead,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? timestamp;

  final _i2.SortOrder? event;

  final _i2.SortOrder? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? leadUuid;

  final _i2.HistoryCommentOrderByWithRelationAndSearchRelevanceInput? comment;

  final _i2.HistoryAttachmentOrderByWithRelationAndSearchRelevanceInput?
      attachment;

  final _i2.UtenteOrderByWithRelationAndSearchRelevanceInput? utente;

  final _i2.LeadOrderByWithRelationAndSearchRelevanceInput? lead;

  final _i2.HistoryOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
        '_relevance': $relevance,
      };
}

class HistoryWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.comment,
    this.attachment,
    this.utente,
    this.lead,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.HistoryWhereInput, Iterable<_i2.HistoryWhereInput>>?
      AND;

  final Iterable<_i2.HistoryWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryWhereInput, Iterable<_i2.HistoryWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? timestamp;

  final _i1.PrismaUnion<_i2.StringFilter, String>? event;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<_i2.HistoryCommentNullableRelationFilter,
      _i1.PrismaUnion<_i2.HistoryCommentWhereInput, _i1.PrismaNull>>? comment;

  final _i1.PrismaUnion<_i2.HistoryAttachmentNullableRelationFilter,
          _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput, _i1.PrismaNull>>?
      attachment;

  final _i1.PrismaUnion<_i2.UtenteRelationFilter, _i2.UtenteWhereInput>? utente;

  final _i1.PrismaUnion<_i2.LeadNullableRelationFilter,
      _i1.PrismaUnion<_i2.LeadWhereInput, _i1.PrismaNull>>? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

enum HistoryScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'History'),
  timestamp<DateTime>('timestamp', 'History'),
  event<String>('event', 'History'),
  utenteUuid<String>('utenteUuid', 'History'),
  leadUuid<String>('leadUuid', 'History');

  const HistoryScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UtenteHistoryArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteHistoryArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.HistoryWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.HistoryOrderByWithRelationAndSearchRelevanceInput>,
      _i2.HistoryOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.HistoryWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.HistoryScalar, Iterable<_i2.HistoryScalar>>?
      distinct;

  final _i2.HistorySelect? select;

  final _i2.HistoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class UtenteCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCountOutputTypeSelect({
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final bool? contratti;

  final bool? pratiche;

  final bool? ingressi;

  final bool? leadsGestiti;

  final bool? leadsAssegnati;

  final bool? opportunitaGestite;

  final bool? opportunitaAssegnate;

  final bool? ordini;

  final bool? history;

  @override
  Map<String, dynamic> toJson() => {
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCountArgs({this.select});

  final _i2.UtenteCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UtenteInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteInclude({
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.UtenteNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.UtenteContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.UtentePraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.UtenteIngressiArgs>? ingressi;

  final _i1.PrismaUnion<bool, _i2.UtenteLeadsGestitiArgs>? leadsGestiti;

  final _i1.PrismaUnion<bool, _i2.UtenteLeadsAssegnatiArgs>? leadsAssegnati;

  final _i1.PrismaUnion<bool, _i2.UtenteOpportunitaGestiteArgs>?
      opportunitaGestite;

  final _i1.PrismaUnion<bool, _i2.UtenteOpportunitaAssegnateArgs>?
      opportunitaAssegnate;

  final _i1.PrismaUnion<bool, _i2.UtenteOrdiniArgs>? ordini;

  final _i1.PrismaUnion<bool, _i2.UtenteHistoryArgs>? history;

  final _i1.PrismaUnion<bool, _i2.UtenteCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
        '_count': $count,
      };
}

class PraticaUtenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUtenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class PraticaNegozioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaNegozioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class StatoPraticaPraticheArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaPraticheArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.PraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.PraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.PraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PraticaScalar, Iterable<_i2.PraticaScalar>>?
      distinct;

  final _i2.PraticaSelect? select;

  final _i2.PraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoPraticaServiziEwoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaServiziEwoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ServizioEwoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ServizioEwoScalar, Iterable<_i2.ServizioEwoScalar>>?
      distinct;

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoPraticaCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCountOutputTypeSelect({
    this.pratiche,
    this.serviziEwo,
  });

  final bool? pratiche;

  final bool? serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCountArgs({this.select});

  final _i2.StatoPraticaCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoPraticaSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaSelect({
    this.id,
    this.nome,
    this.pratiche,
    this.serviziEwo,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaPraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
        '_count': $count,
      };
}

class StatoPraticaInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaInclude({
    this.pratiche,
    this.serviziEwo,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.StatoPraticaPraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
        '_count': $count,
      };
}

class PraticaStatoArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaStatoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.StatoPraticaWhereInput? where;

  final _i2.StatoPraticaSelect? select;

  final _i2.StatoPraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class PraticaContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaContrattoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoScalar, Iterable<_i2.ContrattoScalar>>?
      distinct;

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class PraticaCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCountOutputTypeSelect({this.contratto});

  final bool? contratto;

  @override
  Map<String, dynamic> toJson() => {'contratto': contratto};
}

class PraticaCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCountArgs({this.select});

  final _i2.PraticaCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PraticaInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaInclude({
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.PraticaTipoPraticaArgs>? tipoPratica;

  final _i1.PrismaUnion<bool, _i2.PraticaSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.PraticaUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.PraticaNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.PraticaStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.PraticaContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.PraticaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
        '_count': $count,
      };
}

class TipoPraticaSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaSelect({
    this.id,
    this.nome,
    this.serviziEwo,
    this.pratiche,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaPraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
        '_count': $count,
      };
}

class PraticaSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
    this.$count,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? tipoPraticaId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? statoPraticaId;

  final bool? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i2.PraticaTipoPraticaArgs>? tipoPratica;

  final _i1.PrismaUnion<bool, _i2.PraticaSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.PraticaUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.PraticaNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.PraticaStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.PraticaContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.PraticaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
        '_count': $count,
      };
}

class NegozioSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioSelect({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
    this.$count,
  });

  final bool? codice;

  final bool? nome;

  final bool? zonaNegozioId;

  final _i1.PrismaUnion<bool, _i2.NegozioPraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.NegozioUtentiArgs>? utenti;

  final _i1.PrismaUnion<bool, _i2.NegozioContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.NegozioSoggettiArgs>? soggetti;

  final _i1.PrismaUnion<bool, _i2.NegozioZonaNegozioArgs>? zonaNegozio;

  final _i1.PrismaUnion<bool, _i2.NegozioIngressiArgs>? ingressi;

  final _i1.PrismaUnion<bool, _i2.NegozioLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.NegozioOrdineArgs>? ordine;

  final _i1.PrismaUnion<bool, _i2.NegozioCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
        '_count': $count,
      };
}

class UtenteSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteSelect({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
    this.$count,
  });

  final bool? uuid;

  final bool? firebaseUid;

  final bool? email;

  final bool? ruolo;

  final bool? photoUrl;

  final bool? negozioCodice;

  final bool? nomeVisualizzato;

  final _i1.PrismaUnion<bool, _i2.UtenteNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.UtenteContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.UtentePraticheArgs>? pratiche;

  final _i1.PrismaUnion<bool, _i2.UtenteIngressiArgs>? ingressi;

  final _i1.PrismaUnion<bool, _i2.UtenteLeadsGestitiArgs>? leadsGestiti;

  final _i1.PrismaUnion<bool, _i2.UtenteLeadsAssegnatiArgs>? leadsAssegnati;

  final _i1.PrismaUnion<bool, _i2.UtenteOpportunitaGestiteArgs>?
      opportunitaGestite;

  final _i1.PrismaUnion<bool, _i2.UtenteOpportunitaAssegnateArgs>?
      opportunitaAssegnate;

  final _i1.PrismaUnion<bool, _i2.UtenteOrdiniArgs>? ordini;

  final _i1.PrismaUnion<bool, _i2.UtenteHistoryArgs>? history;

  final _i1.PrismaUnion<bool, _i2.UtenteCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
        '_count': $count,
      };
}

class OpportunitaGestoriLeadArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaGestoriLeadArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.UtenteOrderByWithRelationAndSearchRelevanceInput>,
      _i2.UtenteOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.UtenteWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.UtenteScalar, Iterable<_i2.UtenteScalar>>? distinct;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OpportunitaAgentiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaAgentiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.UtenteOrderByWithRelationAndSearchRelevanceInput>,
      _i2.UtenteOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.UtenteWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.UtenteScalar, Iterable<_i2.UtenteScalar>>? distinct;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OpportunitaCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCountOutputTypeSelect({
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final bool? leads;

  final bool? gestoriLead;

  final bool? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCountArgs({this.select});

  final _i2.OpportunitaCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OpportunitaInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaInclude({
    this.leads,
    this.gestoriLead,
    this.agenti,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.OpportunitaLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.OpportunitaGestoriLeadArgs>? gestoriLead;

  final _i1.PrismaUnion<bool, _i2.OpportunitaAgentiArgs>? agenti;

  final _i1.PrismaUnion<bool, _i2.OpportunitaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
        '_count': $count,
      };
}

class LeadOpportunitaArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadOpportunitaArgs({
    this.select,
    this.include,
  });

  final _i2.OpportunitaSelect? select;

  final _i2.OpportunitaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class LeadSoggettoArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadSoggettoArgs({
    this.select,
    this.include,
  });

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class LeadDomicilioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadDomicilioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.DomicilioWhereInput? where;

  final _i2.DomicilioSelect? select;

  final _i2.DomicilioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class StatoOpportunitaLeadsArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaLeadsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoOpportunitaCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCountOutputTypeSelect({this.leads});

  final bool? leads;

  @override
  Map<String, dynamic> toJson() => {'leads': leads};
}

class StatoOpportunitaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCountArgs({this.select});

  final _i2.StatoOpportunitaCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOpportunitaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaSelect({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.leads,
    this.$count,
  });

  final bool? uuid;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final bool? opportunitaUuid;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
        '_count': $count,
      };
}

class StatoOpportunitaInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaInclude({
    this.leads,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'leads': leads,
        '_count': $count,
      };
}

class LeadStatoOpportunitaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadStatoOpportunitaArgs({
    this.select,
    this.include,
  });

  final _i2.StatoOpportunitaSelect? select;

  final _i2.StatoOpportunitaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class LeadUtenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUtenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class LeadNegozioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadNegozioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class LeadAgenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadAgenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class LeadOrdineArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadOrdineArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class LeadHistoryArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadHistoryArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.HistoryWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.HistoryOrderByWithRelationAndSearchRelevanceInput>,
      _i2.HistoryOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.HistoryWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.HistoryScalar, Iterable<_i2.HistoryScalar>>?
      distinct;

  final _i2.HistorySelect? select;

  final _i2.HistoryInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class LeadCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCountOutputTypeSelect({
    this.ordine,
    this.history,
  });

  final bool? ordine;

  final bool? history;

  @override
  Map<String, dynamic> toJson() => {
        'ordine': ordine,
        'history': history,
      };
}

class LeadCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCountArgs({this.select});

  final _i2.LeadCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LeadInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadInclude({
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.LeadOpportunitaArgs>? opportunita;

  final _i1.PrismaUnion<bool, _i2.LeadSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.LeadDomicilioArgs>? domicilio;

  final _i1.PrismaUnion<bool, _i2.LeadStatoOpportunitaArgs>? statoOpportunita;

  final _i1.PrismaUnion<bool, _i2.LeadUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.LeadNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.LeadAgenteArgs>? agente;

  final _i1.PrismaUnion<bool, _i2.LeadOrdineArgs>? ordine;

  final _i1.PrismaUnion<bool, _i2.LeadHistoryArgs>? history;

  final _i1.PrismaUnion<bool, _i2.LeadCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
        '_count': $count,
      };
}

class OpportunitaSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaSelect({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
    this.$count,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataInizio;

  final bool? dataFine;

  final bool? form;

  final _i1.PrismaUnion<bool, _i2.OpportunitaLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.OpportunitaGestoriLeadArgs>? gestoriLead;

  final _i1.PrismaUnion<bool, _i2.OpportunitaAgentiArgs>? agenti;

  final _i1.PrismaUnion<bool, _i2.OpportunitaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
        '_count': $count,
      };
}

class LeadSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadSelect({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
    this.$count,
  });

  final bool? uuid;

  final bool? opportunitaUuid;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOpportunitaUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? agenteUuid;

  final bool? appuntamenti;

  final bool? form;

  final bool? dataInserimento;

  final bool? dataScadenza;

  final bool? dataAppuntamento;

  final bool? nota;

  final _i1.PrismaUnion<bool, _i2.LeadOpportunitaArgs>? opportunita;

  final _i1.PrismaUnion<bool, _i2.LeadSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.LeadDomicilioArgs>? domicilio;

  final _i1.PrismaUnion<bool, _i2.LeadStatoOpportunitaArgs>? statoOpportunita;

  final _i1.PrismaUnion<bool, _i2.LeadUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.LeadNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.LeadAgenteArgs>? agente;

  final _i1.PrismaUnion<bool, _i2.LeadOrdineArgs>? ordine;

  final _i1.PrismaUnion<bool, _i2.LeadHistoryArgs>? history;

  final _i1.PrismaUnion<bool, _i2.LeadCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
        '_count': $count,
      };
}

class OrdineLeadArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineLeadArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class OrdineUtenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUtenteArgs({
    this.select,
    this.include,
  });

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OrdineNegozioArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineNegozioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class OrdineCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCountOutputTypeSelect({this.prodotti});

  final bool? prodotti;

  @override
  Map<String, dynamic> toJson() => {'prodotti': prodotti};
}

class OrdineCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCountArgs({this.select});

  final _i2.OrdineCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdineInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineInclude({
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.OrdineProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.OrdineSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.OrdineDomicilioArgs>? domicilio;

  final _i1.PrismaUnion<bool, _i2.OrdineStatoOrdineArgs>? statoOrdine;

  final _i1.PrismaUnion<bool, _i2.OrdineLeadArgs>? lead;

  final _i1.PrismaUnion<bool, _i2.OrdineUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.OrdineNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.OrdineCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
        '_count': $count,
      };
}

class StatoOrdineSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineSelect({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.ordini,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineOrdiniArgs>? ordini;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
        '_count': $count,
      };
}

class OrdineSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
    this.$count,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? valore;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOrdineId;

  final bool? leadUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final _i1.PrismaUnion<bool, _i2.OrdineProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.OrdineSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.OrdineDomicilioArgs>? domicilio;

  final _i1.PrismaUnion<bool, _i2.OrdineStatoOrdineArgs>? statoOrdine;

  final _i1.PrismaUnion<bool, _i2.OrdineLeadArgs>? lead;

  final _i1.PrismaUnion<bool, _i2.OrdineUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.OrdineNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.OrdineCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
        '_count': $count,
      };
}

class ProdottoProdottiOrdinatiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoProdottiOrdinatiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ProdottoFornitoreArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoFornitoreArgs({
    this.select,
    this.include,
  });

  final _i2.FornitoreSelect? select;

  final _i2.FornitoreInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class TipoProdottoProdottiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoProdottiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProdottoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ProdottoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProdottoScalar, Iterable<_i2.ProdottoScalar>>?
      distinct;

  final _i2.ProdottoSelect? select;

  final _i2.ProdottoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class TipoProdottoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCountOutputTypeSelect({this.prodotti});

  final bool? prodotti;

  @override
  Map<String, dynamic> toJson() => {'prodotti': prodotti};
}

class TipoProdottoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCountArgs({this.select});

  final _i2.TipoProdottoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoProdottoSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoSelect({
    this.id,
    this.nome,
    this.prodotti,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.TipoProdottoProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.TipoProdottoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
        '_count': $count,
      };
}

class TipoProdottoInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoInclude({
    this.prodotti,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.TipoProdottoProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.TipoProdottoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'prodotti': prodotti,
        '_count': $count,
      };
}

class ProdottoTipoProdottoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoTipoProdottoArgs({
    this.select,
    this.include,
  });

  final _i2.TipoProdottoSelect? select;

  final _i2.TipoProdottoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ProdottoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCountOutputTypeSelect({this.prodottiOrdinati});

  final bool? prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {'prodottiOrdinati': prodottiOrdinati};
}

class ProdottoCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCountArgs({this.select});

  final _i2.ProdottoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProdottoInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoInclude({
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ProdottoProduttoreArgs>? produttore;

  final _i1.PrismaUnion<bool, _i2.ProdottoProdottiOrdinatiArgs>?
      prodottiOrdinati;

  final _i1.PrismaUnion<bool, _i2.ProdottoFornitoreArgs>? fornitore;

  final _i1.PrismaUnion<bool, _i2.ProdottoTipoProdottoArgs>? tipoProdotto;

  final _i1.PrismaUnion<bool, _i2.ProdottoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
        '_count': $count,
      };
}

class ProduttoreSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreSelect({
    this.id,
    this.nome,
    this.prodotti,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.ProduttoreProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.ProduttoreCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
        '_count': $count,
      };
}

class ProdottoSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoSelect({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
    this.$count,
  });

  final bool? uuid;

  final bool? modello;

  final bool? prezzo;

  final bool? vendibileDal;

  final bool? vendibileAl;

  final bool? produttoreId;

  final bool? fornitoreId;

  final bool? tipoProdottoId;

  final _i1.PrismaUnion<bool, _i2.ProdottoProduttoreArgs>? produttore;

  final _i1.PrismaUnion<bool, _i2.ProdottoProdottiOrdinatiArgs>?
      prodottiOrdinati;

  final _i1.PrismaUnion<bool, _i2.ProdottoFornitoreArgs>? fornitore;

  final _i1.PrismaUnion<bool, _i2.ProdottoTipoProdottoArgs>? tipoProdotto;

  final _i1.PrismaUnion<bool, _i2.ProdottoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
        '_count': $count,
      };
}

class FornitoreProdottiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreProdottiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ProdottoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ProdottoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ProdottoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ProdottoScalar, Iterable<_i2.ProdottoScalar>>?
      distinct;

  final _i2.ProdottoSelect? select;

  final _i2.ProdottoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class FornitoreCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCountOutputTypeSelect({
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final bool? serviziEwo;

  final bool? moduliContratto;

  final bool? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCountArgs({this.select});

  final _i2.FornitoreCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornitoreInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreInclude({
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.FornitoreServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.FornitoreModuliContrattoArgs>?
      moduliContratto;

  final _i1.PrismaUnion<bool, _i2.FornitoreProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.FornitoreCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
        '_count': $count,
      };
}

class ServizioEwoFornitoreArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoFornitoreArgs({
    this.select,
    this.include,
  });

  final _i2.FornitoreSelect? select;

  final _i2.FornitoreInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class TipoPraticaWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.serviziEwo,
    this.pratiche,
  });

  final String? id;

  final String? nome;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereInput,
      Iterable<_i2.TipoPraticaWhereInput>>? AND;

  final Iterable<_i2.TipoPraticaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereInput,
      Iterable<_i2.TipoPraticaWhereInput>>? NOT;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  final _i2.PraticaListRelationFilter? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

enum TipoPraticaScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'TipoPratica'),
  nome<String>('nome', 'TipoPratica');

  const TipoPraticaScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ServizioEwoTipiPraticheArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoTipiPraticheArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.TipoPraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.TipoPraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.TipoPraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.TipoPraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.TipoPraticaScalar, Iterable<_i2.TipoPraticaScalar>>?
      distinct;

  final _i2.TipoPraticaSelect? select;

  final _i2.TipoPraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class FornituraDomicilioArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraDomicilioArgs({
    this.select,
    this.include,
  });

  final _i2.DomicilioSelect? select;

  final _i2.DomicilioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class FornituraServizioEwoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraServizioEwoArgs({
    this.select,
    this.include,
  });

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class FornituraFornituraLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraFornituraLuceArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.FornituraLuceWhereInput? where;

  final _i2.FornituraLuceSelect? select;

  final _i2.FornituraLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class FornituraGasWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasWhereUniqueInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
  });

  final String? uuid;

  final String? pdr;

  final String? fornituraUuid;

  final _i1.PrismaUnion<_i2.FornituraGasWhereInput,
      Iterable<_i2.FornituraGasWhereInput>>? AND;

  final Iterable<_i2.FornituraGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraGasWhereInput,
      Iterable<_i2.FornituraGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? remi;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasNullableRelationFilter,
          _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput, _i1.PrismaNull>>?
      classeMisuratore;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasNullableRelationFilter,
          _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput, _i1.PrismaNull>>?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i1.PrismaUnion<_i2.FornituraRelationFilter, _i2.FornituraWhereInput>?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

enum FornituraGasScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'FornituraGas'),
  pdr<String>('pdr', 'FornituraGas'),
  fornituraUuid<String>('fornituraUuid', 'FornituraGas'),
  classeMisuratoreGasId<String>('classeMisuratoreGasId', 'FornituraGas'),
  matricolaContatore<String>('matricolaContatore', 'FornituraGas'),
  remi<String>('remi', 'FornituraGas');

  const FornituraGasScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ClasseMisuratoreGasFornituraGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasFornituraGasArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.FornituraGasWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.FornituraGasOrderByWithRelationAndSearchRelevanceInput>,
      _i2.FornituraGasOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.FornituraGasWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1
      .PrismaUnion<_i2.FornituraGasScalar, Iterable<_i2.FornituraGasScalar>>?
      distinct;

  final _i2.FornituraGasSelect? select;

  final _i2.FornituraGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ClasseMisuratoreGasCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCountOutputTypeSelect({this.fornituraGas});

  final bool? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {'fornituraGas': fornituraGas};
}

class ClasseMisuratoreGasCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCountArgs({this.select});

  final _i2.ClasseMisuratoreGasCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClasseMisuratoreGasInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasInclude({
    this.fornituraGas,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasFornituraGasArgs>?
      fornituraGas;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'fornituraGas': fornituraGas,
        '_count': $count,
      };
}

class FornituraGasClasseMisuratoreArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasClasseMisuratoreArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ClasseMisuratoreGasWhereInput? where;

  final _i2.ClasseMisuratoreGasSelect? select;

  final _i2.ClasseMisuratoreGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ConsumoAnnuoGasFornituraGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasFornituraGasArgs({
    this.select,
    this.include,
  });

  final _i2.FornituraGasSelect? select;

  final _i2.FornituraGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ConsumoAnnuoGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.fornituraGas,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraGasUuid;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasFornituraGasArgs>?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
        'fornituraGas': fornituraGas,
      };
}

class ConsumoAnnuoGasInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasInclude({this.fornituraGas});

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasFornituraGasArgs>?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {'fornituraGas': fornituraGas};
}

class FornituraGasConsumoAnnuoGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasConsumoAnnuoGasArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ConsumoAnnuoGasWhereInput? where;

  final _i2.ConsumoAnnuoGasSelect? select;

  final _i2.ConsumoAnnuoGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelGasStatoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasStatoArgs({
    this.select,
    this.include,
  });

  final _i2.StatoContrattoSelect? select;

  final _i2.StatoContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelGasFornituraGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasFornituraGasArgs({
    this.select,
    this.include,
  });

  final _i2.FornituraGasSelect? select;

  final _i2.FornituraGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelGasContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasContrattoArgs({
    this.select,
    this.include,
  });

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OffertaServizioEwoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaServizioEwoArgs({
    this.select,
    this.include,
  });

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class OffertaContrattiEnelLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaContrattiEnelLuceArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelLuceWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelLuceWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalar,
      Iterable<_i2.ContrattoEnelLuceScalar>>? distinct;

  final _i2.ContrattoEnelLuceSelect? select;

  final _i2.ContrattoEnelLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelGasOffertaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasOffertaArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelGasInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasInclude({
    this.stato,
    this.fornituraGas,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasFornituraGasArgs>?
      fornituraGas;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasOffertaArgs>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

enum ContrattoEnelGasOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  statoContrattoId._('statoContrattoId'),
  fornituraGasUuid._('fornituraGasUuid'),
  contrattoUuid._('contrattoUuid'),
  offertaUuid._('offertaUuid');

  const ContrattoEnelGasOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ContrattoEnelGasOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasOrderByRelevanceFieldEnum,
      Iterable<_i2.ContrattoEnelGasOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraGas,
    this.contratto,
    this.offerta,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput? stato;

  final _i2.FornituraGasOrderByWithRelationAndSearchRelevanceInput?
      fornituraGas;

  final _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput? contratto;

  final _i2.OffertaOrderByWithRelationAndSearchRelevanceInput? offerta;

  final _i2.ContrattoEnelGasOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
        '_relevance': $relevance,
      };
}

class ContrattoEnelGasWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraGas,
    this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereInput,
      Iterable<_i2.ContrattoEnelGasWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereInput,
      Iterable<_i2.ContrattoEnelGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraGasUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1
      .PrismaUnion<_i2.FornituraGasRelationFilter, _i2.FornituraGasWhereInput>?
      fornituraGas;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

enum ContrattoEnelGasScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'ContrattoEnelGas'),
  statoContrattoId<String>('statoContrattoId', 'ContrattoEnelGas'),
  fornituraGasUuid<String>('fornituraGasUuid', 'ContrattoEnelGas'),
  contrattoUuid<String>('contrattoUuid', 'ContrattoEnelGas'),
  offertaUuid<String>('offertaUuid', 'ContrattoEnelGas');

  const ContrattoEnelGasScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OffertaContrattiEnelGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaContrattiEnelGasArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelGasWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelGasWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalar,
      Iterable<_i2.ContrattoEnelGasScalar>>? distinct;

  final _i2.ContrattoEnelGasSelect? select;

  final _i2.ContrattoEnelGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelFibraStatoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraStatoArgs({
    this.select,
    this.include,
  });

  final _i2.StatoContrattoSelect? select;

  final _i2.StatoContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelFibraContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraContrattoArgs({
    this.select,
    this.include,
  });

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelFibraOffertaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraOffertaArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelFibraDomicilioArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraDomicilioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.DomicilioWhereInput? where;

  final _i2.DomicilioSelect? select;

  final _i2.DomicilioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelFibraSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.offerta,
    this.domicilio,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? servizioContrattoEnelFibra;

  final bool? tipoContrattoEnelFibra;

  final bool? tecnologiaContrattoEnelFibra;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraOffertaArgs>? offerta;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraDomicilioArgs>? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraInclude({
    this.stato,
    this.contratto,
    this.offerta,
    this.domicilio,
  });

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraOffertaArgs>? offerta;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraDomicilioArgs>? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

enum ContrattoEnelFibraOrderByRelevanceFieldEnum implements _i1.PrismaEnum {
  uuid._('uuid'),
  statoContrattoId._('statoContrattoId'),
  contrattoUuid._('contrattoUuid'),
  domicilioUuid._('domicilioUuid'),
  offertaUuid._('offertaUuid');

  const ContrattoEnelFibraOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ContrattoEnelFibraOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraOrderByRelevanceFieldEnum,
      Iterable<_i2.ContrattoEnelFibraOrderByRelevanceFieldEnum>> fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.offerta,
    this.domicilio,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? servizioContrattoEnelFibra;

  final _i2.SortOrder? tipoContrattoEnelFibra;

  final _i2.SortOrder? tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? domicilioUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput? stato;

  final _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput? contratto;

  final _i2.OffertaOrderByWithRelationAndSearchRelevanceInput? offerta;

  final _i2.DomicilioOrderByWithRelationAndSearchRelevanceInput? domicilio;

  final _i2.ContrattoEnelFibraOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
        '_relevance': $relevance,
      };
}

class ContrattoEnelFibraWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.offerta,
    this.domicilio,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereInput,
      Iterable<_i2.ContrattoEnelFibraWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelFibraWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereInput,
      Iterable<_i2.ContrattoEnelFibraWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.EnumServizioContrattoEnelFibraFilter,
      _i3.ServizioContrattoEnelFibra>? servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTipoContrattoEnelFibraFilter,
      _i3.TipoContrattoEnelFibra>? tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTecnologiaContrattoEnelFibraFilter,
      _i3.TecnologiaContrattoEnelFibra>? tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  final _i1.PrismaUnion<_i2.DomicilioNullableRelationFilter,
      _i1.PrismaUnion<_i2.DomicilioWhereInput, _i1.PrismaNull>>? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

enum ContrattoEnelFibraScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'ContrattoEnelFibra'),
  statoContrattoId<String>('statoContrattoId', 'ContrattoEnelFibra'),
  contrattoUuid<String>('contrattoUuid', 'ContrattoEnelFibra'),
  servizioContrattoEnelFibra<_i3.ServizioContrattoEnelFibra>(
      'servizioContrattoEnelFibra', 'ContrattoEnelFibra'),
  tipoContrattoEnelFibra<_i3.TipoContrattoEnelFibra>(
      'tipoContrattoEnelFibra', 'ContrattoEnelFibra'),
  tecnologiaContrattoEnelFibra<_i3.TecnologiaContrattoEnelFibra>(
      'tecnologiaContrattoEnelFibra', 'ContrattoEnelFibra'),
  domicilioUuid<String>('domicilioUuid', 'ContrattoEnelFibra'),
  offertaUuid<String>('offertaUuid', 'ContrattoEnelFibra');

  const ContrattoEnelFibraScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OffertaContrattiEnelFibraArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaContrattiEnelFibraArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelFibraWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>,
          _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelFibraWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalar,
      Iterable<_i2.ContrattoEnelFibraScalar>>? distinct;

  final _i2.ContrattoEnelFibraSelect? select;

  final _i2.ContrattoEnelFibraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

enum ContrattoEnelXAssicurazioneOrderByRelevanceFieldEnum
    implements _i1.PrismaEnum {
  uuid._('uuid'),
  statoContrattoId._('statoContrattoId'),
  contrattoUuid._('contrattoUuid'),
  domicilioUuid._('domicilioUuid'),
  offertaUuid._('offertaUuid');

  const ContrattoEnelXAssicurazioneOrderByRelevanceFieldEnum._(this.name);

  @override
  final String name;
}

class ContrattoEnelXAssicurazioneOrderByRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneOrderByRelevanceInput({
    required this.fields,
    required this.sort,
    required this.search,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneOrderByRelevanceFieldEnum,
          Iterable<_i2.ContrattoEnelXAssicurazioneOrderByRelevanceFieldEnum>>
      fields;

  final _i2.SortOrder sort;

  final String search;

  @override
  Map<String, dynamic> toJson() => {
        'fields': fields,
        'sort': sort,
        'search': search,
      };
}

class ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.domicilio,
    this.offerta,
    this.$relevance,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput? stato;

  final _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput? contratto;

  final _i2.DomicilioOrderByWithRelationAndSearchRelevanceInput? domicilio;

  final _i2.OffertaOrderByWithRelationAndSearchRelevanceInput? offerta;

  final _i2.ContrattoEnelXAssicurazioneOrderByRelevanceInput? $relevance;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
        '_relevance': $relevance,
      };
}

class ContrattoEnelXAssicurazioneWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.domicilio,
    this.offerta,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelXAssicurazioneWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StatoContrattoRelationFilter,
      _i2.StatoContrattoWhereInput>? stato;

  final _i1.PrismaUnion<_i2.ContrattoRelationFilter, _i2.ContrattoWhereInput>?
      contratto;

  final _i1.PrismaUnion<_i2.DomicilioRelationFilter, _i2.DomicilioWhereInput>?
      domicilio;

  final _i1.PrismaUnion<_i2.OffertaNullableRelationFilter,
      _i1.PrismaUnion<_i2.OffertaWhereInput, _i1.PrismaNull>>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

enum ContrattoEnelXAssicurazioneScalar<T>
    implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'ContrattoEnelXAssicurazione'),
  statoContrattoId<String>('statoContrattoId', 'ContrattoEnelXAssicurazione'),
  contrattoUuid<String>('contrattoUuid', 'ContrattoEnelXAssicurazione'),
  domicilioUuid<String>('domicilioUuid', 'ContrattoEnelXAssicurazione'),
  offertaUuid<String>('offertaUuid', 'ContrattoEnelXAssicurazione');

  const ContrattoEnelXAssicurazioneScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OffertaContrattiEnelXAssicurazioneArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaContrattiEnelXAssicurazioneArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>,
          _i2
          .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalar,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalar>>? distinct;

  final _i2.ContrattoEnelXAssicurazioneSelect? select;

  final _i2.ContrattoEnelXAssicurazioneInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OffertaWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaWhereUniqueInput({
    this.uuid,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String? nome;

  final _i1.PrismaUnion<_i2.OffertaWhereInput, Iterable<_i2.OffertaWhereInput>>?
      AND;

  final Iterable<_i2.OffertaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OffertaWhereInput, Iterable<_i2.OffertaWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataFineOfferta;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInizioOfferta;

  final _i1.PrismaUnion<_i2.StringFilter, String>? servizioEwoId;

  final _i1
      .PrismaUnion<_i2.ServizioEwoRelationFilter, _i2.ServizioEwoWhereInput>?
      servizioEwo;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  final _i2.OffertaListRelationFilter? offerteIncluse;

  final _i2.OffertaListRelationFilter? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

enum OffertaScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Offerta'),
  nome<String>('nome', 'Offerta'),
  dataFineOfferta<DateTime>('dataFineOfferta', 'Offerta'),
  dataInizioOfferta<DateTime>('dataInizioOfferta', 'Offerta'),
  servizioEwoId<String>('servizioEwoId', 'Offerta');

  const OffertaScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OffertaOfferteIncluseArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaOfferteIncluseArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OffertaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OffertaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OffertaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OffertaScalar, Iterable<_i2.OffertaScalar>>?
      distinct;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OffertaInclusaInOfferteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaInclusaInOfferteArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OffertaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OffertaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OffertaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OffertaScalar, Iterable<_i2.OffertaScalar>>?
      distinct;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class OffertaCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCountOutputTypeSelect({
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final bool? contrattiEnelLuce;

  final bool? contrattiEnelGas;

  final bool? contrattiEnelFibra;

  final bool? contrattiEnelXAssicurazione;

  final bool? offerteIncluse;

  final bool? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCountArgs({this.select});

  final _i2.OffertaCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OffertaInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaInclude({
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.OffertaServizioEwoArgs>? servizioEwo;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.OffertaOfferteIncluseArgs>? offerteIncluse;

  final _i1.PrismaUnion<bool, _i2.OffertaInclusaInOfferteArgs>?
      inclusaInOfferte;

  final _i1.PrismaUnion<bool, _i2.OffertaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
        '_count': $count,
      };
}

class ContrattoEnelGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraGas,
    this.contratto,
    this.offerta,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraGasUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasFornituraGasArgs>?
      fornituraGas;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasOffertaArgs>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class FornituraGasContrattiEnelGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasContrattiEnelGasArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelGasWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelGasWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalar,
      Iterable<_i2.ContrattoEnelGasScalar>>? distinct;

  final _i2.ContrattoEnelGasSelect? select;

  final _i2.ContrattoEnelGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class FornituraGasFornituraArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasFornituraArgs({
    this.select,
    this.include,
  });

  final _i2.FornituraSelect? select;

  final _i2.FornituraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class FornituraGasCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCountOutputTypeSelect({this.contrattiEnelGas});

  final bool? contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {'contrattiEnelGas': contrattiEnelGas};
}

class FornituraGasCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCountArgs({this.select});

  final _i2.FornituraGasCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraGasInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasInclude({
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.FornituraGasClasseMisuratoreArgs>?
      classeMisuratore;

  final _i1.PrismaUnion<bool, _i2.FornituraGasConsumoAnnuoGasArgs>?
      consumoAnnuoGas;

  final _i1.PrismaUnion<bool, _i2.FornituraGasContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.FornituraGasFornituraArgs>? fornitura;

  final _i1.PrismaUnion<bool, _i2.FornituraGasCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
        '_count': $count,
      };
}

class ClasseMisuratoreGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.fornituraGas,
    this.$count,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  final bool? id;

  final bool? classe;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasFornituraGasArgs>?
      fornituraGas;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
        '_count': $count,
      };
}

class FornituraGasSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasSelect({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
    this.$count,
  });

  final bool? uuid;

  final bool? pdr;

  final bool? fornituraUuid;

  final bool? classeMisuratoreGasId;

  final bool? matricolaContatore;

  final bool? remi;

  final _i1.PrismaUnion<bool, _i2.FornituraGasClasseMisuratoreArgs>?
      classeMisuratore;

  final _i1.PrismaUnion<bool, _i2.FornituraGasConsumoAnnuoGasArgs>?
      consumoAnnuoGas;

  final _i1.PrismaUnion<bool, _i2.FornituraGasContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.FornituraGasFornituraArgs>? fornitura;

  final _i1.PrismaUnion<bool, _i2.FornituraGasCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
        '_count': $count,
      };
}

class FornituraFornituraGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraFornituraGasArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.FornituraGasWhereInput? where;

  final _i2.FornituraGasSelect? select;

  final _i2.FornituraGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class FornituraInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraInclude({
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<bool, _i2.FornituraDomicilioArgs>? domicilio;

  final _i1.PrismaUnion<bool, _i2.FornituraServizioEwoArgs>? servizioEwo;

  final _i1.PrismaUnion<bool, _i2.FornituraFornituraLuceArgs>? fornituraLuce;

  final _i1.PrismaUnion<bool, _i2.FornituraFornituraGasArgs>? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1
      .PrismaUnion<_i2.FornituraWhereInput, Iterable<_i2.FornituraWhereInput>>?
      AND;

  final Iterable<_i2.FornituraWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.FornituraWhereInput, Iterable<_i2.FornituraWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? servizioEwoId;

  final _i1.PrismaUnion<_i2.DomicilioRelationFilter, _i2.DomicilioWhereInput>?
      domicilio;

  final _i1
      .PrismaUnion<_i2.ServizioEwoRelationFilter, _i2.ServizioEwoWhereInput>?
      servizioEwo;

  final _i1.PrismaUnion<_i2.FornituraLuceNullableRelationFilter,
          _i1.PrismaUnion<_i2.FornituraLuceWhereInput, _i1.PrismaNull>>?
      fornituraLuce;

  final _i1.PrismaUnion<_i2.FornituraGasNullableRelationFilter,
          _i1.PrismaUnion<_i2.FornituraGasWhereInput, _i1.PrismaNull>>?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

enum FornituraScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Fornitura'),
  etichetta<String>('etichetta', 'Fornitura'),
  domicilioUuid<String>('domicilioUuid', 'Fornitura'),
  servizioEwoId<String>('servizioEwoId', 'Fornitura');

  const FornituraScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ServizioEwoFornitureArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoFornitureArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.FornituraWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.FornituraOrderByWithRelationAndSearchRelevanceInput>,
      _i2.FornituraOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.FornituraWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.FornituraScalar, Iterable<_i2.FornituraScalar>>?
      distinct;

  final _i2.FornituraSelect? select;

  final _i2.FornituraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoPraticaWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.pratiche,
    this.serviziEwo,
  });

  final String? id;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereInput,
      Iterable<_i2.StatoPraticaWhereInput>>? AND;

  final Iterable<_i2.StatoPraticaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereInput,
      Iterable<_i2.StatoPraticaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.PraticaListRelationFilter? pratiche;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

enum StatoPraticaScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'StatoPratica'),
  nome<String>('nome', 'StatoPratica');

  const StatoPraticaScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ServizioEwoStatiPossibiliPraticheArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoStatiPossibiliPraticheArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.StatoPraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.StatoPraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.StatoPraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.StatoPraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1
      .PrismaUnion<_i2.StatoPraticaScalar, Iterable<_i2.StatoPraticaScalar>>?
      distinct;

  final _i2.StatoPraticaSelect? select;

  final _i2.StatoPraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? id;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereInput,
      Iterable<_i2.StatoContrattoWhereInput>>? AND;

  final Iterable<_i2.StatoContrattoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereInput,
      Iterable<_i2.StatoContrattoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i2.ContrattoListRelationFilter? contratti;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i2.ContrattoEnelGasListRelationFilter? contrattiEnelGas;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

enum StatoContrattoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'StatoContratto'),
  nome<String>('nome', 'StatoContratto');

  const StatoContrattoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ServizioEwoStatiPossibiliContrattiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoStatiPossibiliContrattiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.StatoContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.StatoContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.StatoContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.StatoContrattoScalar,
      Iterable<_i2.StatoContrattoScalar>>? distinct;

  final _i2.StatoContrattoSelect? select;

  final _i2.StatoContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ServizioEwoOfferteArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoOfferteArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OffertaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OffertaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OffertaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OffertaScalar, Iterable<_i2.OffertaScalar>>?
      distinct;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ServizioEwoModuliContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoModuliContrattoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ModuloContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ModuloContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ModuloContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalar,
      Iterable<_i2.ModuloContrattoScalar>>? distinct;

  final _i2.ModuloContrattoSelect? select;

  final _i2.ModuloContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ServizioEwoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCountOutputTypeSelect({
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final bool? tipiPratiche;

  final bool? forniture;

  final bool? statiPossibiliPratiche;

  final bool? statiPossibiliContratti;

  final bool? offerte;

  final bool? moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCountArgs({this.select});

  final _i2.ServizioEwoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ServizioEwoInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoInclude({
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ServizioEwoFornitoreArgs>? fornitore;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoTipiPraticheArgs>? tipiPratiche;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoFornitureArgs>? forniture;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoStatiPossibiliPraticheArgs>?
      statiPossibiliPratiche;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoStatiPossibiliContrattiArgs>?
      statiPossibiliContratti;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoOfferteArgs>? offerte;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoModuliContrattoArgs>?
      moduliContratto;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
        '_count': $count,
      };
}

class FornitoreSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreSelect({
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.FornitoreServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.FornitoreModuliContrattoArgs>?
      moduliContratto;

  final _i1.PrismaUnion<bool, _i2.FornitoreProdottiArgs>? prodotti;

  final _i1.PrismaUnion<bool, _i2.FornitoreCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
        '_count': $count,
      };
}

class ServizioEwoSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? tipoServizioEwo;

  final bool? colore;

  final bool? icona;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoFornitoreArgs>? fornitore;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoTipiPraticheArgs>? tipiPratiche;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoFornitureArgs>? forniture;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoStatiPossibiliPraticheArgs>?
      statiPossibiliPratiche;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoStatiPossibiliContrattiArgs>?
      statiPossibiliContratti;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoOfferteArgs>? offerte;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoModuliContrattoArgs>?
      moduliContratto;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
        '_count': $count,
      };
}

class OffertaSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaSelect({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
    this.$count,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataFineOfferta;

  final bool? dataInizioOfferta;

  final bool? servizioEwoId;

  final _i1.PrismaUnion<bool, _i2.OffertaServizioEwoArgs>? servizioEwo;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1.PrismaUnion<bool, _i2.OffertaContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.OffertaOfferteIncluseArgs>? offerteIncluse;

  final _i1.PrismaUnion<bool, _i2.OffertaInclusaInOfferteArgs>?
      inclusaInOfferte;

  final _i1.PrismaUnion<bool, _i2.OffertaCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
        '_count': $count,
      };
}

class ContrattoEnelXAssicurazioneOffertaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneOffertaArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelXAssicurazioneInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneInclude({
    this.stato,
    this.contratto,
    this.domicilio,
    this.offerta,
  });

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneContrattoArgs>?
      contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneDomicilioArgs>?
      domicilio;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneOffertaArgs>?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class DomicilioContrattiEnelXAssicurazioneArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioContrattiEnelXAssicurazioneArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>,
          _i2
          .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalar,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalar>>? distinct;

  final _i2.ContrattoEnelXAssicurazioneSelect? select;

  final _i2.ContrattoEnelXAssicurazioneInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class DomicilioFornitureArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioFornitureArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.FornituraWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.FornituraOrderByWithRelationAndSearchRelevanceInput>,
      _i2.FornituraOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.FornituraWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.FornituraScalar, Iterable<_i2.FornituraScalar>>?
      distinct;

  final _i2.FornituraSelect? select;

  final _i2.FornituraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class DomicilioContrattiEnelFibraArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioContrattiEnelFibraArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelFibraWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>,
          _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelFibraWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalar,
      Iterable<_i2.ContrattoEnelFibraScalar>>? distinct;

  final _i2.ContrattoEnelFibraSelect? select;

  final _i2.ContrattoEnelFibraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class DomicilioProdottiOrdinatiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioProdottiOrdinatiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class DomicilioLeadsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioLeadsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class DomicilioCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCountOutputTypeSelect({
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final bool? contrattiEnelXAssicurazione;

  final bool? forniture;

  final bool? contrattiEnelFibra;

  final bool? prodottiOrdinati;

  final bool? leads;

  @override
  Map<String, dynamic> toJson() => {
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCountArgs({this.select});

  final _i2.DomicilioCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomicilioInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioInclude({
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.DomicilioSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.DomicilioContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.DomicilioFornitureArgs>? forniture;

  final _i1.PrismaUnion<bool, _i2.DomicilioContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1.PrismaUnion<bool, _i2.DomicilioProdottiOrdinatiArgs>?
      prodottiOrdinati;

  final _i1.PrismaUnion<bool, _i2.DomicilioLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.DomicilioCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        '_count': $count,
      };
}

class FornituraSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraSelect({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? domicilioUuid;

  final bool? servizioEwoId;

  final _i1.PrismaUnion<bool, _i2.FornituraDomicilioArgs>? domicilio;

  final _i1.PrismaUnion<bool, _i2.FornituraServizioEwoArgs>? servizioEwo;

  final _i1.PrismaUnion<bool, _i2.FornituraFornituraLuceArgs>? fornituraLuce;

  final _i1.PrismaUnion<bool, _i2.FornituraFornituraGasArgs>? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraLuceFornituraArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceFornituraArgs({
    this.select,
    this.include,
  });

  final _i2.FornituraSelect? select;

  final _i2.FornituraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class FornituraLuceCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCountOutputTypeSelect({this.contrattiEnelLuce});

  final bool? contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {'contrattiEnelLuce': contrattiEnelLuce};
}

class FornituraLuceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCountArgs({this.select});

  final _i2.FornituraLuceCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraLuceInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceInclude({
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    this.fornitura,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.FornituraLuceConsumoAnnuoLuceArgs>?
      consumoAnnuoLuce;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceFornituraArgs>? fornitura;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
        '_count': $count,
      };
}

class ConsumoAnnuoLuceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.fornituraLuce,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraLuceUuid;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceFornituraLuceArgs>?
      fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
        'fornituraLuce': fornituraLuce,
      };
}

class FornituraLuceSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceSelect({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    this.fornitura,
    this.$count,
  });

  final bool? uuid;

  final bool? pod;

  final bool? fornituraUuid;

  final bool? potenza;

  final bool? tensione;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceConsumoAnnuoLuceArgs>?
      consumoAnnuoLuce;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceFornituraArgs>? fornitura;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
        '_count': $count,
      };
}

class ContrattoEnelLuceFornituraLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceFornituraLuceArgs({
    this.select,
    this.include,
  });

  final _i2.FornituraLuceSelect? select;

  final _i2.FornituraLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelLuceContrattoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceContrattoArgs({
    this.select,
    this.include,
  });

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoEnelLuceOffertaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceOffertaArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.OffertaWhereInput? where;

  final _i2.OffertaSelect? select;

  final _i2.OffertaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoEnelLuceInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceInclude({
    this.stato,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceFornituraLuceArgs>?
      fornituraLuce;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceOffertaArgs>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoContrattiEnelLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoContrattiEnelLuceArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelLuceWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelLuceWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalar,
      Iterable<_i2.ContrattoEnelLuceScalar>>? distinct;

  final _i2.ContrattoEnelLuceSelect? select;

  final _i2.ContrattoEnelLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoContrattiEnelGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoContrattiEnelGasArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelGasWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelGasWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalar,
      Iterable<_i2.ContrattoEnelGasScalar>>? distinct;

  final _i2.ContrattoEnelGasSelect? select;

  final _i2.ContrattoEnelGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoContrattiEnelFibraArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoContrattiEnelFibraArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelFibraWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>,
          _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelFibraWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalar,
      Iterable<_i2.ContrattoEnelFibraScalar>>? distinct;

  final _i2.ContrattoEnelFibraSelect? select;

  final _i2.ContrattoEnelFibraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoContrattiEnelXAssicurazioneArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoContrattiEnelXAssicurazioneArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>,
          _i2
          .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalar,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalar>>? distinct;

  final _i2.ContrattoEnelXAssicurazioneSelect? select;

  final _i2.ContrattoEnelXAssicurazioneInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class ContrattoStatoArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoStatoArgs({
    this.select,
    this.include,
  });

  final _i2.StatoContrattoSelect? select;

  final _i2.StatoContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'select': select,
        'include': include,
      };
}

class ContrattoSoggettoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoSoggettoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.SoggettoWhereInput? where;

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoUtenteArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUtenteArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.UtenteWhereInput? where;

  final _i2.UtenteSelect? select;

  final _i2.UtenteInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoNegozioArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoNegozioArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoPraticaArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoPraticaArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.PraticaWhereInput? where;

  final _i2.PraticaSelect? select;

  final _i2.PraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoModuloArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoModuloArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.ModuloContrattoWhereInput? where;

  final _i2.ModuloContrattoSelect? select;

  final _i2.ModuloContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class ContrattoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCountOutputTypeSelect({
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final bool? contrattiEnelLuce;

  final bool? contrattiEnelGas;

  final bool? contrattiEnelFibra;

  final bool? contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCountArgs({this.select});

  final _i2.ContrattoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoInclude({
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.ContrattoStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.ContrattoUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.ContrattoNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.ContrattoPraticaArgs>? pratica;

  final _i1.PrismaUnion<bool, _i2.ContrattoModuloArgs>? modulo;

  final _i1.PrismaUnion<bool, _i2.ContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
        '_count': $count,
      };
}

class StatoContrattoContrattiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoContrattiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoScalar, Iterable<_i2.ContrattoScalar>>?
      distinct;

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoServiziEwoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoServiziEwoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ServizioEwoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ServizioEwoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ServizioEwoScalar, Iterable<_i2.ServizioEwoScalar>>?
      distinct;

  final _i2.ServizioEwoSelect? select;

  final _i2.ServizioEwoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoContrattiEnelLuceArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoContrattiEnelLuceArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelLuceWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelLuceOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelLuceWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalar,
      Iterable<_i2.ContrattoEnelLuceScalar>>? distinct;

  final _i2.ContrattoEnelLuceSelect? select;

  final _i2.ContrattoEnelLuceInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoContrattiEnelGasArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoContrattiEnelGasArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelGasWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoEnelGasOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoEnelGasWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalar,
      Iterable<_i2.ContrattoEnelGasScalar>>? distinct;

  final _i2.ContrattoEnelGasSelect? select;

  final _i2.ContrattoEnelGasInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoContrattiEnelFibraArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoContrattiEnelFibraArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelFibraWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>,
          _i2.ContrattoEnelFibraOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelFibraWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalar,
      Iterable<_i2.ContrattoEnelFibraScalar>>? distinct;

  final _i2.ContrattoEnelFibraSelect? select;

  final _i2.ContrattoEnelFibraInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoContrattiEnelXAssicurazioneArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoContrattiEnelXAssicurazioneArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereInput? where;

  final _i1.PrismaUnion<
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>,
          _i2
          .ContrattoEnelXAssicurazioneOrderByWithRelationAndSearchRelevanceInput>?
      orderBy;

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalar,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalar>>? distinct;

  final _i2.ContrattoEnelXAssicurazioneSelect? select;

  final _i2.ContrattoEnelXAssicurazioneInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class StatoContrattoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCountOutputTypeSelect({
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final bool? contratti;

  final bool? serviziEwo;

  final bool? contrattiEnelLuce;

  final bool? contrattiEnelGas;

  final bool? contrattiEnelFibra;

  final bool? contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCountArgs({this.select});

  final _i2.StatoContrattoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoContrattoInclude
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoInclude({
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1
      .PrismaUnion<bool, _i2.StatoContrattoContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        '_count': $count,
      };
}

class ContrattoEnelLuceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.stato,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraLuceUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceFornituraLuceArgs>?
      fornituraLuce;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceContrattoArgs>? contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceOffertaArgs>? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
    this.$count,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? dataAttivazione;

  final bool? ultimoAggiornamentoStato;

  final bool? trend;

  final bool? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final bool? dataCessazione;

  final bool? mesiDurata;

  final bool? offertaUuid;

  final bool? statoContrattoId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? praticaUuid;

  final bool? moduloContrattoId;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1.PrismaUnion<bool, _i2.ContrattoContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.ContrattoStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.ContrattoUtenteArgs>? utente;

  final _i1.PrismaUnion<bool, _i2.ContrattoNegozioArgs>? negozio;

  final _i1.PrismaUnion<bool, _i2.ContrattoPraticaArgs>? pratica;

  final _i1.PrismaUnion<bool, _i2.ContrattoModuloArgs>? modulo;

  final _i1.PrismaUnion<bool, _i2.ContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
        '_count': $count,
      };
}

class StatoContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoSelect({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.$count,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoServiziEwoArgs>? serviziEwo;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiEnelLuceArgs>?
      contrattiEnelLuce;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiEnelGasArgs>?
      contrattiEnelGas;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1
      .PrismaUnion<bool, _i2.StatoContrattoContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        '_count': $count,
      };
}

class ContrattoEnelXAssicurazioneSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.stato,
    this.contratto,
    this.domicilio,
    this.offerta,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneStatoArgs>? stato;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneContrattoArgs>?
      contratto;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneDomicilioArgs>?
      domicilio;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelXAssicurazioneOffertaArgs>?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class DomicilioSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioSelect({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
    this.$count,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? indirizzo;

  final bool? numeroCivico;

  final bool? citta;

  final bool? cap;

  final bool? provincia;

  final bool? soggettoUuid;

  final _i1.PrismaUnion<bool, _i2.DomicilioSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.DomicilioContrattiEnelXAssicurazioneArgs>?
      contrattiEnelXAssicurazione;

  final _i1.PrismaUnion<bool, _i2.DomicilioFornitureArgs>? forniture;

  final _i1.PrismaUnion<bool, _i2.DomicilioContrattiEnelFibraArgs>?
      contrattiEnelFibra;

  final _i1.PrismaUnion<bool, _i2.DomicilioProdottiOrdinatiArgs>?
      prodottiOrdinati;

  final _i1.PrismaUnion<bool, _i2.DomicilioLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.DomicilioCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        '_count': $count,
      };
}

class DomicilioWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1
      .PrismaUnion<_i2.DomicilioWhereInput, Iterable<_i2.DomicilioWhereInput>>?
      AND;

  final Iterable<_i2.DomicilioWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.DomicilioWhereInput, Iterable<_i2.DomicilioWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  final _i2.ContrattoEnelXAssicurazioneListRelationFilter?
      contrattiEnelXAssicurazione;

  final _i2.FornituraListRelationFilter? forniture;

  final _i2.ContrattoEnelFibraListRelationFilter? contrattiEnelFibra;

  final _i2.OrdineListRelationFilter? prodottiOrdinati;

  final _i2.LeadListRelationFilter? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

enum DomicilioScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Domicilio'),
  etichetta<String>('etichetta', 'Domicilio'),
  indirizzo<String>('indirizzo', 'Domicilio'),
  numeroCivico<String>('numeroCivico', 'Domicilio'),
  citta<String>('citta', 'Domicilio'),
  cap<String>('cap', 'Domicilio'),
  provincia<String>('provincia', 'Domicilio'),
  soggettoUuid<String>('soggettoUuid', 'Domicilio');

  const DomicilioScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SoggettoDomiciliArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoDomiciliArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.DomicilioWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.DomicilioOrderByWithRelationAndSearchRelevanceInput>,
      _i2.DomicilioOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.DomicilioWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.DomicilioScalar, Iterable<_i2.DomicilioScalar>>?
      distinct;

  final _i2.DomicilioSelect? select;

  final _i2.DomicilioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class SoggettoPraticheIntestateArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoPraticheIntestateArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.PraticaWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.PraticaOrderByWithRelationAndSearchRelevanceInput>,
      _i2.PraticaOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.PraticaWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.PraticaScalar, Iterable<_i2.PraticaScalar>>?
      distinct;

  final _i2.PraticaSelect? select;

  final _i2.PraticaInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class SoggettoContrattiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoContrattiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.ContrattoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.ContrattoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.ContrattoScalar, Iterable<_i2.ContrattoScalar>>?
      distinct;

  final _i2.ContrattoSelect? select;

  final _i2.ContrattoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class IndirizzoEmailIndirizzoSoggettoUuidCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailIndirizzoSoggettoUuidCompoundUniqueInput({
    required this.indirizzo,
    required this.soggettoUuid,
  });

  final String indirizzo;

  final String soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'indirizzo': indirizzo,
        'soggettoUuid': soggettoUuid,
      };
}

class IndirizzoEmailWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailWhereUniqueInput({
    this.uuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.indirizzoSoggettoUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
  });

  final String? uuid;

  final String? legaleRappresentanteUuid;

  final String? referenteUuid;

  final _i2.IndirizzoEmailIndirizzoSoggettoUuidCompoundUniqueInput?
      indirizzoSoggettoUuid;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput,
      Iterable<_i2.IndirizzoEmailWhereInput>>? AND;

  final Iterable<_i2.IndirizzoEmailWhereInput>? OR;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput,
      Iterable<_i2.IndirizzoEmailWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.ReferenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>>? referente;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteNullableRelationFilter,
          _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>>?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        'indirizzo_soggettoUuid': indirizzoSoggettoUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

enum IndirizzoEmailScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'IndirizzoEmail'),
  indirizzo<String>('indirizzo', 'IndirizzoEmail'),
  etichetta<String>('etichetta', 'IndirizzoEmail'),
  soggettoUuid<String>('soggettoUuid', 'IndirizzoEmail'),
  legaleRappresentanteUuid<String>(
      'legaleRappresentanteUuid', 'IndirizzoEmail'),
  referenteUuid<String>('referenteUuid', 'IndirizzoEmail');

  const IndirizzoEmailScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SoggettoIndirizziEmailArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoIndirizziEmailArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.IndirizzoEmailWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.IndirizzoEmailOrderByWithRelationAndSearchRelevanceInput>,
      _i2.IndirizzoEmailOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.IndirizzoEmailWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalar,
      Iterable<_i2.IndirizzoEmailScalar>>? distinct;

  final _i2.IndirizzoEmailSelect? select;

  final _i2.IndirizzoEmailInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class NumeroTelefonoNumeroSoggettoUuidCompoundUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoNumeroSoggettoUuidCompoundUniqueInput({
    required this.numero,
    required this.soggettoUuid,
  });

  final String numero;

  final String soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'numero': numero,
        'soggettoUuid': soggettoUuid,
      };
}

class NumeroTelefonoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoWhereUniqueInput({
    this.uuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.numeroSoggettoUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
  });

  final String? uuid;

  final String? legaleRappresentateUuid;

  final String? referenteUuid;

  final _i2.NumeroTelefonoNumeroSoggettoUuidCompoundUniqueInput?
      numeroSoggettoUuid;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput,
      Iterable<_i2.NumeroTelefonoWhereInput>>? AND;

  final Iterable<_i2.NumeroTelefonoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput,
      Iterable<_i2.NumeroTelefonoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? numero;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteNullableRelationFilter,
          _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>>?
      legaleRappresentate;

  final _i1.PrismaUnion<_i2.ReferenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>>? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        'numero_soggettoUuid': numeroSoggettoUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

enum NumeroTelefonoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'NumeroTelefono'),
  numero<String>('numero', 'NumeroTelefono'),
  etichetta<String>('etichetta', 'NumeroTelefono'),
  soggettoUuid<String>('soggettoUuid', 'NumeroTelefono'),
  legaleRappresentateUuid<String>('legaleRappresentateUuid', 'NumeroTelefono'),
  referenteUuid<String>('referenteUuid', 'NumeroTelefono');

  const NumeroTelefonoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SoggettoNumeriTelefonoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoNumeriTelefonoArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.NumeroTelefonoWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.NumeroTelefonoOrderByWithRelationAndSearchRelevanceInput>,
      _i2.NumeroTelefonoOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.NumeroTelefonoWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalar,
      Iterable<_i2.NumeroTelefonoScalar>>? distinct;

  final _i2.NumeroTelefonoSelect? select;

  final _i2.NumeroTelefonoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class SoggettoNegozioPreferitoArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoNegozioPreferitoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.NegozioWhereInput? where;

  final _i2.NegozioSelect? select;

  final _i2.NegozioInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class SoggettoProdottiOrdinatiArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoProdottiOrdinatiArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.OrdineWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.OrdineOrderByWithRelationAndSearchRelevanceInput>,
      _i2.OrdineOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.OrdineWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.OrdineScalar, Iterable<_i2.OrdineScalar>>? distinct;

  final _i2.OrdineSelect? select;

  final _i2.OrdineInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class SoggettoLeadsArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoLeadsArgs({
    this.where,
    this.orderBy,
    this.cursor,
    this.take,
    this.skip,
    this.distinct,
    this.select,
    this.include,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<
      Iterable<_i2.LeadOrderByWithRelationAndSearchRelevanceInput>,
      _i2.LeadOrderByWithRelationAndSearchRelevanceInput>? orderBy;

  final _i2.LeadWhereUniqueInput? cursor;

  final int? take;

  final int? skip;

  final _i1.PrismaUnion<_i2.LeadScalar, Iterable<_i2.LeadScalar>>? distinct;

  final _i2.LeadSelect? select;

  final _i2.LeadInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'orderBy': orderBy,
        'cursor': cursor,
        'take': take,
        'skip': skip,
        'distinct': distinct,
        'select': select,
        'include': include,
      };
}

class PrivacySoggettoArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacySoggettoArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.SoggettoWhereInput? where;

  final _i2.SoggettoSelect? select;

  final _i2.SoggettoInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class PrivacySelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacySelect({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.soggetto,
  });

  final bool? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final bool? soggettoUuid;

  final _i1.PrismaUnion<bool, _i2.PrivacySoggettoArgs>? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
        'soggetto': soggetto,
      };
}

class PrivacyInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyInclude({this.soggetto});

  final _i1.PrismaUnion<bool, _i2.PrivacySoggettoArgs>? soggetto;

  @override
  Map<String, dynamic> toJson() => {'soggetto': soggetto};
}

class SoggettoPrivacyArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoPrivacyArgs({
    this.where,
    this.select,
    this.include,
  });

  final _i2.PrivacyWhereInput? where;

  final _i2.PrivacySelect? select;

  final _i2.PrivacyInclude? include;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'select': select,
        'include': include,
      };
}

class SoggettoCountOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCountOutputTypeSelect({
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
  });

  final bool? domicili;

  final bool? praticheIntestate;

  final bool? contratti;

  final bool? indirizziEmail;

  final bool? numeriTelefono;

  final bool? prodottiOrdinati;

  final bool? leads;

  @override
  Map<String, dynamic> toJson() => {
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class SoggettoCountArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCountArgs({this.select});

  final _i2.SoggettoCountOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoInclude implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoInclude({
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
    this.$count,
  });

  final _i1.PrismaUnion<bool, _i2.SoggettoSoggettoBusinessInfoArgs>?
      soggettoBusinessInfo;

  final _i1.PrismaUnion<bool, _i2.SoggettoDomiciliArgs>? domicili;

  final _i1.PrismaUnion<bool, _i2.SoggettoPraticheIntestateArgs>?
      praticheIntestate;

  final _i1.PrismaUnion<bool, _i2.SoggettoContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.SoggettoIndirizziEmailArgs>? indirizziEmail;

  final _i1.PrismaUnion<bool, _i2.SoggettoNumeriTelefonoArgs>? numeriTelefono;

  final _i1.PrismaUnion<bool, _i2.SoggettoNegozioPreferitoArgs>?
      negozioPreferito;

  final _i1.PrismaUnion<bool, _i2.SoggettoProdottiOrdinatiArgs>?
      prodottiOrdinati;

  final _i1.PrismaUnion<bool, _i2.SoggettoLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.SoggettoPrivacyArgs>? privacy;

  final _i1.PrismaUnion<bool, _i2.SoggettoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
        '_count': $count,
      };
}

class NumeroTelefonoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoSelect({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
  });

  final bool? uuid;

  final bool? numero;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentateUuid;

  final bool? referenteUuid;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoSoggettoArgs>? soggetto;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoLegaleRappresentateArgs>?
      legaleRappresentate;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoReferenteArgs>? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class LegaleRappresentanteSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteNumeroTelefonoArgs>?
      numeroTelefono;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteIndirizzoEmailArgs>?
      indirizzoEmail;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteSoggettoBusinessInfoArgs>?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class SoggettoBusinessInfoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoSelect({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.legaleRappresentante,
    this.referente,
    this.soggetto,
  });

  final bool? uuid;

  final bool? rea;

  final bool? partitaIVA;

  final bool? sdi;

  final bool? soggettoUuid;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoLegaleRappresentanteArgs>?
      legaleRappresentante;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoReferenteArgs>? referente;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoSoggettoArgs>? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoSelect({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
    this.$count,
  });

  final bool? uuid;

  final bool? ragioneSociale;

  final bool? iban;

  final bool? tipo;

  final bool? negozioPreferitoUuid;

  final bool? codiceFiscale;

  final bool? note;

  final _i1.PrismaUnion<bool, _i2.SoggettoSoggettoBusinessInfoArgs>?
      soggettoBusinessInfo;

  final _i1.PrismaUnion<bool, _i2.SoggettoDomiciliArgs>? domicili;

  final _i1.PrismaUnion<bool, _i2.SoggettoPraticheIntestateArgs>?
      praticheIntestate;

  final _i1.PrismaUnion<bool, _i2.SoggettoContrattiArgs>? contratti;

  final _i1.PrismaUnion<bool, _i2.SoggettoIndirizziEmailArgs>? indirizziEmail;

  final _i1.PrismaUnion<bool, _i2.SoggettoNumeriTelefonoArgs>? numeriTelefono;

  final _i1.PrismaUnion<bool, _i2.SoggettoNegozioPreferitoArgs>?
      negozioPreferito;

  final _i1.PrismaUnion<bool, _i2.SoggettoProdottiOrdinatiArgs>?
      prodottiOrdinati;

  final _i1.PrismaUnion<bool, _i2.SoggettoLeadsArgs>? leads;

  final _i1.PrismaUnion<bool, _i2.SoggettoPrivacyArgs>? privacy;

  final _i1.PrismaUnion<bool, _i2.SoggettoCountArgs>? $count;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
        '_count': $count,
      };
}

class ConsumoAnnuoLuceCreateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCreateWithoutFornituraLuceInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoLuceWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceWhereUniqueInput({
    this.uuid,
    this.fornituraLuceUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuce,
  });

  final String? uuid;

  final String? fornituraLuceUuid;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput,
      Iterable<_i2.ConsumoAnnuoLuceWhereInput>>? AND;

  final Iterable<_i2.ConsumoAnnuoLuceWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput,
      Iterable<_i2.ConsumoAnnuoLuceWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? consumo;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<_i2.FornituraLuceRelationFilter,
      _i2.FornituraLuceWhereInput>? fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuceUuid': fornituraLuceUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuce': fornituraLuce,
      };
}

class ConsumoAnnuoLuceCreateOrConnectWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCreateOrConnectWithoutFornituraLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsumoAnnuoLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceCreateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ConsumoAnnuoLuceCreateNestedOneWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCreateNestedOneWithoutFornituraLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceCreateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput>? create;

  final _i2.ConsumoAnnuoLuceCreateOrConnectWithoutFornituraLuceInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoLuceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ClasseMisuratoreGasCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCreateWithoutFornituraGasInput({
    required this.portataMin,
    required this.portataNominale,
    required this.portataMax,
    required this.id,
    required this.classe,
  });

  final double portataMin;

  final double portataNominale;

  final double portataMax;

  final String id;

  final String classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasUncheckedCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUncheckedCreateWithoutFornituraGasInput({
    required this.portataMin,
    required this.portataNominale,
    required this.portataMax,
    required this.id,
    required this.classe,
  });

  final double portataMin;

  final double portataNominale;

  final double portataMax;

  final String id;

  final String classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasWhereUniqueInput({
    this.id,
    this.classe,
    this.AND,
    this.OR,
    this.NOT,
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.fornituraGas,
  });

  final String? id;

  final String? classe;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput,
      Iterable<_i2.ClasseMisuratoreGasWhereInput>>? AND;

  final Iterable<_i2.ClasseMisuratoreGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasWhereInput,
      Iterable<_i2.ClasseMisuratoreGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? portataMin;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? portataNominale;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? portataMax;

  final _i2.FornituraGasListRelationFilter? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'classe': classe,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'fornituraGas': fornituraGas,
      };
}

class ClasseMisuratoreGasCreateOrConnectWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCreateOrConnectWithoutFornituraGasInput({
    required this.where,
    required this.create,
  });

  final _i2.ClasseMisuratoreGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasCreateWithoutFornituraGasInput,
      _i2.ClasseMisuratoreGasUncheckedCreateWithoutFornituraGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ClasseMisuratoreGasCreateNestedOneWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCreateNestedOneWithoutFornituraGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasCreateWithoutFornituraGasInput,
      _i2.ClasseMisuratoreGasUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.ClasseMisuratoreGasCreateOrConnectWithoutFornituraGasInput?
      connectOrCreate;

  final _i2.ClasseMisuratoreGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ConsumoAnnuoGasCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCreateWithoutFornituraGasInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoGasWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasWhereUniqueInput({
    this.uuid,
    this.fornituraGasUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGas,
  });

  final String? uuid;

  final String? fornituraGasUuid;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput,
      Iterable<_i2.ConsumoAnnuoGasWhereInput>>? AND;

  final Iterable<_i2.ConsumoAnnuoGasWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasWhereInput,
      Iterable<_i2.ConsumoAnnuoGasWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? consumo;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>?
      meseRiferimentoConsumoAnnuo;

  final _i1
      .PrismaUnion<_i2.FornituraGasRelationFilter, _i2.FornituraGasWhereInput>?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGasUuid': fornituraGasUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGas': fornituraGas,
      };
}

class ConsumoAnnuoGasCreateOrConnectWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCreateOrConnectWithoutFornituraGasInput({
    required this.where,
    required this.create,
  });

  final _i2.ConsumoAnnuoGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasCreateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ConsumoAnnuoGasCreateNestedOneWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCreateNestedOneWithoutFornituraGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasCreateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.ConsumoAnnuoGasCreateOrConnectWithoutFornituraGasInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReferenteCreateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoCreateNestedOneWithoutReferenteInput? numeroTelefono;

  final _i2.IndirizzoEmailCreateNestedOneWithoutReferenteInput? indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class NumeroTelefonoUncheckedCreateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateWithoutReferenteInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentateUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
      };
}

class NumeroTelefonoCreateOrConnectWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateOrConnectWithoutReferenteInput({
    required this.where,
    required this.create,
  });

  final _i2.NumeroTelefonoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutReferenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NumeroTelefonoUncheckedCreateNestedOneWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateNestedOneWithoutReferenteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutReferenteInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IndirizzoEmailUncheckedCreateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateWithoutReferenteInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentanteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
      };
}

class IndirizzoEmailCreateOrConnectWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateOrConnectWithoutReferenteInput({
    required this.where,
    required this.create,
  });

  final _i2.IndirizzoEmailWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutReferenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class IndirizzoEmailUncheckedCreateNestedOneWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateNestedOneWithoutReferenteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutReferenteInput>? create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoUncheckedCreateNestedOneWithoutReferenteInput?
      numeroTelefono;

  final _i2.IndirizzoEmailUncheckedCreateNestedOneWithoutReferenteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class ReferenteWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteWhereUniqueInput({
    this.uuid,
    this.soggettoBusinessInfoUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String? soggettoBusinessInfoUuid;

  final _i1
      .PrismaUnion<_i2.ReferenteWhereInput, Iterable<_i2.ReferenteWhereInput>>?
      AND;

  final Iterable<_i2.ReferenteWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ReferenteWhereInput, Iterable<_i2.ReferenteWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? cognome;

  final _i1.PrismaUnion<_i2.NumeroTelefonoNullableRelationFilter,
          _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput, _i1.PrismaNull>>?
      numeroTelefono;

  final _i1.PrismaUnion<_i2.IndirizzoEmailNullableRelationFilter,
          _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput, _i1.PrismaNull>>?
      indirizzoEmail;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoRelationFilter,
      _i2.SoggettoBusinessInfoWhereInput>? soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteCreateOrConnectWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateOrConnectWithoutSoggettoBusinessInfoInput({
    required this.where,
    required this.create,
  });

  final _i2.ReferenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ReferenteCreateNestedOneWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateNestedOneWithoutSoggettoBusinessInfoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.ReferenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProduttoreCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCreateWithoutProdottiInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreUncheckedCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUncheckedCreateWithoutProdottiInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.prodotti,
  });

  final String? id;

  final String? nome;

  final _i1.PrismaUnion<_i2.ProduttoreWhereInput,
      Iterable<_i2.ProduttoreWhereInput>>? AND;

  final Iterable<_i2.ProduttoreWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProduttoreWhereInput,
      Iterable<_i2.ProduttoreWhereInput>>? NOT;

  final _i2.ProdottoListRelationFilter? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'prodotti': prodotti,
      };
}

class ProduttoreCreateOrConnectWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCreateOrConnectWithoutProdottiInput({
    required this.where,
    required this.create,
  });

  final _i2.ProduttoreWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProduttoreCreateWithoutProdottiInput,
      _i2.ProduttoreUncheckedCreateWithoutProdottiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProduttoreCreateNestedOneWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCreateNestedOneWithoutProdottiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ProduttoreCreateWithoutProdottiInput,
      _i2.ProduttoreUncheckedCreateWithoutProdottiInput>? create;

  final _i2.ProduttoreCreateOrConnectWithoutProdottiInput? connectOrCreate;

  final _i2.ProduttoreWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelLuceCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateWithoutOffertaInput({
    this.uuid,
    required this.stato,
    required this.fornituraLuce,
    required this.contratto,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelLuceInput stato;

  final _i2.FornituraLuceCreateNestedOneWithoutContrattiEnelLuceInput
      fornituraLuce;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelLuceInput contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
      };
}

class ContrattoEnelLuceUncheckedCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateWithoutOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraLuceUuid,
    required this.contrattoUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraLuceUuid;

  final String contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelLuceCreateOrConnectWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateOrConnectWithoutOffertaInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutOffertaInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelLuceCreateManyOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraLuceUuid,
    required this.contrattoUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraLuceUuid;

  final String contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelLuceCreateManyOffertaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyOffertaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateManyOffertaInput,
      Iterable<_i2.ContrattoEnelLuceCreateManyOffertaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelLuceCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelGasCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateWithoutOffertaInput({
    this.uuid,
    required this.stato,
    required this.fornituraGas,
    required this.contratto,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelGasInput stato;

  final _i2.FornituraGasCreateNestedOneWithoutContrattiEnelGasInput
      fornituraGas;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelGasInput contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
      };
}

class ContrattoEnelGasUncheckedCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateWithoutOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraGasUuid,
    required this.contrattoUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraGasUuid;

  final String contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelGasCreateOrConnectWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateOrConnectWithoutOffertaInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutOffertaInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelGasCreateManyOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraGasUuid,
    required this.contrattoUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraGasUuid;

  final String contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelGasCreateManyOffertaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyOffertaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateManyOffertaInput,
      Iterable<_i2.ContrattoEnelGasCreateManyOffertaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelGasCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ZonaNegozioCreateWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCreateWithoutNegoziInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioUncheckedCreateWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUncheckedCreateWithoutNegoziInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.negozi,
  });

  final String? id;

  final String? nome;

  final _i1.PrismaUnion<_i2.ZonaNegozioWhereInput,
      Iterable<_i2.ZonaNegozioWhereInput>>? AND;

  final Iterable<_i2.ZonaNegozioWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ZonaNegozioWhereInput,
      Iterable<_i2.ZonaNegozioWhereInput>>? NOT;

  final _i2.NegozioListRelationFilter? negozi;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'negozi': negozi,
      };
}

class ZonaNegozioCreateOrConnectWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCreateOrConnectWithoutNegoziInput({
    required this.where,
    required this.create,
  });

  final _i2.ZonaNegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ZonaNegozioCreateWithoutNegoziInput,
      _i2.ZonaNegozioUncheckedCreateWithoutNegoziInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ZonaNegozioCreateNestedOneWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCreateNestedOneWithoutNegoziInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ZonaNegozioCreateWithoutNegoziInput,
      _i2.ZonaNegozioUncheckedCreateWithoutNegoziInput>? create;

  final _i2.ZonaNegozioCreateOrConnectWithoutNegoziInput? connectOrCreate;

  final _i2.ZonaNegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PrivacyCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCreateWithoutSoggettoInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
  });

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
      };
}

class PrivacyUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
  });

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
      };
}

class PrivacyWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyWhereUniqueInput({
    this.uuid,
    this.soggettoUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggetto,
  });

  final String? uuid;

  final String? soggettoUuid;

  final _i1.PrismaUnion<_i2.PrivacyWhereInput, Iterable<_i2.PrivacyWhereInput>>?
      AND;

  final Iterable<_i2.PrivacyWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PrivacyWhereInput, Iterable<_i2.PrivacyWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? trattamento;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? comunicazione;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? profilazione;

  final _i1.PrismaUnion<_i2.SoggettoNullableRelationFilter,
      _i1.PrismaUnion<_i2.SoggettoWhereInput, _i1.PrismaNull>>? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoUuid': soggettoUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggetto': soggetto,
      };
}

class PrivacyCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.PrivacyWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PrivacyCreateWithoutSoggettoInput,
      _i2.PrivacyUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PrivacyCreateNestedOneWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCreateNestedOneWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.PrivacyCreateWithoutSoggettoInput,
      _i2.PrivacyUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.PrivacyCreateOrConnectWithoutSoggettoInput? connectOrCreate;

  final _i2.PrivacyWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutLeadsInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'privacy': privacy,
      };
}

class NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoCreateOrConnectWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateOrConnectWithoutLegaleRappresentateInput({
    required this.where,
    required this.create,
  });

  final _i2.NumeroTelefonoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NumeroTelefonoUncheckedCreateNestedOneWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateNestedOneWithoutLegaleRappresentateInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutLegaleRappresentateInput?
      connectOrCreate;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailCreateOrConnectWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateOrConnectWithoutLegaleRappresentanteInput({
    required this.where,
    required this.create,
  });

  final _i2.IndirizzoEmailWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailCreateWithoutLegaleRappresentanteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class IndirizzoEmailUncheckedCreateNestedOneWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateNestedOneWithoutLegaleRappresentanteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutLegaleRappresentanteInput,
          _i2.IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput>?
      create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutLegaleRappresentanteInput?
      connectOrCreate;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2
      .NumeroTelefonoUncheckedCreateNestedOneWithoutLegaleRappresentateInput?
      numeroTelefono;

  final _i2
      .IndirizzoEmailUncheckedCreateNestedOneWithoutLegaleRappresentanteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteWhereUniqueInput({
    this.uuid,
    this.soggettoBusinessInfoUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String? soggettoBusinessInfoUuid;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput,
      Iterable<_i2.LegaleRappresentanteWhereInput>>? AND;

  final Iterable<_i2.LegaleRappresentanteWhereInput>? OR;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput,
      Iterable<_i2.LegaleRappresentanteWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? cognome;

  final _i1.PrismaUnion<_i2.NumeroTelefonoNullableRelationFilter,
          _i1.PrismaUnion<_i2.NumeroTelefonoWhereInput, _i1.PrismaNull>>?
      numeroTelefono;

  final _i1.PrismaUnion<_i2.IndirizzoEmailNullableRelationFilter,
          _i1.PrismaUnion<_i2.IndirizzoEmailWhereInput, _i1.PrismaNull>>?
      indirizzoEmail;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoRelationFilter,
      _i2.SoggettoBusinessInfoWhereInput>? soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteCreateOrConnectWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateOrConnectWithoutSoggettoBusinessInfoInput({
    required this.where,
    required this.create,
  });

  final _i2.LegaleRappresentanteWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LegaleRappresentanteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReferenteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.ReferenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final _i2
      .LegaleRappresentanteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput?
      legaleRappresentante;

  final _i2.ReferenteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput?
      referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
      };
}

class SoggettoBusinessInfoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoWhereUniqueInput({
    this.uuid,
    this.partitaIVA,
    this.soggettoUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.rea,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
    this.soggetto,
  });

  final String? uuid;

  final String? partitaIVA;

  final String? soggettoUuid;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput,
      Iterable<_i2.SoggettoBusinessInfoWhereInput>>? AND;

  final Iterable<_i2.SoggettoBusinessInfoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoWhereInput,
      Iterable<_i2.SoggettoBusinessInfoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteNullableRelationFilter,
          _i1.PrismaUnion<_i2.LegaleRappresentanteWhereInput, _i1.PrismaNull>>?
      legaleRappresentante;

  final _i1.PrismaUnion<_i2.ReferenteNullableRelationFilter,
      _i1.PrismaUnion<_i2.ReferenteWhereInput, _i1.PrismaNull>>? referente;

  final _i1.PrismaUnion<_i2.SoggettoRelationFilter, _i2.SoggettoWhereInput>?
      soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'partitaIVA': partitaIVA,
        'soggettoUuid': soggettoUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'rea': rea,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoBusinessInfoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutSoggettoInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneCreateManyDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyDomicilioInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateManyDomicilioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyDomicilioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneCreateManyDomicilioInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneCreateManyDomicilioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyDomicilioInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ConsumoAnnuoLuceUncheckedCreateNestedOneWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedCreateNestedOneWithoutFornituraLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceCreateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput>? create;

  final _i2.ConsumoAnnuoLuceCreateOrConnectWithoutFornituraLuceInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoLuceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelLuceCreateManyFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyFornituraLuceInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateManyFornituraLuceInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyFornituraLuceInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateManyFornituraLuceInput,
      Iterable<_i2.ContrattoEnelLuceCreateManyFornituraLuceInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelLuceUncheckedCreateNestedManyWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateNestedManyWithoutFornituraLuceInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput,
          Iterable<
              _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyFornituraLuceInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornituraLuceUncheckedCreateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedCreateWithoutFornituraInput({
    this.uuid,
    required this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
  });

  final String? uuid;

  final String pod;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ConsumoAnnuoLuceUncheckedCreateNestedOneWithoutFornituraLuceInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutFornituraLuceInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceWhereUniqueInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    this.fornitura,
  });

  final String? uuid;

  final String? pod;

  final String? fornituraUuid;

  final _i1.PrismaUnion<_i2.FornituraLuceWhereInput,
      Iterable<_i2.FornituraLuceWhereInput>>? AND;

  final Iterable<_i2.FornituraLuceWhereInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraLuceWhereInput,
      Iterable<_i2.FornituraLuceWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? tensione;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceNullableRelationFilter,
          _i1.PrismaUnion<_i2.ConsumoAnnuoLuceWhereInput, _i1.PrismaNull>>?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceListRelationFilter? contrattiEnelLuce;

  final _i1.PrismaUnion<_i2.FornituraRelationFilter, _i2.FornituraWhereInput>?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceCreateOrConnectWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateOrConnectWithoutFornituraInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedCreateWithoutFornituraInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraLuceUncheckedCreateNestedOneWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedCreateNestedOneWithoutFornituraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ConsumoAnnuoGasUncheckedCreateNestedOneWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedCreateNestedOneWithoutFornituraGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasCreateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.ConsumoAnnuoGasCreateOrConnectWithoutFornituraGasInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutFornituraGasInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelGasCreateManyFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyFornituraGasInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateManyFornituraGasInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyFornituraGasInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateManyFornituraGasInput,
      Iterable<_i2.ContrattoEnelGasCreateManyFornituraGasInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelGasUncheckedCreateNestedManyWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateNestedManyWithoutFornituraGasInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutFornituraGasInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutFornituraGasInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput,
          Iterable<
              _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyFornituraGasInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornituraGasUncheckedCreateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateWithoutFornituraInput({
    this.uuid,
    required this.pdr,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final String? uuid;

  final String pdr;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classeMisuratoreGasId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ConsumoAnnuoGasUncheckedCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasCreateOrConnectWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateOrConnectWithoutFornituraInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutFornituraInput,
      _i2.FornituraGasUncheckedCreateWithoutFornituraInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraGasUncheckedCreateNestedOneWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateNestedOneWithoutFornituraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutFornituraInput,
      _i2.FornituraGasUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraUncheckedCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateWithoutDomicilioInput({
    this.uuid,
    this.etichetta,
    required this.servizioEwoId,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String servizioEwoId;

  final _i2.FornituraLuceUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraLuce;

  final _i2.FornituraGasUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'servizioEwoId': servizioEwoId,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraCreateOrConnectWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateOrConnectWithoutDomicilioInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutDomicilioInput,
      _i2.FornituraUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraCreateManyDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateManyDomicilioInput({
    this.uuid,
    this.etichetta,
    required this.servizioEwoId,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraCreateManyDomicilioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateManyDomicilioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.FornituraCreateManyDomicilioInput,
      Iterable<_i2.FornituraCreateManyDomicilioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class FornituraUncheckedCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.FornituraCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.FornituraCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<
              _i2.FornituraUncheckedCreateWithoutDomicilioInput,
              Iterable<
                  _i2.FornituraUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.FornituraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PraticaCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateWithoutContrattoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    required this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaCreateNestedOneWithoutPraticheInput tipoPratica;

  final _i2.SoggettoCreateNestedOneWithoutPraticheIntestateInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutPraticheInput? utente;

  final _i2.NegozioCreateNestedOneWithoutPraticheInput? negozio;

  final _i2.StatoPraticaCreateNestedOneWithoutPraticheInput? stato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
      };
}

class PraticaUncheckedCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateWithoutContrattoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCreateOrConnectWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateOrConnectWithoutContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutContrattoInput,
      _i2.PraticaUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PraticaCreateNestedOneWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateNestedOneWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutContrattoInput,
      _i2.PraticaUncheckedCreateWithoutContrattoInput>? create;

  final _i2.PraticaCreateOrConnectWithoutContrattoInput? connectOrCreate;

  final _i2.PraticaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutModuloInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
      };
}

class ContrattoEnelLuceUncheckedCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateWithoutContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraLuceUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateOrConnectWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateOrConnectWithoutContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutContrattoInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelLuceCreateManyContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraLuceUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateManyContrattoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyContrattoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateManyContrattoInput,
      Iterable<_i2.ContrattoEnelLuceCreateManyContrattoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelGasUncheckedCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateWithoutContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraGasUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraGasUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateOrConnectWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateOrConnectWithoutContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutContrattoInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelGasCreateManyContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraGasUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraGasUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateManyContrattoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyContrattoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateManyContrattoInput,
      Iterable<_i2.ContrattoEnelGasCreateManyContrattoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelFibraUncheckedCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateWithoutContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateOrConnectWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateOrConnectWithoutContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutContrattoInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelFibraCreateManyContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateManyContrattoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyContrattoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateManyContrattoInput,
      Iterable<_i2.ContrattoEnelFibraCreateManyContrattoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneCreateManyContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyContrattoInput({
    this.uuid,
    required this.statoContrattoId,
    required this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateManyContrattoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyContrattoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneCreateManyContrattoInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneCreateManyContrattoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyContrattoInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoUncheckedCreateWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutModuloInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutModuloInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutModuloInput,
      _i2.ContrattoUncheckedCreateWithoutModuloInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateManyModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyModuloInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
      };
}

class ContrattoCreateManyModuloInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyModuloInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateManyModuloInput,
      Iterable<_i2.ContrattoCreateManyModuloInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoCreateNestedManyWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedManyWithoutModuloInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutModuloInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutModuloInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutModuloInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutModuloInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutModuloInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutDomicilioInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelFibraCreateManyDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyDomicilioInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateManyDomicilioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyDomicilioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateManyDomicilioInput,
      Iterable<_i2.ContrattoEnelFibraCreateManyDomicilioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoOpportunitaCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCreateWithoutLeadsInput({
    this.uuid,
    required this.nome,
    this.tipoStato,
    this.ordine,
    required this.colore,
    required this.opportunitaUuid,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>? tipoStato;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? ordine;

  final String colore;

  final String opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaUncheckedCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUncheckedCreateWithoutLeadsInput({
    this.uuid,
    required this.nome,
    this.tipoStato,
    this.ordine,
    required this.colore,
    required this.opportunitaUuid,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>? tipoStato;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? ordine;

  final String colore;

  final String opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaWhereUniqueInput({
    this.uuid,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<_i2.StatoOpportunitaWhereInput,
      Iterable<_i2.StatoOpportunitaWhereInput>>? AND;

  final Iterable<_i2.StatoOpportunitaWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoOpportunitaWhereInput,
      Iterable<_i2.StatoOpportunitaWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.EnumTipoStatoNullableFilter,
      _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>>? tipoStato;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      ordine;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? opportunitaUuid;

  final _i2.LeadListRelationFilter? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
      };
}

class StatoOpportunitaCreateOrConnectWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCreateOrConnectWithoutLeadsInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoOpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoOpportunitaCreateWithoutLeadsInput,
      _i2.StatoOpportunitaUncheckedCreateWithoutLeadsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoOpportunitaCreateNestedOneWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCreateNestedOneWithoutLeadsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoOpportunitaCreateWithoutLeadsInput,
      _i2.StatoOpportunitaUncheckedCreateWithoutLeadsInput>? create;

  final _i2.StatoOpportunitaCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.StatoOpportunitaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class DomicilioCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateWithoutLeadsInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.SoggettoCreateNestedOneWithoutDomiciliInput soggetto;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineCreateNestedManyWithoutDomicilioInput? prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoUncheckedCreateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateWithoutProdottiOrdinatiInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.fornitoreId,
    required this.tipoProdottoId,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String fornitoreId;

  final String tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoCreateOrConnectWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateOrConnectWithoutProdottiOrdinatiInput({
    required this.where,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutProdottiOrdinatiInput,
      _i2.ProdottoUncheckedCreateWithoutProdottiOrdinatiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutProdottiOrdinatiInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutProdottiOrdinatiInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutProdottiOrdinatiInput,
                  Iterable<
                      _i2
                      .ProdottoUncheckedCreateWithoutProdottiOrdinatiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrdineUncheckedCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutDomicilioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineCreateOrConnectWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutDomicilioInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutDomicilioInput,
      _i2.OrdineUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateManyDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyDomicilioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCreateManyDomicilioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyDomicilioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OrdineCreateManyDomicilioInput,
      Iterable<_i2.OrdineCreateManyDomicilioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OrdineUncheckedCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutDomicilioInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.OrdineCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioUncheckedCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateWithoutLeadsInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedCreateNestedManyWithoutDomicilioInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class DomicilioCreateOrConnectWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateOrConnectWithoutLeadsInput({
    required this.where,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutLeadsInput,
      _i2.DomicilioUncheckedCreateWithoutLeadsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DomicilioCreateNestedOneWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateNestedOneWithoutLeadsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutLeadsInput,
      _i2.DomicilioUncheckedCreateWithoutLeadsInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.DomicilioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class StatoOrdineCreateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCreateWithoutOrdiniInput({
    required this.id,
    required this.nome,
    required this.tipoStato,
    required this.ordine,
    required this.colore,
  });

  final String id;

  final String nome;

  final _i3.TipoStato tipoStato;

  final int ordine;

  final String colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineUncheckedCreateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUncheckedCreateWithoutOrdiniInput({
    required this.id,
    required this.nome,
    required this.tipoStato,
    required this.ordine,
    required this.colore,
  });

  final String id;

  final String nome;

  final _i3.TipoStato tipoStato;

  final int ordine;

  final String colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.ordini,
  });

  final String? id;

  final _i1.PrismaUnion<_i2.StatoOrdineWhereInput,
      Iterable<_i2.StatoOrdineWhereInput>>? AND;

  final Iterable<_i2.StatoOrdineWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoOrdineWhereInput,
      Iterable<_i2.StatoOrdineWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.EnumTipoStatoFilter, _i3.TipoStato>? tipoStato;

  final _i1.PrismaUnion<_i2.IntFilter, int>? ordine;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i2.OrdineListRelationFilter? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
      };
}

class StatoOrdineCreateOrConnectWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCreateOrConnectWithoutOrdiniInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoOrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoOrdineCreateWithoutOrdiniInput,
      _i2.StatoOrdineUncheckedCreateWithoutOrdiniInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoOrdineCreateNestedOneWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCreateNestedOneWithoutOrdiniInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineCreateWithoutOrdiniInput,
      _i2.StatoOrdineUncheckedCreateWithoutOrdiniInput>? create;

  final _i2.StatoOrdineCreateOrConnectWithoutOrdiniInput? connectOrCreate;

  final _i2.StatoOrdineWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OpportunitaCreateWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateWithoutAgentiInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.LeadCreateNestedManyWithoutOpportunitaInput? leads;

  final _i2.UtenteCreateNestedManyWithoutOpportunitaGestiteInput? gestoriLead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
      };
}

class OrdineUncheckedCreateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutLeadInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    required this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineCreateOrConnectWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutLeadInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutLeadInput,
      _i2.OrdineUncheckedCreateWithoutLeadInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateManyLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyLeadInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    required this.utenteUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCreateManyLeadInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyLeadInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OrdineCreateManyLeadInput,
      Iterable<_i2.OrdineCreateManyLeadInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OrdineUncheckedCreateNestedManyWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutLeadInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutLeadInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutLeadInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i2.OrdineCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class HistoryCommentCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCreateWithoutHistoryInput({required this.comment});

  final String comment;

  @override
  Map<String, dynamic> toJson() => {'comment': comment};
}

class HistoryCommentUncheckedCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedCreateWithoutHistoryInput(
      {required this.comment});

  final String comment;

  @override
  Map<String, dynamic> toJson() => {'comment': comment};
}

class HistoryCommentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentWhereUniqueInput({
    this.historyUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.comment,
    this.history,
  });

  final String? historyUuid;

  final _i1.PrismaUnion<_i2.HistoryCommentWhereInput,
      Iterable<_i2.HistoryCommentWhereInput>>? AND;

  final Iterable<_i2.HistoryCommentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryCommentWhereInput,
      Iterable<_i2.HistoryCommentWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? comment;

  final _i1.PrismaUnion<_i2.HistoryRelationFilter, _i2.HistoryWhereInput>?
      history;

  @override
  Map<String, dynamic> toJson() => {
        'historyUuid': historyUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'comment': comment,
        'History': history,
      };
}

class HistoryCommentCreateOrConnectWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCreateOrConnectWithoutHistoryInput({
    required this.where,
    required this.create,
  });

  final _i2.HistoryCommentWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryCommentCreateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedCreateWithoutHistoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class HistoryCommentCreateNestedOneWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCreateNestedOneWithoutHistoryInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentCreateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryCommentCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.HistoryCommentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryAttachmentCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCreateWithoutHistoryInput({
    required this.url,
    required this.name,
  });

  final String url;

  final String name;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
      };
}

class HistoryAttachmentUncheckedCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedCreateWithoutHistoryInput({
    required this.url,
    required this.name,
  });

  final String url;

  final String name;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
      };
}

class HistoryAttachmentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentWhereUniqueInput({
    this.historyUuid,
    this.AND,
    this.OR,
    this.NOT,
    this.url,
    this.name,
    this.history,
  });

  final String? historyUuid;

  final _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput,
      Iterable<_i2.HistoryAttachmentWhereInput>>? AND;

  final Iterable<_i2.HistoryAttachmentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryAttachmentWhereInput,
      Iterable<_i2.HistoryAttachmentWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? url;

  final _i1.PrismaUnion<_i2.StringFilter, String>? name;

  final _i1.PrismaUnion<_i2.HistoryRelationFilter, _i2.HistoryWhereInput>?
      history;

  @override
  Map<String, dynamic> toJson() => {
        'historyUuid': historyUuid,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'url': url,
        'name': name,
        'History': history,
      };
}

class HistoryAttachmentCreateOrConnectWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCreateOrConnectWithoutHistoryInput({
    required this.where,
    required this.create,
  });

  final _i2.HistoryAttachmentWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryAttachmentCreateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedCreateWithoutHistoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class HistoryAttachmentCreateNestedOneWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCreateNestedOneWithoutHistoryInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentCreateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryAttachmentCreateOrConnectWithoutHistoryInput?
      connectOrCreate;

  final _i2.HistoryAttachmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryCommentUncheckedCreateNestedOneWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedCreateNestedOneWithoutHistoryInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentCreateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryCommentCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.HistoryCommentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryAttachmentUncheckedCreateNestedOneWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedCreateNestedOneWithoutHistoryInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentCreateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryAttachmentCreateOrConnectWithoutHistoryInput?
      connectOrCreate;

  final _i2.HistoryAttachmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryUncheckedCreateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateWithoutLeadInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    required this.utenteUuid,
    this.comment,
    this.attachment,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final String utenteUuid;

  final _i2.HistoryCommentUncheckedCreateNestedOneWithoutHistoryInput? comment;

  final _i2.HistoryAttachmentUncheckedCreateNestedOneWithoutHistoryInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'comment': comment,
        'attachment': attachment,
      };
}

class HistoryCreateOrConnectWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateOrConnectWithoutLeadInput({
    required this.where,
    required this.create,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutLeadInput,
      _i2.HistoryUncheckedCreateWithoutLeadInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class HistoryCreateManyLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateManyLeadInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    required this.utenteUuid,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final String utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
      };
}

class HistoryCreateManyLeadInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateManyLeadInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.HistoryCreateManyLeadInput,
      Iterable<_i2.HistoryCreateManyLeadInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class HistoryCreateNestedManyWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateNestedManyWithoutLeadInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutLeadInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutLeadInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i2.HistoryCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadCreateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutOrdineInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'history': history,
      };
}

class LeadUncheckedCreateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutOrdineInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutOrdineInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutOrdineInput,
      _i2.LeadUncheckedCreateWithoutOrdineInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateNestedOneWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedOneWithoutOrdineInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.LeadCreateWithoutOrdineInput,
      _i2.LeadUncheckedCreateWithoutOrdineInput>? create;

  final _i2.LeadCreateOrConnectWithoutOrdineInput? connectOrCreate;

  final _i2.LeadWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class NegozioCreateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutOrdineInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    required this.zonaNegozio,
    this.ingressi,
    this.leads,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
      };
}

class TipoModuloContrattoCreateWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCreateWithoutModuloContrattoInput({
    required this.id,
    required this.nome,
    required this.numeroOfferteCollegabili,
  });

  final String id;

  final String nome;

  final int numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoUncheckedCreateWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUncheckedCreateWithoutModuloContrattoInput({
    required this.id,
    required this.nome,
    required this.numeroOfferteCollegabili,
  });

  final String id;

  final String nome;

  final int numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.nome,
    this.numeroOfferteCollegabili,
    this.moduloContratto,
  });

  final String? id;

  final _i1.PrismaUnion<_i2.TipoModuloContrattoWhereInput,
      Iterable<_i2.TipoModuloContrattoWhereInput>>? AND;

  final Iterable<_i2.TipoModuloContrattoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoModuloContrattoWhereInput,
      Iterable<_i2.TipoModuloContrattoWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.IntFilter, int>? numeroOfferteCollegabili;

  final _i2.ModuloContrattoListRelationFilter? moduloContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
      };
}

class TipoModuloContrattoCreateOrConnectWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCreateOrConnectWithoutModuloContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.TipoModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.TipoModuloContrattoCreateWithoutModuloContrattoInput,
      _i2.TipoModuloContrattoUncheckedCreateWithoutModuloContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class TipoModuloContrattoCreateNestedOneWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCreateNestedOneWithoutModuloContrattoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.TipoModuloContrattoCreateWithoutModuloContrattoInput,
          _i2.TipoModuloContrattoUncheckedCreateWithoutModuloContrattoInput>?
      create;

  final _i2.TipoModuloContrattoCreateOrConnectWithoutModuloContrattoInput?
      connectOrCreate;

  final _i2.TipoModuloContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ModuloContrattoCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateWithoutContrattiInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    this.serviziEwoCollegabili,
    required this.fornitore,
    required this.tipoModulo,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final _i2.ServizioEwoCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.FornitoreCreateNestedOneWithoutModuliContrattoInput fornitore;

  final _i2.TipoModuloContrattoCreateNestedOneWithoutModuloContrattoInput
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class PraticaUncheckedCreateWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateWithoutTipoPraticaInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaCreateOrConnectWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateOrConnectWithoutTipoPraticaInput({
    required this.where,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutTipoPraticaInput,
      _i2.PraticaUncheckedCreateWithoutTipoPraticaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PraticaCreateManyTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyTipoPraticaInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCreateManyTipoPraticaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyTipoPraticaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateManyTipoPraticaInput,
      Iterable<_i2.PraticaCreateManyTipoPraticaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class PraticaUncheckedCreateNestedManyWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateNestedManyWithoutTipoPraticaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutTipoPraticaInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutTipoPraticaInput>,
          _i1.PrismaUnion<
              _i2.PraticaUncheckedCreateWithoutTipoPraticaInput,
              Iterable<
                  _i2.PraticaUncheckedCreateWithoutTipoPraticaInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput>>?
      connectOrCreate;

  final _i2.PraticaCreateManyTipoPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class TipoPraticaUncheckedCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.pratiche,
  });

  final String id;

  final String nome;

  final _i2.PraticaUncheckedCreateNestedManyWithoutTipoPraticaInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class TipoPraticaCreateOrConnectWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateOrConnectWithoutServiziEwoInput({
    required this.where,
    required this.create,
  });

  final _i2.TipoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateWithoutServiziEwoInput,
      _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.TipoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.TipoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraUncheckedCreateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateWithoutServizioEwoInput({
    this.uuid,
    this.etichetta,
    required this.domicilioUuid,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String domicilioUuid;

  final _i2.FornituraLuceUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraLuce;

  final _i2.FornituraGasUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraCreateOrConnectWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateOrConnectWithoutServizioEwoInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutServizioEwoInput,
      _i2.FornituraUncheckedCreateWithoutServizioEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraCreateManyServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateManyServizioEwoInput({
    this.uuid,
    this.etichetta,
    required this.domicilioUuid,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
      };
}

class FornituraCreateManyServizioEwoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateManyServizioEwoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.FornituraCreateManyServizioEwoInput,
      Iterable<_i2.FornituraCreateManyServizioEwoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class FornituraUncheckedCreateNestedManyWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateNestedManyWithoutServizioEwoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.FornituraCreateWithoutServizioEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraCreateWithoutServizioEwoInput>,
              _i1.PrismaUnion<
                  _i2.FornituraUncheckedCreateWithoutServizioEwoInput,
                  Iterable<
                      _i2.FornituraUncheckedCreateWithoutServizioEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i2.FornituraCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PraticaUncheckedCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateWithoutStatoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaCreateOrConnectWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateOrConnectWithoutStatoInput({
    required this.where,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutStatoInput,
      _i2.PraticaUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PraticaCreateManyStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyStatoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCreateManyStatoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyStatoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateManyStatoInput,
      Iterable<_i2.PraticaCreateManyStatoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class PraticaUncheckedCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutStatoInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutStatoInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutStatoInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutStatoInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutStatoInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i2.PraticaCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoPraticaUncheckedCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.pratiche,
  });

  final String id;

  final String nome;

  final _i2.PraticaUncheckedCreateNestedManyWithoutStatoInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class StatoPraticaCreateOrConnectWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateOrConnectWithoutServiziEwoInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateWithoutServiziEwoInput,
      _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.StatoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoUncheckedCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutStatoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutStatoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutStatoInput,
      _i2.ContrattoUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateManyStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyStatoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCreateManyStatoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyStatoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateManyStatoInput,
      Iterable<_i2.ContrattoCreateManyStatoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoUncheckedCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutStatoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutStatoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutStatoInput,
      Iterable<_i2.ContrattoCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i2.ContrattoCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelLuceUncheckedCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateWithoutStatoInput({
    this.uuid,
    required this.fornituraLuceUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String fornituraLuceUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateOrConnectWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateOrConnectWithoutStatoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutStatoInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelLuceCreateManyStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyStatoInput({
    this.uuid,
    required this.fornituraLuceUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String fornituraLuceUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateManyStatoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyStatoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateManyStatoInput,
      Iterable<_i2.ContrattoEnelLuceCreateManyStatoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelGasUncheckedCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateWithoutStatoInput({
    this.uuid,
    required this.fornituraGasUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String fornituraGasUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateOrConnectWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateOrConnectWithoutStatoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutStatoInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelGasCreateManyStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyStatoInput({
    this.uuid,
    required this.fornituraGasUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String fornituraGasUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateManyStatoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyStatoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateManyStatoInput,
      Iterable<_i2.ContrattoEnelGasCreateManyStatoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelFibraUncheckedCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateWithoutStatoInput({
    this.uuid,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateOrConnectWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateOrConnectWithoutStatoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutStatoInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelFibraCreateManyStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyStatoInput({
    this.uuid,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateManyStatoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyStatoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateManyStatoInput,
      Iterable<_i2.ContrattoEnelFibraCreateManyStatoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput({
    this.uuid,
    required this.contrattoUuid,
    required this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String contrattoUuid;

  final String domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneCreateManyStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyStatoInput({
    this.uuid,
    required this.contrattoUuid,
    required this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String contrattoUuid;

  final String domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateManyStatoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyStatoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneCreateManyStatoInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneCreateManyStatoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoContrattoUncheckedCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateOrConnectWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateOrConnectWithoutServiziEwoInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutServiziEwoInput,
      _i2.StatoContrattoUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoContrattoCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoContrattoUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2
                      .StatoContrattoUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelFibraUncheckedCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateWithoutOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelFibraCreateOrConnectWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateOrConnectWithoutOffertaInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutOffertaInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelFibraCreateManyOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelFibraCreateManyOffertaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyOffertaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateManyOffertaInput,
      Iterable<_i2.ContrattoEnelFibraCreateManyOffertaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateWithoutOffertaInput({
    this.uuid,
    required this.stato,
    required this.contratto,
    required this.domicilio,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      contratto;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.domicilioUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final String domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneCreateManyOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyOffertaInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.domicilioUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final String domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateManyOffertaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyOffertaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneCreateManyOffertaInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneCreateManyOffertaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyOffertaInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyOffertaInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OffertaUncheckedCreateWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutInclusaInOfferteInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
      };
}

class OffertaCreateOrConnectWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutInclusaInOfferteInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutInclusaInOfferteInput,
      _i2.OffertaUncheckedCreateWithoutInclusaInOfferteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateNestedManyWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedManyWithoutInclusaInOfferteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutInclusaInOfferteInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutInclusaInOfferteInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutInclusaInOfferteInput,
                  Iterable<
                      _i2
                      .OffertaUncheckedCreateWithoutInclusaInOfferteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaCreateWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutInclusaInOfferteInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
      };
}

class OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutInclusaInOfferteInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutInclusaInOfferteInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutInclusaInOfferteInput,
                  Iterable<
                      _i2
                      .OffertaUncheckedCreateWithoutInclusaInOfferteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaUncheckedCreateWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutOfferteIncluseInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateOrConnectWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutOfferteIncluseInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutOfferteIncluseInput,
      _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateNestedManyWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedManyWithoutOfferteIncluseInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutOfferteIncluseInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutOfferteIncluseInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput,
                  Iterable<
                      _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaCreateWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutOfferteIncluseInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutOfferteIncluseInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutOfferteIncluseInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput,
                  Iterable<
                      _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaUncheckedCreateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutServizioEwoInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateOrConnectWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutServizioEwoInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutServizioEwoInput,
      _i2.OffertaUncheckedCreateWithoutServizioEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateManyServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateManyServizioEwoInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
      };
}

class OffertaCreateManyServizioEwoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateManyServizioEwoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateManyServizioEwoInput,
      Iterable<_i2.OffertaCreateManyServizioEwoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OffertaUncheckedCreateNestedManyWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateNestedManyWithoutServizioEwoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OffertaCreateWithoutServizioEwoInput,
      _i1.PrismaUnion<
          Iterable<_i2.OffertaCreateWithoutServizioEwoInput>,
          _i1.PrismaUnion<
              _i2.OffertaUncheckedCreateWithoutServizioEwoInput,
              Iterable<
                  _i2.OffertaUncheckedCreateWithoutServizioEwoInput>>>>? create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i2.OffertaCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ServizioEwoUncheckedCreateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutModuliContrattoInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
      };
}

class ServizioEwoCreateOrConnectWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutModuliContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutModuliContrattoInput,
      _i2.ServizioEwoUncheckedCreateWithoutModuliContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoUncheckedCreateNestedManyWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateNestedManyWithoutModuliContrattoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutModuliContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutModuliContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutModuliContrattoInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutModuliContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ModuloContrattoUncheckedCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateWithoutContrattiInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.clienteTarget,
    required this.canale,
    required this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final String tipoModuloContrattoId;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
      };
}

class ModuloContrattoCreateOrConnectWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateOrConnectWithoutContrattiInput({
    required this.where,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutContrattiInput,
      _i2.ModuloContrattoUncheckedCreateWithoutContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ModuloContrattoCreateNestedOneWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateNestedOneWithoutContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutContrattiInput,
      _i2.ModuloContrattoUncheckedCreateWithoutContrattiInput>? create;

  final _i2.ModuloContrattoCreateOrConnectWithoutContrattiInput?
      connectOrCreate;

  final _i2.ModuloContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutPraticaInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'modulo': modulo,
      };
}

class ContrattoUncheckedCreateWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutPraticaInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutPraticaInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutPraticaInput,
      _i2.ContrattoUncheckedCreateWithoutPraticaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateManyPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyPraticaInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.moduloContrattoId,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCreateManyPraticaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyPraticaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateManyPraticaInput,
      Iterable<_i2.ContrattoCreateManyPraticaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoUncheckedCreateNestedManyWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateNestedManyWithoutPraticaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutPraticaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutPraticaInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutPraticaInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutPraticaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutPraticaInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutPraticaInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PraticaUncheckedCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateWithoutNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaCreateOrConnectWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateOrConnectWithoutNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutNegozioInput,
      _i2.PraticaUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PraticaCreateManyNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCreateManyNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateManyNegozioInput,
      Iterable<_i2.PraticaCreateManyNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class PraticaUncheckedCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.PraticaCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoUncheckedCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutUtenteInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutUtenteInput,
      _i2.ContrattoUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateManyUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCreateManyUtenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyUtenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateManyUtenteInput,
      Iterable<_i2.ContrattoCreateManyUtenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoUncheckedCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutUtenteInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutUtenteInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PraticaUncheckedCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateWithoutUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaCreateOrConnectWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateOrConnectWithoutUtenteInput({
    required this.where,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutUtenteInput,
      _i2.PraticaUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PraticaCreateManyUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCreateManyUtenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyUtenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateManyUtenteInput,
      Iterable<_i2.PraticaCreateManyUtenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class PraticaUncheckedCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.PraticaCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class IngressiUncheckedCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedCreateWithoutUtenteInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.negozioCodice,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final String negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'negozioCodice': negozioCodice,
      };
}

class IngressiCreateOrConnectWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateOrConnectWithoutUtenteInput({
    required this.where,
    required this.create,
  });

  final _i2.IngressiWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IngressiCreateWithoutUtenteInput,
      _i2.IngressiUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class IngressiCreateManyUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateManyUtenteInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.negozioCodice,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final String negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'negozioCodice': negozioCodice,
      };
}

class IngressiCreateManyUtenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateManyUtenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.IngressiCreateManyUtenteInput,
      Iterable<_i2.IngressiCreateManyUtenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class IngressiUncheckedCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.IngressiCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.IngressiCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadUncheckedCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutUtenteInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutUtenteInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutUtenteInput,
      _i2.LeadUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManyUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyUtenteInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManyUtenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyUtenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManyUtenteInput,
      Iterable<_i2.LeadCreateManyUtenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadUncheckedCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.LeadCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadUncheckedCreateWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutAgenteInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutAgenteInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutAgenteInput,
      _i2.LeadUncheckedCreateWithoutAgenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManyAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyAgenteInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManyAgenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyAgenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManyAgenteInput,
      Iterable<_i2.LeadCreateManyAgenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadUncheckedCreateNestedManyWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutAgenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutAgenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutAgenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutAgenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutAgenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutAgenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutAgenteInput>>? connectOrCreate;

  final _i2.LeadCreateManyAgenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutHistoryInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
      };
}

class LeadUncheckedCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutHistoryInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
      };
}

class LeadCreateOrConnectWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutHistoryInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutHistoryInput,
      _i2.LeadUncheckedCreateWithoutHistoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateNestedOneWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedOneWithoutHistoryInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.LeadCreateWithoutHistoryInput,
      _i2.LeadUncheckedCreateWithoutHistoryInput>? create;

  final _i2.LeadCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.LeadWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateWithoutUtenteInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.comment,
    this.attachment,
    this.lead,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i2.HistoryCommentCreateNestedOneWithoutHistoryInput? comment;

  final _i2.HistoryAttachmentCreateNestedOneWithoutHistoryInput? attachment;

  final _i2.LeadCreateNestedOneWithoutHistoryInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'attachment': attachment,
        'Lead': lead,
      };
}

class HistoryUncheckedCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateWithoutUtenteInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.leadUuid,
    this.comment,
    this.attachment,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final _i2.HistoryCommentUncheckedCreateNestedOneWithoutHistoryInput? comment;

  final _i2.HistoryAttachmentUncheckedCreateNestedOneWithoutHistoryInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
      };
}

class HistoryCreateOrConnectWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateOrConnectWithoutUtenteInput({
    required this.where,
    required this.create,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutUtenteInput,
      _i2.HistoryUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class HistoryCreateManyUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateManyUtenteInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.leadUuid,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'leadUuid': leadUuid,
      };
}

class HistoryCreateManyUtenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateManyUtenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.HistoryCreateManyUtenteInput,
      Iterable<_i2.HistoryCreateManyUtenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class HistoryCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.HistoryCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutOpportunitaAssegnateInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'ordini': ordini,
        'history': history,
      };
}

class OrdineUncheckedCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineCreateOrConnectWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutUtenteInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutUtenteInput,
      _i2.OrdineUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateManyUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCreateManyUtenteInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyUtenteInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OrdineCreateManyUtenteInput,
      Iterable<_i2.OrdineCreateManyUtenteInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OrdineUncheckedCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.OrdineCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class HistoryUncheckedCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.HistoryCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteUncheckedCreateWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutOpportunitaAssegnateInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutOpportunitaAssegnateInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOpportunitaAssegnateInput,
      _i2.UtenteUncheckedCreateWithoutOpportunitaAssegnateInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteUncheckedCreateNestedManyWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateNestedManyWithoutOpportunitaAssegnateInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaAssegnateInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaAssegnateInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaAssegnateInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaAssegnateInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OpportunitaUncheckedCreateWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedCreateWithoutGestoriLeadInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.agenti,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.LeadUncheckedCreateNestedManyWithoutOpportunitaInput? leads;

  final _i2.UtenteUncheckedCreateNestedManyWithoutOpportunitaAssegnateInput?
      agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'agenti': agenti,
      };
}

class OpportunitaCreateOrConnectWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateOrConnectWithoutGestoriLeadInput({
    required this.where,
    required this.create,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutGestoriLeadInput,
      _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutGestoriLeadInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutGestoriLeadInput>,
              _i1.PrismaUnion<
                  _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput,
                  Iterable<
                      _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OpportunitaCreateOrConnectWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateOrConnectWithoutAgentiInput({
    required this.where,
    required this.create,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutAgentiInput,
      _i2.OpportunitaUncheckedCreateWithoutAgentiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OpportunitaUncheckedCreateNestedManyWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedCreateNestedManyWithoutAgentiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutAgentiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutAgentiInput>,
              _i1.PrismaUnion<_i2.OpportunitaUncheckedCreateWithoutAgentiInput,
                  Iterable<_i2.OpportunitaUncheckedCreateWithoutAgentiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutAgentiInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutAgentiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class UtenteUncheckedCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutNegozioInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutNegozioInput,
      _i2.UtenteUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateManyNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateManyNegozioInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteCreateManyNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateManyNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateManyNegozioInput,
      Iterable<_i2.UtenteCreateManyNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class UtenteUncheckedCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.UtenteCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.UtenteCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.UtenteUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.UtenteUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.UtenteCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.UtenteCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoUncheckedCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutNegozioInput,
      _i2.ContrattoUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateManyNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCreateManyNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateManyNegozioInput,
      Iterable<_i2.ContrattoCreateManyNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoUncheckedCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PraticaUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutSoggettoInput,
      _i2.PraticaUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class PraticaCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManySoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateManySoggettoInput,
      Iterable<_i2.PraticaCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class PraticaUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.PraticaCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutSoggettoInput,
      _i2.ContrattoUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManySoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateManySoggettoInput,
      Iterable<_i2.ContrattoCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ContrattoUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class IndirizzoEmailUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.IndirizzoEmailWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutSoggettoInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class IndirizzoEmailCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateManySoggettoInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateManySoggettoInput,
      Iterable<_i2.IndirizzoEmailCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.IndirizzoEmailCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.IndirizzoEmailCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NumeroTelefonoUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentateUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.NumeroTelefonoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutSoggettoInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NumeroTelefonoCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateManySoggettoInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentateUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateManySoggettoInput,
      Iterable<_i2.NumeroTelefonoCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.NumeroTelefonoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.NumeroTelefonoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrdineUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutSoggettoInput,
      _i2.OrdineUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManySoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OrdineCreateManySoggettoInput,
      Iterable<_i2.OrdineCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OrdineUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i2.OrdineCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    required this.opportunitaUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutSoggettoInput,
      _i2.LeadUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManySoggettoInput({
    this.uuid,
    required this.opportunitaUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManySoggettoInput,
      Iterable<_i2.LeadCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutSoggettoInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutSoggettoInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutSoggettoInput,
              Iterable<_i2.LeadUncheckedCreateWithoutSoggettoInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.LeadCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i2.LeadCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PrivacyUncheckedCreateNestedOneWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedCreateNestedOneWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.PrivacyCreateWithoutSoggettoInput,
      _i2.PrivacyUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.PrivacyCreateOrConnectWithoutSoggettoInput? connectOrCreate;

  final _i2.PrivacyWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoUncheckedCreateWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutNegozioPreferitoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutNegozioPreferitoInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutNegozioPreferitoInput,
      _i2.SoggettoUncheckedCreateWithoutNegozioPreferitoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateManyNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateManyNegozioPreferitoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoCreateManyNegozioPreferitoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateManyNegozioPreferitoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateManyNegozioPreferitoInput,
      Iterable<_i2.SoggettoCreateManyNegozioPreferitoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoCreateWithoutNegozioPreferitoInput,
          _i1.PrismaUnion<
              Iterable<_i2.SoggettoCreateWithoutNegozioPreferitoInput>,
              _i1.PrismaUnion<
                  _i2.SoggettoUncheckedCreateWithoutNegozioPreferitoInput,
                  Iterable<
                      _i2
                      .SoggettoUncheckedCreateWithoutNegozioPreferitoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput,
          Iterable<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput>>?
      connectOrCreate;

  final _i2.SoggettoCreateManyNegozioPreferitoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class IngressiUncheckedCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedCreateWithoutNegozioInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.utenteUuid,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final String utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
      };
}

class IngressiCreateOrConnectWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateOrConnectWithoutNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.IngressiWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IngressiCreateWithoutNegozioInput,
      _i2.IngressiUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class IngressiCreateManyNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateManyNegozioInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.utenteUuid,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final String utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
      };
}

class IngressiCreateManyNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateManyNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.IngressiCreateManyNegozioInput,
      Iterable<_i2.IngressiCreateManyNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class IngressiUncheckedCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.IngressiCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i2.IngressiCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadUncheckedCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutNegozioInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutNegozioInput,
      _i2.LeadUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManyNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyNegozioInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManyNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManyNegozioInput,
      Iterable<_i2.LeadCreateManyNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadUncheckedCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.LeadCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioUncheckedCreateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutOrdineInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
      };
}

class NegozioCreateOrConnectWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutOrdineInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutOrdineInput,
      _i2.NegozioUncheckedCreateWithoutOrdineInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutOrdineInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutOrdineInput,
      _i2.NegozioUncheckedCreateWithoutOrdineInput>? create;

  final _i2.NegozioCreateOrConnectWithoutOrdineInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrdineCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    required this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'negozio': negozio,
      };
}

class OrdineCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.OrdineCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutHistoryInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
      };
}

class UtenteUncheckedCreateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutHistoryInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
      };
}

class UtenteCreateOrConnectWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutHistoryInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutHistoryInput,
      _i2.UtenteUncheckedCreateWithoutHistoryInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutHistoryInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutHistoryInput,
      _i2.UtenteUncheckedCreateWithoutHistoryInput>? create;

  final _i2.UtenteCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryCreateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateWithoutLeadInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.comment,
    this.attachment,
    required this.utente,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i2.HistoryCommentCreateNestedOneWithoutHistoryInput? comment;

  final _i2.HistoryAttachmentCreateNestedOneWithoutHistoryInput? attachment;

  final _i2.UtenteCreateNestedOneWithoutHistoryInput utente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
      };
}

class HistoryUncheckedCreateNestedManyWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateNestedManyWithoutLeadInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutLeadInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutLeadInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i2.HistoryCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadUncheckedCreateWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutOpportunitaInput({
    this.uuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutOpportunitaInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutOpportunitaInput,
      _i2.LeadUncheckedCreateWithoutOpportunitaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManyOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyOpportunitaInput({
    this.uuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManyOpportunitaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyOpportunitaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManyOpportunitaInput,
      Iterable<_i2.LeadCreateManyOpportunitaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadUncheckedCreateNestedManyWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutOpportunitaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutOpportunitaInput>,
              _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutOpportunitaInput,
                  Iterable<_i2.LeadUncheckedCreateWithoutOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutOpportunitaInput>>?
      connectOrCreate;

  final _i2.LeadCreateManyOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteUncheckedCreateWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutOpportunitaGestiteInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutOpportunitaGestiteInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOpportunitaGestiteInput,
      _i2.UtenteUncheckedCreateWithoutOpportunitaGestiteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteUncheckedCreateNestedManyWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateNestedManyWithoutOpportunitaGestiteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaGestiteInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaGestiteInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaGestiteInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaGestiteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OpportunitaUncheckedCreateWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedCreateWithoutAgentiInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.LeadUncheckedCreateNestedManyWithoutOpportunitaInput? leads;

  final _i2.UtenteUncheckedCreateNestedManyWithoutOpportunitaGestiteInput?
      gestoriLead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
      };
}

class OpportunitaCreateNestedManyWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateNestedManyWithoutAgentiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutAgentiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutAgentiInput>,
              _i1.PrismaUnion<_i2.OpportunitaUncheckedCreateWithoutAgentiInput,
                  Iterable<_i2.OpportunitaUncheckedCreateWithoutAgentiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutAgentiInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutAgentiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class UtenteCreateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutOrdiniInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'history': history,
      };
}

class UtenteUncheckedCreateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutOrdiniInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutOrdiniInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOrdiniInput,
      _i2.UtenteUncheckedCreateWithoutOrdiniInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutOrdiniInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOrdiniInput,
      _i2.UtenteUncheckedCreateWithoutOrdiniInput>? create;

  final _i2.UtenteCreateOrConnectWithoutOrdiniInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrdineCreateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutLeadInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    required this.soggetto,
    this.domicilio,
    this.statoOrdine,
    required this.utente,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineCreateNestedManyWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutLeadInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutLeadInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutLeadInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i2.OrdineCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class LeadCreateWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutOpportunitaInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateNestedManyWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutOpportunitaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutOpportunitaInput>,
              _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutOpportunitaInput,
                  Iterable<_i2.LeadUncheckedCreateWithoutOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutOpportunitaInput>>?
      connectOrCreate;

  final _i2.LeadCreateManyOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateNestedManyWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedManyWithoutOpportunitaAssegnateInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaAssegnateInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaAssegnateInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaAssegnateInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaAssegnateInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OpportunitaCreateWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateWithoutGestoriLeadInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.agenti,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.LeadCreateNestedManyWithoutOpportunitaInput? leads;

  final _i2.UtenteCreateNestedManyWithoutOpportunitaAssegnateInput? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'agenti': agenti,
      };
}

class OpportunitaCreateNestedManyWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateNestedManyWithoutGestoriLeadInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutGestoriLeadInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutGestoriLeadInput>,
              _i1.PrismaUnion<
                  _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput,
                  Iterable<
                      _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class UtenteCreateWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutLeadsAssegnatiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedCreateWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutLeadsAssegnatiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutLeadsAssegnatiInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsAssegnatiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsAssegnatiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutLeadsAssegnatiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsAssegnatiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsAssegnatiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutLeadsAssegnatiInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LeadCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutUtenteInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.LeadCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutIngressiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedCreateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutIngressiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutIngressiInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutIngressiInput,
      _i2.UtenteUncheckedCreateWithoutIngressiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutIngressiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutIngressiInput,
      _i2.UtenteUncheckedCreateWithoutIngressiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutIngressiInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IngressiCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateWithoutNegozioInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.utente,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final _i2.UtenteCreateNestedOneWithoutIngressiInput utente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utente': utente,
      };
}

class IngressiCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.IngressiCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i2.IngressiCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OrdineCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    required this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    required this.utente,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
      };
}

class OrdineUncheckedCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'prodotti': prodotti,
      };
}

class OrdineCreateOrConnectWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutNegozioInput,
      _i2.OrdineUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateManyNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
      };
}

class OrdineCreateManyNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OrdineCreateManyNegozioInput,
      Iterable<_i2.OrdineCreateManyNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OrdineCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.OrdineCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutLeadsInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    required this.zonaNegozio,
    this.ingressi,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'Ordine': ordine,
      };
}

class OrdineUncheckedCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.OrdineCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioUncheckedCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutLeadsInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutLeadsInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutLeadsInput,
      _i2.NegozioUncheckedCreateWithoutLeadsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutLeadsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutLeadsInput,
      _i2.NegozioUncheckedCreateWithoutLeadsInput>? create;

  final _i2.NegozioCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LeadCreateWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutAgenteInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateNestedManyWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutAgenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutAgenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutAgenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutAgenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutAgenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutAgenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutAgenteInput>>? connectOrCreate;

  final _i2.LeadCreateManyAgenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutLeadsGestitiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedCreateWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutLeadsGestitiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutLeadsGestitiInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsGestitiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsGestitiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutLeadsGestitiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsGestitiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsGestitiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutLeadsGestitiInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LeadCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutDomicilioInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutDomicilioInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutDomicilioInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutDomicilioInput,
      _i2.LeadUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManyDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyDomicilioInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManyDomicilioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyDomicilioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManyDomicilioInput,
      Iterable<_i2.LeadCreateManyDomicilioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutDomicilioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutDomicilioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutDomicilioInput>>? connectOrCreate;

  final _i2.LeadCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioCreateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.SoggettoCreateNestedOneWithoutDomiciliInput soggetto;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.LeadCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'leads': leads,
      };
}

class LeadUncheckedCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutDomicilioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutDomicilioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutDomicilioInput>>? connectOrCreate;

  final _i2.LeadCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioUncheckedCreateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.LeadUncheckedCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'leads': leads,
      };
}

class DomicilioCreateOrConnectWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateOrConnectWithoutProdottiOrdinatiInput({
    required this.where,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutProdottiOrdinatiInput,
      _i2.DomicilioUncheckedCreateWithoutProdottiOrdinatiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DomicilioCreateNestedOneWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateNestedOneWithoutProdottiOrdinatiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutProdottiOrdinatiInput,
      _i2.DomicilioUncheckedCreateWithoutProdottiOrdinatiInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutProdottiOrdinatiInput?
      connectOrCreate;

  final _i2.DomicilioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrdineCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutProdottiInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    required this.utente,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUncheckedCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutProdottiInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCreateOrConnectWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutProdottiInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutProdottiInput,
      _i2.OrdineUncheckedCreateWithoutProdottiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateNestedManyWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutProdottiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutProdottiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutProdottiInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutProdottiInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutProdottiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutProdottiInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutProdottiInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class TipoProdottoCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCreateWithoutProdottiInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoUncheckedCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUncheckedCreateWithoutProdottiInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.prodotti,
  });

  final String? id;

  final String? nome;

  final _i1.PrismaUnion<_i2.TipoProdottoWhereInput,
      Iterable<_i2.TipoProdottoWhereInput>>? AND;

  final Iterable<_i2.TipoProdottoWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoProdottoWhereInput,
      Iterable<_i2.TipoProdottoWhereInput>>? NOT;

  final _i2.ProdottoListRelationFilter? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'prodotti': prodotti,
      };
}

class TipoProdottoCreateOrConnectWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCreateOrConnectWithoutProdottiInput({
    required this.where,
    required this.create,
  });

  final _i2.TipoProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.TipoProdottoCreateWithoutProdottiInput,
      _i2.TipoProdottoUncheckedCreateWithoutProdottiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class TipoProdottoCreateNestedOneWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCreateNestedOneWithoutProdottiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.TipoProdottoCreateWithoutProdottiInput,
      _i2.TipoProdottoUncheckedCreateWithoutProdottiInput>? create;

  final _i2.TipoProdottoCreateOrConnectWithoutProdottiInput? connectOrCreate;

  final _i2.TipoProdottoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProdottoCreateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateWithoutFornitoreInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttore,
    this.prodottiOrdinati,
    required this.tipoProdotto,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final _i2.ProduttoreCreateNestedOneWithoutProdottiInput produttore;

  final _i2.OrdineCreateNestedManyWithoutProdottiInput? prodottiOrdinati;

  final _i2.TipoProdottoCreateNestedOneWithoutProdottiInput tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'tipoProdotto': tipoProdotto,
      };
}

class OrdineUncheckedCreateNestedManyWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutProdottiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutProdottiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutProdottiInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutProdottiInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutProdottiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutProdottiInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutProdottiInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProdottoUncheckedCreateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateWithoutFornitoreInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.tipoProdottoId,
    this.prodottiOrdinati,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String tipoProdottoId;

  final _i2.OrdineUncheckedCreateNestedManyWithoutProdottiInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'tipoProdottoId': tipoProdottoId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoCreateOrConnectWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateOrConnectWithoutFornitoreInput({
    required this.where,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutFornitoreInput,
      _i2.ProdottoUncheckedCreateWithoutFornitoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProdottoCreateManyFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyFornitoreInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.tipoProdottoId,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoCreateManyFornitoreInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyFornitoreInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ProdottoCreateManyFornitoreInput,
      Iterable<_i2.ProdottoCreateManyFornitoreInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ProdottoCreateNestedManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateNestedManyWithoutFornitoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<_i2.ProdottoUncheckedCreateWithoutFornitoreInput,
                  Iterable<_i2.ProdottoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i2.ProdottoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornitoreCreateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateWithoutModuliContrattoInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutFornitoreInput? serviziEwo;

  final _i2.ProdottoCreateNestedManyWithoutFornitoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'prodotti': prodotti,
      };
}

class ContrattoUncheckedCreateNestedManyWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateNestedManyWithoutModuloInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutModuloInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutModuloInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutModuloInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutModuloInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutModuloInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.clienteTarget,
    required this.canale,
    required this.tipoModuloContrattoId,
    this.contratti,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final String tipoModuloContrattoId;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutModuloInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'contratti': contratti,
      };
}

class ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput({
    required this.where,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput,
          _i2.ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput>,
              _i1.PrismaUnion<
                  _i2
                  .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ServizioEwoUncheckedCreateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutFornitoreInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateOrConnectWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutFornitoreInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutFornitoreInput,
      _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoCreateManyFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateManyFornitoreInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoCreateManyFornitoreInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateManyFornitoreInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoCreateManyFornitoreInput,
      Iterable<_i2.ServizioEwoCreateManyFornitoreInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ServizioEwoUncheckedCreateNestedManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateNestedManyWithoutFornitoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i2.ServizioEwoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProdottoUncheckedCreateNestedManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateNestedManyWithoutFornitoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<_i2.ProdottoUncheckedCreateWithoutFornitoreInput,
                  Iterable<_i2.ProdottoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i2.ProdottoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornitoreUncheckedCreateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedCreateWithoutModuliContrattoInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutFornitoreInput?
      serviziEwo;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutFornitoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'prodotti': prodotti,
      };
}

class FornitoreWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreWhereUniqueInput({
    this.id,
    this.nome,
    this.AND,
    this.OR,
    this.NOT,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final String? id;

  final String? nome;

  final _i1
      .PrismaUnion<_i2.FornitoreWhereInput, Iterable<_i2.FornitoreWhereInput>>?
      AND;

  final Iterable<_i2.FornitoreWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.FornitoreWhereInput, Iterable<_i2.FornitoreWhereInput>>?
      NOT;

  final _i2.ServizioEwoListRelationFilter? serviziEwo;

  final _i2.ModuloContrattoListRelationFilter? moduliContratto;

  final _i2.ProdottoListRelationFilter? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreCreateOrConnectWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateOrConnectWithoutModuliContrattoInput({
    required this.where,
    required this.create,
  });

  final _i2.FornitoreWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutModuliContrattoInput,
      _i2.FornitoreUncheckedCreateWithoutModuliContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornitoreCreateNestedOneWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateNestedOneWithoutModuliContrattoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutModuliContrattoInput,
      _i2.FornitoreUncheckedCreateWithoutModuliContrattoInput>? create;

  final _i2.FornitoreCreateOrConnectWithoutModuliContrattoInput?
      connectOrCreate;

  final _i2.FornitoreWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ModuloContrattoCreateWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateWithoutServiziEwoCollegabiliInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    this.contratti,
    required this.fornitore,
    required this.tipoModulo,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final _i2.ContrattoCreateNestedManyWithoutModuloInput? contratti;

  final _i2.FornitoreCreateNestedOneWithoutModuliContrattoInput fornitore;

  final _i2.TipoModuloContrattoCreateNestedOneWithoutModuloContrattoInput
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput>,
              _i1.PrismaUnion<
                  _i2
                  .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutOfferteInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedCreateWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutOfferteInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateOrConnectWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutOfferteInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutOfferteInput,
      _i2.ServizioEwoUncheckedCreateWithoutOfferteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoCreateNestedOneWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedOneWithoutOfferteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutOfferteInput,
      _i2.ServizioEwoUncheckedCreateWithoutOfferteInput>? create;

  final _i2.ServizioEwoCreateOrConnectWithoutOfferteInput? connectOrCreate;

  final _i2.ServizioEwoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutContrattiEnelFibraInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutContrattiEnelFibraInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateOrConnectWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutContrattiEnelFibraInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelFibraInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelFibraInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateNestedOneWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedOneWithoutContrattiEnelFibraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelFibraInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.OffertaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelFibraCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateWithoutDomicilioInput({
    this.uuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    required this.stato,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelFibraInput stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelFibraInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelFibraInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioUncheckedCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateWithoutSoggettoInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedCreateNestedManyWithoutDomicilioInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCreateOrConnectWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateOrConnectWithoutSoggettoInput({
    required this.where,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutSoggettoInput,
      _i2.DomicilioUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DomicilioCreateManySoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateManySoggettoInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
      };
}

class DomicilioCreateManySoggettoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateManySoggettoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateManySoggettoInput,
      Iterable<_i2.DomicilioCreateManySoggettoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class DomicilioUncheckedCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.DomicilioCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.DomicilioUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.DomicilioUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.DomicilioCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.DomicilioCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.DomicilioCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoUncheckedCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutLeadsInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutLeadsInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutLeadsInput,
      _i2.SoggettoUncheckedCreateWithoutLeadsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutLeadsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutLeadsInput,
      _i2.SoggettoUncheckedCreateWithoutLeadsInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LeadCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutNegozioInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.LeadCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioCreateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutIngressiInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    required this.zonaNegozio,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutIngressiInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutIngressiInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutIngressiInput,
      _i2.NegozioUncheckedCreateWithoutIngressiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutIngressiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutIngressiInput,
      _i2.NegozioUncheckedCreateWithoutIngressiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutIngressiInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IngressiCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateWithoutUtenteInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.negozio,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final _i2.NegozioCreateNestedOneWithoutIngressiInput negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'negozio': negozio,
      };
}

class IngressiCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.IngressiCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.IngressiCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutContrattiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutContrattiInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutContrattiInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutContrattiInput,
      _i2.UtenteUncheckedCreateWithoutContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutContrattiInput,
      _i2.UtenteUncheckedCreateWithoutContrattiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutPraticheInput({
    required this.codice,
    required this.nome,
    this.utenti,
    this.contratti,
    this.soggetti,
    required this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutPraticheInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutPraticheInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutPraticheInput,
      _i2.NegozioUncheckedCreateWithoutPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutPraticheInput,
      _i2.NegozioUncheckedCreateWithoutPraticheInput>? create;

  final _i2.NegozioCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateNestedManyWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedManyWithoutPraticaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutPraticaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutPraticaInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutPraticaInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutPraticaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutPraticaInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutPraticaInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class PraticaCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateWithoutUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    required this.tipoPratica,
    this.soggetto,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaCreateNestedOneWithoutPraticheInput tipoPratica;

  final _i2.SoggettoCreateNestedOneWithoutPraticheIntestateInput? soggetto;

  final _i2.NegozioCreateNestedOneWithoutPraticheInput? negozio;

  final _i2.StatoPraticaCreateNestedOneWithoutPraticheInput? stato;

  final _i2.ContrattoCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i2.PraticaCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutOpportunitaGestiteInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateNestedManyWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedManyWithoutOpportunitaGestiteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaGestiteInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaGestiteInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaGestiteInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaGestiteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OpportunitaCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateWithoutLeadsInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.gestoriLead,
    this.agenti,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.UtenteCreateNestedManyWithoutOpportunitaGestiteInput? gestoriLead;

  final _i2.UtenteCreateNestedManyWithoutOpportunitaAssegnateInput? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaUncheckedCreateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedCreateWithoutLeadsInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.gestoriLead,
    this.agenti,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.UtenteUncheckedCreateNestedManyWithoutOpportunitaGestiteInput?
      gestoriLead;

  final _i2.UtenteUncheckedCreateNestedManyWithoutOpportunitaAssegnateInput?
      agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaCreateOrConnectWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateOrConnectWithoutLeadsInput({
    required this.where,
    required this.create,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutLeadsInput,
      _i2.OpportunitaUncheckedCreateWithoutLeadsInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OpportunitaCreateNestedOneWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateNestedOneWithoutLeadsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutLeadsInput,
      _i2.OpportunitaUncheckedCreateWithoutLeadsInput>? create;

  final _i2.OpportunitaCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.OpportunitaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LeadCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutSoggettoInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutSoggettoInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutSoggettoInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutSoggettoInput,
              Iterable<_i2.LeadUncheckedCreateWithoutSoggettoInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.LeadCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i2.LeadCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutProdottiOrdinatiInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutProdottiOrdinatiInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutProdottiOrdinatiInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutProdottiOrdinatiInput,
      _i2.SoggettoUncheckedCreateWithoutProdottiOrdinatiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutProdottiOrdinatiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutProdottiOrdinatiInput,
      _i2.SoggettoUncheckedCreateWithoutProdottiOrdinatiInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutProdottiOrdinatiInput?
      connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrdineCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutDomicilioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    required this.soggetto,
    this.statoOrdine,
    this.lead,
    required this.utente,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutDomicilioInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.OrdineCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.SoggettoCreateNestedOneWithoutDomiciliInput soggetto;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.OrdineCreateNestedManyWithoutDomicilioInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.OrdineUncheckedCreateNestedManyWithoutDomicilioInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCreateOrConnectWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateOrConnectWithoutContrattiEnelFibraInput({
    required this.where,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutContrattiEnelFibraInput,
      _i2.DomicilioUncheckedCreateWithoutContrattiEnelFibraInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DomicilioCreateNestedOneWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateNestedOneWithoutContrattiEnelFibraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutContrattiEnelFibraInput,
      _i2.DomicilioUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.DomicilioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelFibraCreateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateWithoutOffertaInput({
    this.uuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    required this.stato,
    required this.contratto,
    this.domicilio,
  });

  final String? uuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelFibraInput stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelFibraInput contratto;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelFibraInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraCreateNestedManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateNestedManyWithoutOffertaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class OffertaCreateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutServizioEwoInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateNestedManyWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedManyWithoutServizioEwoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.OffertaCreateWithoutServizioEwoInput,
      _i1.PrismaUnion<
          Iterable<_i2.OffertaCreateWithoutServizioEwoInput>,
          _i1.PrismaUnion<
              _i2.OffertaUncheckedCreateWithoutServizioEwoInput,
              Iterable<
                  _i2.OffertaUncheckedCreateWithoutServizioEwoInput>>>>? create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i2.OffertaCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutFornitoreInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateNestedManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedManyWithoutFornitoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i2.ServizioEwoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornitoreCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateWithoutProdottiInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutFornitoreInput? serviziEwo;

  final _i2.ModuloContrattoCreateNestedManyWithoutFornitoreInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
      };
}

class ModuloContrattoUncheckedCreateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateWithoutFornitoreInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    required this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final String tipoModuloContrattoId;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutModuloInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoCreateOrConnectWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateOrConnectWithoutFornitoreInput({
    required this.where,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutFornitoreInput,
      _i2.ModuloContrattoUncheckedCreateWithoutFornitoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ModuloContrattoCreateManyFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateManyFornitoreInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    required this.tipoModuloContrattoId,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final String tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoCreateManyFornitoreInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateManyFornitoreInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateManyFornitoreInput,
      Iterable<_i2.ModuloContrattoCreateManyFornitoreInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ModuloContrattoUncheckedCreateNestedManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateNestedManyWithoutFornitoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i2.ModuloContrattoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornitoreUncheckedCreateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedCreateWithoutProdottiInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutFornitoreInput?
      serviziEwo;

  final _i2.ModuloContrattoUncheckedCreateNestedManyWithoutFornitoreInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
      };
}

class FornitoreCreateOrConnectWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateOrConnectWithoutProdottiInput({
    required this.where,
    required this.create,
  });

  final _i2.FornitoreWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutProdottiInput,
      _i2.FornitoreUncheckedCreateWithoutProdottiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornitoreCreateNestedOneWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateNestedOneWithoutProdottiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutProdottiInput,
      _i2.FornitoreUncheckedCreateWithoutProdottiInput>? create;

  final _i2.FornitoreCreateOrConnectWithoutProdottiInput? connectOrCreate;

  final _i2.FornitoreWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ProdottoCreateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateWithoutProdottiOrdinatiInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttore,
    required this.fornitore,
    required this.tipoProdotto,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final _i2.ProduttoreCreateNestedOneWithoutProdottiInput produttore;

  final _i2.FornitoreCreateNestedOneWithoutProdottiInput fornitore;

  final _i2.TipoProdottoCreateNestedOneWithoutProdottiInput tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoCreateNestedManyWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateNestedManyWithoutProdottiOrdinatiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutProdottiOrdinatiInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutProdottiOrdinatiInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutProdottiOrdinatiInput,
                  Iterable<
                      _i2
                      .ProdottoUncheckedCreateWithoutProdottiOrdinatiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OrdineCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutSoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    required this.utente,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i2.OrdineCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutNegozioPreferitoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateNestedManyWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedManyWithoutNegozioPreferitoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoCreateWithoutNegozioPreferitoInput,
          _i1.PrismaUnion<
              Iterable<_i2.SoggettoCreateWithoutNegozioPreferitoInput>,
              _i1.PrismaUnion<
                  _i2.SoggettoUncheckedCreateWithoutNegozioPreferitoInput,
                  Iterable<
                      _i2
                      .SoggettoUncheckedCreateWithoutNegozioPreferitoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput,
          Iterable<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput>>?
      connectOrCreate;

  final _i2.SoggettoCreateManyNegozioPreferitoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutContrattiInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.soggetti,
    required this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutContrattiInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutContrattiInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutContrattiInput,
      _i2.NegozioUncheckedCreateWithoutContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutContrattiInput,
      _i2.NegozioUncheckedCreateWithoutContrattiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutUtenteInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoCreateNestedManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedManyWithoutUtenteInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutUtenteInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutUtenteInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class UtenteCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutNegozioInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.UtenteCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.UtenteCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.UtenteUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.UtenteUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.UtenteCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.UtenteCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioCreateWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutSoggettiInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    required this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutSoggettiInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutSoggettiInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutSoggettiInput,
      _i2.NegozioUncheckedCreateWithoutSoggettiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutSoggettiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutSoggettiInput,
      _i2.NegozioUncheckedCreateWithoutSoggettiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutSoggettiInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoCreateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutSoggettoBusinessInfoInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutSoggettoBusinessInfoInput,
      _i2.SoggettoUncheckedCreateWithoutSoggettoBusinessInfoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutSoggettoBusinessInfoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutSoggettoBusinessInfoInput,
      _i2.SoggettoUncheckedCreateWithoutSoggettoBusinessInfoInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoBusinessInfoCreateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateWithoutLegaleRappresentanteInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    this.referente,
    required this.soggetto,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final _i2.ReferenteCreateNestedOneWithoutSoggettoBusinessInfoInput? referente;

  final _i2.SoggettoCreateNestedOneWithoutSoggettoBusinessInfoInput soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoUncheckedCreateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedCreateWithoutLegaleRappresentanteInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    required this.soggettoUuid,
    this.referente,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final String soggettoUuid;

  final _i2.ReferenteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput?
      referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'referente': referente,
      };
}

class SoggettoBusinessInfoCreateOrConnectWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateOrConnectWithoutLegaleRappresentanteInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoBusinessInfoWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoCreateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedCreateWithoutLegaleRappresentanteInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoBusinessInfoCreateNestedOneWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateNestedOneWithoutLegaleRappresentanteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoCreateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedCreateWithoutLegaleRappresentanteInput>?
      create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutLegaleRappresentanteInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LegaleRappresentanteCreateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateWithoutIndirizzoEmailInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    required this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoCreateNestedOneWithoutLegaleRappresentateInput?
      numeroTelefono;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutLegaleRappresentanteInput
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteUncheckedCreateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedCreateWithoutIndirizzoEmailInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  final _i2
      .NumeroTelefonoUncheckedCreateNestedOneWithoutLegaleRappresentateInput?
      numeroTelefono;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
      };
}

class LegaleRappresentanteCreateOrConnectWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateOrConnectWithoutIndirizzoEmailInput({
    required this.where,
    required this.create,
  });

  final _i2.LegaleRappresentanteWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteCreateWithoutIndirizzoEmailInput,
      _i2.LegaleRappresentanteUncheckedCreateWithoutIndirizzoEmailInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LegaleRappresentanteCreateNestedOneWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateNestedOneWithoutIndirizzoEmailInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutIndirizzoEmailInput,
          _i2.LegaleRappresentanteUncheckedCreateWithoutIndirizzoEmailInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutIndirizzoEmailInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IndirizzoEmailCreateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateWithoutReferenteInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggetto,
    this.legaleRappresentante,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.SoggettoCreateNestedOneWithoutIndirizziEmailInput? soggetto;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutIndirizzoEmailInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailCreateNestedOneWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateNestedOneWithoutReferenteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutReferenteInput>? create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoBusinessInfoCreateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateWithoutReferenteInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    required this.soggetto,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutSoggettoBusinessInfoInput?
      legaleRappresentante;

  final _i2.SoggettoCreateNestedOneWithoutSoggettoBusinessInfoInput soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoUncheckedCreateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedCreateWithoutReferenteInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    required this.soggettoUuid,
    this.legaleRappresentante,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final String soggettoUuid;

  final _i2
      .LegaleRappresentanteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
      };
}

class SoggettoBusinessInfoCreateOrConnectWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateOrConnectWithoutReferenteInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoBusinessInfoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutReferenteInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutReferenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoBusinessInfoCreateNestedOneWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateNestedOneWithoutReferenteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutReferenteInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutReferenteInput>? create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutReferenteInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReferenteCreateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateWithoutNumeroTelefonoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.indirizzoEmail,
    required this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.IndirizzoEmailCreateNestedOneWithoutReferenteInput? indirizzoEmail;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutReferenteInput
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteUncheckedCreateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedCreateWithoutNumeroTelefonoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  final _i2.IndirizzoEmailUncheckedCreateNestedOneWithoutReferenteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'indirizzoEmail': indirizzoEmail,
      };
}

class ReferenteCreateOrConnectWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateOrConnectWithoutNumeroTelefonoInput({
    required this.where,
    required this.create,
  });

  final _i2.ReferenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutNumeroTelefonoInput,
      _i2.ReferenteUncheckedCreateWithoutNumeroTelefonoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ReferenteCreateNestedOneWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateNestedOneWithoutNumeroTelefonoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutNumeroTelefonoInput,
      _i2.ReferenteUncheckedCreateWithoutNumeroTelefonoInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutNumeroTelefonoInput? connectOrCreate;

  final _i2.ReferenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class NumeroTelefonoCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateWithoutSoggettoInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.legaleRappresentate,
    this.referente,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutNumeroTelefonoInput?
      legaleRappresentate;

  final _i2.ReferenteCreateNestedOneWithoutNumeroTelefonoInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class NumeroTelefonoCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.NumeroTelefonoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.NumeroTelefonoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutIndirizziEmailInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutIndirizziEmailInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutIndirizziEmailInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutIndirizziEmailInput,
      _i2.SoggettoUncheckedCreateWithoutIndirizziEmailInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutIndirizziEmailInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutIndirizziEmailInput,
      _i2.SoggettoUncheckedCreateWithoutIndirizziEmailInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutIndirizziEmailInput? connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IndirizzoEmailCreateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateWithoutLegaleRappresentanteInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggetto,
    this.referente,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.SoggettoCreateNestedOneWithoutIndirizziEmailInput? soggetto;

  final _i2.ReferenteCreateNestedOneWithoutIndirizzoEmailInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'referente': referente,
      };
}

class IndirizzoEmailCreateNestedOneWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateNestedOneWithoutLegaleRappresentanteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutLegaleRappresentanteInput,
          _i2.IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput>?
      create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutLegaleRappresentanteInput?
      connectOrCreate;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LegaleRappresentanteCreateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateWithoutNumeroTelefonoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.indirizzoEmail,
    required this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.IndirizzoEmailCreateNestedOneWithoutLegaleRappresentanteInput?
      indirizzoEmail;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutLegaleRappresentanteInput
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteUncheckedCreateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedCreateWithoutNumeroTelefonoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  final _i2
      .IndirizzoEmailUncheckedCreateNestedOneWithoutLegaleRappresentanteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteCreateOrConnectWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateOrConnectWithoutNumeroTelefonoInput({
    required this.where,
    required this.create,
  });

  final _i2.LegaleRappresentanteWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteCreateWithoutNumeroTelefonoInput,
      _i2.LegaleRappresentanteUncheckedCreateWithoutNumeroTelefonoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LegaleRappresentanteCreateNestedOneWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateNestedOneWithoutNumeroTelefonoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutNumeroTelefonoInput,
          _i2.LegaleRappresentanteUncheckedCreateWithoutNumeroTelefonoInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutNumeroTelefonoInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class NumeroTelefonoCreateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateWithoutReferenteInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggetto,
    this.legaleRappresentate,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.SoggettoCreateNestedOneWithoutNumeriTelefonoInput? soggetto;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutNumeroTelefonoInput?
      legaleRappresentate;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
      };
}

class NumeroTelefonoCreateNestedOneWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateNestedOneWithoutReferenteInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutReferenteInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ReferenteCreateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateWithoutIndirizzoEmailInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    required this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoCreateNestedOneWithoutReferenteInput? numeroTelefono;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutReferenteInput
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteUncheckedCreateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedCreateWithoutIndirizzoEmailInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  final _i2.NumeroTelefonoUncheckedCreateNestedOneWithoutReferenteInput?
      numeroTelefono;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
      };
}

class ReferenteCreateOrConnectWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateOrConnectWithoutIndirizzoEmailInput({
    required this.where,
    required this.create,
  });

  final _i2.ReferenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutIndirizzoEmailInput,
      _i2.ReferenteUncheckedCreateWithoutIndirizzoEmailInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ReferenteCreateNestedOneWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateNestedOneWithoutIndirizzoEmailInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutIndirizzoEmailInput,
      _i2.ReferenteUncheckedCreateWithoutIndirizzoEmailInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutIndirizzoEmailInput? connectOrCreate;

  final _i2.ReferenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class IndirizzoEmailCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateWithoutSoggettoInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.referente,
    this.legaleRappresentante,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.ReferenteCreateNestedOneWithoutIndirizzoEmailInput? referente;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutIndirizzoEmailInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.IndirizzoEmailCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.IndirizzoEmailCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutContrattiInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutContrattiInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutContrattiInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutContrattiInput,
      _i2.SoggettoUncheckedCreateWithoutContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutContrattiInput,
      _i2.SoggettoUncheckedCreateWithoutContrattiInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
      };
}

class ContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.ContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.ContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.ContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateOrConnectWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutContrattiEnelXAssicurazioneInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.OffertaCreateWithoutContrattiEnelXAssicurazioneInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelXAssicurazioneInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedOneWithoutContrattiEnelXAssicurazioneInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.OffertaUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.OffertaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateWithoutStatoInput({
    this.uuid,
    required this.contratto,
    required this.domicilio,
    this.offerta,
  });

  final String? uuid;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      contratto;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      domicilio;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelXAssicurazioneInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoContrattoCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateWithoutContrattiInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutStatoInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput,
      _i2.ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class StatoContrattoUncheckedCreateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateWithoutContrattiInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateOrConnectWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateOrConnectWithoutContrattiInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoContrattoCreateNestedOneWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateNestedOneWithoutContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutContrattiEnelGasInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutContrattiEnelGasInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutContrattiEnelGasInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelGasInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateNestedOneWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedOneWithoutContrattiEnelGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelGasInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelGasInput?
      connectOrCreate;

  final _i2.ContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutContrattiEnelGasInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutContrattiEnelGasInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateOrConnectWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutContrattiEnelGasInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelGasInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateNestedOneWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedOneWithoutContrattiEnelGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelGasInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelGasInput? connectOrCreate;

  final _i2.OffertaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelGasCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateWithoutFornituraGasInput({
    this.uuid,
    required this.stato,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelGasInput stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelGasInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelGasInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasCreateNestedManyWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateNestedManyWithoutFornituraGasInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutFornituraGasInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutFornituraGasInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput,
          Iterable<
              _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyFornituraGasInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornituraGasCreateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateWithoutFornituraInput({
    this.uuid,
    required this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final String? uuid;

  final String pdr;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ClasseMisuratoreGasCreateNestedOneWithoutFornituraGasInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasCreateNestedOneWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateNestedOneWithoutFornituraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutFornituraInput,
      _i2.FornituraGasUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateWithoutDomicilioInput({
    this.uuid,
    this.etichetta,
    required this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.ServizioEwoCreateNestedOneWithoutFornitureInput servizioEwo;

  final _i2.FornituraLuceCreateNestedOneWithoutFornituraInput? fornituraLuce;

  final _i2.FornituraGasCreateNestedOneWithoutFornituraInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.FornituraCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.FornituraCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<
              _i2.FornituraUncheckedCreateWithoutDomicilioInput,
              Iterable<
                  _i2.FornituraUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.FornituraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggetto,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.SoggettoCreateNestedOneWithoutDomiciliInput soggetto;

  final _i2.FornituraCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineCreateNestedManyWithoutDomicilioInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  final _i2.FornituraUncheckedCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedCreateNestedManyWithoutDomicilioInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCreateOrConnectWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateOrConnectWithoutContrattiEnelXAssicurazioneInput({
    required this.where,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.DomicilioUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DomicilioCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateNestedOneWithoutContrattiEnelXAssicurazioneInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.DomicilioUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2.DomicilioCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.DomicilioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateWithoutContrattoInput({
    this.uuid,
    required this.stato,
    required this.domicilio,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      stato;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      domicilio;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelXAssicurazioneInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyContrattoInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutContrattiEnelFibraInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutContrattiEnelFibraInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutContrattiEnelFibraInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelFibraInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateNestedOneWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedOneWithoutContrattiEnelFibraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.ContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelFibraCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateWithoutStatoInput({
    this.uuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    required this.contratto,
    this.offerta,
    this.domicilio,
  });

  final String? uuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelFibraInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelFibraInput? offerta;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelFibraInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoContrattoCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutStatoInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateNestedManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateNestedManyWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoContrattoCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoContrattoUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2
                      .StatoContrattoUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutStatiPossibiliPraticheInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput,
      _i2.ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoCreateNestedManyWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedManyWithoutStatiPossibiliPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class StatoPraticaCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateWithoutPraticheInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliPraticheInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class StatoPraticaUncheckedCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedCreateWithoutPraticheInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
  });

  final String id;

  final String nome;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliPraticheInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaCreateOrConnectWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateOrConnectWithoutPraticheInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateWithoutPraticheInput,
      _i2.StatoPraticaUncheckedCreateWithoutPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoPraticaCreateNestedOneWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateNestedOneWithoutPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaCreateWithoutPraticheInput,
      _i2.StatoPraticaUncheckedCreateWithoutPraticheInput>? create;

  final _i2.StatoPraticaCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.StatoPraticaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PraticaCreateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateWithoutNegozioInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    required this.tipoPratica,
    this.soggetto,
    this.utente,
    this.stato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaCreateNestedOneWithoutPraticheInput tipoPratica;

  final _i2.SoggettoCreateNestedOneWithoutPraticheIntestateInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutPraticheInput? utente;

  final _i2.StatoPraticaCreateNestedOneWithoutPraticheInput? stato;

  final _i2.ContrattoCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaCreateNestedManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateNestedManyWithoutNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i2.PraticaCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class NegozioCreateWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutUtentiInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.contratti,
    this.soggetti,
    required this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutUtentiInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutUtentiInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutUtentiInput,
      _i2.NegozioUncheckedCreateWithoutUtentiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateNestedOneWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedOneWithoutUtentiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutUtentiInput,
      _i2.NegozioUncheckedCreateWithoutUtentiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutUtentiInput? connectOrCreate;

  final _i2.NegozioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class UtenteCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateWithoutPraticheInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateWithoutPraticheInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateOrConnectWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateOrConnectWithoutPraticheInput({
    required this.where,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutPraticheInput,
      _i2.UtenteUncheckedCreateWithoutPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class UtenteCreateNestedOneWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateNestedOneWithoutPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutPraticheInput,
      _i2.UtenteUncheckedCreateWithoutPraticheInput>? create;

  final _i2.UtenteCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.UtenteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PraticaCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateWithoutStatoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    required this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaCreateNestedOneWithoutPraticheInput tipoPratica;

  final _i2.SoggettoCreateNestedOneWithoutPraticheIntestateInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutPraticheInput? utente;

  final _i2.NegozioCreateNestedOneWithoutPraticheInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'contratto': contratto,
      };
}

class PraticaCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutStatoInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutStatoInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutStatoInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutStatoInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutStatoInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i2.PraticaCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoPraticaCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.pratiche,
  });

  final String id;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutStatoInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class StatoPraticaCreateNestedManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateNestedManyWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.StatoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutFornitureInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.tipiPratiche,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedCreateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutFornitureInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateOrConnectWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutFornitureInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutFornitureInput,
      _i2.ServizioEwoUncheckedCreateWithoutFornitureInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoCreateNestedOneWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedOneWithoutFornitureInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutFornitureInput,
      _i2.ServizioEwoUncheckedCreateWithoutFornitureInput>? create;

  final _i2.ServizioEwoCreateOrConnectWithoutFornitureInput? connectOrCreate;

  final _i2.ServizioEwoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateWithoutFornituraGasInput({
    this.uuid,
    this.etichetta,
    required this.domicilio,
    required this.servizioEwo,
    this.fornituraLuce,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.DomicilioCreateNestedOneWithoutFornitureInput domicilio;

  final _i2.ServizioEwoCreateNestedOneWithoutFornitureInput servizioEwo;

  final _i2.FornituraLuceCreateNestedOneWithoutFornituraInput? fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
      };
}

class FornituraUncheckedCreateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateWithoutFornituraGasInput({
    this.uuid,
    this.etichetta,
    required this.domicilioUuid,
    required this.servizioEwoId,
    this.fornituraLuce,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String domicilioUuid;

  final String servizioEwoId;

  final _i2.FornituraLuceUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'fornituraLuce': fornituraLuce,
      };
}

class FornituraCreateOrConnectWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateOrConnectWithoutFornituraGasInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraGasInput,
      _i2.FornituraUncheckedCreateWithoutFornituraGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraCreateNestedOneWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateNestedOneWithoutFornituraGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraGasInput,
      _i2.FornituraUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.FornituraCreateOrConnectWithoutFornituraGasInput? connectOrCreate;

  final _i2.FornituraWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraGasCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateWithoutContrattiEnelGasInput({
    this.uuid,
    required this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    required this.fornitura,
  });

  final String? uuid;

  final String pdr;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ClasseMisuratoreGasCreateNestedOneWithoutFornituraGasInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.FornituraCreateNestedOneWithoutFornituraGasInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateWithoutContrattiEnelGasInput({
    this.uuid,
    required this.pdr,
    required this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
  });

  final String? uuid;

  final String pdr;

  final String fornituraUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classeMisuratoreGasId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ConsumoAnnuoGasUncheckedCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
      };
}

class FornituraGasCreateOrConnectWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateOrConnectWithoutContrattiEnelGasInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutContrattiEnelGasInput,
      _i2.FornituraGasUncheckedCreateWithoutContrattiEnelGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraGasCreateNestedOneWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateNestedOneWithoutContrattiEnelGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutContrattiEnelGasInput,
      _i2.FornituraGasUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutContrattiEnelGasInput?
      connectOrCreate;

  final _i2.FornituraGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelGasCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateWithoutStatoInput({
    this.uuid,
    required this.fornituraGas,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.FornituraGasCreateNestedOneWithoutContrattiEnelGasInput
      fornituraGas;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelGasInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelGasInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoContrattoCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateWithoutContrattiEnelFibraInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutStatoInput? contrattiEnelGas;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedCreateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateWithoutContrattiEnelFibraInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutStatoInput? contratti;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelGas;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateOrConnectWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateOrConnectWithoutContrattiEnelFibraInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelFibraInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoContrattoCreateNestedOneWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateNestedOneWithoutContrattiEnelFibraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelFibraCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateWithoutContrattoInput({
    this.uuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    required this.stato,
    this.offerta,
    this.domicilio,
  });

  final String? uuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelFibraInput stato;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelFibraInput? offerta;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelFibraInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelFibraCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutContrattiEnelLuceInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateWithoutContrattiEnelLuceInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateOrConnectWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateOrConnectWithoutContrattiEnelLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ContrattoCreateNestedOneWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedOneWithoutContrattiEnelLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.ContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class OffertaCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateWithoutContrattiEnelLuceInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateWithoutContrattiEnelLuceInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateOrConnectWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateOrConnectWithoutContrattiEnelLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelLuceInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OffertaCreateNestedOneWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateNestedOneWithoutContrattiEnelLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelLuceInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.OffertaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelLuceCreateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateWithoutFornituraLuceInput({
    this.uuid,
    required this.stato,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelLuceInput stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelLuceInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelLuceInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceCreateNestedManyWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateNestedManyWithoutFornituraLuceInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput,
          Iterable<
              _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyFornituraLuceInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornituraLuceCreateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateWithoutFornituraInput({
    this.uuid,
    required this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
  });

  final String? uuid;

  final String pod;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ConsumoAnnuoLuceCreateNestedOneWithoutFornituraLuceInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutFornituraLuceInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceCreateNestedOneWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateNestedOneWithoutFornituraInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraCreateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateWithoutServizioEwoInput({
    this.uuid,
    this.etichetta,
    required this.domicilio,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.DomicilioCreateNestedOneWithoutFornitureInput domicilio;

  final _i2.FornituraLuceCreateNestedOneWithoutFornituraInput? fornituraLuce;

  final _i2.FornituraGasCreateNestedOneWithoutFornituraInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraCreateNestedManyWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateNestedManyWithoutServizioEwoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.FornituraCreateWithoutServizioEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraCreateWithoutServizioEwoInput>,
              _i1.PrismaUnion<
                  _i2.FornituraUncheckedCreateWithoutServizioEwoInput,
                  Iterable<
                      _i2.FornituraUncheckedCreateWithoutServizioEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i2.FornituraCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutTipiPraticheInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedCreateWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateWithoutTipiPraticheInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateOrConnectWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateOrConnectWithoutTipiPraticheInput({
    required this.where,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutTipiPraticheInput,
      _i2.ServizioEwoUncheckedCreateWithoutTipiPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ServizioEwoCreateNestedManyWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedManyWithoutTipiPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutTipiPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutTipiPraticheInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutTipiPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutTipiPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class TipoPraticaCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateWithoutPraticheInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutTipiPraticheInput? serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class ServizioEwoUncheckedCreateNestedManyWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateNestedManyWithoutTipiPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutTipiPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutTipiPraticheInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutTipiPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutTipiPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class TipoPraticaUncheckedCreateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedCreateWithoutPraticheInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutTipiPraticheInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class TipoPraticaCreateOrConnectWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateOrConnectWithoutPraticheInput({
    required this.where,
    required this.create,
  });

  final _i2.TipoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateWithoutPraticheInput,
      _i2.TipoPraticaUncheckedCreateWithoutPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class TipoPraticaCreateNestedOneWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateNestedOneWithoutPraticheInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaCreateWithoutPraticheInput,
      _i2.TipoPraticaUncheckedCreateWithoutPraticheInput>? create;

  final _i2.TipoPraticaCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.TipoPraticaWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PraticaCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateWithoutSoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    required this.tipoPratica,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaCreateNestedOneWithoutPraticheInput tipoPratica;

  final _i2.UtenteCreateNestedOneWithoutPraticheInput? utente;

  final _i2.NegozioCreateNestedOneWithoutPraticheInput? negozio;

  final _i2.StatoPraticaCreateNestedOneWithoutPraticheInput? stato;

  final _i2.ContrattoCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.PraticaCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutDomiciliInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutDomiciliInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutDomiciliInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutDomiciliInput,
      _i2.SoggettoUncheckedCreateWithoutDomiciliInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutDomiciliInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutDomiciliInput,
      _i2.SoggettoUncheckedCreateWithoutDomiciliInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutDomiciliInput? connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class DomicilioCreateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateWithoutFornitureInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.SoggettoCreateNestedOneWithoutDomiciliInput soggetto;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineCreateNestedManyWithoutDomicilioInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedCreateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateWithoutFornitureInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedCreateNestedManyWithoutDomicilioInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCreateOrConnectWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateOrConnectWithoutFornitureInput({
    required this.where,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutFornitureInput,
      _i2.DomicilioUncheckedCreateWithoutFornitureInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class DomicilioCreateNestedOneWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateNestedOneWithoutFornitureInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutFornitureInput,
      _i2.DomicilioUncheckedCreateWithoutFornitureInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutFornitureInput? connectOrCreate;

  final _i2.DomicilioWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraCreateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateWithoutFornituraLuceInput({
    this.uuid,
    this.etichetta,
    required this.domicilio,
    required this.servizioEwo,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.DomicilioCreateNestedOneWithoutFornitureInput domicilio;

  final _i2.ServizioEwoCreateNestedOneWithoutFornitureInput servizioEwo;

  final _i2.FornituraGasCreateNestedOneWithoutFornituraInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUncheckedCreateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateWithoutFornituraLuceInput({
    this.uuid,
    this.etichetta,
    required this.domicilioUuid,
    required this.servizioEwoId,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String domicilioUuid;

  final String servizioEwoId;

  final _i2.FornituraGasUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'fornituraGas': fornituraGas,
      };
}

class FornituraCreateOrConnectWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateOrConnectWithoutFornituraLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraLuceInput,
      _i2.FornituraUncheckedCreateWithoutFornituraLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraCreateNestedOneWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateNestedOneWithoutFornituraLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraLuceInput,
      _i2.FornituraUncheckedCreateWithoutFornituraLuceInput>? create;

  final _i2.FornituraCreateOrConnectWithoutFornituraLuceInput? connectOrCreate;

  final _i2.FornituraWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class FornituraLuceCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateWithoutContrattiEnelLuceInput({
    this.uuid,
    required this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    required this.fornitura,
  });

  final String? uuid;

  final String pod;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ConsumoAnnuoLuceCreateNestedOneWithoutFornituraLuceInput?
      consumoAnnuoLuce;

  final _i2.FornituraCreateNestedOneWithoutFornituraLuceInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceUncheckedCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedCreateWithoutContrattiEnelLuceInput({
    this.uuid,
    required this.pod,
    required this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
  });

  final String? uuid;

  final String pod;

  final String fornituraUuid;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ConsumoAnnuoLuceUncheckedCreateNestedOneWithoutFornituraLuceInput?
      consumoAnnuoLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
      };
}

class FornituraLuceCreateOrConnectWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateOrConnectWithoutContrattiEnelLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutContrattiEnelLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutContrattiEnelLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraLuceCreateNestedOneWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateNestedOneWithoutContrattiEnelLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutContrattiEnelLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelLuceCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateWithoutStatoInput({
    this.uuid,
    required this.fornituraLuce,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.FornituraLuceCreateNestedOneWithoutContrattiEnelLuceInput
      fornituraLuce;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelLuceInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelLuceInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoContrattoCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateWithoutContrattiEnelGasInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedCreateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateWithoutContrattiEnelGasInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutStatoInput? contratti;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateOrConnectWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateOrConnectWithoutContrattiEnelGasInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelGasInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoContrattoCreateNestedOneWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateNestedOneWithoutContrattiEnelGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelGasInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiEnelGasInput?
      connectOrCreate;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelGasCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateWithoutContrattoInput({
    this.uuid,
    required this.stato,
    required this.fornituraGas,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelGasInput stato;

  final _i2.FornituraGasCreateNestedOneWithoutContrattiEnelGasInput
      fornituraGas;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelGasInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'offerta': offerta,
      };
}

class ContrattoEnelGasCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelGasCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutSoggettoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.ContrattoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutPraticheIntestateInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutPraticheIntestateInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutPraticheIntestateInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPraticheIntestateInput,
      _i2.SoggettoUncheckedCreateWithoutPraticheIntestateInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutPraticheIntestateInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPraticheIntestateInput,
      _i2.SoggettoUncheckedCreateWithoutPraticheIntestateInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutPraticheIntestateInput?
      connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PraticaCreateWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateWithoutTipoPraticaInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.SoggettoCreateNestedOneWithoutPraticheIntestateInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutPraticheInput? utente;

  final _i2.NegozioCreateNestedOneWithoutPraticheInput? negozio;

  final _i2.StatoPraticaCreateNestedOneWithoutPraticheInput? stato;

  final _i2.ContrattoCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaCreateNestedManyWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateNestedManyWithoutTipoPraticaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutTipoPraticaInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutTipoPraticaInput>,
          _i1.PrismaUnion<
              _i2.PraticaUncheckedCreateWithoutTipoPraticaInput,
              Iterable<
                  _i2.PraticaUncheckedCreateWithoutTipoPraticaInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput>>?
      connectOrCreate;

  final _i2.PraticaCreateManyTipoPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class TipoPraticaCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.pratiche,
  });

  final String id;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutTipoPraticaInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class TipoPraticaCreateNestedManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateNestedManyWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.TipoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.TipoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutModuliContrattoInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
      };
}

class ServizioEwoCreateNestedManyWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedManyWithoutModuliContrattoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutModuliContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutModuliContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutModuliContrattoInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutModuliContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ModuloContrattoCreateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateWithoutFornitoreInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
    required this.tipoModulo,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final _i2.ServizioEwoCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.ContrattoCreateNestedManyWithoutModuloInput? contratti;

  final _i2.TipoModuloContrattoCreateNestedOneWithoutModuloContrattoInput
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoCreateNestedManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateNestedManyWithoutFornitoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i2.ModuloContrattoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class FornitoreCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.moduliContratto,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ModuloContrattoCreateNestedManyWithoutFornitoreInput?
      moduliContratto;

  final _i2.ProdottoCreateNestedManyWithoutFornitoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreUncheckedCreateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedCreateWithoutServiziEwoInput({
    required this.id,
    required this.nome,
    this.moduliContratto,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ModuloContrattoUncheckedCreateNestedManyWithoutFornitoreInput?
      moduliContratto;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutFornitoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreCreateOrConnectWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateOrConnectWithoutServiziEwoInput({
    required this.where,
    required this.create,
  });

  final _i2.FornitoreWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutServiziEwoInput,
      _i2.FornitoreUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornitoreCreateNestedOneWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateNestedOneWithoutServiziEwoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutServiziEwoInput,
      _i2.FornitoreUncheckedCreateWithoutServiziEwoInput>? create;

  final _i2.FornitoreCreateOrConnectWithoutServiziEwoInput? connectOrCreate;

  final _i2.FornitoreWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ServizioEwoCreateWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateWithoutStatiPossibiliContrattiInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class StatoContrattoCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateWithoutContrattiEnelLuceInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutStatoInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedCreateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateWithoutContrattiEnelLuceInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutStatoInput? contratti;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateOrConnectWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateOrConnectWithoutContrattiEnelLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoContrattoCreateNestedOneWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateNestedOneWithoutContrattiEnelLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelLuceCreateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateWithoutContrattoInput({
    this.uuid,
    required this.stato,
    required this.fornituraLuce,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelLuceInput stato;

  final _i2.FornituraLuceCreateNestedOneWithoutContrattiEnelLuceInput
      fornituraLuce;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelLuceInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceCreateNestedManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateNestedManyWithoutContrattoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelLuceCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ContrattoCreateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateWithoutStatoInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoCreateNestedManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateNestedManyWithoutStatoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutStatoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutStatoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutStatoInput,
      Iterable<_i2.ContrattoCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i2.ContrattoCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoContrattoCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateWithoutContrattiEnelXAssicurazioneInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
  });

  final String id;

  final String nome;

  final _i2.ContrattoCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutStatoInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
      };
}

class StatoContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
  });

  final String id;

  final String nome;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutStatoInput? contratti;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
      };
}

class StatoContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput({
    required this.where,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class StatoContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2
      .StatoContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput({
    this.uuid,
    required this.stato,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelXAssicurazioneInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i2.ContrattoEnelXAssicurazioneCreateManyDomicilioInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class DomicilioCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateWithoutSoggettoInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineCreateNestedManyWithoutDomicilioInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCreateNestedManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateNestedManyWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.DomicilioCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.DomicilioUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.DomicilioUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.DomicilioCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.DomicilioCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i2.DomicilioCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class SoggettoCreateWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutNumeriTelefonoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutNumeriTelefonoInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoCreateOrConnectWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutNumeriTelefonoInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutNumeriTelefonoInput,
      _i2.SoggettoUncheckedCreateWithoutNumeriTelefonoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutNumeriTelefonoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutNumeriTelefonoInput,
      _i2.SoggettoUncheckedCreateWithoutNumeriTelefonoInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutNumeriTelefonoInput? connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class NumeroTelefonoCreateWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateWithoutLegaleRappresentateInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggetto,
    this.referente,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.SoggettoCreateNestedOneWithoutNumeriTelefonoInput? soggetto;

  final _i2.ReferenteCreateNestedOneWithoutNumeroTelefonoInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'referente': referente,
      };
}

class NumeroTelefonoCreateNestedOneWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateNestedOneWithoutLegaleRappresentateInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutLegaleRappresentateInput?
      connectOrCreate;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoCreateNestedOneWithoutLegaleRappresentateInput?
      numeroTelefono;

  final _i2.IndirizzoEmailCreateNestedOneWithoutLegaleRappresentanteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteCreateNestedOneWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateNestedOneWithoutSoggettoBusinessInfoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoBusinessInfoCreateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateWithoutSoggettoInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutSoggettoBusinessInfoInput?
      legaleRappresentante;

  final _i2.ReferenteCreateNestedOneWithoutSoggettoBusinessInfoInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
      };
}

class SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutSoggettoInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class SoggettoCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  final _i2.PrivacyUncheckedCreateNestedOneWithoutSoggettoInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class AffectedRowsOutput {
  const AffectedRowsOutput({this.count});

  factory AffectedRowsOutput.fromJson(Map json) =>
      AffectedRowsOutput(count: json['count']);

  final int? count;
}

class SoggettoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateManyInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class StringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringFieldUpdateOperationsInput({this.set});

  final String? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableStringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableStringFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<String, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumTipoSoggettoFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoSoggettoFieldUpdateOperationsInput({this.set});

  final _i3.TipoSoggetto? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class DateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFieldUpdateOperationsInput({this.set});

  final DateTime? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableDateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableDateTimeFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableBoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableBoolFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class BoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFieldUpdateOperationsInput({this.set});

  final bool? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableIntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class EnumTipoServizioEwoFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoServizioEwoFieldUpdateOperationsInput({this.set});

  final _i3.TipoServizioEwo? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumCanaleFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumCanaleFieldUpdateOperationsInput({this.set});

  final _i3.Canale? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableFloatFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableFloatFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<double, _i1.PrismaNull>? set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class FloatFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final double? set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class ConsumoAnnuoLuceUpdateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUpdateWithoutFornituraLuceInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoLuceUncheckedUpdateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedUpdateWithoutFornituraLuceInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoLuceUpsertWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUpsertWithoutFornituraLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceUpdateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedUpdateWithoutFornituraLuceInput> update;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceCreateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput> create;

  final _i2.ConsumoAnnuoLuceWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ConsumoAnnuoLuceUpdateToOneWithWhereWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUpdateToOneWithWhereWithoutFornituraLuceInput({
    this.where,
    required this.data,
  });

  final _i2.ConsumoAnnuoLuceWhereInput? where;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceUpdateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedUpdateWithoutFornituraLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ConsumoAnnuoLuceUpdateOneWithoutFornituraLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUpdateOneWithoutFornituraLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceCreateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput>? create;

  final _i2.ConsumoAnnuoLuceCreateOrConnectWithoutFornituraLuceInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoLuceUpsertWithoutFornituraLuceInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceWhereInput>? delete;

  final _i2.ConsumoAnnuoLuceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.ConsumoAnnuoLuceUpdateToOneWithWhereWithoutFornituraLuceInput,
          _i1.PrismaUnion<_i2.ConsumoAnnuoLuceUpdateWithoutFornituraLuceInput,
              _i2.ConsumoAnnuoLuceUncheckedUpdateWithoutFornituraLuceInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class EnumServizioContrattoEnelFibraFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumServizioContrattoEnelFibraFieldUpdateOperationsInput({this.set});

  final _i3.ServizioContrattoEnelFibra? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumTipoContrattoEnelFibraFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoContrattoEnelFibraFieldUpdateOperationsInput({this.set});

  final _i3.TipoContrattoEnelFibra? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput({this.set});

  final _i3.TecnologiaContrattoEnelFibra? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ClasseMisuratoreGasUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUpdateWithoutFornituraGasInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMin;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataNominale;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMax;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasUncheckedUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUncheckedUpdateWithoutFornituraGasInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMin;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataNominale;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMax;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasUpsertWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUpsertWithoutFornituraGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasUpdateWithoutFornituraGasInput,
      _i2.ClasseMisuratoreGasUncheckedUpdateWithoutFornituraGasInput> update;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasCreateWithoutFornituraGasInput,
      _i2.ClasseMisuratoreGasUncheckedCreateWithoutFornituraGasInput> create;

  final _i2.ClasseMisuratoreGasWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ClasseMisuratoreGasUpdateToOneWithWhereWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUpdateToOneWithWhereWithoutFornituraGasInput({
    this.where,
    required this.data,
  });

  final _i2.ClasseMisuratoreGasWhereInput? where;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasUpdateWithoutFornituraGasInput,
      _i2.ClasseMisuratoreGasUncheckedUpdateWithoutFornituraGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ClasseMisuratoreGasUpdateOneWithoutFornituraGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUpdateOneWithoutFornituraGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasCreateWithoutFornituraGasInput,
      _i2.ClasseMisuratoreGasUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.ClasseMisuratoreGasCreateOrConnectWithoutFornituraGasInput?
      connectOrCreate;

  final _i2.ClasseMisuratoreGasUpsertWithoutFornituraGasInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasWhereInput>? delete;

  final _i2.ClasseMisuratoreGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.ClasseMisuratoreGasUpdateToOneWithWhereWithoutFornituraGasInput,
          _i1.PrismaUnion<_i2.ClasseMisuratoreGasUpdateWithoutFornituraGasInput,
              _i2.ClasseMisuratoreGasUncheckedUpdateWithoutFornituraGasInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ConsumoAnnuoGasUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUpdateWithoutFornituraGasInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoGasUncheckedUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedUpdateWithoutFornituraGasInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoGasUpsertWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUpsertWithoutFornituraGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasUpdateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedUpdateWithoutFornituraGasInput> update;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasCreateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput> create;

  final _i2.ConsumoAnnuoGasWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ConsumoAnnuoGasUpdateToOneWithWhereWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUpdateToOneWithWhereWithoutFornituraGasInput({
    this.where,
    required this.data,
  });

  final _i2.ConsumoAnnuoGasWhereInput? where;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasUpdateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedUpdateWithoutFornituraGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ConsumoAnnuoGasUpdateOneWithoutFornituraGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUpdateOneWithoutFornituraGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasCreateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.ConsumoAnnuoGasCreateOrConnectWithoutFornituraGasInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoGasUpsertWithoutFornituraGasInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasWhereInput>? delete;

  final _i2.ConsumoAnnuoGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ConsumoAnnuoGasUpdateToOneWithWhereWithoutFornituraGasInput,
      _i1.PrismaUnion<_i2.ConsumoAnnuoGasUpdateWithoutFornituraGasInput,
          _i2.ConsumoAnnuoGasUncheckedUpdateWithoutFornituraGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class EnumRuoloUtenteFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumRuoloUtenteFieldUpdateOperationsInput({this.set});

  final _i3.RuoloUtente? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class ReferenteUpdateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUpdateOneWithoutReferenteNestedInput? numeroTelefono;

  final _i2.IndirizzoEmailUpdateOneWithoutReferenteNestedInput? indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class NumeroTelefonoUncheckedUpdateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateWithoutReferenteInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentateUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
      };
}

class NumeroTelefonoUpdateToOneWithWhereWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateToOneWithWhereWithoutReferenteInput({
    this.where,
    required this.data,
  });

  final _i2.NumeroTelefonoWhereInput? where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedUpdateWithoutReferenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NumeroTelefonoUncheckedUpdateOneWithoutReferenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateOneWithoutReferenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutReferenteInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.NumeroTelefonoUpsertWithoutReferenteInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? delete;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NumeroTelefonoUpdateToOneWithWhereWithoutReferenteInput,
      _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutReferenteInput,
          _i2.NumeroTelefonoUncheckedUpdateWithoutReferenteInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class IndirizzoEmailUncheckedUpdateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateWithoutReferenteInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentanteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
      };
}

class IndirizzoEmailUpdateToOneWithWhereWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateToOneWithWhereWithoutReferenteInput({
    this.where,
    required this.data,
  });

  final _i2.IndirizzoEmailWhereInput? where;

  final _i1.PrismaUnion<_i2.IndirizzoEmailUpdateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedUpdateWithoutReferenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IndirizzoEmailUncheckedUpdateOneWithoutReferenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateOneWithoutReferenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutReferenteInput>? create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.IndirizzoEmailUpsertWithoutReferenteInput? upsert;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? delete;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpdateToOneWithWhereWithoutReferenteInput,
      _i1.PrismaUnion<_i2.IndirizzoEmailUpdateWithoutReferenteInput,
          _i2.IndirizzoEmailUncheckedUpdateWithoutReferenteInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ReferenteUncheckedUpdateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedUpdateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUncheckedUpdateOneWithoutReferenteNestedInput?
      numeroTelefono;

  final _i2.IndirizzoEmailUncheckedUpdateOneWithoutReferenteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class ReferenteUpsertWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpsertWithoutSoggettoBusinessInfoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ReferenteUpdateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedUpdateWithoutSoggettoBusinessInfoInput> update;

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput> create;

  final _i2.ReferenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ReferenteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput({
    this.where,
    required this.data,
  });

  final _i2.ReferenteWhereInput? where;

  final _i1.PrismaUnion<_i2.ReferenteUpdateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedUpdateWithoutSoggettoBusinessInfoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReferenteUpdateOneWithoutSoggettoBusinessInfoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateOneWithoutSoggettoBusinessInfoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.ReferenteUpsertWithoutSoggettoBusinessInfoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? delete;

  final _i2.ReferenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.ReferenteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput,
          _i1.PrismaUnion<_i2.ReferenteUpdateWithoutSoggettoBusinessInfoInput,
              _i2.ReferenteUncheckedUpdateWithoutSoggettoBusinessInfoInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ProduttoreUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUpdateWithoutProdottiInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreUncheckedUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUncheckedUpdateWithoutProdottiInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreUpsertWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUpsertWithoutProdottiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ProduttoreUpdateWithoutProdottiInput,
      _i2.ProduttoreUncheckedUpdateWithoutProdottiInput> update;

  final _i1.PrismaUnion<_i2.ProduttoreCreateWithoutProdottiInput,
      _i2.ProduttoreUncheckedCreateWithoutProdottiInput> create;

  final _i2.ProduttoreWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ProduttoreUpdateToOneWithWhereWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUpdateToOneWithWhereWithoutProdottiInput({
    this.where,
    required this.data,
  });

  final _i2.ProduttoreWhereInput? where;

  final _i1.PrismaUnion<_i2.ProduttoreUpdateWithoutProdottiInput,
      _i2.ProduttoreUncheckedUpdateWithoutProdottiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProduttoreUpdateOneRequiredWithoutProdottiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUpdateOneRequiredWithoutProdottiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ProduttoreCreateWithoutProdottiInput,
      _i2.ProduttoreUncheckedCreateWithoutProdottiInput>? create;

  final _i2.ProduttoreCreateOrConnectWithoutProdottiInput? connectOrCreate;

  final _i2.ProduttoreUpsertWithoutProdottiInput? upsert;

  final _i2.ProduttoreWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ProduttoreUpdateToOneWithWhereWithoutProdottiInput,
      _i1.PrismaUnion<_i2.ProduttoreUpdateWithoutProdottiInput,
          _i2.ProduttoreUncheckedUpdateWithoutProdottiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelLuceUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithoutOffertaInput({
    this.uuid,
    this.stato,
    this.fornituraLuce,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      stato;

  final _i2.FornituraLuceUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      fornituraLuce;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
      };
}

class ContrattoEnelLuceUncheckedUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelLuceUpsertWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpsertWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutOffertaInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutOffertaInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutOffertaInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelLuceUpdateWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutOffertaInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelLuceScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraLuceUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyMutationInput({this.uuid});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  @override
  Map<String, dynamic> toJson() => {'uuid': uuid};
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelLuceUpdateManyWithWhereWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithWhereWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateManyMutationInput,
      _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelLuceCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelGasUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithoutOffertaInput({
    this.uuid,
    this.stato,
    this.fornituraGas,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      stato;

  final _i2.FornituraGasUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      fornituraGas;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
      };
}

class ContrattoEnelGasUncheckedUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelGasUpsertWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpsertWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutOffertaInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutOffertaInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutOffertaInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelGasUpdateWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutOffertaInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelGasScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraGasUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyMutationInput({this.uuid});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  @override
  Map<String, dynamic> toJson() => {'uuid': uuid};
}

class ContrattoEnelGasUncheckedUpdateManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
      };
}

class ContrattoEnelGasUpdateManyWithWhereWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithWhereWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateManyMutationInput,
      _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelGasUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class IntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class ZonaNegozioUpdateWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUpdateWithoutNegoziInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioUncheckedUpdateWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUncheckedUpdateWithoutNegoziInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioUpsertWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUpsertWithoutNegoziInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ZonaNegozioUpdateWithoutNegoziInput,
      _i2.ZonaNegozioUncheckedUpdateWithoutNegoziInput> update;

  final _i1.PrismaUnion<_i2.ZonaNegozioCreateWithoutNegoziInput,
      _i2.ZonaNegozioUncheckedCreateWithoutNegoziInput> create;

  final _i2.ZonaNegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ZonaNegozioUpdateToOneWithWhereWithoutNegoziInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUpdateToOneWithWhereWithoutNegoziInput({
    this.where,
    required this.data,
  });

  final _i2.ZonaNegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.ZonaNegozioUpdateWithoutNegoziInput,
      _i2.ZonaNegozioUncheckedUpdateWithoutNegoziInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ZonaNegozioCreateWithoutNegoziInput,
      _i2.ZonaNegozioUncheckedCreateWithoutNegoziInput>? create;

  final _i2.ZonaNegozioCreateOrConnectWithoutNegoziInput? connectOrCreate;

  final _i2.ZonaNegozioUpsertWithoutNegoziInput? upsert;

  final _i2.ZonaNegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ZonaNegozioUpdateToOneWithWhereWithoutNegoziInput,
      _i1.PrismaUnion<_i2.ZonaNegozioUpdateWithoutNegoziInput,
          _i2.ZonaNegozioUncheckedUpdateWithoutNegoziInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class PrivacyUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUpdateWithoutSoggettoInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? trattamento;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      comunicazione;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? profilazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
      };
}

class PrivacyUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? trattamento;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      comunicazione;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? profilazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
      };
}

class PrivacyUpsertWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUpsertWithoutSoggettoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.PrivacyUpdateWithoutSoggettoInput,
      _i2.PrivacyUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.PrivacyCreateWithoutSoggettoInput,
      _i2.PrivacyUncheckedCreateWithoutSoggettoInput> create;

  final _i2.PrivacyWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class PrivacyUpdateToOneWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUpdateToOneWithWhereWithoutSoggettoInput({
    this.where,
    required this.data,
  });

  final _i2.PrivacyWhereInput? where;

  final _i1.PrismaUnion<_i2.PrivacyUpdateWithoutSoggettoInput,
      _i2.PrivacyUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PrivacyUpdateOneWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUpdateOneWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.PrivacyCreateWithoutSoggettoInput,
      _i2.PrivacyUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.PrivacyCreateOrConnectWithoutSoggettoInput? connectOrCreate;

  final _i2.PrivacyUpsertWithoutSoggettoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.PrivacyWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.PrivacyWhereInput>? delete;

  final _i2.PrivacyWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.PrivacyUpdateToOneWithWhereWithoutSoggettoInput,
      _i1.PrismaUnion<_i2.PrivacyUpdateWithoutSoggettoInput,
          _i2.PrivacyUncheckedUpdateWithoutSoggettoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutLeadsInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'privacy': privacy,
      };
}

class NumeroTelefonoUncheckedUpdateWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateWithoutLegaleRappresentateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoUpdateToOneWithWhereWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateToOneWithWhereWithoutLegaleRappresentateInput({
    this.where,
    required this.data,
  });

  final _i2.NumeroTelefonoWhereInput? where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedUpdateWithoutLegaleRappresentateInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NumeroTelefonoUncheckedUpdateOneWithoutLegaleRappresentateNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateOneWithoutLegaleRappresentateNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutLegaleRappresentateInput?
      connectOrCreate;

  final _i2.NumeroTelefonoUpsertWithoutLegaleRappresentateInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? delete;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoUpdateToOneWithWhereWithoutLegaleRappresentateInput,
          _i1.PrismaUnion<
              _i2.NumeroTelefonoUpdateWithoutLegaleRappresentateInput,
              _i2
              .NumeroTelefonoUncheckedUpdateWithoutLegaleRappresentateInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class IndirizzoEmailUncheckedUpdateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateWithoutLegaleRappresentanteInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailUpdateToOneWithWhereWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateToOneWithWhereWithoutLegaleRappresentanteInput({
    this.where,
    required this.data,
  });

  final _i2.IndirizzoEmailWhereInput? where;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpdateWithoutLegaleRappresentanteInput,
      _i2.IndirizzoEmailUncheckedUpdateWithoutLegaleRappresentanteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IndirizzoEmailUncheckedUpdateOneWithoutLegaleRappresentanteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateOneWithoutLegaleRappresentanteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutLegaleRappresentanteInput,
          _i2.IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput>?
      create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutLegaleRappresentanteInput?
      connectOrCreate;

  final _i2.IndirizzoEmailUpsertWithoutLegaleRappresentanteInput? upsert;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? delete;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .IndirizzoEmailUpdateToOneWithWhereWithoutLegaleRappresentanteInput,
          _i1.PrismaUnion<
              _i2.IndirizzoEmailUpdateWithoutLegaleRappresentanteInput,
              _i2
              .IndirizzoEmailUncheckedUpdateWithoutLegaleRappresentanteInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class LegaleRappresentanteUncheckedUpdateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedUpdateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2
      .NumeroTelefonoUncheckedUpdateOneWithoutLegaleRappresentateNestedInput?
      numeroTelefono;

  final _i2
      .IndirizzoEmailUncheckedUpdateOneWithoutLegaleRappresentanteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput({
    this.where,
    required this.data,
  });

  final _i2.LegaleRappresentanteWhereInput? where;

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteUpdateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedUpdateWithoutSoggettoBusinessInfoInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LegaleRappresentanteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteUpsertWithoutSoggettoBusinessInfoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? delete;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2
      .LegaleRappresentanteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput,
      _i1.PrismaUnion<
          _i2.LegaleRappresentanteUpdateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedUpdateWithoutSoggettoBusinessInfoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ReferenteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutSoggettoBusinessInfoInput,
      _i2.ReferenteUncheckedCreateWithoutSoggettoBusinessInfoInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.ReferenteUpsertWithoutSoggettoBusinessInfoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? delete;

  final _i2.ReferenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.ReferenteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput,
          _i1.PrismaUnion<_i2.ReferenteUpdateWithoutSoggettoBusinessInfoInput,
              _i2.ReferenteUncheckedUpdateWithoutSoggettoBusinessInfoInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoBusinessInfoUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i2
      .LegaleRappresentanteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      legaleRappresentante;

  final _i2.ReferenteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
      };
}

class SoggettoBusinessInfoUpdateToOneWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateToOneWithWhereWithoutSoggettoInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoBusinessInfoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutSoggettoInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoUpsertWithoutSoggettoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoWhereInput>? delete;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoBusinessInfoUpdateToOneWithWhereWithoutSoggettoInput,
      _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutSoggettoInput,
          _i2.SoggettoBusinessInfoUncheckedUpdateWithoutSoggettoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateWithoutDomicilioInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneUpdateWithoutDomicilioInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyMutationInput({this.uuid});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  @override
  Map<String, dynamic> toJson() => {'uuid': uuid};
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneScalarWhereInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateManyMutationInput,
          _i2
          .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutDomicilioInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyDomicilioInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutDomicilioInput>>?
      update;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutDomicilioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ConsumoAnnuoLuceUncheckedUpdateOneWithoutFornituraLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedUpdateOneWithoutFornituraLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceCreateWithoutFornituraLuceInput,
      _i2.ConsumoAnnuoLuceUncheckedCreateWithoutFornituraLuceInput>? create;

  final _i2.ConsumoAnnuoLuceCreateOrConnectWithoutFornituraLuceInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoLuceUpsertWithoutFornituraLuceInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceWhereInput>? delete;

  final _i2.ConsumoAnnuoLuceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.ConsumoAnnuoLuceUpdateToOneWithWhereWithoutFornituraLuceInput,
          _i1.PrismaUnion<_i2.ConsumoAnnuoLuceUpdateWithoutFornituraLuceInput,
              _i2.ConsumoAnnuoLuceUncheckedUpdateWithoutFornituraLuceInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelLuceUncheckedUpdateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateWithoutFornituraLuceInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateWithWhereUniqueWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithWhereUniqueWithoutFornituraLuceInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutFornituraLuceInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutFornituraLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateManyWithWhereWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithWhereWithoutFornituraLuceInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateManyMutationInput,
      _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput,
          Iterable<
              _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutFornituraLuceInput,
          Iterable<
              _i2
              .ContrattoEnelLuceUpsertWithWhereUniqueWithoutFornituraLuceInput>>?
      upsert;

  final _i2.ContrattoEnelLuceCreateManyFornituraLuceInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutFornituraLuceInput,
          Iterable<
              _i2
              .ContrattoEnelLuceUpdateWithWhereUniqueWithoutFornituraLuceInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutFornituraLuceInput,
          Iterable<
              _i2
              .ContrattoEnelLuceUpdateManyWithWhereWithoutFornituraLuceInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornituraLuceUncheckedUpdateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedUpdateWithoutFornituraInput({
    this.uuid,
    this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ConsumoAnnuoLuceUncheckedUpdateOneWithoutFornituraLuceNestedInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceNestedInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceUpdateToOneWithWhereWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateToOneWithWhereWithoutFornituraInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraLuceWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedUpdateWithoutFornituraInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraLuceUncheckedUpdateOneWithoutFornituraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedUpdateOneWithoutFornituraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraLuceUpsertWithoutFornituraInput? upsert;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceWhereInput>? delete;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraLuceUpdateToOneWithWhereWithoutFornituraInput,
      _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutFornituraInput,
          _i2.FornituraLuceUncheckedUpdateWithoutFornituraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ConsumoAnnuoGasUncheckedUpdateOneWithoutFornituraGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedUpdateOneWithoutFornituraGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasCreateWithoutFornituraGasInput,
      _i2.ConsumoAnnuoGasUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.ConsumoAnnuoGasCreateOrConnectWithoutFornituraGasInput?
      connectOrCreate;

  final _i2.ConsumoAnnuoGasUpsertWithoutFornituraGasInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasWhereInput>? delete;

  final _i2.ConsumoAnnuoGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ConsumoAnnuoGasUpdateToOneWithWhereWithoutFornituraGasInput,
      _i1.PrismaUnion<_i2.ConsumoAnnuoGasUpdateWithoutFornituraGasInput,
          _i2.ConsumoAnnuoGasUncheckedUpdateWithoutFornituraGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelGasUncheckedUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateWithoutFornituraGasInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateWithWhereUniqueWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithWhereUniqueWithoutFornituraGasInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutFornituraGasInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutFornituraGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateManyWithWhereWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithWhereWithoutFornituraGasInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateManyMutationInput,
      _i2.ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutFornituraGasInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutFornituraGasInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput,
          Iterable<
              _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutFornituraGasInput,
          Iterable<
              _i2
              .ContrattoEnelGasUpsertWithWhereUniqueWithoutFornituraGasInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyFornituraGasInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutFornituraGasInput,
          Iterable<
              _i2
              .ContrattoEnelGasUpdateWithWhereUniqueWithoutFornituraGasInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutFornituraGasInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateManyWithWhereWithoutFornituraGasInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornituraGasUncheckedUpdateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateWithoutFornituraInput({
    this.uuid,
    this.pdr,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ConsumoAnnuoGasUncheckedUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasUpdateToOneWithWhereWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateToOneWithWhereWithoutFornituraInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraGasWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutFornituraInput,
      _i2.FornituraGasUncheckedUpdateWithoutFornituraInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraGasUncheckedUpdateOneWithoutFornituraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateOneWithoutFornituraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutFornituraInput,
      _i2.FornituraGasUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraGasUpsertWithoutFornituraInput? upsert;

  final _i1.PrismaUnion<bool, _i2.FornituraGasWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.FornituraGasWhereInput>? delete;

  final _i2.FornituraGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraGasUpdateToOneWithWhereWithoutFornituraInput,
      _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutFornituraInput,
          _i2.FornituraGasUncheckedUpdateWithoutFornituraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class FornituraUncheckedUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateWithoutDomicilioInput({
    this.uuid,
    this.etichetta,
    this.servizioEwoId,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.FornituraLuceUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraLuce;

  final _i2.FornituraGasUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'servizioEwoId': servizioEwoId,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUpdateWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutDomicilioInput,
      _i2.FornituraUncheckedUpdateWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<_i2.FornituraScalarWhereInput,
      Iterable<_i2.FornituraScalarWhereInput>>? AND;

  final Iterable<_i2.FornituraScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraScalarWhereInput,
      Iterable<_i2.FornituraScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateManyMutationInput({
    this.uuid,
    this.etichetta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
      };
}

class FornituraUncheckedUpdateManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateManyWithoutDomicilioInput({
    this.uuid,
    this.etichetta,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraUpdateManyWithWhereWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateManyWithWhereWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.FornituraScalarWhereInput where;

  final _i1.PrismaUnion<_i2.FornituraUpdateManyMutationInput,
      _i2.FornituraUncheckedUpdateManyWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraUncheckedUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.FornituraCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.FornituraCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<
              _i2.FornituraUncheckedCreateWithoutDomicilioInput,
              Iterable<
                  _i2.FornituraUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.FornituraUpsertWithWhereUniqueWithoutDomicilioInput,
          Iterable<_i2.FornituraUpsertWithWhereUniqueWithoutDomicilioInput>>?
      upsert;

  final _i2.FornituraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithWhereUniqueWithoutDomicilioInput,
          Iterable<_i2.FornituraUpdateWithWhereUniqueWithoutDomicilioInput>>?
      update;

  final _i1.PrismaUnion<_i2.FornituraUpdateManyWithWhereWithoutDomicilioInput,
          Iterable<_i2.FornituraUpdateManyWithWhereWithoutDomicilioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.FornituraScalarWhereInput,
      Iterable<_i2.FornituraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PraticaUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithoutContrattoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput? tipoPratica;

  final _i2.SoggettoUpdateOneWithoutPraticheIntestateNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutPraticheNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutPraticheNestedInput? negozio;

  final _i2.StatoPraticaUpdateOneWithoutPraticheNestedInput? stato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
      };
}

class PraticaUncheckedUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateWithoutContrattoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpsertWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpsertWithoutContrattoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutContrattoInput,
      _i2.PraticaUncheckedUpdateWithoutContrattoInput> update;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutContrattoInput,
      _i2.PraticaUncheckedCreateWithoutContrattoInput> create;

  final _i2.PraticaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class PraticaUpdateToOneWithWhereWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateToOneWithWhereWithoutContrattoInput({
    this.where,
    required this.data,
  });

  final _i2.PraticaWhereInput? where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutContrattoInput,
      _i2.PraticaUncheckedUpdateWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUpdateOneWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateOneWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutContrattoInput,
      _i2.PraticaUncheckedCreateWithoutContrattoInput>? create;

  final _i2.PraticaCreateOrConnectWithoutContrattoInput? connectOrCreate;

  final _i2.PraticaUpsertWithoutContrattoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.PraticaWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.PraticaWhereInput>? delete;

  final _i2.PraticaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.PraticaUpdateToOneWithWhereWithoutContrattoInput,
      _i1.PrismaUnion<_i2.PraticaUpdateWithoutContrattoInput,
          _i2.PraticaUncheckedUpdateWithoutContrattoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutModuloInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
      };
}

class ContrattoEnelLuceUncheckedUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutContrattoInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateManyWithWhereWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithWhereWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateManyMutationInput,
      _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelLuceCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelGasUncheckedUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutContrattoInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateManyWithWhereWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithWhereWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateManyMutationInput,
      _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelFibraUncheckedUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutContrattoInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? AND;

  final Iterable<_i2.ContrattoEnelFibraScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.EnumServizioContrattoEnelFibraFilter,
      _i3.ServizioContrattoEnelFibra>? servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTipoContrattoEnelFibraFilter,
      _i3.TipoContrattoEnelFibra>? tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTecnologiaContrattoEnelFibraFilter,
      _i3.TecnologiaContrattoEnelFibra>? tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyMutationInput({
    this.uuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateManyWithWhereWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithWhereWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateManyMutationInput,
      _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneUpdateWithoutContrattoInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoInput({
    this.uuid,
    this.statoContrattoId,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneScalarWhereInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateManyMutationInput,
          _i2
          .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyContrattoInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUncheckedUpdateWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutModuloInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpsertWithWhereUniqueWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithWhereUniqueWithoutModuloInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutModuloInput,
      _i2.ContrattoUncheckedUpdateWithoutModuloInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutModuloInput,
      _i2.ContrattoUncheckedCreateWithoutModuloInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoUpdateWithWhereUniqueWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithWhereUniqueWithoutModuloInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutModuloInput,
      _i2.ContrattoUncheckedUpdateWithoutModuloInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? AND;

  final Iterable<_i2.ContrattoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketingEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? marketingGruppoEnel;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? profilazioneEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? bollettaWeb;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? rid;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataCessazione;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      mesiDurata;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoContrattoId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyMutationInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoUncheckedUpdateManyWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutModuloInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
      };
}

class ContrattoUpdateManyWithWhereWithoutModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithWhereWithoutModuloInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyMutationInput,
      _i2.ContrattoUncheckedUpdateManyWithoutModuloInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUpdateManyWithoutModuloNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithoutModuloNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutModuloInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutModuloInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutModuloInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutModuloInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutModuloInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutModuloInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutModuloInput>>? upsert;

  final _i2.ContrattoCreateManyModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutModuloInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutModuloInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutModuloInput,
      Iterable<_i2.ContrattoUpdateManyWithWhereWithoutModuloInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelFibraUncheckedUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateWithoutDomicilioInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutDomicilioInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateManyWithWhereWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithWhereWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateManyMutationInput,
      _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpsertWithWhereUniqueWithoutDomicilioInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpdateWithWhereUniqueWithoutDomicilioInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutDomicilioInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutDomicilioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NullableEnumTipoStatoFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableEnumTipoStatoFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class StatoOpportunitaUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUpdateWithoutLeadsInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NullableEnumTipoStatoFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaUncheckedUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUncheckedUpdateWithoutLeadsInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NullableEnumTipoStatoFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaUpsertWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUpsertWithoutLeadsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoOpportunitaUpdateWithoutLeadsInput,
      _i2.StatoOpportunitaUncheckedUpdateWithoutLeadsInput> update;

  final _i1.PrismaUnion<_i2.StatoOpportunitaCreateWithoutLeadsInput,
      _i2.StatoOpportunitaUncheckedCreateWithoutLeadsInput> create;

  final _i2.StatoOpportunitaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoOpportunitaUpdateToOneWithWhereWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUpdateToOneWithWhereWithoutLeadsInput({
    this.where,
    required this.data,
  });

  final _i2.StatoOpportunitaWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoOpportunitaUpdateWithoutLeadsInput,
      _i2.StatoOpportunitaUncheckedUpdateWithoutLeadsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoOpportunitaCreateWithoutLeadsInput,
      _i2.StatoOpportunitaUncheckedCreateWithoutLeadsInput>? create;

  final _i2.StatoOpportunitaCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.StatoOpportunitaUpsertWithoutLeadsInput? upsert;

  final _i2.StatoOpportunitaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.StatoOpportunitaUpdateToOneWithWhereWithoutLeadsInput,
      _i1.PrismaUnion<_i2.StatoOpportunitaUpdateWithoutLeadsInput,
          _i2.StatoOpportunitaUncheckedUpdateWithoutLeadsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class DomicilioUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithoutLeadsInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.SoggettoUpdateOneRequiredWithoutDomiciliNestedInput? soggetto;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUpdateManyWithoutDomicilioNestedInput? prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoUncheckedUpdateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoUpdateWithWhereUniqueWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithWhereUniqueWithoutProdottiOrdinatiInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutProdottiOrdinatiInput,
      _i2.ProdottoUncheckedUpdateWithoutProdottiOrdinatiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? AND;

  final Iterable<_i2.ProdottoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? modello;

  final _i1.PrismaUnion<_i2.FloatNullableFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<_i2.StringFilter, String>? produttoreId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyMutationInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
      };
}

class ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoUpdateManyWithWhereWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithWhereWithoutProdottiOrdinatiInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyMutationInput,
      _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutProdottiOrdinatiInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutProdottiOrdinatiInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutProdottiOrdinatiInput,
                  Iterable<
                      _i2
                      .ProdottoUncheckedCreateWithoutProdottiOrdinatiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProdottoUpsertWithWhereUniqueWithoutProdottiOrdinatiInput,
          Iterable<
              _i2.ProdottoUpsertWithWhereUniqueWithoutProdottiOrdinatiInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProdottoUpdateWithWhereUniqueWithoutProdottiOrdinatiInput,
          Iterable<
              _i2.ProdottoUpdateWithWhereUniqueWithoutProdottiOrdinatiInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ProdottoUpdateManyWithWhereWithoutProdottiOrdinatiInput,
          Iterable<
              _i2.ProdottoUpdateManyWithWhereWithoutProdottiOrdinatiInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrdineUncheckedUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutDomicilioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineUpdateWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutDomicilioInput,
      _i2.OrdineUncheckedUpdateWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? AND;

  final Iterable<_i2.OrdineScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.FloatFilter, double>? valore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyMutationInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
      };
}

class OrdineUncheckedUpdateManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutDomicilioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyWithWhereWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutDomicilioInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutDomicilioInput>>? upsert;

  final _i2.OrdineCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutDomicilioInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutDomicilioInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutDomicilioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUncheckedUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateWithoutLeadsInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedUpdateManyWithoutDomicilioNestedInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class DomicilioUpsertWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpsertWithoutLeadsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutLeadsInput,
      _i2.DomicilioUncheckedUpdateWithoutLeadsInput> update;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutLeadsInput,
      _i2.DomicilioUncheckedCreateWithoutLeadsInput> create;

  final _i2.DomicilioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class DomicilioUpdateToOneWithWhereWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateToOneWithWhereWithoutLeadsInput({
    this.where,
    required this.data,
  });

  final _i2.DomicilioWhereInput? where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutLeadsInput,
      _i2.DomicilioUncheckedUpdateWithoutLeadsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioUpdateOneWithoutLeadsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateOneWithoutLeadsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutLeadsInput,
      _i2.DomicilioUncheckedCreateWithoutLeadsInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.DomicilioUpsertWithoutLeadsInput? upsert;

  final _i1.PrismaUnion<bool, _i2.DomicilioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.DomicilioWhereInput>? delete;

  final _i2.DomicilioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.DomicilioUpdateToOneWithWhereWithoutLeadsInput,
      _i1.PrismaUnion<_i2.DomicilioUpdateWithoutLeadsInput,
          _i2.DomicilioUncheckedUpdateWithoutLeadsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class EnumTipoStatoFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoStatoFieldUpdateOperationsInput({this.set});

  final _i3.TipoStato? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class StatoOrdineUpdateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUpdateWithoutOrdiniInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.EnumTipoStatoFieldUpdateOperationsInput>?
      tipoStato;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineUncheckedUpdateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUncheckedUpdateWithoutOrdiniInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.EnumTipoStatoFieldUpdateOperationsInput>?
      tipoStato;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineUpsertWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUpsertWithoutOrdiniInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineUpdateWithoutOrdiniInput,
      _i2.StatoOrdineUncheckedUpdateWithoutOrdiniInput> update;

  final _i1.PrismaUnion<_i2.StatoOrdineCreateWithoutOrdiniInput,
      _i2.StatoOrdineUncheckedCreateWithoutOrdiniInput> create;

  final _i2.StatoOrdineWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoOrdineUpdateToOneWithWhereWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUpdateToOneWithWhereWithoutOrdiniInput({
    this.where,
    required this.data,
  });

  final _i2.StatoOrdineWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoOrdineUpdateWithoutOrdiniInput,
      _i2.StatoOrdineUncheckedUpdateWithoutOrdiniInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoOrdineUpdateOneWithoutOrdiniNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUpdateOneWithoutOrdiniNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineCreateWithoutOrdiniInput,
      _i2.StatoOrdineUncheckedCreateWithoutOrdiniInput>? create;

  final _i2.StatoOrdineCreateOrConnectWithoutOrdiniInput? connectOrCreate;

  final _i2.StatoOrdineUpsertWithoutOrdiniInput? upsert;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineWhereInput>? delete;

  final _i2.StatoOrdineWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.StatoOrdineUpdateToOneWithWhereWithoutOrdiniInput,
      _i1.PrismaUnion<_i2.StatoOrdineUpdateWithoutOrdiniInput,
          _i2.StatoOrdineUncheckedUpdateWithoutOrdiniInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class OpportunitaUpdateWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateWithoutAgentiInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.LeadUpdateManyWithoutOpportunitaNestedInput? leads;

  final _i2.UtenteUpdateManyWithoutOpportunitaGestiteNestedInput? gestoriLead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
      };
}

class OrdineUncheckedUpdateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutLeadInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineUpdateWithWhereUniqueWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutLeadInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutLeadInput,
      _i2.OrdineUncheckedUpdateWithoutLeadInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutLeadInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyWithWhereWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutLeadInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutLeadInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutLeadNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutLeadNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutLeadInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutLeadInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutLeadInput>>? upsert;

  final _i2.OrdineCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutLeadInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutLeadInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutLeadInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class HistoryCommentUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUpdateWithoutHistoryInput({this.comment});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? comment;

  @override
  Map<String, dynamic> toJson() => {'comment': comment};
}

class HistoryCommentUncheckedUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedUpdateWithoutHistoryInput({this.comment});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? comment;

  @override
  Map<String, dynamic> toJson() => {'comment': comment};
}

class HistoryCommentUpsertWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUpsertWithoutHistoryInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentUpdateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedUpdateWithoutHistoryInput> update;

  final _i1.PrismaUnion<_i2.HistoryCommentCreateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedCreateWithoutHistoryInput> create;

  final _i2.HistoryCommentWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class HistoryCommentUpdateToOneWithWhereWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUpdateToOneWithWhereWithoutHistoryInput({
    this.where,
    required this.data,
  });

  final _i2.HistoryCommentWhereInput? where;

  final _i1.PrismaUnion<_i2.HistoryCommentUpdateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedUpdateWithoutHistoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryCommentUpdateOneWithoutHistoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUpdateOneWithoutHistoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentCreateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryCommentCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.HistoryCommentUpsertWithoutHistoryInput? upsert;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentWhereInput>? delete;

  final _i2.HistoryCommentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.HistoryCommentUpdateToOneWithWhereWithoutHistoryInput,
      _i1.PrismaUnion<_i2.HistoryCommentUpdateWithoutHistoryInput,
          _i2.HistoryCommentUncheckedUpdateWithoutHistoryInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class HistoryAttachmentUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUpdateWithoutHistoryInput({
    this.url,
    this.name,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? url;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
      };
}

class HistoryAttachmentUncheckedUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedUpdateWithoutHistoryInput({
    this.url,
    this.name,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? url;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
      };
}

class HistoryAttachmentUpsertWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUpsertWithoutHistoryInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentUpdateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedUpdateWithoutHistoryInput> update;

  final _i1.PrismaUnion<_i2.HistoryAttachmentCreateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedCreateWithoutHistoryInput> create;

  final _i2.HistoryAttachmentWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class HistoryAttachmentUpdateToOneWithWhereWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUpdateToOneWithWhereWithoutHistoryInput({
    this.where,
    required this.data,
  });

  final _i2.HistoryAttachmentWhereInput? where;

  final _i1.PrismaUnion<_i2.HistoryAttachmentUpdateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedUpdateWithoutHistoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryAttachmentUpdateOneWithoutHistoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUpdateOneWithoutHistoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentCreateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryAttachmentCreateOrConnectWithoutHistoryInput?
      connectOrCreate;

  final _i2.HistoryAttachmentUpsertWithoutHistoryInput? upsert;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentWhereInput>? delete;

  final _i2.HistoryAttachmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.HistoryAttachmentUpdateToOneWithWhereWithoutHistoryInput,
      _i1.PrismaUnion<_i2.HistoryAttachmentUpdateWithoutHistoryInput,
          _i2.HistoryAttachmentUncheckedUpdateWithoutHistoryInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class HistoryCommentUncheckedUpdateOneWithoutHistoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedUpdateOneWithoutHistoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentCreateWithoutHistoryInput,
      _i2.HistoryCommentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryCommentCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.HistoryCommentUpsertWithoutHistoryInput? upsert;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentWhereInput>? delete;

  final _i2.HistoryCommentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.HistoryCommentUpdateToOneWithWhereWithoutHistoryInput,
      _i1.PrismaUnion<_i2.HistoryCommentUpdateWithoutHistoryInput,
          _i2.HistoryCommentUncheckedUpdateWithoutHistoryInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class HistoryAttachmentUncheckedUpdateOneWithoutHistoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedUpdateOneWithoutHistoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentCreateWithoutHistoryInput,
      _i2.HistoryAttachmentUncheckedCreateWithoutHistoryInput>? create;

  final _i2.HistoryAttachmentCreateOrConnectWithoutHistoryInput?
      connectOrCreate;

  final _i2.HistoryAttachmentUpsertWithoutHistoryInput? upsert;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentWhereInput>? delete;

  final _i2.HistoryAttachmentWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.HistoryAttachmentUpdateToOneWithWhereWithoutHistoryInput,
      _i1.PrismaUnion<_i2.HistoryAttachmentUpdateWithoutHistoryInput,
          _i2.HistoryAttachmentUncheckedUpdateWithoutHistoryInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class HistoryUncheckedUpdateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateWithoutLeadInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.comment,
    this.attachment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i2.HistoryCommentUncheckedUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.HistoryAttachmentUncheckedUpdateOneWithoutHistoryNestedInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'comment': comment,
        'attachment': attachment,
      };
}

class HistoryUpdateWithWhereUniqueWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateWithWhereUniqueWithoutLeadInput({
    required this.where,
    required this.data,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutLeadInput,
      _i2.HistoryUncheckedUpdateWithoutLeadInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final _i1.PrismaUnion<_i2.HistoryScalarWhereInput,
      Iterable<_i2.HistoryScalarWhereInput>>? AND;

  final Iterable<_i2.HistoryScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryScalarWhereInput,
      Iterable<_i2.HistoryScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? timestamp;

  final _i1.PrismaUnion<_i2.StringFilter, String>? event;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateManyMutationInput({
    this.uuid,
    this.timestamp,
    this.event,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
      };
}

class HistoryUncheckedUpdateManyWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateManyWithoutLeadInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
      };
}

class HistoryUpdateManyWithWhereWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateManyWithWhereWithoutLeadInput({
    required this.where,
    required this.data,
  });

  final _i2.HistoryScalarWhereInput where;

  final _i1.PrismaUnion<_i2.HistoryUpdateManyMutationInput,
      _i2.HistoryUncheckedUpdateManyWithoutLeadInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryUpdateManyWithoutLeadNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateManyWithoutLeadNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutLeadInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutLeadInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.HistoryUpsertWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.HistoryUpsertWithWhereUniqueWithoutLeadInput>>? upsert;

  final _i2.HistoryCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.HistoryUpdateWithWhereUniqueWithoutLeadInput>>? update;

  final _i1.PrismaUnion<_i2.HistoryUpdateManyWithWhereWithoutLeadInput,
      Iterable<_i2.HistoryUpdateManyWithWhereWithoutLeadInput>>? updateMany;

  final _i1.PrismaUnion<_i2.HistoryScalarWhereInput,
      Iterable<_i2.HistoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUpdateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutOrdineInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'history': history,
      };
}

class LeadUncheckedUpdateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutOrdineInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'history': history,
      };
}

class LeadUpsertWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithoutOrdineInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutOrdineInput,
      _i2.LeadUncheckedUpdateWithoutOrdineInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutOrdineInput,
      _i2.LeadUncheckedCreateWithoutOrdineInput> create;

  final _i2.LeadWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class LeadUpdateToOneWithWhereWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateToOneWithWhereWithoutOrdineInput({
    this.where,
    required this.data,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutOrdineInput,
      _i2.LeadUncheckedUpdateWithoutOrdineInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUpdateOneWithoutOrdineNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateOneWithoutOrdineNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.LeadCreateWithoutOrdineInput,
      _i2.LeadUncheckedCreateWithoutOrdineInput>? create;

  final _i2.LeadCreateOrConnectWithoutOrdineInput? connectOrCreate;

  final _i2.LeadUpsertWithoutOrdineInput? upsert;

  final _i1.PrismaUnion<bool, _i2.LeadWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.LeadWhereInput>? delete;

  final _i2.LeadWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.LeadUpdateToOneWithWhereWithoutOrdineInput,
      _i1.PrismaUnion<_i2.LeadUpdateWithoutOrdineInput,
          _i2.LeadUncheckedUpdateWithoutOrdineInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class NegozioUpdateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutOrdineInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
      };
}

class TipoModuloContrattoUpdateWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUpdateWithoutModuloContrattoInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoUncheckedUpdateWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUncheckedUpdateWithoutModuloContrattoInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoUpsertWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUpsertWithoutModuloContrattoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
      _i2.TipoModuloContrattoUpdateWithoutModuloContrattoInput,
      _i2.TipoModuloContrattoUncheckedUpdateWithoutModuloContrattoInput> update;

  final _i1.PrismaUnion<
      _i2.TipoModuloContrattoCreateWithoutModuloContrattoInput,
      _i2.TipoModuloContrattoUncheckedCreateWithoutModuloContrattoInput> create;

  final _i2.TipoModuloContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class TipoModuloContrattoUpdateToOneWithWhereWithoutModuloContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUpdateToOneWithWhereWithoutModuloContrattoInput({
    this.where,
    required this.data,
  });

  final _i2.TipoModuloContrattoWhereInput? where;

  final _i1.PrismaUnion<
      _i2.TipoModuloContrattoUpdateWithoutModuloContrattoInput,
      _i2.TipoModuloContrattoUncheckedUpdateWithoutModuloContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class TipoModuloContrattoUpdateOneRequiredWithoutModuloContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUpdateOneRequiredWithoutModuloContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.TipoModuloContrattoCreateWithoutModuloContrattoInput,
          _i2.TipoModuloContrattoUncheckedCreateWithoutModuloContrattoInput>?
      create;

  final _i2.TipoModuloContrattoCreateOrConnectWithoutModuloContrattoInput?
      connectOrCreate;

  final _i2.TipoModuloContrattoUpsertWithoutModuloContrattoInput? upsert;

  final _i2.TipoModuloContrattoWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .TipoModuloContrattoUpdateToOneWithWhereWithoutModuloContrattoInput,
          _i1.PrismaUnion<
              _i2.TipoModuloContrattoUpdateWithoutModuloContrattoInput,
              _i2
              .TipoModuloContrattoUncheckedUpdateWithoutModuloContrattoInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ModuloContrattoUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithoutContrattiInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.serviziEwoCollegabili,
    this.fornitore,
    this.tipoModulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i2.ServizioEwoUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.FornitoreUpdateOneRequiredWithoutModuliContrattoNestedInput?
      fornitore;

  final _i2
      .TipoModuloContrattoUpdateOneRequiredWithoutModuloContrattoNestedInput?
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class PraticaUncheckedUpdateWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateWithoutTipoPraticaInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaUpdateWithWhereUniqueWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithWhereUniqueWithoutTipoPraticaInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutTipoPraticaInput,
      _i2.PraticaUncheckedUpdateWithoutTipoPraticaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? AND;

  final Iterable<_i2.PraticaScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInserimento;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoPraticaId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyMutationInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUncheckedUpdateManyWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutTipoPraticaInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateManyWithWhereWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithWhereWithoutTipoPraticaInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyMutationInput,
      _i2.PraticaUncheckedUpdateManyWithoutTipoPraticaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutTipoPraticaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutTipoPraticaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutTipoPraticaInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutTipoPraticaInput>,
          _i1.PrismaUnion<
              _i2.PraticaUncheckedCreateWithoutTipoPraticaInput,
              Iterable<
                  _i2.PraticaUncheckedCreateWithoutTipoPraticaInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutTipoPraticaInput,
          Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutTipoPraticaInput>>?
      upsert;

  final _i2.PraticaCreateManyTipoPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutTipoPraticaInput,
          Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutTipoPraticaInput>>?
      update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutTipoPraticaInput,
          Iterable<_i2.PraticaUpdateManyWithWhereWithoutTipoPraticaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoPraticaUncheckedUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.pratiche,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUncheckedUpdateManyWithoutTipoPraticaNestedInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class TipoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.TipoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.TipoPraticaUpdateWithoutServiziEwoInput,
      _i2.TipoPraticaUncheckedUpdateWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class TipoPraticaScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaScalarWhereInput,
      Iterable<_i2.TipoPraticaScalarWhereInput>>? AND;

  final Iterable<_i2.TipoPraticaScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.TipoPraticaScalarWhereInput,
      Iterable<_i2.TipoPraticaScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaUncheckedUpdateManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedUpdateManyWithoutServiziEwoInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaUpdateManyWithWhereWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateManyWithWhereWithoutServiziEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.TipoPraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.TipoPraticaUpdateManyMutationInput,
      _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.TipoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.TipoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.TipoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.TipoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.TipoPraticaUpdateManyWithWhereWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaUpdateManyWithWhereWithoutServiziEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.TipoPraticaScalarWhereInput,
      Iterable<_i2.TipoPraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornituraUncheckedUpdateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateWithoutServizioEwoInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i2.FornituraLuceUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraLuce;

  final _i2.FornituraGasUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUpdateWithWhereUniqueWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateWithWhereUniqueWithoutServizioEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutServizioEwoInput,
      _i2.FornituraUncheckedUpdateWithoutServizioEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraUncheckedUpdateManyWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateManyWithoutServizioEwoInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
      };
}

class FornituraUpdateManyWithWhereWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateManyWithWhereWithoutServizioEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.FornituraScalarWhereInput where;

  final _i1.PrismaUnion<_i2.FornituraUpdateManyMutationInput,
      _i2.FornituraUncheckedUpdateManyWithoutServizioEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.FornituraCreateWithoutServizioEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraCreateWithoutServizioEwoInput>,
              _i1.PrismaUnion<
                  _i2.FornituraUncheckedCreateWithoutServizioEwoInput,
                  Iterable<
                      _i2.FornituraUncheckedCreateWithoutServizioEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.FornituraUpsertWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.FornituraUpsertWithWhereUniqueWithoutServizioEwoInput>>?
      upsert;

  final _i2.FornituraCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.FornituraUpdateWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.FornituraUpdateWithWhereUniqueWithoutServizioEwoInput>>?
      update;

  final _i1.PrismaUnion<_i2.FornituraUpdateManyWithWhereWithoutServizioEwoInput,
          Iterable<_i2.FornituraUpdateManyWithWhereWithoutServizioEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.FornituraScalarWhereInput,
      Iterable<_i2.FornituraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PraticaUncheckedUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateWithoutStatoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaUpdateWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutStatoInput,
      _i2.PraticaUncheckedUpdateWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutStatoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateManyWithWhereWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithWhereWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyMutationInput,
      _i2.PraticaUncheckedUpdateManyWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutStatoInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutStatoInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutStatoInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutStatoInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutStatoInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutStatoInput>>? upsert;

  final _i2.PraticaCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutStatoInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutStatoInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutStatoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoPraticaUncheckedUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.pratiche,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUncheckedUpdateManyWithoutStatoNestedInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class StatoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.StatoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoPraticaUpdateWithoutServiziEwoInput,
      _i2.StatoPraticaUncheckedUpdateWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoPraticaScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaScalarWhereInput,
      Iterable<_i2.StatoPraticaScalarWhereInput>>? AND;

  final Iterable<_i2.StatoPraticaScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoPraticaScalarWhereInput,
      Iterable<_i2.StatoPraticaScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaUncheckedUpdateManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedUpdateManyWithoutServiziEwoInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaUpdateManyWithWhereWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateManyWithWhereWithoutServiziEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.StatoPraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.StatoPraticaUpdateManyMutationInput,
      _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.StatoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.StatoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput,
      Iterable<
          _i2.StatoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput>>? upsert;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.StatoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput,
      Iterable<
          _i2.StatoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput>>? update;

  final _i1.PrismaUnion<
          _i2.StatoPraticaUpdateManyWithWhereWithoutServiziEwoInput,
          Iterable<_i2.StatoPraticaUpdateManyWithWhereWithoutServiziEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.StatoPraticaScalarWhereInput,
      Iterable<_i2.StatoPraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUncheckedUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutStatoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpdateWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutStatoInput,
      _i2.ContrattoUncheckedUpdateWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutStatoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateManyWithWhereWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithWhereWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyMutationInput,
      _i2.ContrattoUncheckedUpdateManyWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutStatoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutStatoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutStatoInput,
      Iterable<_i2.ContrattoCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutStatoInput>>? upsert;

  final _i2.ContrattoCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutStatoInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutStatoInput,
      Iterable<_i2.ContrattoUpdateManyWithWhereWithoutStatoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelLuceUncheckedUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateWithoutStatoInput({
    this.uuid,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutStatoInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutStatoInput({
    this.uuid,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateManyWithWhereWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithWhereWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelLuceScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateManyMutationInput,
      _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutStatoInput,
      Iterable<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutStatoInput>>? upsert;

  final _i2.ContrattoEnelLuceCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutStatoInput,
      Iterable<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutStatoInput>>? update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutStatoInput,
          Iterable<_i2.ContrattoEnelLuceUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelGasUncheckedUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateWithoutStatoInput({
    this.uuid,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutStatoInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutStatoInput({
    this.uuid,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateManyWithWhereWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithWhereWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelGasScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateManyMutationInput,
      _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutStatoInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutStatoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelFibraUncheckedUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateWithoutStatoInput({
    this.uuid,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutStatoInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutStatoInput({
    this.uuid,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateManyWithWhereWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithWhereWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateManyMutationInput,
      _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutStatoInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutStatoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutStatoInput,
          Iterable<_i2.ContrattoEnelFibraUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateWithoutStatoInput({
    this.uuid,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneUpdateWithoutStatoInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoInput({
    this.uuid,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutStatoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneUpdateManyMutationInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutStatoInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutStatoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutStatoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUncheckedUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.contratti,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUncheckedUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUpdateWithWhereUniqueWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithWhereUniqueWithoutServiziEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutServiziEwoInput,
      _i2.StatoContrattoUncheckedUpdateWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoScalarWhereInput,
      Iterable<_i2.StatoContrattoScalarWhereInput>>? AND;

  final Iterable<_i2.StatoContrattoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StatoContrattoScalarWhereInput,
      Iterable<_i2.StatoContrattoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoUncheckedUpdateManyWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateManyWithoutServiziEwoInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoUpdateManyWithWhereWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateManyWithWhereWithoutServiziEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.StatoContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateManyMutationInput,
      _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoContrattoCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoContrattoUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2
                      .StatoContrattoUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpsertWithWhereUniqueWithoutServiziEwoInput,
          Iterable<
              _i2.StatoContrattoUpsertWithWhereUniqueWithoutServiziEwoInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateWithWhereUniqueWithoutServiziEwoInput,
          Iterable<
              _i2.StatoContrattoUpdateWithWhereUniqueWithoutServiziEwoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateManyWithWhereWithoutServiziEwoInput,
          Iterable<
              _i2.StatoContrattoUpdateManyWithWhereWithoutServiziEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.StatoContrattoScalarWhereInput,
      Iterable<_i2.StatoContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelLuceCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelGasUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelFibraUncheckedUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelFibraUpdateWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutOffertaInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelFibraUpdateManyWithWhereWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithWhereWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelFibraScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateManyMutationInput,
      _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithoutOffertaInput({
    this.uuid,
    this.stato,
    this.contratto,
    this.domicilio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2
      .StatoContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      stato;

  final _i2
      .ContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      contratto;

  final _i2
      .DomicilioUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneUpdateWithoutOffertaInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutOffertaInput> update;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneUpdateWithoutOffertaInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutOffertaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutOffertaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoEnelXAssicurazioneScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneUpdateManyMutationInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyOffertaInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyOffertaInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutOffertaInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OffertaUncheckedUpdateWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutInclusaInOfferteInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
      };
}

class OffertaUpdateWithWhereUniqueWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithWhereUniqueWithoutInclusaInOfferteInput({
    required this.where,
    required this.data,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutInclusaInOfferteInput,
      _i2.OffertaUncheckedUpdateWithoutInclusaInOfferteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? AND;

  final Iterable<_i2.OffertaScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataFineOfferta;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? dataInizioOfferta;

  final _i1.PrismaUnion<_i2.StringFilter, String>? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyMutationInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
      };
}

class OffertaUncheckedUpdateManyWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyWithoutInclusaInOfferteInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaUpdateManyWithWhereWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyWithWhereWithoutInclusaInOfferteInput({
    required this.where,
    required this.data,
  });

  final _i2.OffertaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateManyMutationInput,
      _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUpdateManyWithoutInclusaInOfferteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyWithoutInclusaInOfferteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutInclusaInOfferteInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutInclusaInOfferteInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutInclusaInOfferteInput,
                  Iterable<
                      _i2
                      .OffertaUncheckedCreateWithoutInclusaInOfferteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OffertaUpsertWithWhereUniqueWithoutInclusaInOfferteInput,
          Iterable<
              _i2.OffertaUpsertWithWhereUniqueWithoutInclusaInOfferteInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateWithWhereUniqueWithoutInclusaInOfferteInput,
          Iterable<
              _i2.OffertaUpdateWithWhereUniqueWithoutInclusaInOfferteInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateManyWithWhereWithoutInclusaInOfferteInput,
          Iterable<_i2.OffertaUpdateManyWithWhereWithoutInclusaInOfferteInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OffertaUpdateWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutInclusaInOfferteInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
      };
}

class OffertaUpsertWithWhereUniqueWithoutInclusaInOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithWhereUniqueWithoutInclusaInOfferteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutInclusaInOfferteInput,
      _i2.OffertaUncheckedUpdateWithoutInclusaInOfferteInput> update;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutInclusaInOfferteInput,
      _i2.OffertaUncheckedCreateWithoutInclusaInOfferteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutInclusaInOfferteInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutInclusaInOfferteInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutInclusaInOfferteInput,
                  Iterable<
                      _i2
                      .OffertaUncheckedCreateWithoutInclusaInOfferteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutInclusaInOfferteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OffertaUpsertWithWhereUniqueWithoutInclusaInOfferteInput,
          Iterable<
              _i2.OffertaUpsertWithWhereUniqueWithoutInclusaInOfferteInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateWithWhereUniqueWithoutInclusaInOfferteInput,
          Iterable<
              _i2.OffertaUpdateWithWhereUniqueWithoutInclusaInOfferteInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateManyWithWhereWithoutInclusaInOfferteInput,
          Iterable<_i2.OffertaUpdateManyWithWhereWithoutInclusaInOfferteInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OffertaUncheckedUpdateWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutOfferteIncluseInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpdateWithWhereUniqueWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithWhereUniqueWithoutOfferteIncluseInput({
    required this.where,
    required this.data,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutOfferteIncluseInput,
      _i2.OffertaUncheckedUpdateWithoutOfferteIncluseInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUncheckedUpdateManyWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyWithoutOfferteIncluseInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaUpdateManyWithWhereWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyWithWhereWithoutOfferteIncluseInput({
    required this.where,
    required this.data,
  });

  final _i2.OffertaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateManyMutationInput,
      _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUpdateManyWithoutOfferteIncluseNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyWithoutOfferteIncluseNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutOfferteIncluseInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutOfferteIncluseInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput,
                  Iterable<
                      _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OffertaUpsertWithWhereUniqueWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaUpsertWithWhereUniqueWithoutOfferteIncluseInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateWithWhereUniqueWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaUpdateWithWhereUniqueWithoutOfferteIncluseInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateManyWithWhereWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaUpdateManyWithWhereWithoutOfferteIncluseInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OffertaUpdateWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutOfferteIncluseInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpsertWithWhereUniqueWithoutOfferteIncluseInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithWhereUniqueWithoutOfferteIncluseInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutOfferteIncluseInput,
      _i2.OffertaUncheckedUpdateWithoutOfferteIncluseInput> update;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutOfferteIncluseInput,
      _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutOfferteIncluseInput,
          _i1.PrismaUnion<
              Iterable<_i2.OffertaCreateWithoutOfferteIncluseInput>,
              _i1.PrismaUnion<
                  _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput,
                  Iterable<
                      _i2.OffertaUncheckedCreateWithoutOfferteIncluseInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutOfferteIncluseInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.OffertaUpsertWithWhereUniqueWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaUpsertWithWhereUniqueWithoutOfferteIncluseInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateWithWhereUniqueWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaUpdateWithWhereUniqueWithoutOfferteIncluseInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.OffertaUpdateManyWithWhereWithoutOfferteIncluseInput,
          Iterable<_i2.OffertaUpdateManyWithWhereWithoutOfferteIncluseInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OffertaUncheckedUpdateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutServizioEwoInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpdateWithWhereUniqueWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithWhereUniqueWithoutServizioEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutServizioEwoInput,
      _i2.OffertaUncheckedUpdateWithoutServizioEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUncheckedUpdateManyWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyWithoutServizioEwoInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
      };
}

class OffertaUpdateManyWithWhereWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyWithWhereWithoutServizioEwoInput({
    required this.where,
    required this.data,
  });

  final _i2.OffertaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateManyMutationInput,
      _i2.OffertaUncheckedUpdateManyWithoutServizioEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OffertaCreateWithoutServizioEwoInput,
      _i1.PrismaUnion<
          Iterable<_i2.OffertaCreateWithoutServizioEwoInput>,
          _i1.PrismaUnion<
              _i2.OffertaUncheckedCreateWithoutServizioEwoInput,
              Iterable<
                  _i2.OffertaUncheckedCreateWithoutServizioEwoInput>>>>? create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OffertaUpsertWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.OffertaUpsertWithWhereUniqueWithoutServizioEwoInput>>?
      upsert;

  final _i2.OffertaCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.OffertaUpdateWithWhereUniqueWithoutServizioEwoInput>>?
      update;

  final _i1.PrismaUnion<_i2.OffertaUpdateManyWithWhereWithoutServizioEwoInput,
          Iterable<_i2.OffertaUpdateManyWithWhereWithoutServizioEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUncheckedUpdateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutModuliContrattoInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
      };
}

class ServizioEwoUpdateWithWhereUniqueWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithWhereUniqueWithoutModuliContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutModuliContrattoInput,
      _i2.ServizioEwoUncheckedUpdateWithoutModuliContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? AND;

  final Iterable<_i2.ServizioEwoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoServizioEwoFilter, _i3.TipoServizioEwo>?
      tipoServizioEwo;

  final _i1.PrismaUnion<_i2.StringFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringFilter, String>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyMutationInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutModuliContrattoInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateManyWithWhereWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithWhereWithoutModuliContrattoInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyMutationInput,
      _i2.ServizioEwoUncheckedUpdateManyWithoutModuliContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutModuliContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutModuliContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutModuliContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutModuliContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutModuliContrattoInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutModuliContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpsertWithWhereUniqueWithoutModuliContrattoInput,
          Iterable<
              _i2.ServizioEwoUpsertWithWhereUniqueWithoutModuliContrattoInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateWithWhereUniqueWithoutModuliContrattoInput,
          Iterable<
              _i2.ServizioEwoUpdateWithWhereUniqueWithoutModuliContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutModuliContrattoInput,
          Iterable<
              _i2.ServizioEwoUpdateManyWithWhereWithoutModuliContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ModuloContrattoUncheckedUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateWithoutContrattiInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
      };
}

class ModuloContrattoUpsertWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpsertWithoutContrattiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutContrattiInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutContrattiInput> update;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutContrattiInput,
      _i2.ModuloContrattoUncheckedCreateWithoutContrattiInput> create;

  final _i2.ModuloContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ModuloContrattoUpdateToOneWithWhereWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateToOneWithWhereWithoutContrattiInput({
    this.where,
    required this.data,
  });

  final _i2.ModuloContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutContrattiInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutContrattiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoUpdateOneWithoutContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateOneWithoutContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutContrattiInput,
      _i2.ModuloContrattoUncheckedCreateWithoutContrattiInput>? create;

  final _i2.ModuloContrattoCreateOrConnectWithoutContrattiInput?
      connectOrCreate;

  final _i2.ModuloContrattoUpsertWithoutContrattiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoWhereInput>? delete;

  final _i2.ModuloContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ModuloContrattoUpdateToOneWithWhereWithoutContrattiInput,
      _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutContrattiInput,
          _i2.ModuloContrattoUncheckedUpdateWithoutContrattiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutPraticaInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'modulo': modulo,
      };
}

class ContrattoUncheckedUpdateWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutPraticaInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpsertWithWhereUniqueWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithWhereUniqueWithoutPraticaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutPraticaInput,
      _i2.ContrattoUncheckedUpdateWithoutPraticaInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutPraticaInput,
      _i2.ContrattoUncheckedCreateWithoutPraticaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoUpdateWithWhereUniqueWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithWhereUniqueWithoutPraticaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutPraticaInput,
      _i2.ContrattoUncheckedUpdateWithoutPraticaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutPraticaInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateManyWithWhereWithoutPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithWhereWithoutPraticaInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyMutationInput,
      _i2.ContrattoUncheckedUpdateManyWithoutPraticaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutPraticaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutPraticaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutPraticaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutPraticaInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutPraticaInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutPraticaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutPraticaInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutPraticaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutPraticaInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutPraticaInput>>? upsert;

  final _i2.ContrattoCreateManyPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutPraticaInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutPraticaInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutPraticaInput,
          Iterable<_i2.ContrattoUpdateManyWithWhereWithoutPraticaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PraticaUncheckedUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaUpdateWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutNegozioInput,
      _i2.PraticaUncheckedUpdateWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateManyWithWhereWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithWhereWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyMutationInput,
      _i2.PraticaUncheckedUpdateManyWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.PraticaCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUncheckedUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpdateWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutUtenteInput,
      _i2.ContrattoUncheckedUpdateWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateManyWithWhereWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithWhereWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyMutationInput,
      _i2.ContrattoUncheckedUpdateManyWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutUtenteInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutUtenteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.ContrattoCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.ContrattoUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PraticaUncheckedUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaUpdateWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutUtenteInput,
      _i2.PraticaUncheckedUpdateWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateManyWithWhereWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithWhereWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyMutationInput,
      _i2.PraticaUncheckedUpdateManyWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.PraticaCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class IngressiUncheckedUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateWithoutUtenteInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'negozioCodice': negozioCodice,
      };
}

class IngressiUpdateWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.IngressiWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithoutUtenteInput,
      _i2.IngressiUncheckedUpdateWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IngressiScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<_i2.IngressiScalarWhereInput,
      Iterable<_i2.IngressiScalarWhereInput>>? AND;

  final Iterable<_i2.IngressiScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.IngressiScalarWhereInput,
      Iterable<_i2.IngressiScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? data;

  final _i1.PrismaUnion<_i2.IntFilter, int>? clienti;

  final _i1.PrismaUnion<_i2.IntFilter, int>? nonClienti;

  final _i1.PrismaUnion<_i2.StringFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateManyMutationInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
      };
}

class IngressiUncheckedUpdateManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateManyWithoutUtenteInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'negozioCodice': negozioCodice,
      };
}

class IngressiUpdateManyWithWhereWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateManyWithWhereWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.IngressiScalarWhereInput where;

  final _i1.PrismaUnion<_i2.IngressiUpdateManyMutationInput,
      _i2.IngressiUncheckedUpdateManyWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IngressiUncheckedUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.IngressiCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.IngressiUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.IngressiUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.IngressiCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.IngressiUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.IngressiUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.IngressiUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.IngressiScalarWhereInput,
      Iterable<_i2.IngressiScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUncheckedUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutUtenteInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpdateWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutUtenteInput,
      _i2.LeadUncheckedUpdateWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? AND;

  final Iterable<_i2.LeadScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? opportunitaUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? statoOpportunitaUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyMutationInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUncheckedUpdateManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutUtenteInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.LeadCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUncheckedUpdateWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutAgenteInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpdateWithWhereUniqueWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutAgenteInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutAgenteInput,
      _i2.LeadUncheckedUpdateWithoutAgenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutAgenteInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutAgenteInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutAgenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutAgenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutAgenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutAgenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutAgenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutAgenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutAgenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutAgenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutAgenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutAgenteInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutAgenteInput>>? upsert;

  final _i2.LeadCreateManyAgenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutAgenteInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutAgenteInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutAgenteInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutAgenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutHistoryInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
      };
}

class LeadUncheckedUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutHistoryInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
      };
}

class LeadUpsertWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithoutHistoryInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutHistoryInput,
      _i2.LeadUncheckedUpdateWithoutHistoryInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutHistoryInput,
      _i2.LeadUncheckedCreateWithoutHistoryInput> create;

  final _i2.LeadWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class LeadUpdateToOneWithWhereWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateToOneWithWhereWithoutHistoryInput({
    this.where,
    required this.data,
  });

  final _i2.LeadWhereInput? where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutHistoryInput,
      _i2.LeadUncheckedUpdateWithoutHistoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUpdateOneWithoutHistoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateOneWithoutHistoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.LeadCreateWithoutHistoryInput,
      _i2.LeadUncheckedCreateWithoutHistoryInput>? create;

  final _i2.LeadCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.LeadUpsertWithoutHistoryInput? upsert;

  final _i1.PrismaUnion<bool, _i2.LeadWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.LeadWhereInput>? delete;

  final _i2.LeadWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.LeadUpdateToOneWithWhereWithoutHistoryInput,
      _i1.PrismaUnion<_i2.LeadUpdateWithoutHistoryInput,
          _i2.LeadUncheckedUpdateWithoutHistoryInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class HistoryUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateWithoutUtenteInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.comment,
    this.attachment,
    this.lead,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i2.HistoryCommentUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.HistoryAttachmentUpdateOneWithoutHistoryNestedInput? attachment;

  final _i2.LeadUpdateOneWithoutHistoryNestedInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'attachment': attachment,
        'Lead': lead,
      };
}

class HistoryUncheckedUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateWithoutUtenteInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.leadUuid,
    this.comment,
    this.attachment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i2.HistoryCommentUncheckedUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.HistoryAttachmentUncheckedUpdateOneWithoutHistoryNestedInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
      };
}

class HistoryUpsertWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpsertWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutUtenteInput,
      _i2.HistoryUncheckedUpdateWithoutUtenteInput> update;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutUtenteInput,
      _i2.HistoryUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class HistoryUpdateWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutUtenteInput,
      _i2.HistoryUncheckedUpdateWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryUncheckedUpdateManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateManyWithoutUtenteInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.leadUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'leadUuid': leadUuid,
      };
}

class HistoryUpdateManyWithWhereWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateManyWithWhereWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.HistoryScalarWhereInput where;

  final _i1.PrismaUnion<_i2.HistoryUpdateManyMutationInput,
      _i2.HistoryUncheckedUpdateManyWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.HistoryUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.HistoryUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.HistoryCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.HistoryUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.HistoryUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.HistoryUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.HistoryScalarWhereInput,
      Iterable<_i2.HistoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutOpportunitaAssegnateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'ordini': ordini,
        'history': history,
      };
}

class OrdineUncheckedUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineUpdateWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutUtenteInput,
      _i2.OrdineUncheckedUpdateWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyWithWhereWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutUtenteInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutUtenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.OrdineCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class HistoryUncheckedUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.HistoryUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.HistoryUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.HistoryCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.HistoryUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.HistoryUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.HistoryUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.HistoryScalarWhereInput,
      Iterable<_i2.HistoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUncheckedUpdateWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutOpportunitaAssegnateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithWhereUniqueWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithWhereUniqueWithoutOpportunitaAssegnateInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutOpportunitaAssegnateInput,
      _i2.UtenteUncheckedUpdateWithoutOpportunitaAssegnateInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOpportunitaAssegnateInput,
      _i2.UtenteUncheckedCreateWithoutOpportunitaAssegnateInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class UtenteUpdateWithWhereUniqueWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithWhereUniqueWithoutOpportunitaAssegnateInput({
    required this.where,
    required this.data,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutOpportunitaAssegnateInput,
      _i2.UtenteUncheckedUpdateWithoutOpportunitaAssegnateInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? AND;

  final Iterable<_i2.UtenteScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? email;

  final _i1.PrismaUnion<_i2.EnumRuoloUtenteFilter, _i3.RuoloUtente>? ruolo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyMutationInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteUpdateManyWithWhereWithoutOpportunitaAssegnateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyWithWhereWithoutOpportunitaAssegnateInput({
    required this.where,
    required this.data,
  });

  final _i2.UtenteScalarWhereInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateManyMutationInput,
      _i2.UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaAssegnateInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaAssegnateInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaAssegnateInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaAssegnateInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaAssegnateInput,
          Iterable<
              _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaAssegnateInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaAssegnateInput,
          Iterable<
              _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaAssegnateInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateManyWithWhereWithoutOpportunitaAssegnateInput,
          Iterable<
              _i2.UtenteUpdateManyWithWhereWithoutOpportunitaAssegnateInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OpportunitaUncheckedUpdateWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateWithoutGestoriLeadInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.agenti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.LeadUncheckedUpdateManyWithoutOpportunitaNestedInput? leads;

  final _i2.UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateNestedInput?
      agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'agenti': agenti,
      };
}

class OpportunitaUpdateWithWhereUniqueWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateWithWhereUniqueWithoutGestoriLeadInput({
    required this.where,
    required this.data,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutGestoriLeadInput,
      _i2.OpportunitaUncheckedUpdateWithoutGestoriLeadInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OpportunitaScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereInput,
      Iterable<_i2.OpportunitaScalarWhereInput>>? AND;

  final Iterable<_i2.OpportunitaScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereInput,
      Iterable<_i2.OpportunitaScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateManyMutationInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaUncheckedUpdateManyWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateManyWithoutGestoriLeadInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaUpdateManyWithWhereWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateManyWithWhereWithoutGestoriLeadInput({
    required this.where,
    required this.data,
  });

  final _i2.OpportunitaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateManyMutationInput,
      _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutGestoriLeadInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutGestoriLeadInput>,
              _i1.PrismaUnion<
                  _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput,
                  Iterable<
                      _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.OpportunitaUpsertWithWhereUniqueWithoutGestoriLeadInput,
      Iterable<
          _i2.OpportunitaUpsertWithWhereUniqueWithoutGestoriLeadInput>>? upsert;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.OpportunitaUpdateWithWhereUniqueWithoutGestoriLeadInput,
      Iterable<
          _i2.OpportunitaUpdateWithWhereUniqueWithoutGestoriLeadInput>>? update;

  final _i1.PrismaUnion<
          _i2.OpportunitaUpdateManyWithWhereWithoutGestoriLeadInput,
          Iterable<_i2.OpportunitaUpdateManyWithWhereWithoutGestoriLeadInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereInput,
      Iterable<_i2.OpportunitaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OpportunitaUpdateWithWhereUniqueWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateWithWhereUniqueWithoutAgentiInput({
    required this.where,
    required this.data,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutAgentiInput,
      _i2.OpportunitaUncheckedUpdateWithoutAgentiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OpportunitaUncheckedUpdateManyWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateManyWithoutAgentiInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaUpdateManyWithWhereWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateManyWithWhereWithoutAgentiInput({
    required this.where,
    required this.data,
  });

  final _i2.OpportunitaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateManyMutationInput,
      _i2.OpportunitaUncheckedUpdateManyWithoutAgentiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutAgentiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutAgentiInput>,
              _i1.PrismaUnion<_i2.OpportunitaUncheckedCreateWithoutAgentiInput,
                  Iterable<_i2.OpportunitaUncheckedCreateWithoutAgentiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutAgentiInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutAgentiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OpportunitaUpsertWithWhereUniqueWithoutAgentiInput,
      Iterable<_i2.OpportunitaUpsertWithWhereUniqueWithoutAgentiInput>>? upsert;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithWhereUniqueWithoutAgentiInput,
      Iterable<_i2.OpportunitaUpdateWithWhereUniqueWithoutAgentiInput>>? update;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateManyWithWhereWithoutAgentiInput,
          Iterable<_i2.OpportunitaUpdateManyWithWhereWithoutAgentiInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereInput,
      Iterable<_i2.OpportunitaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUncheckedUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutNegozioInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpdateWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutNegozioInput,
      _i2.UtenteUncheckedUpdateWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUncheckedUpdateManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyWithoutNegozioInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteUpdateManyWithWhereWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyWithWhereWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.UtenteScalarWhereInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateManyMutationInput,
      _i2.UtenteUncheckedUpdateManyWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUncheckedUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.UtenteCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.UtenteCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.UtenteUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.UtenteUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.UtenteCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.UtenteUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.UtenteUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.UtenteCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.UtenteUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.UtenteUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.UtenteUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUncheckedUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpdateWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutNegozioInput,
      _i2.ContrattoUncheckedUpdateWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateManyWithWhereWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithWhereWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyMutationInput,
      _i2.ContrattoUncheckedUpdateManyWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.ContrattoCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutNegozioInput,
          Iterable<_i2.ContrattoUpdateManyWithWhereWithoutNegozioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PraticaUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutSoggettoInput,
      _i2.PraticaUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.PraticaScalarWhereInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyMutationInput,
      _i2.PraticaUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class PraticaUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.PraticaCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutSoggettoInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutSoggettoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutSoggettoInput,
      _i2.ContrattoUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.ContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyMutationInput,
      _i2.ContrattoUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.ContrattoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.ContrattoUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class IndirizzoEmailUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.IndirizzoEmailWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IndirizzoEmailUpdateWithoutSoggettoInput,
      _i2.IndirizzoEmailUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IndirizzoEmailScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalarWhereInput,
      Iterable<_i2.IndirizzoEmailScalarWhereInput>>? AND;

  final Iterable<_i2.IndirizzoEmailScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalarWhereInput,
      Iterable<_i2.IndirizzoEmailScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateManyMutationInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
      };
}

class IndirizzoEmailUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.IndirizzoEmailScalarWhereInput where;

  final _i1.PrismaUnion<_i2.IndirizzoEmailUpdateManyMutationInput,
      _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.IndirizzoEmailCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.IndirizzoEmailUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.IndirizzoEmailCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.IndirizzoEmailUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.IndirizzoEmailUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalarWhereInput,
      Iterable<_i2.IndirizzoEmailScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NumeroTelefonoUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.NumeroTelefonoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutSoggettoInput,
      _i2.NumeroTelefonoUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NumeroTelefonoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalarWhereInput,
      Iterable<_i2.NumeroTelefonoScalarWhereInput>>? AND;

  final Iterable<_i2.NumeroTelefonoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalarWhereInput,
      Iterable<_i2.NumeroTelefonoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? numero;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateManyMutationInput({
    this.uuid,
    this.numero,
    this.etichetta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
      };
}

class NumeroTelefonoUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.NumeroTelefonoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateManyMutationInput,
      _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.NumeroTelefonoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.NumeroTelefonoUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.NumeroTelefonoUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.NumeroTelefonoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.NumeroTelefonoUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.NumeroTelefonoUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.NumeroTelefonoUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalarWhereInput,
      Iterable<_i2.NumeroTelefonoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrdineUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutSoggettoInput,
      _i2.OrdineUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.OrdineCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutSoggettoInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutSoggettoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.opportunitaUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutSoggettoInput,
      _i2.LeadUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.opportunitaUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutSoggettoInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutSoggettoInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutSoggettoInput,
              Iterable<_i2.LeadUncheckedCreateWithoutSoggettoInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.LeadCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.LeadCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutSoggettoInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutSoggettoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.PrivacyCreateWithoutSoggettoInput,
      _i2.PrivacyUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.PrivacyCreateOrConnectWithoutSoggettoInput? connectOrCreate;

  final _i2.PrivacyUpsertWithoutSoggettoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.PrivacyWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.PrivacyWhereInput>? delete;

  final _i2.PrivacyWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.PrivacyUpdateToOneWithWhereWithoutSoggettoInput,
      _i1.PrismaUnion<_i2.PrivacyUpdateWithoutSoggettoInput,
          _i2.PrivacyUncheckedUpdateWithoutSoggettoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoUncheckedUpdateWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutNegozioPreferitoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpdateWithWhereUniqueWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithWhereUniqueWithoutNegozioPreferitoInput({
    required this.where,
    required this.data,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutNegozioPreferitoInput,
      _i2.SoggettoUncheckedUpdateWithoutNegozioPreferitoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final _i1.PrismaUnion<_i2.SoggettoScalarWhereInput,
      Iterable<_i2.SoggettoScalarWhereInput>>? AND;

  final Iterable<_i2.SoggettoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SoggettoScalarWhereInput,
      Iterable<_i2.SoggettoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? ragioneSociale;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i2.EnumTipoSoggettoFilter, _i3.TipoSoggetto>? tipo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateManyMutationInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoUncheckedUpdateManyWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateManyWithoutNegozioPreferitoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoUpdateManyWithWhereWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateManyWithWhereWithoutNegozioPreferitoInput({
    required this.where,
    required this.data,
  });

  final _i2.SoggettoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateManyMutationInput,
      _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoCreateWithoutNegozioPreferitoInput,
          _i1.PrismaUnion<
              Iterable<_i2.SoggettoCreateWithoutNegozioPreferitoInput>,
              _i1.PrismaUnion<
                  _i2.SoggettoUncheckedCreateWithoutNegozioPreferitoInput,
                  Iterable<
                      _i2
                      .SoggettoUncheckedCreateWithoutNegozioPreferitoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput,
          Iterable<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.SoggettoUpsertWithWhereUniqueWithoutNegozioPreferitoInput,
          Iterable<
              _i2.SoggettoUpsertWithWhereUniqueWithoutNegozioPreferitoInput>>?
      upsert;

  final _i2.SoggettoCreateManyNegozioPreferitoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.SoggettoUpdateWithWhereUniqueWithoutNegozioPreferitoInput,
          Iterable<
              _i2.SoggettoUpdateWithWhereUniqueWithoutNegozioPreferitoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.SoggettoUpdateManyWithWhereWithoutNegozioPreferitoInput,
          Iterable<
              _i2.SoggettoUpdateManyWithWhereWithoutNegozioPreferitoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.SoggettoScalarWhereInput,
      Iterable<_i2.SoggettoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class IngressiUncheckedUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateWithoutNegozioInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
      };
}

class IngressiUpdateWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.IngressiWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithoutNegozioInput,
      _i2.IngressiUncheckedUpdateWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IngressiUncheckedUpdateManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateManyWithoutNegozioInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
      };
}

class IngressiUpdateManyWithWhereWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateManyWithWhereWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.IngressiScalarWhereInput where;

  final _i1.PrismaUnion<_i2.IngressiUpdateManyMutationInput,
      _i2.IngressiUncheckedUpdateManyWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class IngressiUncheckedUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.IngressiCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.IngressiUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.IngressiUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.IngressiCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.IngressiUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.IngressiUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.IngressiUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.IngressiScalarWhereInput,
      Iterable<_i2.IngressiScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUncheckedUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutNegozioInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpdateWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutNegozioInput,
      _i2.LeadUncheckedUpdateWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutNegozioInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.LeadCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUncheckedUpdateWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutOrdineInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
      };
}

class NegozioUpsertWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutOrdineInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutOrdineInput,
      _i2.NegozioUncheckedUpdateWithoutOrdineInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutOrdineInput,
      _i2.NegozioUncheckedCreateWithoutOrdineInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutOrdineInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutOrdineInput,
      _i2.NegozioUncheckedUpdateWithoutOrdineInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneWithoutOrdineNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneWithoutOrdineNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutOrdineInput,
      _i2.NegozioUncheckedCreateWithoutOrdineInput>? create;

  final _i2.NegozioCreateOrConnectWithoutOrdineInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutOrdineInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? delete;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutOrdineInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutOrdineInput,
          _i2.NegozioUncheckedUpdateWithoutOrdineInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class OrdineUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'negozio': negozio,
      };
}

class OrdineUpsertWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutUtenteInput,
      _i2.OrdineUncheckedUpdateWithoutUtenteInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutUtenteInput,
      _i2.OrdineUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.OrdineCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutHistoryInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
      };
}

class UtenteUncheckedUpdateWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutHistoryInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
      };
}

class UtenteUpsertWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutHistoryInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutHistoryInput,
      _i2.UtenteUncheckedUpdateWithoutHistoryInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutHistoryInput,
      _i2.UtenteUncheckedCreateWithoutHistoryInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutHistoryInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutHistoryInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutHistoryInput,
      _i2.UtenteUncheckedUpdateWithoutHistoryInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneRequiredWithoutHistoryNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneRequiredWithoutHistoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutHistoryInput,
      _i2.UtenteUncheckedCreateWithoutHistoryInput>? create;

  final _i2.UtenteCreateOrConnectWithoutHistoryInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutHistoryInput? upsert;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutHistoryInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutHistoryInput,
          _i2.UtenteUncheckedUpdateWithoutHistoryInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class HistoryUpdateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateWithoutLeadInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.comment,
    this.attachment,
    this.utente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i2.HistoryCommentUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.HistoryAttachmentUpdateOneWithoutHistoryNestedInput? attachment;

  final _i2.UtenteUpdateOneRequiredWithoutHistoryNestedInput? utente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
      };
}

class HistoryUpsertWithWhereUniqueWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpsertWithWhereUniqueWithoutLeadInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutLeadInput,
      _i2.HistoryUncheckedUpdateWithoutLeadInput> update;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutLeadInput,
      _i2.HistoryUncheckedCreateWithoutLeadInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class HistoryUncheckedUpdateManyWithoutLeadNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateManyWithoutLeadNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.HistoryCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.HistoryCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.HistoryUncheckedCreateWithoutLeadInput,
              Iterable<_i2.HistoryUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.HistoryCreateOrConnectWithoutLeadInput,
      Iterable<_i2.HistoryCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.HistoryUpsertWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.HistoryUpsertWithWhereUniqueWithoutLeadInput>>? upsert;

  final _i2.HistoryCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.HistoryWhereUniqueInput,
      Iterable<_i2.HistoryWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.HistoryUpdateWithWhereUniqueWithoutLeadInput>>? update;

  final _i1.PrismaUnion<_i2.HistoryUpdateManyWithWhereWithoutLeadInput,
      Iterable<_i2.HistoryUpdateManyWithWhereWithoutLeadInput>>? updateMany;

  final _i1.PrismaUnion<_i2.HistoryScalarWhereInput,
      Iterable<_i2.HistoryScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUncheckedUpdateWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutOpportunitaInput({
    this.uuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpdateWithWhereUniqueWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutOpportunitaInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutOpportunitaInput,
      _i2.LeadUncheckedUpdateWithoutOpportunitaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutOpportunitaInput({
    this.uuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutOpportunitaInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutOpportunitaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutOpportunitaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutOpportunitaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutOpportunitaInput>,
              _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutOpportunitaInput,
                  Iterable<_i2.LeadUncheckedCreateWithoutOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutOpportunitaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutOpportunitaInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutOpportunitaInput>>? upsert;

  final _i2.LeadCreateManyOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutOpportunitaInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutOpportunitaInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutOpportunitaInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutOpportunitaInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUncheckedUpdateWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutOpportunitaGestiteInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpdateWithWhereUniqueWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithWhereUniqueWithoutOpportunitaGestiteInput({
    required this.where,
    required this.data,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutOpportunitaGestiteInput,
      _i2.UtenteUncheckedUpdateWithoutOpportunitaGestiteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUncheckedUpdateManyWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyWithoutOpportunitaGestiteInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteUpdateManyWithWhereWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyWithWhereWithoutOpportunitaGestiteInput({
    required this.where,
    required this.data,
  });

  final _i2.UtenteScalarWhereInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateManyMutationInput,
      _i2.UtenteUncheckedUpdateManyWithoutOpportunitaGestiteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUncheckedUpdateManyWithoutOpportunitaGestiteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyWithoutOpportunitaGestiteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaGestiteInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaGestiteInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaGestiteInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaGestiteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaGestiteInput,
          Iterable<
              _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaGestiteInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaGestiteInput,
          Iterable<
              _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaGestiteInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateManyWithWhereWithoutOpportunitaGestiteInput,
          Iterable<
              _i2.UtenteUpdateManyWithWhereWithoutOpportunitaGestiteInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OpportunitaUncheckedUpdateWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateWithoutAgentiInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.LeadUncheckedUpdateManyWithoutOpportunitaNestedInput? leads;

  final _i2.UtenteUncheckedUpdateManyWithoutOpportunitaGestiteNestedInput?
      gestoriLead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
      };
}

class OpportunitaUpsertWithWhereUniqueWithoutAgentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpsertWithWhereUniqueWithoutAgentiInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutAgentiInput,
      _i2.OpportunitaUncheckedUpdateWithoutAgentiInput> update;

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutAgentiInput,
      _i2.OpportunitaUncheckedCreateWithoutAgentiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OpportunitaUpdateManyWithoutAgentiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateManyWithoutAgentiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutAgentiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutAgentiInput>,
              _i1.PrismaUnion<_i2.OpportunitaUncheckedCreateWithoutAgentiInput,
                  Iterable<_i2.OpportunitaUncheckedCreateWithoutAgentiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutAgentiInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutAgentiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OpportunitaUpsertWithWhereUniqueWithoutAgentiInput,
      Iterable<_i2.OpportunitaUpsertWithWhereUniqueWithoutAgentiInput>>? upsert;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithWhereUniqueWithoutAgentiInput,
      Iterable<_i2.OpportunitaUpdateWithWhereUniqueWithoutAgentiInput>>? update;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateManyWithWhereWithoutAgentiInput,
          Iterable<_i2.OpportunitaUpdateManyWithWhereWithoutAgentiInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereInput,
      Iterable<_i2.OpportunitaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutOrdiniInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'history': history,
      };
}

class UtenteUncheckedUpdateWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutOrdiniInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'history': history,
      };
}

class UtenteUpsertWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutOrdiniInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutOrdiniInput,
      _i2.UtenteUncheckedUpdateWithoutOrdiniInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOrdiniInput,
      _i2.UtenteUncheckedCreateWithoutOrdiniInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutOrdiniInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutOrdiniInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutOrdiniInput,
      _i2.UtenteUncheckedUpdateWithoutOrdiniInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneRequiredWithoutOrdiniNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneRequiredWithoutOrdiniNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOrdiniInput,
      _i2.UtenteUncheckedCreateWithoutOrdiniInput>? create;

  final _i2.UtenteCreateOrConnectWithoutOrdiniInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutOrdiniInput? upsert;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutOrdiniInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutOrdiniInput,
          _i2.UtenteUncheckedUpdateWithoutOrdiniInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrdineUpdateWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutLeadInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUpsertWithWhereUniqueWithoutLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutLeadInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutLeadInput,
      _i2.OrdineUncheckedUpdateWithoutLeadInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutLeadInput,
      _i2.OrdineUncheckedCreateWithoutLeadInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateManyWithoutLeadNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutLeadNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutLeadInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutLeadInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutLeadInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutLeadInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutLeadInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutLeadInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutLeadInput>>? upsert;

  final _i2.OrdineCreateManyLeadInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutLeadInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutLeadInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutLeadInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutLeadInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class LeadUpdateWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutOpportunitaInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutOpportunitaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutOpportunitaInput,
      _i2.LeadUncheckedUpdateWithoutOpportunitaInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutOpportunitaInput,
      _i2.LeadUncheckedCreateWithoutOpportunitaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateManyWithoutOpportunitaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutOpportunitaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutOpportunitaInput>,
              _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutOpportunitaInput,
                  Iterable<_i2.LeadUncheckedCreateWithoutOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutOpportunitaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutOpportunitaInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutOpportunitaInput>>? upsert;

  final _i2.LeadCreateManyOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutOpportunitaInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutOpportunitaInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutOpportunitaInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutOpportunitaInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateManyWithoutOpportunitaAssegnateNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyWithoutOpportunitaAssegnateNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaAssegnateInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaAssegnateInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaAssegnateInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaAssegnateInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaAssegnateInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaAssegnateInput,
          Iterable<
              _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaAssegnateInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaAssegnateInput,
          Iterable<
              _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaAssegnateInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateManyWithWhereWithoutOpportunitaAssegnateInput,
          Iterable<
              _i2.UtenteUpdateManyWithWhereWithoutOpportunitaAssegnateInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OpportunitaUpdateWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateWithoutGestoriLeadInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.agenti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.LeadUpdateManyWithoutOpportunitaNestedInput? leads;

  final _i2.UtenteUpdateManyWithoutOpportunitaAssegnateNestedInput? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'agenti': agenti,
      };
}

class OpportunitaUpsertWithWhereUniqueWithoutGestoriLeadInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpsertWithWhereUniqueWithoutGestoriLeadInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OpportunitaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutGestoriLeadInput,
      _i2.OpportunitaUncheckedUpdateWithoutGestoriLeadInput> update;

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutGestoriLeadInput,
      _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OpportunitaUpdateManyWithoutGestoriLeadNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateManyWithoutGestoriLeadNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OpportunitaCreateWithoutGestoriLeadInput,
          _i1.PrismaUnion<
              Iterable<_i2.OpportunitaCreateWithoutGestoriLeadInput>,
              _i1.PrismaUnion<
                  _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput,
                  Iterable<
                      _i2.OpportunitaUncheckedCreateWithoutGestoriLeadInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput,
          Iterable<_i2.OpportunitaCreateOrConnectWithoutGestoriLeadInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.OpportunitaUpsertWithWhereUniqueWithoutGestoriLeadInput,
      Iterable<
          _i2.OpportunitaUpsertWithWhereUniqueWithoutGestoriLeadInput>>? upsert;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OpportunitaWhereUniqueInput,
      Iterable<_i2.OpportunitaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.OpportunitaUpdateWithWhereUniqueWithoutGestoriLeadInput,
      Iterable<
          _i2.OpportunitaUpdateWithWhereUniqueWithoutGestoriLeadInput>>? update;

  final _i1.PrismaUnion<
          _i2.OpportunitaUpdateManyWithWhereWithoutGestoriLeadInput,
          Iterable<_i2.OpportunitaUpdateManyWithWhereWithoutGestoriLeadInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereInput,
      Iterable<_i2.OpportunitaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutLeadsAssegnatiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutLeadsAssegnatiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutLeadsAssegnatiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutLeadsAssegnatiInput,
      _i2.UtenteUncheckedUpdateWithoutLeadsAssegnatiInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsAssegnatiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsAssegnatiInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutLeadsAssegnatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutLeadsAssegnatiInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutLeadsAssegnatiInput,
      _i2.UtenteUncheckedUpdateWithoutLeadsAssegnatiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneWithoutLeadsAssegnatiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneWithoutLeadsAssegnatiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsAssegnatiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsAssegnatiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutLeadsAssegnatiInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutLeadsAssegnatiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? delete;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutLeadsAssegnatiInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutLeadsAssegnatiInput,
          _i2.UtenteUncheckedUpdateWithoutLeadsAssegnatiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class LeadUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutUtenteInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutUtenteInput,
      _i2.LeadUncheckedUpdateWithoutUtenteInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutUtenteInput,
      _i2.LeadUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.LeadCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutIngressiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutIngressiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutIngressiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutIngressiInput,
      _i2.UtenteUncheckedUpdateWithoutIngressiInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutIngressiInput,
      _i2.UtenteUncheckedCreateWithoutIngressiInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutIngressiInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutIngressiInput,
      _i2.UtenteUncheckedUpdateWithoutIngressiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneRequiredWithoutIngressiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneRequiredWithoutIngressiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutIngressiInput,
      _i2.UtenteUncheckedCreateWithoutIngressiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutIngressiInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutIngressiInput? upsert;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutIngressiInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutIngressiInput,
          _i2.UtenteUncheckedUpdateWithoutIngressiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class IngressiUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateWithoutNegozioInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i2.UtenteUpdateOneRequiredWithoutIngressiNestedInput? utente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utente': utente,
      };
}

class IngressiUpsertWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpsertWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.IngressiWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithoutNegozioInput,
      _i2.IngressiUncheckedUpdateWithoutNegozioInput> update;

  final _i1.PrismaUnion<_i2.IngressiCreateWithoutNegozioInput,
      _i2.IngressiUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class IngressiUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.IngressiCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.IngressiUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.IngressiUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.IngressiCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.IngressiUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.IngressiUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.IngressiUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.IngressiScalarWhereInput,
      Iterable<_i2.IngressiScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrdineUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
      };
}

class OrdineUncheckedUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'prodotti': prodotti,
      };
}

class OrdineUpsertWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutNegozioInput,
      _i2.OrdineUncheckedUpdateWithoutNegozioInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutNegozioInput,
      _i2.OrdineUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutNegozioInput,
      _i2.OrdineUncheckedUpdateWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
      };
}

class OrdineUpdateManyWithWhereWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.OrdineCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutLeadsInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'Ordine': ordine,
      };
}

class OrdineUncheckedUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OrdineCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.OrdineCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.OrdineUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.OrdineCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUncheckedUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutLeadsInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutLeadsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutLeadsInput,
      _i2.NegozioUncheckedUpdateWithoutLeadsInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutLeadsInput,
      _i2.NegozioUncheckedCreateWithoutLeadsInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutLeadsInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutLeadsInput,
      _i2.NegozioUncheckedUpdateWithoutLeadsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneWithoutLeadsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneWithoutLeadsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutLeadsInput,
      _i2.NegozioUncheckedCreateWithoutLeadsInput>? create;

  final _i2.NegozioCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutLeadsInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? delete;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutLeadsInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutLeadsInput,
          _i2.NegozioUncheckedUpdateWithoutLeadsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class LeadUpdateWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutAgenteInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutAgenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutAgenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutAgenteInput,
      _i2.LeadUncheckedUpdateWithoutAgenteInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutAgenteInput,
      _i2.LeadUncheckedCreateWithoutAgenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateManyWithoutAgenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutAgenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutAgenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutAgenteInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutAgenteInput,
              Iterable<_i2.LeadUncheckedCreateWithoutAgenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutAgenteInput,
      Iterable<_i2.LeadCreateOrConnectWithoutAgenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutAgenteInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutAgenteInput>>? upsert;

  final _i2.LeadCreateManyAgenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutAgenteInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutAgenteInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutAgenteInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutAgenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutLeadsGestitiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutLeadsGestitiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutLeadsGestitiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutLeadsGestitiInput,
      _i2.UtenteUncheckedUpdateWithoutLeadsGestitiInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsGestitiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsGestitiInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutLeadsGestitiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutLeadsGestitiInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutLeadsGestitiInput,
      _i2.UtenteUncheckedUpdateWithoutLeadsGestitiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneWithoutLeadsGestitiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneWithoutLeadsGestitiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutLeadsGestitiInput,
      _i2.UtenteUncheckedCreateWithoutLeadsGestitiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutLeadsGestitiInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutLeadsGestitiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? delete;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutLeadsGestitiInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutLeadsGestitiInput,
          _i2.UtenteUncheckedUpdateWithoutLeadsGestitiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class LeadUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutDomicilioInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutDomicilioInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutDomicilioInput,
      _i2.LeadUncheckedUpdateWithoutDomicilioInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutDomicilioInput,
      _i2.LeadUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutDomicilioInput,
      _i2.LeadUncheckedUpdateWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutDomicilioInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutDomicilioInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutDomicilioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutDomicilioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutDomicilioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutDomicilioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutDomicilioInput>>? upsert;

  final _i2.LeadCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutDomicilioInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutDomicilioInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutDomicilioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUpdateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.SoggettoUpdateOneRequiredWithoutDomiciliNestedInput? soggetto;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.LeadUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'leads': leads,
      };
}

class LeadUncheckedUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutDomicilioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutDomicilioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutDomicilioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutDomicilioInput>>? upsert;

  final _i2.LeadCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutDomicilioInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutDomicilioInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutDomicilioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUncheckedUpdateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.LeadUncheckedUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'leads': leads,
      };
}

class DomicilioUpsertWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpsertWithoutProdottiOrdinatiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutProdottiOrdinatiInput,
      _i2.DomicilioUncheckedUpdateWithoutProdottiOrdinatiInput> update;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutProdottiOrdinatiInput,
      _i2.DomicilioUncheckedCreateWithoutProdottiOrdinatiInput> create;

  final _i2.DomicilioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class DomicilioUpdateToOneWithWhereWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateToOneWithWhereWithoutProdottiOrdinatiInput({
    this.where,
    required this.data,
  });

  final _i2.DomicilioWhereInput? where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutProdottiOrdinatiInput,
      _i2.DomicilioUncheckedUpdateWithoutProdottiOrdinatiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutProdottiOrdinatiInput,
      _i2.DomicilioUncheckedCreateWithoutProdottiOrdinatiInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutProdottiOrdinatiInput?
      connectOrCreate;

  final _i2.DomicilioUpsertWithoutProdottiOrdinatiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.DomicilioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.DomicilioWhereInput>? delete;

  final _i2.DomicilioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.DomicilioUpdateToOneWithWhereWithoutProdottiOrdinatiInput,
      _i1.PrismaUnion<_i2.DomicilioUpdateWithoutProdottiOrdinatiInput,
          _i2.DomicilioUncheckedUpdateWithoutProdottiOrdinatiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class OrdineUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutProdottiInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUncheckedUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutProdottiInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpsertWithWhereUniqueWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutProdottiInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutProdottiInput,
      _i2.OrdineUncheckedUpdateWithoutProdottiInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutProdottiInput,
      _i2.OrdineUncheckedCreateWithoutProdottiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateWithWhereUniqueWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutProdottiInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutProdottiInput,
      _i2.OrdineUncheckedUpdateWithoutProdottiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutProdottiInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyWithWhereWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutProdottiInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutProdottiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUpdateManyWithoutProdottiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutProdottiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutProdottiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutProdottiInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutProdottiInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutProdottiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutProdottiInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutProdottiInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutProdottiInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutProdottiInput>>? upsert;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutProdottiInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutProdottiInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutProdottiInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutProdottiInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoProdottoUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUpdateWithoutProdottiInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoUncheckedUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUncheckedUpdateWithoutProdottiInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoUpsertWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUpsertWithoutProdottiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.TipoProdottoUpdateWithoutProdottiInput,
      _i2.TipoProdottoUncheckedUpdateWithoutProdottiInput> update;

  final _i1.PrismaUnion<_i2.TipoProdottoCreateWithoutProdottiInput,
      _i2.TipoProdottoUncheckedCreateWithoutProdottiInput> create;

  final _i2.TipoProdottoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class TipoProdottoUpdateToOneWithWhereWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUpdateToOneWithWhereWithoutProdottiInput({
    this.where,
    required this.data,
  });

  final _i2.TipoProdottoWhereInput? where;

  final _i1.PrismaUnion<_i2.TipoProdottoUpdateWithoutProdottiInput,
      _i2.TipoProdottoUncheckedUpdateWithoutProdottiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class TipoProdottoUpdateOneRequiredWithoutProdottiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUpdateOneRequiredWithoutProdottiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.TipoProdottoCreateWithoutProdottiInput,
      _i2.TipoProdottoUncheckedCreateWithoutProdottiInput>? create;

  final _i2.TipoProdottoCreateOrConnectWithoutProdottiInput? connectOrCreate;

  final _i2.TipoProdottoUpsertWithoutProdottiInput? upsert;

  final _i2.TipoProdottoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.TipoProdottoUpdateToOneWithWhereWithoutProdottiInput,
      _i1.PrismaUnion<_i2.TipoProdottoUpdateWithoutProdottiInput,
          _i2.TipoProdottoUncheckedUpdateWithoutProdottiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProdottoUpdateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithoutFornitoreInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttore,
    this.prodottiOrdinati,
    this.tipoProdotto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i2.ProduttoreUpdateOneRequiredWithoutProdottiNestedInput? produttore;

  final _i2.OrdineUpdateManyWithoutProdottiNestedInput? prodottiOrdinati;

  final _i2.TipoProdottoUpdateOneRequiredWithoutProdottiNestedInput?
      tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'tipoProdotto': tipoProdotto,
      };
}

class OrdineUncheckedUpdateManyWithoutProdottiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutProdottiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutProdottiInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutProdottiInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutProdottiInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutProdottiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutProdottiInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutProdottiInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutProdottiInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutProdottiInput>>? upsert;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutProdottiInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutProdottiInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutProdottiInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutProdottiInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProdottoUncheckedUpdateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateWithoutFornitoreInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.tipoProdottoId,
    this.prodottiOrdinati,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  final _i2.OrdineUncheckedUpdateManyWithoutProdottiNestedInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'tipoProdottoId': tipoProdottoId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoUpsertWithWhereUniqueWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpsertWithWhereUniqueWithoutFornitoreInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutFornitoreInput,
      _i2.ProdottoUncheckedUpdateWithoutFornitoreInput> update;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutFornitoreInput,
      _i2.ProdottoUncheckedCreateWithoutFornitoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProdottoUpdateWithWhereUniqueWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithWhereUniqueWithoutFornitoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutFornitoreInput,
      _i2.ProdottoUncheckedUpdateWithoutFornitoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUncheckedUpdateManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutFornitoreInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoUpdateManyWithWhereWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithWhereWithoutFornitoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyMutationInput,
      _i2.ProdottoUncheckedUpdateManyWithoutFornitoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUpdateManyWithoutFornitoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithoutFornitoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<_i2.ProdottoUncheckedCreateWithoutFornitoreInput,
                  Iterable<_i2.ProdottoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ProdottoUpsertWithWhereUniqueWithoutFornitoreInput,
      Iterable<_i2.ProdottoUpsertWithWhereUniqueWithoutFornitoreInput>>? upsert;

  final _i2.ProdottoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithWhereUniqueWithoutFornitoreInput,
      Iterable<_i2.ProdottoUpdateWithWhereUniqueWithoutFornitoreInput>>? update;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyWithWhereWithoutFornitoreInput,
          Iterable<_i2.ProdottoUpdateManyWithWhereWithoutFornitoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornitoreUpdateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateWithoutModuliContrattoInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutFornitoreNestedInput? serviziEwo;

  final _i2.ProdottoUpdateManyWithoutFornitoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'prodotti': prodotti,
      };
}

class ContrattoUncheckedUpdateManyWithoutModuloNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyWithoutModuloNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutModuloInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutModuloInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutModuloInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutModuloInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutModuloInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutModuloInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutModuloInput>>? upsert;

  final _i2.ContrattoCreateManyModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutModuloInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutModuloInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutModuloInput,
      Iterable<_i2.ContrattoUpdateManyWithWhereWithoutModuloInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ModuloContrattoUncheckedUpdateWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateWithoutServiziEwoCollegabiliInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.contratti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  final _i2.ContrattoUncheckedUpdateManyWithoutModuloNestedInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'contratti': contratti,
      };
}

class ModuloContrattoUpdateWithWhereUniqueWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithWhereUniqueWithoutServiziEwoCollegabiliInput({
    required this.where,
    required this.data,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ModuloContrattoUpdateWithoutServiziEwoCollegabiliInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutServiziEwoCollegabiliInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? AND;

  final Iterable<_i2.ModuloContrattoScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoSoggettoFilter, _i3.TipoSoggetto>?
      clienteTarget;

  final _i1.PrismaUnion<_i2.EnumCanaleFilter, _i3.Canale>? canale;

  final _i1.PrismaUnion<_i2.StringFilter, String>? tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyMutationInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
      };
}

class ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoUpdateManyWithWhereWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyWithWhereWithoutServiziEwoCollegabiliInput({
    required this.where,
    required this.data,
  });

  final _i2.ModuloContrattoScalarWhereInput where;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateManyMutationInput,
          _i2
          .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput>,
              _i1.PrismaUnion<
                  _i2
                  .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ModuloContrattoUpsertWithWhereUniqueWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoUpsertWithWhereUniqueWithoutServiziEwoCollegabiliInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ModuloContrattoUpdateWithWhereUniqueWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoUpdateWithWhereUniqueWithoutServiziEwoCollegabiliInput>>?
      update;

  final _i1
      .PrismaUnion<
          _i2
          .ModuloContrattoUpdateManyWithWhereWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoUpdateManyWithWhereWithoutServiziEwoCollegabiliInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUncheckedUpdateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutFornitoreInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpdateWithWhereUniqueWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithWhereUniqueWithoutFornitoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutFornitoreInput,
      _i2.ServizioEwoUncheckedUpdateWithoutFornitoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutFornitoreInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateManyWithWhereWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithWhereWithoutFornitoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyMutationInput,
      _i2.ServizioEwoUncheckedUpdateManyWithoutFornitoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutFornitoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutFornitoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpsertWithWhereUniqueWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoUpsertWithWhereUniqueWithoutFornitoreInput>>?
      upsert;

  final _i2.ServizioEwoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateWithWhereUniqueWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoUpdateWithWhereUniqueWithoutFornitoreInput>>?
      update;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyWithWhereWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoUpdateManyWithWhereWithoutFornitoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProdottoUncheckedUpdateManyWithoutFornitoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutFornitoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<_i2.ProdottoUncheckedCreateWithoutFornitoreInput,
                  Iterable<_i2.ProdottoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ProdottoUpsertWithWhereUniqueWithoutFornitoreInput,
      Iterable<_i2.ProdottoUpsertWithWhereUniqueWithoutFornitoreInput>>? upsert;

  final _i2.ProdottoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithWhereUniqueWithoutFornitoreInput,
      Iterable<_i2.ProdottoUpdateWithWhereUniqueWithoutFornitoreInput>>? update;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyWithWhereWithoutFornitoreInput,
          Iterable<_i2.ProdottoUpdateManyWithWhereWithoutFornitoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornitoreUncheckedUpdateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedUpdateWithoutModuliContrattoInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutFornitoreNestedInput?
      serviziEwo;

  final _i2.ProdottoUncheckedUpdateManyWithoutFornitoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'prodotti': prodotti,
      };
}

class FornitoreUpsertWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpsertWithoutModuliContrattoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornitoreUpdateWithoutModuliContrattoInput,
      _i2.FornitoreUncheckedUpdateWithoutModuliContrattoInput> update;

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutModuliContrattoInput,
      _i2.FornitoreUncheckedCreateWithoutModuliContrattoInput> create;

  final _i2.FornitoreWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornitoreUpdateToOneWithWhereWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateToOneWithWhereWithoutModuliContrattoInput({
    this.where,
    required this.data,
  });

  final _i2.FornitoreWhereInput? where;

  final _i1.PrismaUnion<_i2.FornitoreUpdateWithoutModuliContrattoInput,
      _i2.FornitoreUncheckedUpdateWithoutModuliContrattoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornitoreUpdateOneRequiredWithoutModuliContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateOneRequiredWithoutModuliContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutModuliContrattoInput,
      _i2.FornitoreUncheckedCreateWithoutModuliContrattoInput>? create;

  final _i2.FornitoreCreateOrConnectWithoutModuliContrattoInput?
      connectOrCreate;

  final _i2.FornitoreUpsertWithoutModuliContrattoInput? upsert;

  final _i2.FornitoreWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornitoreUpdateToOneWithWhereWithoutModuliContrattoInput,
      _i1.PrismaUnion<_i2.FornitoreUpdateWithoutModuliContrattoInput,
          _i2.FornitoreUncheckedUpdateWithoutModuliContrattoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ModuloContrattoUpdateWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithoutServiziEwoCollegabiliInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i2.ContrattoUpdateManyWithoutModuloNestedInput? contratti;

  final _i2.FornitoreUpdateOneRequiredWithoutModuliContrattoNestedInput?
      fornitore;

  final _i2
      .TipoModuloContrattoUpdateOneRequiredWithoutModuloContrattoNestedInput?
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoUpsertWithWhereUniqueWithoutServiziEwoCollegabiliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpsertWithWhereUniqueWithoutServiziEwoCollegabiliInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateWithoutServiziEwoCollegabiliInput,
          _i2.ModuloContrattoUncheckedUpdateWithoutServiziEwoCollegabiliInput>
      update;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput,
          _i2.ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ModuloContrattoCreateWithoutServiziEwoCollegabiliInput>,
              _i1.PrismaUnion<
                  _i2
                  .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutServiziEwoCollegabiliInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoCreateOrConnectWithoutServiziEwoCollegabiliInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ModuloContrattoUpsertWithWhereUniqueWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoUpsertWithWhereUniqueWithoutServiziEwoCollegabiliInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ModuloContrattoUpdateWithWhereUniqueWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoUpdateWithWhereUniqueWithoutServiziEwoCollegabiliInput>>?
      update;

  final _i1
      .PrismaUnion<
          _i2
          .ModuloContrattoUpdateManyWithWhereWithoutServiziEwoCollegabiliInput,
          Iterable<
              _i2
              .ModuloContrattoUpdateManyWithWhereWithoutServiziEwoCollegabiliInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUpdateWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutOfferteInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedUpdateWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutOfferteInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpsertWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithoutOfferteInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutOfferteInput,
      _i2.ServizioEwoUncheckedUpdateWithoutOfferteInput> update;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutOfferteInput,
      _i2.ServizioEwoUncheckedCreateWithoutOfferteInput> create;

  final _i2.ServizioEwoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ServizioEwoUpdateToOneWithWhereWithoutOfferteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateToOneWithWhereWithoutOfferteInput({
    this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutOfferteInput,
      _i2.ServizioEwoUncheckedUpdateWithoutOfferteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutOfferteInput,
      _i2.ServizioEwoUncheckedCreateWithoutOfferteInput>? create;

  final _i2.ServizioEwoCreateOrConnectWithoutOfferteInput? connectOrCreate;

  final _i2.ServizioEwoUpsertWithoutOfferteInput? upsert;

  final _i2.ServizioEwoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ServizioEwoUpdateToOneWithWhereWithoutOfferteInput,
      _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutOfferteInput,
          _i2.ServizioEwoUncheckedUpdateWithoutOfferteInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OffertaUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpsertWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithoutContrattiEnelFibraInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelFibraInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelFibraInput> update;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelFibraInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelFibraInput> create;

  final _i2.OffertaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OffertaUpdateToOneWithWhereWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateToOneWithWhereWithoutContrattiEnelFibraInput({
    this.where,
    required this.data,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelFibraInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelFibraInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUpdateOneWithoutContrattiEnelFibraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateOneWithoutContrattiEnelFibraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelFibraInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.OffertaUpsertWithoutContrattiEnelFibraInput? upsert;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? delete;

  final _i2.OffertaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.OffertaUpdateToOneWithWhereWithoutContrattiEnelFibraInput,
      _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelFibraInput,
          _i2.OffertaUncheckedUpdateWithoutContrattiEnelFibraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelFibraUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithoutDomicilioInput({
    this.uuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.stato,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      stato;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelFibraNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelFibraUpsertWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpsertWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutDomicilioInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutDomicilioInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutDomicilioInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpsertWithWhereUniqueWithoutDomicilioInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpdateWithWhereUniqueWithoutDomicilioInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutDomicilioInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutDomicilioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUncheckedUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateWithoutSoggettoInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedUpdateManyWithoutDomicilioNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUpdateWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutSoggettoInput,
      _i2.DomicilioUncheckedUpdateWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<_i2.DomicilioScalarWhereInput,
      Iterable<_i2.DomicilioScalarWhereInput>>? AND;

  final Iterable<_i2.DomicilioScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.DomicilioScalarWhereInput,
      Iterable<_i2.DomicilioScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<_i2.StringFilter, String>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateManyMutationInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
      };
}

class DomicilioUncheckedUpdateManyWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateManyWithoutSoggettoInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
      };
}

class DomicilioUpdateManyWithWhereWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateManyWithWhereWithoutSoggettoInput({
    required this.where,
    required this.data,
  });

  final _i2.DomicilioScalarWhereInput where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateManyMutationInput,
      _i2.DomicilioUncheckedUpdateManyWithoutSoggettoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.DomicilioCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.DomicilioUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.DomicilioUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.DomicilioCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.DomicilioCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.DomicilioUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.DomicilioUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.DomicilioCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.DomicilioUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.DomicilioUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.DomicilioUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.DomicilioScalarWhereInput,
      Iterable<_i2.DomicilioScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUncheckedUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutLeadsInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutLeadsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutLeadsInput,
      _i2.SoggettoUncheckedUpdateWithoutLeadsInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutLeadsInput,
      _i2.SoggettoUncheckedCreateWithoutLeadsInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutLeadsInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutLeadsInput,
      _i2.SoggettoUncheckedUpdateWithoutLeadsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneRequiredWithoutLeadsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneRequiredWithoutLeadsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutLeadsInput,
      _i2.SoggettoUncheckedCreateWithoutLeadsInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.SoggettoUpsertWithoutLeadsInput? upsert;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutLeadsInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutLeadsInput,
          _i2.SoggettoUncheckedUpdateWithoutLeadsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class LeadUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutNegozioInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutNegozioInput,
      _i2.LeadUncheckedUpdateWithoutNegozioInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutNegozioInput,
      _i2.LeadUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.LeadUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.LeadCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.LeadCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUpdateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutIngressiInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutIngressiInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutIngressiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutIngressiInput,
      _i2.NegozioUncheckedUpdateWithoutIngressiInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutIngressiInput,
      _i2.NegozioUncheckedCreateWithoutIngressiInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutIngressiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutIngressiInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutIngressiInput,
      _i2.NegozioUncheckedUpdateWithoutIngressiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneRequiredWithoutIngressiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneRequiredWithoutIngressiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutIngressiInput,
      _i2.NegozioUncheckedCreateWithoutIngressiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutIngressiInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutIngressiInput? upsert;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutIngressiInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutIngressiInput,
          _i2.NegozioUncheckedUpdateWithoutIngressiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class IngressiUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateWithoutUtenteInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i2.NegozioUpdateOneRequiredWithoutIngressiNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'negozio': negozio,
      };
}

class IngressiUpsertWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpsertWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.IngressiWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithoutUtenteInput,
      _i2.IngressiUncheckedUpdateWithoutUtenteInput> update;

  final _i1.PrismaUnion<_i2.IngressiCreateWithoutUtenteInput,
      _i2.IngressiUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class IngressiUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.IngressiCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.IngressiCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.IngressiUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.IngressiUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IngressiCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.IngressiCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.IngressiUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.IngressiUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.IngressiCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.IngressiWhereUniqueInput,
      Iterable<_i2.IngressiWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.IngressiUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.IngressiUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.IngressiUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.IngressiUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.IngressiScalarWhereInput,
      Iterable<_i2.IngressiScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutContrattiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutContrattiInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutContrattiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutContrattiInput,
      _i2.UtenteUncheckedUpdateWithoutContrattiInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutContrattiInput,
      _i2.UtenteUncheckedCreateWithoutContrattiInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutContrattiInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutContrattiInput,
      _i2.UtenteUncheckedUpdateWithoutContrattiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneWithoutContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneWithoutContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutContrattiInput,
      _i2.UtenteUncheckedCreateWithoutContrattiInput>? create;

  final _i2.UtenteCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutContrattiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? delete;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutContrattiInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutContrattiInput,
          _i2.UtenteUncheckedUpdateWithoutContrattiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUpsertWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutNegozioInput,
      _i2.ContrattoUncheckedUpdateWithoutNegozioInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutNegozioInput,
      _i2.ContrattoUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutNegozioInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutNegozioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.ContrattoCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutNegozioInput,
          Iterable<_i2.ContrattoUpdateManyWithWhereWithoutNegozioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutPraticheInput({
    this.codice,
    this.nome,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutPraticheInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutPraticheInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutPraticheInput,
      _i2.NegozioUncheckedUpdateWithoutPraticheInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutPraticheInput,
      _i2.NegozioUncheckedCreateWithoutPraticheInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutPraticheInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutPraticheInput,
      _i2.NegozioUncheckedUpdateWithoutPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneWithoutPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneWithoutPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutPraticheInput,
      _i2.NegozioUncheckedCreateWithoutPraticheInput>? create;

  final _i2.NegozioCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutPraticheInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? delete;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutPraticheInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutPraticheInput,
          _i2.NegozioUncheckedUpdateWithoutPraticheInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateManyWithoutPraticaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithoutPraticaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutPraticaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutPraticaInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutPraticaInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutPraticaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutPraticaInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutPraticaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutPraticaInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutPraticaInput>>? upsert;

  final _i2.ContrattoCreateManyPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutPraticaInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutPraticaInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutPraticaInput,
          Iterable<_i2.ContrattoUpdateManyWithWhereWithoutPraticaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class PraticaUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput? tipoPratica;

  final _i2.SoggettoUpdateOneWithoutPraticheIntestateNestedInput? soggetto;

  final _i2.NegozioUpdateOneWithoutPraticheNestedInput? negozio;

  final _i2.StatoPraticaUpdateOneWithoutPraticheNestedInput? stato;

  final _i2.ContrattoUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaUpsertWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpsertWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutUtenteInput,
      _i2.PraticaUncheckedUpdateWithoutUtenteInput> update;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutUtenteInput,
      _i2.PraticaUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class PraticaUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutUtenteInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutUtenteInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutUtenteInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutUtenteInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutUtenteInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutUtenteInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.PraticaCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutOpportunitaGestiteInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithWhereUniqueWithoutOpportunitaGestiteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithWhereUniqueWithoutOpportunitaGestiteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutOpportunitaGestiteInput,
      _i2.UtenteUncheckedUpdateWithoutOpportunitaGestiteInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutOpportunitaGestiteInput,
      _i2.UtenteUncheckedCreateWithoutOpportunitaGestiteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class UtenteUpdateManyWithoutOpportunitaGestiteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyWithoutOpportunitaGestiteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.UtenteCreateWithoutOpportunitaGestiteInput,
          _i1.PrismaUnion<
              Iterable<_i2.UtenteCreateWithoutOpportunitaGestiteInput>,
              _i1.PrismaUnion<
                  _i2.UtenteUncheckedCreateWithoutOpportunitaGestiteInput,
                  Iterable<
                      _i2
                      .UtenteUncheckedCreateWithoutOpportunitaGestiteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput,
          Iterable<_i2.UtenteCreateOrConnectWithoutOpportunitaGestiteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaGestiteInput,
          Iterable<
              _i2.UtenteUpsertWithWhereUniqueWithoutOpportunitaGestiteInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaGestiteInput,
          Iterable<
              _i2.UtenteUpdateWithWhereUniqueWithoutOpportunitaGestiteInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.UtenteUpdateManyWithWhereWithoutOpportunitaGestiteInput,
          Iterable<
              _i2.UtenteUpdateManyWithWhereWithoutOpportunitaGestiteInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OpportunitaUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateWithoutLeadsInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.gestoriLead,
    this.agenti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.UtenteUpdateManyWithoutOpportunitaGestiteNestedInput? gestoriLead;

  final _i2.UtenteUpdateManyWithoutOpportunitaAssegnateNestedInput? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaUncheckedUpdateWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateWithoutLeadsInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.gestoriLead,
    this.agenti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.UtenteUncheckedUpdateManyWithoutOpportunitaGestiteNestedInput?
      gestoriLead;

  final _i2.UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateNestedInput?
      agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaUpsertWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpsertWithoutLeadsInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutLeadsInput,
      _i2.OpportunitaUncheckedUpdateWithoutLeadsInput> update;

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutLeadsInput,
      _i2.OpportunitaUncheckedCreateWithoutLeadsInput> create;

  final _i2.OpportunitaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OpportunitaUpdateToOneWithWhereWithoutLeadsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateToOneWithWhereWithoutLeadsInput({
    this.where,
    required this.data,
  });

  final _i2.OpportunitaWhereInput? where;

  final _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutLeadsInput,
      _i2.OpportunitaUncheckedUpdateWithoutLeadsInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OpportunitaUpdateOneRequiredWithoutLeadsNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateOneRequiredWithoutLeadsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.OpportunitaCreateWithoutLeadsInput,
      _i2.OpportunitaUncheckedCreateWithoutLeadsInput>? create;

  final _i2.OpportunitaCreateOrConnectWithoutLeadsInput? connectOrCreate;

  final _i2.OpportunitaUpsertWithoutLeadsInput? upsert;

  final _i2.OpportunitaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.OpportunitaUpdateToOneWithWhereWithoutLeadsInput,
      _i1.PrismaUnion<_i2.OpportunitaUpdateWithoutLeadsInput,
          _i2.OpportunitaUncheckedUpdateWithoutLeadsInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class LeadUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutSoggettoInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutSoggettoInput,
      _i2.LeadUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutSoggettoInput,
      _i2.LeadUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.LeadCreateWithoutSoggettoInput,
      _i1.PrismaUnion<
          Iterable<_i2.LeadCreateWithoutSoggettoInput>,
          _i1.PrismaUnion<_i2.LeadUncheckedCreateWithoutSoggettoInput,
              Iterable<_i2.LeadUncheckedCreateWithoutSoggettoInput>>>>? create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.LeadCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.LeadUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.LeadUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.LeadCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.LeadUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.LeadUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutSoggettoInput,
      Iterable<_i2.LeadUpdateManyWithWhereWithoutSoggettoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutProdottiOrdinatiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutProdottiOrdinatiInput,
      _i2.SoggettoUncheckedUpdateWithoutProdottiOrdinatiInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutProdottiOrdinatiInput,
      _i2.SoggettoUncheckedCreateWithoutProdottiOrdinatiInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutProdottiOrdinatiInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutProdottiOrdinatiInput,
      _i2.SoggettoUncheckedUpdateWithoutProdottiOrdinatiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutProdottiOrdinatiInput,
      _i2.SoggettoUncheckedCreateWithoutProdottiOrdinatiInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutProdottiOrdinatiInput?
      connectOrCreate;

  final _i2.SoggettoUpsertWithoutProdottiOrdinatiInput? upsert;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutProdottiOrdinatiInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutProdottiOrdinatiInput,
          _i2.SoggettoUncheckedUpdateWithoutProdottiOrdinatiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OrdineUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutDomicilioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.soggetto,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUpsertWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutDomicilioInput,
      _i2.OrdineUncheckedUpdateWithoutDomicilioInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutDomicilioInput,
      _i2.OrdineUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutDomicilioInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutDomicilioInput>>? upsert;

  final _i2.OrdineCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutDomicilioInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutDomicilioInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutDomicilioInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutDomicilioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.SoggettoUpdateOneRequiredWithoutDomiciliNestedInput? soggetto;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.OrdineUpdateManyWithoutDomicilioNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.OrdineUncheckedUpdateManyWithoutDomicilioNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUpsertWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpsertWithoutContrattiEnelFibraInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutContrattiEnelFibraInput,
      _i2.DomicilioUncheckedUpdateWithoutContrattiEnelFibraInput> update;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutContrattiEnelFibraInput,
      _i2.DomicilioUncheckedCreateWithoutContrattiEnelFibraInput> create;

  final _i2.DomicilioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class DomicilioUpdateToOneWithWhereWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateToOneWithWhereWithoutContrattiEnelFibraInput({
    this.where,
    required this.data,
  });

  final _i2.DomicilioWhereInput? where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutContrattiEnelFibraInput,
      _i2.DomicilioUncheckedUpdateWithoutContrattiEnelFibraInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioUpdateOneWithoutContrattiEnelFibraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateOneWithoutContrattiEnelFibraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutContrattiEnelFibraInput,
      _i2.DomicilioUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.DomicilioUpsertWithoutContrattiEnelFibraInput? upsert;

  final _i1.PrismaUnion<bool, _i2.DomicilioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.DomicilioWhereInput>? delete;

  final _i2.DomicilioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.DomicilioUpdateToOneWithWhereWithoutContrattiEnelFibraInput,
      _i1.PrismaUnion<_i2.DomicilioUpdateWithoutContrattiEnelFibraInput,
          _i2.DomicilioUncheckedUpdateWithoutContrattiEnelFibraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelFibraUpdateWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithoutOffertaInput({
    this.uuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.stato,
    this.contratto,
    this.domicilio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      stato;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      contratto;

  final _i2.DomicilioUpdateOneWithoutContrattiEnelFibraNestedInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraUpsertWithWhereUniqueWithoutOffertaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpsertWithWhereUniqueWithoutOffertaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutOffertaInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutOffertaInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutOffertaInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutOffertaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutOffertaInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutOffertaInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutOffertaInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutOffertaInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutOffertaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutOffertaInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyOffertaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutOffertaInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutOffertaInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutOffertaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OffertaUpdateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutServizioEwoInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpsertWithWhereUniqueWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithWhereUniqueWithoutServizioEwoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OffertaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutServizioEwoInput,
      _i2.OffertaUncheckedUpdateWithoutServizioEwoInput> update;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutServizioEwoInput,
      _i2.OffertaUncheckedCreateWithoutServizioEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OffertaUpdateManyWithoutServizioEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateManyWithoutServizioEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.OffertaCreateWithoutServizioEwoInput,
      _i1.PrismaUnion<
          Iterable<_i2.OffertaCreateWithoutServizioEwoInput>,
          _i1.PrismaUnion<
              _i2.OffertaUncheckedCreateWithoutServizioEwoInput,
              Iterable<
                  _i2.OffertaUncheckedCreateWithoutServizioEwoInput>>>>? create;

  final _i1.PrismaUnion<_i2.OffertaCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.OffertaCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OffertaUpsertWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.OffertaUpsertWithWhereUniqueWithoutServizioEwoInput>>?
      upsert;

  final _i2.OffertaCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OffertaWhereUniqueInput,
      Iterable<_i2.OffertaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.OffertaUpdateWithWhereUniqueWithoutServizioEwoInput>>?
      update;

  final _i1.PrismaUnion<_i2.OffertaUpdateManyWithWhereWithoutServizioEwoInput,
          Iterable<_i2.OffertaUpdateManyWithWhereWithoutServizioEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereInput,
      Iterable<_i2.OffertaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUpdateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutFornitoreInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpsertWithWhereUniqueWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithWhereUniqueWithoutFornitoreInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutFornitoreInput,
      _i2.ServizioEwoUncheckedUpdateWithoutFornitoreInput> update;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutFornitoreInput,
      _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ServizioEwoUpdateManyWithoutFornitoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithoutFornitoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2.ServizioEwoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpsertWithWhereUniqueWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoUpsertWithWhereUniqueWithoutFornitoreInput>>?
      upsert;

  final _i2.ServizioEwoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateWithWhereUniqueWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoUpdateWithWhereUniqueWithoutFornitoreInput>>?
      update;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyWithWhereWithoutFornitoreInput,
          Iterable<_i2.ServizioEwoUpdateManyWithWhereWithoutFornitoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornitoreUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateWithoutProdottiInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutFornitoreNestedInput? serviziEwo;

  final _i2.ModuloContrattoUpdateManyWithoutFornitoreNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
      };
}

class ModuloContrattoUncheckedUpdateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateWithoutFornitoreInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUncheckedUpdateManyWithoutModuloNestedInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoUpdateWithWhereUniqueWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithWhereUniqueWithoutFornitoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutFornitoreInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutFornitoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoUncheckedUpdateManyWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyWithoutFornitoreInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoUpdateManyWithWhereWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyWithWhereWithoutFornitoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ModuloContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateManyMutationInput,
      _i2.ModuloContrattoUncheckedUpdateManyWithoutFornitoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoUncheckedUpdateManyWithoutFornitoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyWithoutFornitoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpsertWithWhereUniqueWithoutFornitoreInput,
          Iterable<
              _i2.ModuloContrattoUpsertWithWhereUniqueWithoutFornitoreInput>>?
      upsert;

  final _i2.ModuloContrattoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateWithWhereUniqueWithoutFornitoreInput,
          Iterable<
              _i2.ModuloContrattoUpdateWithWhereUniqueWithoutFornitoreInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateManyWithWhereWithoutFornitoreInput,
          Iterable<
              _i2.ModuloContrattoUpdateManyWithWhereWithoutFornitoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornitoreUncheckedUpdateWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedUpdateWithoutProdottiInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutFornitoreNestedInput?
      serviziEwo;

  final _i2.ModuloContrattoUncheckedUpdateManyWithoutFornitoreNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
      };
}

class FornitoreUpsertWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpsertWithoutProdottiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornitoreUpdateWithoutProdottiInput,
      _i2.FornitoreUncheckedUpdateWithoutProdottiInput> update;

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutProdottiInput,
      _i2.FornitoreUncheckedCreateWithoutProdottiInput> create;

  final _i2.FornitoreWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornitoreUpdateToOneWithWhereWithoutProdottiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateToOneWithWhereWithoutProdottiInput({
    this.where,
    required this.data,
  });

  final _i2.FornitoreWhereInput? where;

  final _i1.PrismaUnion<_i2.FornitoreUpdateWithoutProdottiInput,
      _i2.FornitoreUncheckedUpdateWithoutProdottiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornitoreUpdateOneRequiredWithoutProdottiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateOneRequiredWithoutProdottiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutProdottiInput,
      _i2.FornitoreUncheckedCreateWithoutProdottiInput>? create;

  final _i2.FornitoreCreateOrConnectWithoutProdottiInput? connectOrCreate;

  final _i2.FornitoreUpsertWithoutProdottiInput? upsert;

  final _i2.FornitoreWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornitoreUpdateToOneWithWhereWithoutProdottiInput,
      _i1.PrismaUnion<_i2.FornitoreUpdateWithoutProdottiInput,
          _i2.FornitoreUncheckedUpdateWithoutProdottiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ProdottoUpdateWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithoutProdottiOrdinatiInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttore,
    this.fornitore,
    this.tipoProdotto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i2.ProduttoreUpdateOneRequiredWithoutProdottiNestedInput? produttore;

  final _i2.FornitoreUpdateOneRequiredWithoutProdottiNestedInput? fornitore;

  final _i2.TipoProdottoUpdateOneRequiredWithoutProdottiNestedInput?
      tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoUpsertWithWhereUniqueWithoutProdottiOrdinatiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpsertWithWhereUniqueWithoutProdottiOrdinatiInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutProdottiOrdinatiInput,
      _i2.ProdottoUncheckedUpdateWithoutProdottiOrdinatiInput> update;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutProdottiOrdinatiInput,
      _i2.ProdottoUncheckedCreateWithoutProdottiOrdinatiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutProdottiOrdinatiInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutProdottiOrdinatiInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutProdottiOrdinatiInput,
                  Iterable<
                      _i2
                      .ProdottoUncheckedCreateWithoutProdottiOrdinatiInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProdottiOrdinatiInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProdottoUpsertWithWhereUniqueWithoutProdottiOrdinatiInput,
          Iterable<
              _i2.ProdottoUpsertWithWhereUniqueWithoutProdottiOrdinatiInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProdottoUpdateWithWhereUniqueWithoutProdottiOrdinatiInput,
          Iterable<
              _i2.ProdottoUpdateWithWhereUniqueWithoutProdottiOrdinatiInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ProdottoUpdateManyWithWhereWithoutProdottiOrdinatiInput,
          Iterable<
              _i2.ProdottoUpdateManyWithWhereWithoutProdottiOrdinatiInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class OrdineUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutSoggettoInput,
      _i2.OrdineUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutSoggettoInput,
      _i2.OrdineUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutSoggettoInput,
      Iterable<_i2.OrdineCreateOrConnectWithoutSoggettoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.OrdineCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutSoggettoInput,
      Iterable<_i2.OrdineUpdateManyWithWhereWithoutSoggettoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutNegozioPreferitoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithWhereUniqueWithoutNegozioPreferitoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithWhereUniqueWithoutNegozioPreferitoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutNegozioPreferitoInput,
      _i2.SoggettoUncheckedUpdateWithoutNegozioPreferitoInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutNegozioPreferitoInput,
      _i2.SoggettoUncheckedCreateWithoutNegozioPreferitoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class SoggettoUpdateManyWithoutNegozioPreferitoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateManyWithoutNegozioPreferitoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoCreateWithoutNegozioPreferitoInput,
          _i1.PrismaUnion<
              Iterable<_i2.SoggettoCreateWithoutNegozioPreferitoInput>,
              _i1.PrismaUnion<
                  _i2.SoggettoUncheckedCreateWithoutNegozioPreferitoInput,
                  Iterable<
                      _i2
                      .SoggettoUncheckedCreateWithoutNegozioPreferitoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput,
          Iterable<_i2.SoggettoCreateOrConnectWithoutNegozioPreferitoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.SoggettoUpsertWithWhereUniqueWithoutNegozioPreferitoInput,
          Iterable<
              _i2.SoggettoUpsertWithWhereUniqueWithoutNegozioPreferitoInput>>?
      upsert;

  final _i2.SoggettoCreateManyNegozioPreferitoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.SoggettoWhereUniqueInput,
      Iterable<_i2.SoggettoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.SoggettoUpdateWithWhereUniqueWithoutNegozioPreferitoInput,
          Iterable<
              _i2.SoggettoUpdateWithWhereUniqueWithoutNegozioPreferitoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.SoggettoUpdateManyWithWhereWithoutNegozioPreferitoInput,
          Iterable<
              _i2.SoggettoUpdateManyWithWhereWithoutNegozioPreferitoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.SoggettoScalarWhereInput,
      Iterable<_i2.SoggettoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutContrattiInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutContrattiInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutContrattiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutContrattiInput,
      _i2.NegozioUncheckedUpdateWithoutContrattiInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutContrattiInput,
      _i2.NegozioUncheckedCreateWithoutContrattiInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutContrattiInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutContrattiInput,
      _i2.NegozioUncheckedUpdateWithoutContrattiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneWithoutContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneWithoutContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutContrattiInput,
      _i2.NegozioUncheckedCreateWithoutContrattiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutContrattiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? delete;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutContrattiInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutContrattiInput,
          _i2.NegozioUncheckedUpdateWithoutContrattiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutUtenteInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUpsertWithWhereUniqueWithoutUtenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithWhereUniqueWithoutUtenteInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutUtenteInput,
      _i2.ContrattoUncheckedUpdateWithoutUtenteInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutUtenteInput,
      _i2.ContrattoUncheckedCreateWithoutUtenteInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoUpdateManyWithoutUtenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithoutUtenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutUtenteInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutUtenteInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutUtenteInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutUtenteInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutUtenteInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutUtenteInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutUtenteInput>>? upsert;

  final _i2.ContrattoCreateManyUtenteInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutUtenteInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutUtenteInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutUtenteInput,
      Iterable<_i2.ContrattoUpdateManyWithWhereWithoutUtenteInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class UtenteUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutNegozioInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.UtenteWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutNegozioInput,
      _i2.UtenteUncheckedUpdateWithoutNegozioInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutNegozioInput,
      _i2.UtenteUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class UtenteUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.UtenteCreateWithoutNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.UtenteCreateWithoutNegozioInput>,
          _i1.PrismaUnion<_i2.UtenteUncheckedCreateWithoutNegozioInput,
              Iterable<_i2.UtenteUncheckedCreateWithoutNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.UtenteCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.UtenteCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.UtenteUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.UtenteUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.UtenteCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.UtenteWhereUniqueInput,
      Iterable<_i2.UtenteWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.UtenteUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.UtenteUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.UtenteUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereInput,
      Iterable<_i2.UtenteScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUpdateWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutSoggettiInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutSoggettiInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutSoggettiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutSoggettiInput,
      _i2.NegozioUncheckedUpdateWithoutSoggettiInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutSoggettiInput,
      _i2.NegozioUncheckedCreateWithoutSoggettiInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutSoggettiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutSoggettiInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutSoggettiInput,
      _i2.NegozioUncheckedUpdateWithoutSoggettiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneWithoutSoggettiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneWithoutSoggettiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutSoggettiInput,
      _i2.NegozioUncheckedCreateWithoutSoggettiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutSoggettiInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutSoggettiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? delete;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutSoggettiInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutSoggettiInput,
          _i2.NegozioUncheckedUpdateWithoutSoggettiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoUpdateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutSoggettoBusinessInfoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutSoggettoBusinessInfoInput,
      _i2.SoggettoUncheckedUpdateWithoutSoggettoBusinessInfoInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutSoggettoBusinessInfoInput,
      _i2.SoggettoUncheckedCreateWithoutSoggettoBusinessInfoInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutSoggettoBusinessInfoInput,
      _i2.SoggettoUncheckedUpdateWithoutSoggettoBusinessInfoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneRequiredWithoutSoggettoBusinessInfoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneRequiredWithoutSoggettoBusinessInfoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutSoggettoBusinessInfoInput,
      _i2.SoggettoUncheckedCreateWithoutSoggettoBusinessInfoInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.SoggettoUpsertWithoutSoggettoBusinessInfoInput? upsert;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutSoggettoBusinessInfoInput,
          _i2.SoggettoUncheckedUpdateWithoutSoggettoBusinessInfoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class SoggettoBusinessInfoUpdateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateWithoutLegaleRappresentanteInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.referente,
    this.soggetto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i2.ReferenteUpdateOneWithoutSoggettoBusinessInfoNestedInput? referente;

  final _i2.SoggettoUpdateOneRequiredWithoutSoggettoBusinessInfoNestedInput?
      soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoUncheckedUpdateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedUpdateWithoutLegaleRappresentanteInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2.ReferenteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'referente': referente,
      };
}

class SoggettoBusinessInfoUpsertWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpsertWithoutLegaleRappresentanteInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoUpdateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedUpdateWithoutLegaleRappresentanteInput>
      update;

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoCreateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedCreateWithoutLegaleRappresentanteInput>
      create;

  final _i2.SoggettoBusinessInfoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoBusinessInfoUpdateToOneWithWhereWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateToOneWithWhereWithoutLegaleRappresentanteInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoBusinessInfoWhereInput? where;

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoUpdateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedUpdateWithoutLegaleRappresentanteInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoBusinessInfoUpdateOneRequiredWithoutLegaleRappresentanteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateOneRequiredWithoutLegaleRappresentanteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoCreateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedCreateWithoutLegaleRappresentanteInput>?
      create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutLegaleRappresentanteInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoUpsertWithoutLegaleRappresentanteInput? upsert;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2
      .SoggettoBusinessInfoUpdateToOneWithWhereWithoutLegaleRappresentanteInput,
      _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoUpdateWithoutLegaleRappresentanteInput,
          _i2
          .SoggettoBusinessInfoUncheckedUpdateWithoutLegaleRappresentanteInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class LegaleRappresentanteUpdateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateWithoutIndirizzoEmailInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUpdateOneWithoutLegaleRappresentateNestedInput?
      numeroTelefono;

  final _i2
      .SoggettoBusinessInfoUpdateOneRequiredWithoutLegaleRappresentanteNestedInput?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteUncheckedUpdateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedUpdateWithoutIndirizzoEmailInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  final _i2
      .NumeroTelefonoUncheckedUpdateOneWithoutLegaleRappresentateNestedInput?
      numeroTelefono;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
      };
}

class LegaleRappresentanteUpsertWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpsertWithoutIndirizzoEmailInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteUpdateWithoutIndirizzoEmailInput,
      _i2.LegaleRappresentanteUncheckedUpdateWithoutIndirizzoEmailInput> update;

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteCreateWithoutIndirizzoEmailInput,
      _i2.LegaleRappresentanteUncheckedCreateWithoutIndirizzoEmailInput> create;

  final _i2.LegaleRappresentanteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class LegaleRappresentanteUpdateToOneWithWhereWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateToOneWithWhereWithoutIndirizzoEmailInput({
    this.where,
    required this.data,
  });

  final _i2.LegaleRappresentanteWhereInput? where;

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteUpdateWithoutIndirizzoEmailInput,
      _i2.LegaleRappresentanteUncheckedUpdateWithoutIndirizzoEmailInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LegaleRappresentanteUpdateOneWithoutIndirizzoEmailNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateOneWithoutIndirizzoEmailNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutIndirizzoEmailInput,
          _i2.LegaleRappresentanteUncheckedCreateWithoutIndirizzoEmailInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutIndirizzoEmailInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteUpsertWithoutIndirizzoEmailInput? upsert;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? delete;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .LegaleRappresentanteUpdateToOneWithWhereWithoutIndirizzoEmailInput,
          _i1.PrismaUnion<
              _i2.LegaleRappresentanteUpdateWithoutIndirizzoEmailInput,
              _i2
              .LegaleRappresentanteUncheckedUpdateWithoutIndirizzoEmailInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class IndirizzoEmailUpdateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateWithoutReferenteInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggetto,
    this.legaleRappresentante,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.SoggettoUpdateOneWithoutIndirizziEmailNestedInput? soggetto;

  final _i2.LegaleRappresentanteUpdateOneWithoutIndirizzoEmailNestedInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailUpsertWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpsertWithoutReferenteInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailUpdateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedUpdateWithoutReferenteInput> update;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutReferenteInput> create;

  final _i2.IndirizzoEmailWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class IndirizzoEmailUpdateOneWithoutReferenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateOneWithoutReferenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutReferenteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutReferenteInput>? create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.IndirizzoEmailUpsertWithoutReferenteInput? upsert;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? delete;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpdateToOneWithWhereWithoutReferenteInput,
      _i1.PrismaUnion<_i2.IndirizzoEmailUpdateWithoutReferenteInput,
          _i2.IndirizzoEmailUncheckedUpdateWithoutReferenteInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoBusinessInfoUpdateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateWithoutReferenteInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.soggetto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i2.LegaleRappresentanteUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      legaleRappresentante;

  final _i2.SoggettoUpdateOneRequiredWithoutSoggettoBusinessInfoNestedInput?
      soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoUncheckedUpdateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedUpdateWithoutReferenteInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.legaleRappresentante,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .LegaleRappresentanteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
      };
}

class SoggettoBusinessInfoUpsertWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpsertWithoutReferenteInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutReferenteInput,
      _i2.SoggettoBusinessInfoUncheckedUpdateWithoutReferenteInput> update;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutReferenteInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutReferenteInput> create;

  final _i2.SoggettoBusinessInfoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoBusinessInfoUpdateToOneWithWhereWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateToOneWithWhereWithoutReferenteInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoBusinessInfoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutReferenteInput,
      _i2.SoggettoBusinessInfoUncheckedUpdateWithoutReferenteInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoBusinessInfoUpdateOneRequiredWithoutReferenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateOneRequiredWithoutReferenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutReferenteInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutReferenteInput>? create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutReferenteInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoUpsertWithoutReferenteInput? upsert;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.SoggettoBusinessInfoUpdateToOneWithWhereWithoutReferenteInput,
          _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutReferenteInput,
              _i2.SoggettoBusinessInfoUncheckedUpdateWithoutReferenteInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ReferenteUpdateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateWithoutNumeroTelefonoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.IndirizzoEmailUpdateOneWithoutReferenteNestedInput? indirizzoEmail;

  final _i2.SoggettoBusinessInfoUpdateOneRequiredWithoutReferenteNestedInput?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteUncheckedUpdateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedUpdateWithoutNumeroTelefonoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  final _i2.IndirizzoEmailUncheckedUpdateOneWithoutReferenteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'indirizzoEmail': indirizzoEmail,
      };
}

class ReferenteUpsertWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpsertWithoutNumeroTelefonoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ReferenteUpdateWithoutNumeroTelefonoInput,
      _i2.ReferenteUncheckedUpdateWithoutNumeroTelefonoInput> update;

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutNumeroTelefonoInput,
      _i2.ReferenteUncheckedCreateWithoutNumeroTelefonoInput> create;

  final _i2.ReferenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ReferenteUpdateToOneWithWhereWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateToOneWithWhereWithoutNumeroTelefonoInput({
    this.where,
    required this.data,
  });

  final _i2.ReferenteWhereInput? where;

  final _i1.PrismaUnion<_i2.ReferenteUpdateWithoutNumeroTelefonoInput,
      _i2.ReferenteUncheckedUpdateWithoutNumeroTelefonoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReferenteUpdateOneWithoutNumeroTelefonoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateOneWithoutNumeroTelefonoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutNumeroTelefonoInput,
      _i2.ReferenteUncheckedCreateWithoutNumeroTelefonoInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutNumeroTelefonoInput? connectOrCreate;

  final _i2.ReferenteUpsertWithoutNumeroTelefonoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? delete;

  final _i2.ReferenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ReferenteUpdateToOneWithWhereWithoutNumeroTelefonoInput,
      _i1.PrismaUnion<_i2.ReferenteUpdateWithoutNumeroTelefonoInput,
          _i2.ReferenteUncheckedUpdateWithoutNumeroTelefonoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class NumeroTelefonoUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateWithoutSoggettoInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.legaleRappresentate,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.LegaleRappresentanteUpdateOneWithoutNumeroTelefonoNestedInput?
      legaleRappresentate;

  final _i2.ReferenteUpdateOneWithoutNumeroTelefonoNestedInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class NumeroTelefonoUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.NumeroTelefonoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutSoggettoInput,
      _i2.NumeroTelefonoUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutSoggettoInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class NumeroTelefonoUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.NumeroTelefonoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.NumeroTelefonoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.NumeroTelefonoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.NumeroTelefonoUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.NumeroTelefonoUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.NumeroTelefonoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.NumeroTelefonoWhereUniqueInput,
      Iterable<_i2.NumeroTelefonoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.NumeroTelefonoUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.NumeroTelefonoUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.NumeroTelefonoUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalarWhereInput,
      Iterable<_i2.NumeroTelefonoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutIndirizziEmailInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutIndirizziEmailInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutIndirizziEmailInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutIndirizziEmailInput,
      _i2.SoggettoUncheckedUpdateWithoutIndirizziEmailInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutIndirizziEmailInput,
      _i2.SoggettoUncheckedCreateWithoutIndirizziEmailInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutIndirizziEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutIndirizziEmailInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutIndirizziEmailInput,
      _i2.SoggettoUncheckedUpdateWithoutIndirizziEmailInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneWithoutIndirizziEmailNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneWithoutIndirizziEmailNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutIndirizziEmailInput,
      _i2.SoggettoUncheckedCreateWithoutIndirizziEmailInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutIndirizziEmailInput? connectOrCreate;

  final _i2.SoggettoUpsertWithoutIndirizziEmailInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? delete;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutIndirizziEmailInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutIndirizziEmailInput,
          _i2.SoggettoUncheckedUpdateWithoutIndirizziEmailInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class IndirizzoEmailUpdateWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateWithoutLegaleRappresentanteInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggetto,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.SoggettoUpdateOneWithoutIndirizziEmailNestedInput? soggetto;

  final _i2.ReferenteUpdateOneWithoutIndirizzoEmailNestedInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'referente': referente,
      };
}

class IndirizzoEmailUpsertWithoutLegaleRappresentanteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpsertWithoutLegaleRappresentanteInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpdateWithoutLegaleRappresentanteInput,
      _i2.IndirizzoEmailUncheckedUpdateWithoutLegaleRappresentanteInput> update;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailCreateWithoutLegaleRappresentanteInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput> create;

  final _i2.IndirizzoEmailWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class IndirizzoEmailUpdateOneWithoutLegaleRappresentanteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateOneWithoutLegaleRappresentanteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutLegaleRappresentanteInput,
          _i2.IndirizzoEmailUncheckedCreateWithoutLegaleRappresentanteInput>?
      create;

  final _i2.IndirizzoEmailCreateOrConnectWithoutLegaleRappresentanteInput?
      connectOrCreate;

  final _i2.IndirizzoEmailUpsertWithoutLegaleRappresentanteInput? upsert;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailWhereInput>? delete;

  final _i2.IndirizzoEmailWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .IndirizzoEmailUpdateToOneWithWhereWithoutLegaleRappresentanteInput,
          _i1.PrismaUnion<
              _i2.IndirizzoEmailUpdateWithoutLegaleRappresentanteInput,
              _i2
              .IndirizzoEmailUncheckedUpdateWithoutLegaleRappresentanteInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class LegaleRappresentanteUpdateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateWithoutNumeroTelefonoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.IndirizzoEmailUpdateOneWithoutLegaleRappresentanteNestedInput?
      indirizzoEmail;

  final _i2
      .SoggettoBusinessInfoUpdateOneRequiredWithoutLegaleRappresentanteNestedInput?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteUncheckedUpdateWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedUpdateWithoutNumeroTelefonoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  final _i2
      .IndirizzoEmailUncheckedUpdateOneWithoutLegaleRappresentanteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteUpsertWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpsertWithoutNumeroTelefonoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteUpdateWithoutNumeroTelefonoInput,
      _i2.LegaleRappresentanteUncheckedUpdateWithoutNumeroTelefonoInput> update;

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteCreateWithoutNumeroTelefonoInput,
      _i2.LegaleRappresentanteUncheckedCreateWithoutNumeroTelefonoInput> create;

  final _i2.LegaleRappresentanteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class LegaleRappresentanteUpdateToOneWithWhereWithoutNumeroTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateToOneWithWhereWithoutNumeroTelefonoInput({
    this.where,
    required this.data,
  });

  final _i2.LegaleRappresentanteWhereInput? where;

  final _i1.PrismaUnion<
      _i2.LegaleRappresentanteUpdateWithoutNumeroTelefonoInput,
      _i2.LegaleRappresentanteUncheckedUpdateWithoutNumeroTelefonoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LegaleRappresentanteUpdateOneWithoutNumeroTelefonoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateOneWithoutNumeroTelefonoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutNumeroTelefonoInput,
          _i2.LegaleRappresentanteUncheckedCreateWithoutNumeroTelefonoInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutNumeroTelefonoInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteUpsertWithoutNumeroTelefonoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? delete;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .LegaleRappresentanteUpdateToOneWithWhereWithoutNumeroTelefonoInput,
          _i1.PrismaUnion<
              _i2.LegaleRappresentanteUpdateWithoutNumeroTelefonoInput,
              _i2
              .LegaleRappresentanteUncheckedUpdateWithoutNumeroTelefonoInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class NumeroTelefonoUpdateWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateWithoutReferenteInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggetto,
    this.legaleRappresentate,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.SoggettoUpdateOneWithoutNumeriTelefonoNestedInput? soggetto;

  final _i2.LegaleRappresentanteUpdateOneWithoutNumeroTelefonoNestedInput?
      legaleRappresentate;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
      };
}

class NumeroTelefonoUpsertWithoutReferenteInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpsertWithoutReferenteInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedUpdateWithoutReferenteInput> update;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutReferenteInput> create;

  final _i2.NumeroTelefonoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NumeroTelefonoUpdateOneWithoutReferenteNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateOneWithoutReferenteNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutReferenteInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutReferenteInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutReferenteInput? connectOrCreate;

  final _i2.NumeroTelefonoUpsertWithoutReferenteInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? delete;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NumeroTelefonoUpdateToOneWithWhereWithoutReferenteInput,
      _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutReferenteInput,
          _i2.NumeroTelefonoUncheckedUpdateWithoutReferenteInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ReferenteUpdateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateWithoutIndirizzoEmailInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUpdateOneWithoutReferenteNestedInput? numeroTelefono;

  final _i2.SoggettoBusinessInfoUpdateOneRequiredWithoutReferenteNestedInput?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteUncheckedUpdateWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedUpdateWithoutIndirizzoEmailInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  final _i2.NumeroTelefonoUncheckedUpdateOneWithoutReferenteNestedInput?
      numeroTelefono;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
      };
}

class ReferenteUpsertWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpsertWithoutIndirizzoEmailInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ReferenteUpdateWithoutIndirizzoEmailInput,
      _i2.ReferenteUncheckedUpdateWithoutIndirizzoEmailInput> update;

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutIndirizzoEmailInput,
      _i2.ReferenteUncheckedCreateWithoutIndirizzoEmailInput> create;

  final _i2.ReferenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ReferenteUpdateToOneWithWhereWithoutIndirizzoEmailInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateToOneWithWhereWithoutIndirizzoEmailInput({
    this.where,
    required this.data,
  });

  final _i2.ReferenteWhereInput? where;

  final _i1.PrismaUnion<_i2.ReferenteUpdateWithoutIndirizzoEmailInput,
      _i2.ReferenteUncheckedUpdateWithoutIndirizzoEmailInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ReferenteUpdateOneWithoutIndirizzoEmailNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateOneWithoutIndirizzoEmailNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ReferenteCreateWithoutIndirizzoEmailInput,
      _i2.ReferenteUncheckedCreateWithoutIndirizzoEmailInput>? create;

  final _i2.ReferenteCreateOrConnectWithoutIndirizzoEmailInput? connectOrCreate;

  final _i2.ReferenteUpsertWithoutIndirizzoEmailInput? upsert;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.ReferenteWhereInput>? delete;

  final _i2.ReferenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ReferenteUpdateToOneWithWhereWithoutIndirizzoEmailInput,
      _i1.PrismaUnion<_i2.ReferenteUpdateWithoutIndirizzoEmailInput,
          _i2.ReferenteUncheckedUpdateWithoutIndirizzoEmailInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class IndirizzoEmailUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateWithoutSoggettoInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.referente,
    this.legaleRappresentante,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.ReferenteUpdateOneWithoutIndirizzoEmailNestedInput? referente;

  final _i2.LegaleRappresentanteUpdateOneWithoutIndirizzoEmailNestedInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.IndirizzoEmailWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.IndirizzoEmailUpdateWithoutSoggettoInput,
      _i2.IndirizzoEmailUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateWithoutSoggettoInput,
      _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class IndirizzoEmailUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.IndirizzoEmailCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<
                  _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput,
                  Iterable<
                      _i2.IndirizzoEmailUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.IndirizzoEmailCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.IndirizzoEmailUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.IndirizzoEmailCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.IndirizzoEmailWhereUniqueInput,
      Iterable<_i2.IndirizzoEmailWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.IndirizzoEmailUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<
          _i2.IndirizzoEmailUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<
          _i2.IndirizzoEmailUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.IndirizzoEmailUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalarWhereInput,
      Iterable<_i2.IndirizzoEmailScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutContrattiInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutContrattiInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutContrattiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutContrattiInput,
      _i2.SoggettoUncheckedUpdateWithoutContrattiInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutContrattiInput,
      _i2.SoggettoUncheckedCreateWithoutContrattiInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutContrattiInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutContrattiInput,
      _i2.SoggettoUncheckedUpdateWithoutContrattiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneWithoutContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneWithoutContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutContrattiInput,
      _i2.SoggettoUncheckedCreateWithoutContrattiInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.SoggettoUpsertWithoutContrattiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? delete;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutContrattiInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutContrattiInput,
          _i2.SoggettoUncheckedUpdateWithoutContrattiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
      };
}

class ContrattoUpsertWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithoutContrattiEnelXAssicurazioneInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoUpdateWithoutContrattiEnelXAssicurazioneInput,
          _i2.ContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.ContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>
      create;

  final _i2.ContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ContrattoUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput({
    this.where,
    required this.data,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<
      _i2.ContrattoUpdateWithoutContrattiEnelXAssicurazioneInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.ContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.ContrattoUpsertWithoutContrattiEnelXAssicurazioneInput? upsert;

  final _i2.ContrattoWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput,
          _i1.PrismaUnion<
              _i2.ContrattoUpdateWithoutContrattiEnelXAssicurazioneInput,
              _i2
              .ContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OffertaUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpsertWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithoutContrattiEnelXAssicurazioneInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
      _i2.OffertaUpdateWithoutContrattiEnelXAssicurazioneInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput> update;

  final _i1.PrismaUnion<
      _i2.OffertaCreateWithoutContrattiEnelXAssicurazioneInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelXAssicurazioneInput> create;

  final _i2.OffertaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OffertaUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput({
    this.where,
    required this.data,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<
      _i2.OffertaUpdateWithoutContrattiEnelXAssicurazioneInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUpdateOneWithoutContrattiEnelXAssicurazioneNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateOneWithoutContrattiEnelXAssicurazioneNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.OffertaCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.OffertaUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.OffertaUpsertWithoutContrattiEnelXAssicurazioneInput? upsert;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? delete;

  final _i2.OffertaWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .OffertaUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput,
          _i1.PrismaUnion<
              _i2.OffertaUpdateWithoutContrattiEnelXAssicurazioneInput,
              _i2
              .OffertaUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithoutStatoInput({
    this.uuid,
    this.contratto,
    this.domicilio,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2
      .ContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      contratto;

  final _i2
      .DomicilioUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      domicilio;

  final _i2.OffertaUpdateOneWithoutContrattiEnelXAssicurazioneNestedInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneUpdateWithoutStatoInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutStatoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput,
      _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelXAssicurazioneCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutStatoInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutStatoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutStatoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithoutContrattiInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutStatoNestedInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ServizioEwoUncheckedUpdateWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutStatiPossibiliContrattiInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliContrattiInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ServizioEwoUpdateWithoutStatiPossibiliContrattiInput,
      _i2.ServizioEwoUncheckedUpdateWithoutStatiPossibiliContrattiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliContrattiInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyMutationInput,
          _i2.ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliContrattiInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliContrattiInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliContrattiInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUncheckedUpdateWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateWithoutContrattiInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUpsertWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpsertWithoutContrattiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiInput> update;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiInput> create;

  final _i2.StatoContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoContrattoUpdateToOneWithWhereWithoutContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateToOneWithWhereWithoutContrattiInput({
    this.where,
    required this.data,
  });

  final _i2.StatoContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiInput? connectOrCreate;

  final _i2.StatoContrattoUpsertWithoutContrattiInput? upsert;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.StatoContrattoUpdateToOneWithWhereWithoutContrattiInput,
      _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiInput,
          _i2.StatoContrattoUncheckedUpdateWithoutContrattiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutContrattiEnelGasInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutContrattiEnelGasInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpsertWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithoutContrattiEnelGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelGasInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelGasInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelGasInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelGasInput> create;

  final _i2.ContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ContrattoUpdateToOneWithWhereWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateToOneWithWhereWithoutContrattiEnelGasInput({
    this.where,
    required this.data,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelGasInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelGasInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelGasInput?
      connectOrCreate;

  final _i2.ContrattoUpsertWithoutContrattiEnelGasInput? upsert;

  final _i2.ContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ContrattoUpdateToOneWithWhereWithoutContrattiEnelGasInput,
      _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelGasInput,
          _i2.ContrattoUncheckedUpdateWithoutContrattiEnelGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OffertaUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutContrattiEnelGasInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutContrattiEnelGasInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpsertWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithoutContrattiEnelGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelGasInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelGasInput> update;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelGasInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelGasInput> create;

  final _i2.OffertaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OffertaUpdateToOneWithWhereWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateToOneWithWhereWithoutContrattiEnelGasInput({
    this.where,
    required this.data,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelGasInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUpdateOneWithoutContrattiEnelGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateOneWithoutContrattiEnelGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelGasInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelGasInput? connectOrCreate;

  final _i2.OffertaUpsertWithoutContrattiEnelGasInput? upsert;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? delete;

  final _i2.OffertaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.OffertaUpdateToOneWithWhereWithoutContrattiEnelGasInput,
      _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelGasInput,
          _i2.OffertaUncheckedUpdateWithoutContrattiEnelGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelGasUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithoutFornituraGasInput({
    this.uuid,
    this.stato,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      stato;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelGasNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasUpsertWithWhereUniqueWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpsertWithWhereUniqueWithoutFornituraGasInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutFornituraGasInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutFornituraGasInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutFornituraGasInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelGasUpdateManyWithoutFornituraGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithoutFornituraGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutFornituraGasInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutFornituraGasInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutFornituraGasInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput,
          Iterable<
              _i2.ContrattoEnelGasCreateOrConnectWithoutFornituraGasInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutFornituraGasInput,
          Iterable<
              _i2
              .ContrattoEnelGasUpsertWithWhereUniqueWithoutFornituraGasInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyFornituraGasInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutFornituraGasInput,
          Iterable<
              _i2
              .ContrattoEnelGasUpdateWithWhereUniqueWithoutFornituraGasInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutFornituraGasInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateManyWithWhereWithoutFornituraGasInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornituraGasUpdateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateWithoutFornituraInput({
    this.uuid,
    this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ClasseMisuratoreGasUpdateOneWithoutFornituraGasNestedInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasUpsertWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpsertWithoutFornituraInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutFornituraInput,
      _i2.FornituraGasUncheckedUpdateWithoutFornituraInput> update;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutFornituraInput,
      _i2.FornituraGasUncheckedCreateWithoutFornituraInput> create;

  final _i2.FornituraGasWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraGasUpdateOneWithoutFornituraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateOneWithoutFornituraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutFornituraInput,
      _i2.FornituraGasUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraGasUpsertWithoutFornituraInput? upsert;

  final _i1.PrismaUnion<bool, _i2.FornituraGasWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.FornituraGasWhereInput>? delete;

  final _i2.FornituraGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraGasUpdateToOneWithWhereWithoutFornituraInput,
      _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutFornituraInput,
          _i2.FornituraGasUncheckedUpdateWithoutFornituraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class FornituraUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateWithoutDomicilioInput({
    this.uuid,
    this.etichetta,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutFornitureNestedInput?
      servizioEwo;

  final _i2.FornituraLuceUpdateOneWithoutFornituraNestedInput? fornituraLuce;

  final _i2.FornituraGasUpdateOneWithoutFornituraNestedInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUpsertWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpsertWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutDomicilioInput,
      _i2.FornituraUncheckedUpdateWithoutDomicilioInput> update;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutDomicilioInput,
      _i2.FornituraUncheckedCreateWithoutDomicilioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class FornituraUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.FornituraCreateWithoutDomicilioInput,
      _i1.PrismaUnion<
          Iterable<_i2.FornituraCreateWithoutDomicilioInput>,
          _i1.PrismaUnion<
              _i2.FornituraUncheckedCreateWithoutDomicilioInput,
              Iterable<
                  _i2.FornituraUncheckedCreateWithoutDomicilioInput>>>>? create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutDomicilioInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.FornituraUpsertWithWhereUniqueWithoutDomicilioInput,
          Iterable<_i2.FornituraUpsertWithWhereUniqueWithoutDomicilioInput>>?
      upsert;

  final _i2.FornituraCreateManyDomicilioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithWhereUniqueWithoutDomicilioInput,
          Iterable<_i2.FornituraUpdateWithWhereUniqueWithoutDomicilioInput>>?
      update;

  final _i1.PrismaUnion<_i2.FornituraUpdateManyWithWhereWithoutDomicilioInput,
          Iterable<_i2.FornituraUpdateManyWithWhereWithoutDomicilioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.FornituraScalarWhereInput,
      Iterable<_i2.FornituraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggetto,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.SoggettoUpdateOneRequiredWithoutDomiciliNestedInput? soggetto;

  final _i2.FornituraUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUpdateManyWithoutDomicilioNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2.FornituraUncheckedUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedUpdateManyWithoutDomicilioNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUpsertWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpsertWithoutContrattiEnelXAssicurazioneInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioUpdateWithoutContrattiEnelXAssicurazioneInput,
          _i2.DomicilioUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>
      update;

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.DomicilioUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>
      create;

  final _i2.DomicilioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class DomicilioUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput({
    this.where,
    required this.data,
  });

  final _i2.DomicilioWhereInput? where;

  final _i1.PrismaUnion<
      _i2.DomicilioUpdateWithoutContrattiEnelXAssicurazioneInput,
      _i2.DomicilioUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2.DomicilioUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2.DomicilioCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.DomicilioUpsertWithoutContrattiEnelXAssicurazioneInput? upsert;

  final _i2.DomicilioWhereUniqueInput? connect;

  final _i1
      .PrismaUnion<
          _i2
          .DomicilioUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput,
          _i1.PrismaUnion<
              _i2.DomicilioUpdateWithoutContrattiEnelXAssicurazioneInput,
              _i2
              .DomicilioUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithoutContrattoInput({
    this.uuid,
    this.stato,
    this.domicilio,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2
      .StatoContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      stato;

  final _i2
      .DomicilioUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      domicilio;

  final _i2.OffertaUpdateOneWithoutContrattiEnelXAssicurazioneNestedInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateWithoutContrattoInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutContrattoInput>
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyContrattoInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutContrattiEnelFibraInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpsertWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithoutContrattiEnelFibraInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelFibraInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelFibraInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelFibraInput> create;

  final _i2.ContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ContrattoUpdateToOneWithWhereWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateToOneWithWhereWithoutContrattiEnelFibraInput({
    this.where,
    required this.data,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelFibraInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelFibraInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.ContrattoUpsertWithoutContrattiEnelFibraInput? upsert;

  final _i2.ContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ContrattoUpdateToOneWithWhereWithoutContrattiEnelFibraInput,
      _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelFibraInput,
          _i2.ContrattoUncheckedUpdateWithoutContrattiEnelFibraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelFibraUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithoutStatoInput({
    this.uuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.contratto,
    this.offerta,
    this.domicilio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelFibraNestedInput? offerta;

  final _i2.DomicilioUpdateOneWithoutContrattiEnelFibraNestedInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraUpsertWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpsertWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutStatoInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutStatoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutStatoInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelFibraUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutStatoInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutStatoInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutStatoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutStatoInput,
          Iterable<_i2.ContrattoEnelFibraUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.contratti,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ContrattoEnelLuceUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutStatoNestedInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUpsertWithWhereUniqueWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpsertWithWhereUniqueWithoutServiziEwoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.StatoContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutServiziEwoInput,
      _i2.StatoContrattoUncheckedUpdateWithoutServiziEwoInput> update;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutServiziEwoInput,
      _i2.StatoContrattoUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class StatoContrattoUpdateManyWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateManyWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoContrattoCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoContrattoUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2
                      .StatoContrattoUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoContrattoCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpsertWithWhereUniqueWithoutServiziEwoInput,
          Iterable<
              _i2.StatoContrattoUpsertWithWhereUniqueWithoutServiziEwoInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.StatoContrattoWhereUniqueInput,
      Iterable<_i2.StatoContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateWithWhereUniqueWithoutServiziEwoInput,
          Iterable<
              _i2.StatoContrattoUpdateWithWhereUniqueWithoutServiziEwoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateManyWithWhereWithoutServiziEwoInput,
          Iterable<
              _i2.StatoContrattoUpdateManyWithWhereWithoutServiziEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.StatoContrattoScalarWhereInput,
      Iterable<_i2.StatoContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUpdateWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutStatiPossibiliPraticheInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedUpdateWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutStatiPossibiliPraticheInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliPraticheInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutStatiPossibiliPraticheInput,
      _i2.ServizioEwoUncheckedUpdateWithoutStatiPossibiliPraticheInput> update;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput,
      _i2.ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliPraticheInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutStatiPossibiliPraticheInput,
      _i2.ServizioEwoUncheckedUpdateWithoutStatiPossibiliPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliPraticheInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyMutationInput,
          _i2.ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUpdateManyWithoutStatiPossibiliPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithoutStatiPossibiliPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliPraticheInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliPraticheInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliPraticheInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoPraticaUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateWithoutPraticheInput({
    this.id,
    this.nome,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliPraticheNestedInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutStatiPossibiliPraticheInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliPraticheInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliPraticheInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliPraticheInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliPraticheInput,
          Iterable<
              _i2
              .ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliPraticheInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoPraticaUncheckedUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedUpdateWithoutPraticheInput({
    this.id,
    this.nome,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheNestedInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaUpsertWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpsertWithoutPraticheInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaUpdateWithoutPraticheInput,
      _i2.StatoPraticaUncheckedUpdateWithoutPraticheInput> update;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateWithoutPraticheInput,
      _i2.StatoPraticaUncheckedCreateWithoutPraticheInput> create;

  final _i2.StatoPraticaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoPraticaUpdateToOneWithWhereWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateToOneWithWhereWithoutPraticheInput({
    this.where,
    required this.data,
  });

  final _i2.StatoPraticaWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoPraticaUpdateWithoutPraticheInput,
      _i2.StatoPraticaUncheckedUpdateWithoutPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoPraticaUpdateOneWithoutPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateOneWithoutPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaCreateWithoutPraticheInput,
      _i2.StatoPraticaUncheckedCreateWithoutPraticheInput>? create;

  final _i2.StatoPraticaCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.StatoPraticaUpsertWithoutPraticheInput? upsert;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaWhereInput>? delete;

  final _i2.StatoPraticaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.StatoPraticaUpdateToOneWithWhereWithoutPraticheInput,
      _i1.PrismaUnion<_i2.StatoPraticaUpdateWithoutPraticheInput,
          _i2.StatoPraticaUncheckedUpdateWithoutPraticheInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class PraticaUpdateWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithoutNegozioInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.stato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput? tipoPratica;

  final _i2.SoggettoUpdateOneWithoutPraticheIntestateNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutPraticheNestedInput? utente;

  final _i2.StatoPraticaUpdateOneWithoutPraticheNestedInput? stato;

  final _i2.ContrattoUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaUpsertWithWhereUniqueWithoutNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpsertWithWhereUniqueWithoutNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutNegozioInput,
      _i2.PraticaUncheckedUpdateWithoutNegozioInput> update;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutNegozioInput,
      _i2.PraticaUncheckedCreateWithoutNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class PraticaUpdateManyWithoutNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithoutNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutNegozioInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutNegozioInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutNegozioInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutNegozioInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutNegozioInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutNegozioInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutNegozioInput>>? upsert;

  final _i2.PraticaCreateManyNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutNegozioInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutNegozioInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutNegozioInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutNegozioInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class NegozioUpdateWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutUtentiInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutUtentiInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithoutUtentiInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutUtentiInput,
      _i2.NegozioUncheckedUpdateWithoutUtentiInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutUtentiInput,
      _i2.NegozioUncheckedCreateWithoutUtentiInput> create;

  final _i2.NegozioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NegozioUpdateToOneWithWhereWithoutUtentiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateToOneWithWhereWithoutUtentiInput({
    this.where,
    required this.data,
  });

  final _i2.NegozioWhereInput? where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutUtentiInput,
      _i2.NegozioUncheckedUpdateWithoutUtentiInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateOneWithoutUtentiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateOneWithoutUtentiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutUtentiInput,
      _i2.NegozioUncheckedCreateWithoutUtentiInput>? create;

  final _i2.NegozioCreateOrConnectWithoutUtentiInput? connectOrCreate;

  final _i2.NegozioUpsertWithoutUtentiInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NegozioWhereInput>? delete;

  final _i2.NegozioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.NegozioUpdateToOneWithWhereWithoutUtentiInput,
      _i1.PrismaUnion<_i2.NegozioUpdateWithoutUtentiInput,
          _i2.NegozioUncheckedUpdateWithoutUtentiInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class UtenteUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateWithoutPraticheInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateWithoutPraticheInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUpsertWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpsertWithoutPraticheInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutPraticheInput,
      _i2.UtenteUncheckedUpdateWithoutPraticheInput> update;

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutPraticheInput,
      _i2.UtenteUncheckedCreateWithoutPraticheInput> create;

  final _i2.UtenteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class UtenteUpdateToOneWithWhereWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateToOneWithWhereWithoutPraticheInput({
    this.where,
    required this.data,
  });

  final _i2.UtenteWhereInput? where;

  final _i1.PrismaUnion<_i2.UtenteUpdateWithoutPraticheInput,
      _i2.UtenteUncheckedUpdateWithoutPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class UtenteUpdateOneWithoutPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateOneWithoutPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.UtenteCreateWithoutPraticheInput,
      _i2.UtenteUncheckedCreateWithoutPraticheInput>? create;

  final _i2.UtenteCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.UtenteUpsertWithoutPraticheInput? upsert;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.UtenteWhereInput>? delete;

  final _i2.UtenteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.UtenteUpdateToOneWithWhereWithoutPraticheInput,
      _i1.PrismaUnion<_i2.UtenteUpdateWithoutPraticheInput,
          _i2.UtenteUncheckedUpdateWithoutPraticheInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class PraticaUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithoutStatoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput? tipoPratica;

  final _i2.SoggettoUpdateOneWithoutPraticheIntestateNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutPraticheNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutPraticheNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'contratto': contratto,
      };
}

class PraticaUpsertWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpsertWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutStatoInput,
      _i2.PraticaUncheckedUpdateWithoutStatoInput> update;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutStatoInput,
      _i2.PraticaUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class PraticaUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutStatoInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutStatoInput>,
          _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutStatoInput,
              Iterable<_i2.PraticaUncheckedCreateWithoutStatoInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutStatoInput,
      Iterable<_i2.PraticaCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutStatoInput>>? upsert;

  final _i2.PraticaCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutStatoInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutStatoInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutStatoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoPraticaUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.pratiche,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutStatoNestedInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class StatoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.StatoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.StatoPraticaUpdateWithoutServiziEwoInput,
      _i2.StatoPraticaUncheckedUpdateWithoutServiziEwoInput> update;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateWithoutServiziEwoInput,
      _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class StatoPraticaUpdateManyWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateManyWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.StatoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.StatoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.StatoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.StatoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.StatoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput,
      Iterable<
          _i2.StatoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput>>? upsert;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.StatoPraticaWhereUniqueInput,
      Iterable<_i2.StatoPraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.StatoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput,
      Iterable<
          _i2.StatoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput>>? update;

  final _i1.PrismaUnion<
          _i2.StatoPraticaUpdateManyWithWhereWithoutServiziEwoInput,
          Iterable<_i2.StatoPraticaUpdateManyWithWhereWithoutServiziEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.StatoPraticaScalarWhereInput,
      Iterable<_i2.StatoPraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUpdateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutFornitureInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedUpdateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutFornitureInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpsertWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithoutFornitureInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutFornitureInput,
      _i2.ServizioEwoUncheckedUpdateWithoutFornitureInput> update;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutFornitureInput,
      _i2.ServizioEwoUncheckedCreateWithoutFornitureInput> create;

  final _i2.ServizioEwoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ServizioEwoUpdateToOneWithWhereWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateToOneWithWhereWithoutFornitureInput({
    this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereInput? where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutFornitureInput,
      _i2.ServizioEwoUncheckedUpdateWithoutFornitureInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUpdateOneRequiredWithoutFornitureNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateOneRequiredWithoutFornitureNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutFornitureInput,
      _i2.ServizioEwoUncheckedCreateWithoutFornitureInput>? create;

  final _i2.ServizioEwoCreateOrConnectWithoutFornitureInput? connectOrCreate;

  final _i2.ServizioEwoUpsertWithoutFornitureInput? upsert;

  final _i2.ServizioEwoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ServizioEwoUpdateToOneWithWhereWithoutFornitureInput,
      _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutFornitureInput,
          _i2.ServizioEwoUncheckedUpdateWithoutFornitureInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class FornituraUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateWithoutFornituraGasInput({
    this.uuid,
    this.etichetta,
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.DomicilioUpdateOneRequiredWithoutFornitureNestedInput? domicilio;

  final _i2.ServizioEwoUpdateOneRequiredWithoutFornitureNestedInput?
      servizioEwo;

  final _i2.FornituraLuceUpdateOneWithoutFornituraNestedInput? fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
      };
}

class FornituraUncheckedUpdateWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateWithoutFornituraGasInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.fornituraLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.FornituraLuceUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'fornituraLuce': fornituraLuce,
      };
}

class FornituraUpsertWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpsertWithoutFornituraGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutFornituraGasInput,
      _i2.FornituraUncheckedUpdateWithoutFornituraGasInput> update;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraGasInput,
      _i2.FornituraUncheckedCreateWithoutFornituraGasInput> create;

  final _i2.FornituraWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraUpdateToOneWithWhereWithoutFornituraGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateToOneWithWhereWithoutFornituraGasInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutFornituraGasInput,
      _i2.FornituraUncheckedUpdateWithoutFornituraGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraUpdateOneRequiredWithoutFornituraGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateOneRequiredWithoutFornituraGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraGasInput,
      _i2.FornituraUncheckedCreateWithoutFornituraGasInput>? create;

  final _i2.FornituraCreateOrConnectWithoutFornituraGasInput? connectOrCreate;

  final _i2.FornituraUpsertWithoutFornituraGasInput? upsert;

  final _i2.FornituraWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraUpdateToOneWithWhereWithoutFornituraGasInput,
      _i1.PrismaUnion<_i2.FornituraUpdateWithoutFornituraGasInput,
          _i2.FornituraUncheckedUpdateWithoutFornituraGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class FornituraGasUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateWithoutContrattiEnelGasInput({
    this.uuid,
    this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ClasseMisuratoreGasUpdateOneWithoutFornituraGasNestedInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraGasNestedInput? fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateWithoutContrattiEnelGasInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ConsumoAnnuoGasUncheckedUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
      };
}

class FornituraGasUpsertWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpsertWithoutContrattiEnelGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutContrattiEnelGasInput,
      _i2.FornituraGasUncheckedUpdateWithoutContrattiEnelGasInput> update;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutContrattiEnelGasInput,
      _i2.FornituraGasUncheckedCreateWithoutContrattiEnelGasInput> create;

  final _i2.FornituraGasWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraGasUpdateToOneWithWhereWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateToOneWithWhereWithoutContrattiEnelGasInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraGasWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutContrattiEnelGasInput,
      _i2.FornituraGasUncheckedUpdateWithoutContrattiEnelGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraGasUpdateOneRequiredWithoutContrattiEnelGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateOneRequiredWithoutContrattiEnelGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutContrattiEnelGasInput,
      _i2.FornituraGasUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutContrattiEnelGasInput?
      connectOrCreate;

  final _i2.FornituraGasUpsertWithoutContrattiEnelGasInput? upsert;

  final _i2.FornituraGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraGasUpdateToOneWithWhereWithoutContrattiEnelGasInput,
      _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutContrattiEnelGasInput,
          _i2.FornituraGasUncheckedUpdateWithoutContrattiEnelGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelGasUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithoutStatoInput({
    this.uuid,
    this.fornituraGas,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.FornituraGasUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      fornituraGas;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelGasNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasUpsertWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpsertWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutStatoInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutStatoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutStatoInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelGasUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelGasUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutStatoInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutStatoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutStatoInput,
          Iterable<_i2.ContrattoEnelGasUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithoutContrattiEnelFibraInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutStatoNestedInput? contrattiEnelGas;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedUpdateWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateWithoutContrattiEnelFibraInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUncheckedUpdateManyWithoutStatoNestedInput? contratti;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelGas;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUpsertWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpsertWithoutContrattiEnelFibraInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelFibraInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelFibraInput> update;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelFibraInput> create;

  final _i2.StatoContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelFibraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelFibraInput({
    this.where,
    required this.data,
  });

  final _i2.StatoContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelFibraInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelFibraInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelFibraInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelFibraInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiEnelFibraInput?
      connectOrCreate;

  final _i2.StatoContrattoUpsertWithoutContrattiEnelFibraInput? upsert;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelFibraInput,
          _i1.PrismaUnion<
              _i2.StatoContrattoUpdateWithoutContrattiEnelFibraInput,
              _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelFibraInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelFibraUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateWithoutContrattoInput({
    this.uuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.stato,
    this.offerta,
    this.domicilio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      stato;

  final _i2.OffertaUpdateOneWithoutContrattiEnelFibraNestedInput? offerta;

  final _i2.DomicilioUpdateOneWithoutContrattiEnelFibraNestedInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraUpsertWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpsertWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelFibraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraUpdateWithoutContrattoInput,
      _i2.ContrattoEnelFibraUncheckedUpdateWithoutContrattoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraCreateWithoutContrattoInput,
      _i2.ContrattoEnelFibraUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelFibraCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelFibraUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelFibraUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelFibraCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelFibraCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraWhereUniqueInput,
      Iterable<_i2.ContrattoEnelFibraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2
              .ContrattoEnelFibraUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelFibraUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutContrattiEnelLuceInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateWithoutContrattiEnelLuceInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUpsertWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithoutContrattiEnelLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelLuceInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelLuceInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelLuceInput> create;

  final _i2.ContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class ContrattoUpdateToOneWithWhereWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateToOneWithWhereWithoutContrattiEnelLuceInput({
    this.where,
    required this.data,
  });

  final _i2.ContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelLuceInput,
      _i2.ContrattoUncheckedUpdateWithoutContrattiEnelLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.ContrattoUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.ContrattoCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.ContrattoUpsertWithoutContrattiEnelLuceInput? upsert;

  final _i2.ContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.ContrattoUpdateToOneWithWhereWithoutContrattiEnelLuceInput,
      _i1.PrismaUnion<_i2.ContrattoUpdateWithoutContrattiEnelLuceInput,
          _i2.ContrattoUncheckedUpdateWithoutContrattiEnelLuceInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class OffertaUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateWithoutContrattiEnelLuceInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateWithoutContrattiEnelLuceInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUpsertWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpsertWithoutContrattiEnelLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelLuceInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelLuceInput> update;

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelLuceInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelLuceInput> create;

  final _i2.OffertaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class OffertaUpdateToOneWithWhereWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateToOneWithWhereWithoutContrattiEnelLuceInput({
    this.where,
    required this.data,
  });

  final _i2.OffertaWhereInput? where;

  final _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelLuceInput,
      _i2.OffertaUncheckedUpdateWithoutContrattiEnelLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OffertaUpdateOneWithoutContrattiEnelLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateOneWithoutContrattiEnelLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.OffertaCreateWithoutContrattiEnelLuceInput,
      _i2.OffertaUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.OffertaCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.OffertaUpsertWithoutContrattiEnelLuceInput? upsert;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.OffertaWhereInput>? delete;

  final _i2.OffertaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.OffertaUpdateToOneWithWhereWithoutContrattiEnelLuceInput,
      _i1.PrismaUnion<_i2.OffertaUpdateWithoutContrattiEnelLuceInput,
          _i2.OffertaUncheckedUpdateWithoutContrattiEnelLuceInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelLuceUpdateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithoutFornituraLuceInput({
    this.uuid,
    this.stato,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      stato;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelLuceNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceUpsertWithWhereUniqueWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpsertWithWhereUniqueWithoutFornituraLuceInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutFornituraLuceInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutFornituraLuceInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelLuceUpdateManyWithoutFornituraLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithoutFornituraLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutFornituraLuceInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutFornituraLuceInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput,
          Iterable<
              _i2.ContrattoEnelLuceCreateOrConnectWithoutFornituraLuceInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutFornituraLuceInput,
          Iterable<
              _i2
              .ContrattoEnelLuceUpsertWithWhereUniqueWithoutFornituraLuceInput>>?
      upsert;

  final _i2.ContrattoEnelLuceCreateManyFornituraLuceInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutFornituraLuceInput,
          Iterable<
              _i2
              .ContrattoEnelLuceUpdateWithWhereUniqueWithoutFornituraLuceInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutFornituraLuceInput,
          Iterable<
              _i2
              .ContrattoEnelLuceUpdateManyWithWhereWithoutFornituraLuceInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornituraLuceUpdateWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateWithoutFornituraInput({
    this.uuid,
    this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ConsumoAnnuoLuceUpdateOneWithoutFornituraLuceNestedInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceUpdateManyWithoutFornituraLuceNestedInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceUpsertWithoutFornituraInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpsertWithoutFornituraInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedUpdateWithoutFornituraInput> update;

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedCreateWithoutFornituraInput> create;

  final _i2.FornituraLuceWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraLuceUpdateOneWithoutFornituraNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateOneWithoutFornituraNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutFornituraInput,
      _i2.FornituraLuceUncheckedCreateWithoutFornituraInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutFornituraInput? connectOrCreate;

  final _i2.FornituraLuceUpsertWithoutFornituraInput? upsert;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceWhereInput>? delete;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraLuceUpdateToOneWithWhereWithoutFornituraInput,
      _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutFornituraInput,
          _i2.FornituraLuceUncheckedUpdateWithoutFornituraInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class FornituraUpdateWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateWithoutServizioEwoInput({
    this.uuid,
    this.etichetta,
    this.domicilio,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.DomicilioUpdateOneRequiredWithoutFornitureNestedInput? domicilio;

  final _i2.FornituraLuceUpdateOneWithoutFornituraNestedInput? fornituraLuce;

  final _i2.FornituraGasUpdateOneWithoutFornituraNestedInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUpsertWithWhereUniqueWithoutServizioEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpsertWithWhereUniqueWithoutServizioEwoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.FornituraWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutServizioEwoInput,
      _i2.FornituraUncheckedUpdateWithoutServizioEwoInput> update;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutServizioEwoInput,
      _i2.FornituraUncheckedCreateWithoutServizioEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class FornituraUpdateManyWithoutServizioEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateManyWithoutServizioEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.FornituraCreateWithoutServizioEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraCreateWithoutServizioEwoInput>,
              _i1.PrismaUnion<
                  _i2.FornituraUncheckedCreateWithoutServizioEwoInput,
                  Iterable<
                      _i2.FornituraUncheckedCreateWithoutServizioEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.FornituraCreateOrConnectWithoutServizioEwoInput,
          Iterable<_i2.FornituraCreateOrConnectWithoutServizioEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.FornituraUpsertWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.FornituraUpsertWithWhereUniqueWithoutServizioEwoInput>>?
      upsert;

  final _i2.FornituraCreateManyServizioEwoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.FornituraWhereUniqueInput,
      Iterable<_i2.FornituraWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.FornituraUpdateWithWhereUniqueWithoutServizioEwoInput,
          Iterable<_i2.FornituraUpdateWithWhereUniqueWithoutServizioEwoInput>>?
      update;

  final _i1.PrismaUnion<_i2.FornituraUpdateManyWithWhereWithoutServizioEwoInput,
          Iterable<_i2.FornituraUpdateManyWithWhereWithoutServizioEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.FornituraScalarWhereInput,
      Iterable<_i2.FornituraScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUpdateWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutTipiPraticheInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedUpdateWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateWithoutTipiPraticheInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpsertWithWhereUniqueWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithWhereUniqueWithoutTipiPraticheInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutTipiPraticheInput,
      _i2.ServizioEwoUncheckedUpdateWithoutTipiPraticheInput> update;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutTipiPraticheInput,
      _i2.ServizioEwoUncheckedCreateWithoutTipiPraticheInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ServizioEwoUpdateWithWhereUniqueWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithWhereUniqueWithoutTipiPraticheInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutTipiPraticheInput,
      _i2.ServizioEwoUncheckedUpdateWithoutTipiPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutTipiPraticheInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateManyWithWhereWithoutTipiPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithWhereWithoutTipiPraticheInput({
    required this.where,
    required this.data,
  });

  final _i2.ServizioEwoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateManyMutationInput,
      _i2.ServizioEwoUncheckedUpdateManyWithoutTipiPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ServizioEwoUpdateManyWithoutTipiPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithoutTipiPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutTipiPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutTipiPraticheInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutTipiPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutTipiPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpsertWithWhereUniqueWithoutTipiPraticheInput,
          Iterable<
              _i2.ServizioEwoUpsertWithWhereUniqueWithoutTipiPraticheInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateWithWhereUniqueWithoutTipiPraticheInput,
          Iterable<
              _i2.ServizioEwoUpdateWithWhereUniqueWithoutTipiPraticheInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutTipiPraticheInput,
          Iterable<_i2.ServizioEwoUpdateManyWithWhereWithoutTipiPraticheInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoPraticaUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateWithoutPraticheInput({
    this.id,
    this.nome,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutTipiPraticheNestedInput? serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class ServizioEwoUncheckedUpdateManyWithoutTipiPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyWithoutTipiPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutTipiPraticheInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutTipiPraticheInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutTipiPraticheInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutTipiPraticheInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutTipiPraticheInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpsertWithWhereUniqueWithoutTipiPraticheInput,
          Iterable<
              _i2.ServizioEwoUpsertWithWhereUniqueWithoutTipiPraticheInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateWithWhereUniqueWithoutTipiPraticheInput,
          Iterable<
              _i2.ServizioEwoUpdateWithWhereUniqueWithoutTipiPraticheInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutTipiPraticheInput,
          Iterable<_i2.ServizioEwoUpdateManyWithWhereWithoutTipiPraticheInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoPraticaUncheckedUpdateWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedUpdateWithoutPraticheInput({
    this.id,
    this.nome,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutTipiPraticheNestedInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
      };
}

class TipoPraticaUpsertWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpsertWithoutPraticheInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaUpdateWithoutPraticheInput,
      _i2.TipoPraticaUncheckedUpdateWithoutPraticheInput> update;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateWithoutPraticheInput,
      _i2.TipoPraticaUncheckedCreateWithoutPraticheInput> create;

  final _i2.TipoPraticaWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class TipoPraticaUpdateToOneWithWhereWithoutPraticheInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateToOneWithWhereWithoutPraticheInput({
    this.where,
    required this.data,
  });

  final _i2.TipoPraticaWhereInput? where;

  final _i1.PrismaUnion<_i2.TipoPraticaUpdateWithoutPraticheInput,
      _i2.TipoPraticaUncheckedUpdateWithoutPraticheInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaCreateWithoutPraticheInput,
      _i2.TipoPraticaUncheckedCreateWithoutPraticheInput>? create;

  final _i2.TipoPraticaCreateOrConnectWithoutPraticheInput? connectOrCreate;

  final _i2.TipoPraticaUpsertWithoutPraticheInput? upsert;

  final _i2.TipoPraticaWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.TipoPraticaUpdateToOneWithWhereWithoutPraticheInput,
      _i1.PrismaUnion<_i2.TipoPraticaUpdateWithoutPraticheInput,
          _i2.TipoPraticaUncheckedUpdateWithoutPraticheInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class PraticaUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput? tipoPratica;

  final _i2.UtenteUpdateOneWithoutPraticheNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutPraticheNestedInput? negozio;

  final _i2.StatoPraticaUpdateOneWithoutPraticheNestedInput? stato;

  final _i2.ContrattoUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutSoggettoInput,
      _i2.PraticaUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutSoggettoInput,
      _i2.PraticaUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class PraticaUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.PraticaCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.PraticaCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.PraticaUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.PraticaUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.PraticaCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutSoggettoInput,
      Iterable<_i2.PraticaUpdateManyWithWhereWithoutSoggettoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutDomiciliInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutDomiciliInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutDomiciliInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutDomiciliInput,
      _i2.SoggettoUncheckedUpdateWithoutDomiciliInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutDomiciliInput,
      _i2.SoggettoUncheckedCreateWithoutDomiciliInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutDomiciliInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutDomiciliInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutDomiciliInput,
      _i2.SoggettoUncheckedUpdateWithoutDomiciliInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneRequiredWithoutDomiciliNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneRequiredWithoutDomiciliNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutDomiciliInput,
      _i2.SoggettoUncheckedCreateWithoutDomiciliInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutDomiciliInput? connectOrCreate;

  final _i2.SoggettoUpsertWithoutDomiciliInput? upsert;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutDomiciliInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutDomiciliInput,
          _i2.SoggettoUncheckedUpdateWithoutDomiciliInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class DomicilioUpdateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithoutFornitureInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.SoggettoUpdateOneRequiredWithoutDomiciliNestedInput? soggetto;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUpdateManyWithoutDomicilioNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedUpdateWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateWithoutFornitureInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedUpdateManyWithoutDomicilioNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUpsertWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpsertWithoutFornitureInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutFornitureInput,
      _i2.DomicilioUncheckedUpdateWithoutFornitureInput> update;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutFornitureInput,
      _i2.DomicilioUncheckedCreateWithoutFornitureInput> create;

  final _i2.DomicilioWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class DomicilioUpdateToOneWithWhereWithoutFornitureInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateToOneWithWhereWithoutFornitureInput({
    this.where,
    required this.data,
  });

  final _i2.DomicilioWhereInput? where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutFornitureInput,
      _i2.DomicilioUncheckedUpdateWithoutFornitureInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class DomicilioUpdateOneRequiredWithoutFornitureNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateOneRequiredWithoutFornitureNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutFornitureInput,
      _i2.DomicilioUncheckedCreateWithoutFornitureInput>? create;

  final _i2.DomicilioCreateOrConnectWithoutFornitureInput? connectOrCreate;

  final _i2.DomicilioUpsertWithoutFornitureInput? upsert;

  final _i2.DomicilioWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.DomicilioUpdateToOneWithWhereWithoutFornitureInput,
      _i1.PrismaUnion<_i2.DomicilioUpdateWithoutFornitureInput,
          _i2.DomicilioUncheckedUpdateWithoutFornitureInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class FornituraUpdateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateWithoutFornituraLuceInput({
    this.uuid,
    this.etichetta,
    this.domicilio,
    this.servizioEwo,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.DomicilioUpdateOneRequiredWithoutFornitureNestedInput? domicilio;

  final _i2.ServizioEwoUpdateOneRequiredWithoutFornitureNestedInput?
      servizioEwo;

  final _i2.FornituraGasUpdateOneWithoutFornituraNestedInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUncheckedUpdateWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateWithoutFornituraLuceInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.FornituraGasUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUpsertWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpsertWithoutFornituraLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutFornituraLuceInput,
      _i2.FornituraUncheckedUpdateWithoutFornituraLuceInput> update;

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraLuceInput,
      _i2.FornituraUncheckedCreateWithoutFornituraLuceInput> create;

  final _i2.FornituraWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraUpdateToOneWithWhereWithoutFornituraLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateToOneWithWhereWithoutFornituraLuceInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraUpdateWithoutFornituraLuceInput,
      _i2.FornituraUncheckedUpdateWithoutFornituraLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraUpdateOneRequiredWithoutFornituraLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateOneRequiredWithoutFornituraLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraCreateWithoutFornituraLuceInput,
      _i2.FornituraUncheckedCreateWithoutFornituraLuceInput>? create;

  final _i2.FornituraCreateOrConnectWithoutFornituraLuceInput? connectOrCreate;

  final _i2.FornituraUpsertWithoutFornituraLuceInput? upsert;

  final _i2.FornituraWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraUpdateToOneWithWhereWithoutFornituraLuceInput,
      _i1.PrismaUnion<_i2.FornituraUpdateWithoutFornituraLuceInput,
          _i2.FornituraUncheckedUpdateWithoutFornituraLuceInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class FornituraLuceUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateWithoutContrattiEnelLuceInput({
    this.uuid,
    this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ConsumoAnnuoLuceUpdateOneWithoutFornituraLuceNestedInput?
      consumoAnnuoLuce;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraLuceNestedInput?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceUncheckedUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedUpdateWithoutContrattiEnelLuceInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ConsumoAnnuoLuceUncheckedUpdateOneWithoutFornituraLuceNestedInput?
      consumoAnnuoLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
      };
}

class FornituraLuceUpsertWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpsertWithoutContrattiEnelLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutContrattiEnelLuceInput,
      _i2.FornituraLuceUncheckedUpdateWithoutContrattiEnelLuceInput> update;

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutContrattiEnelLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutContrattiEnelLuceInput> create;

  final _i2.FornituraLuceWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraLuceUpdateToOneWithWhereWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateToOneWithWhereWithoutContrattiEnelLuceInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraLuceWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutContrattiEnelLuceInput,
      _i2.FornituraLuceUncheckedUpdateWithoutContrattiEnelLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraLuceUpdateOneRequiredWithoutContrattiEnelLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateOneRequiredWithoutContrattiEnelLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutContrattiEnelLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.FornituraLuceUpsertWithoutContrattiEnelLuceInput? upsert;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.FornituraLuceUpdateToOneWithWhereWithoutContrattiEnelLuceInput,
          _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutContrattiEnelLuceInput,
              _i2.FornituraLuceUncheckedUpdateWithoutContrattiEnelLuceInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelLuceUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithoutStatoInput({
    this.uuid,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.FornituraLuceUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      fornituraLuce;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelLuceNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceUpsertWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpsertWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutStatoInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutStatoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutStatoInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelLuceUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutStatoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput,
                  Iterable<
                      _i2.ContrattoEnelLuceUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutStatoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutStatoInput,
      Iterable<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutStatoInput>>? upsert;

  final _i2.ContrattoEnelLuceCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutStatoInput,
      Iterable<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutStatoInput>>? update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutStatoInput,
          Iterable<_i2.ContrattoEnelLuceUpdateManyWithWhereWithoutStatoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithoutContrattiEnelGasInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedUpdateWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateWithoutContrattiEnelGasInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUncheckedUpdateManyWithoutStatoNestedInput? contratti;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUpsertWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpsertWithoutContrattiEnelGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelGasInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelGasInput> update;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelGasInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelGasInput> create;

  final _i2.StatoContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelGasInput({
    this.where,
    required this.data,
  });

  final _i2.StatoContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelGasInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelGasInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelGasInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiEnelGasInput?
      connectOrCreate;

  final _i2.StatoContrattoUpsertWithoutContrattiEnelGasInput? upsert;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelGasInput,
          _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelGasInput,
              _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelGasInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelGasUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateWithoutContrattoInput({
    this.uuid,
    this.stato,
    this.fornituraGas,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      stato;

  final _i2.FornituraGasUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      fornituraGas;

  final _i2.OffertaUpdateOneWithoutContrattiEnelGasNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'offerta': offerta,
      };
}

class ContrattoEnelGasUpsertWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpsertWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasUpdateWithoutContrattoInput,
      _i2.ContrattoEnelGasUncheckedUpdateWithoutContrattoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasCreateWithoutContrattoInput,
      _i2.ContrattoEnelGasUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelGasUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelGasCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelGasUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelGasUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelGasCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelGasUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelGasCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasWhereUniqueInput,
      Iterable<_i2.ContrattoEnelGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelGasUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelGasUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutSoggettoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutSoggettoInput,
      _i2.ContrattoUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutSoggettoInput,
      _i2.ContrattoUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.ContrattoCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.ContrattoCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.ContrattoUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutPraticheIntestateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutPraticheIntestateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutPraticheIntestateInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutPraticheIntestateInput,
      _i2.SoggettoUncheckedUpdateWithoutPraticheIntestateInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPraticheIntestateInput,
      _i2.SoggettoUncheckedCreateWithoutPraticheIntestateInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutPraticheIntestateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutPraticheIntestateInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutPraticheIntestateInput,
      _i2.SoggettoUncheckedUpdateWithoutPraticheIntestateInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneWithoutPraticheIntestateNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneWithoutPraticheIntestateNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPraticheIntestateInput,
      _i2.SoggettoUncheckedCreateWithoutPraticheIntestateInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutPraticheIntestateInput?
      connectOrCreate;

  final _i2.SoggettoUpsertWithoutPraticheIntestateInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? delete;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutPraticheIntestateInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutPraticheIntestateInput,
          _i2.SoggettoUncheckedUpdateWithoutPraticheIntestateInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class PraticaUpdateWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateWithoutTipoPraticaInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.SoggettoUpdateOneWithoutPraticheIntestateNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutPraticheNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutPraticheNestedInput? negozio;

  final _i2.StatoPraticaUpdateOneWithoutPraticheNestedInput? stato;

  final _i2.ContrattoUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaUpsertWithWhereUniqueWithoutTipoPraticaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpsertWithWhereUniqueWithoutTipoPraticaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.PraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithoutTipoPraticaInput,
      _i2.PraticaUncheckedUpdateWithoutTipoPraticaInput> update;

  final _i1.PrismaUnion<_i2.PraticaCreateWithoutTipoPraticaInput,
      _i2.PraticaUncheckedCreateWithoutTipoPraticaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class PraticaUpdateManyWithoutTipoPraticaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateManyWithoutTipoPraticaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.PraticaCreateWithoutTipoPraticaInput,
      _i1.PrismaUnion<
          Iterable<_i2.PraticaCreateWithoutTipoPraticaInput>,
          _i1.PrismaUnion<
              _i2.PraticaUncheckedCreateWithoutTipoPraticaInput,
              Iterable<
                  _i2.PraticaUncheckedCreateWithoutTipoPraticaInput>>>>? create;

  final _i1.PrismaUnion<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput,
          Iterable<_i2.PraticaCreateOrConnectWithoutTipoPraticaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.PraticaUpsertWithWhereUniqueWithoutTipoPraticaInput,
          Iterable<_i2.PraticaUpsertWithWhereUniqueWithoutTipoPraticaInput>>?
      upsert;

  final _i2.PraticaCreateManyTipoPraticaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.PraticaWhereUniqueInput,
      Iterable<_i2.PraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.PraticaUpdateWithWhereUniqueWithoutTipoPraticaInput,
          Iterable<_i2.PraticaUpdateWithWhereUniqueWithoutTipoPraticaInput>>?
      update;

  final _i1.PrismaUnion<_i2.PraticaUpdateManyWithWhereWithoutTipoPraticaInput,
          Iterable<_i2.PraticaUpdateManyWithWhereWithoutTipoPraticaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereInput,
      Iterable<_i2.PraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoPraticaUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.pratiche,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutTipoPraticaNestedInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
      };
}

class TipoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.TipoPraticaWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.TipoPraticaUpdateWithoutServiziEwoInput,
      _i2.TipoPraticaUncheckedUpdateWithoutServiziEwoInput> update;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateWithoutServiziEwoInput,
      _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class TipoPraticaUpdateManyWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateManyWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.TipoPraticaCreateWithoutServiziEwoInput,
          _i1.PrismaUnion<
              Iterable<_i2.TipoPraticaCreateWithoutServiziEwoInput>,
              _i1.PrismaUnion<
                  _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput,
                  Iterable<
                      _i2.TipoPraticaUncheckedCreateWithoutServiziEwoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaCreateOrConnectWithoutServiziEwoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.TipoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaUpsertWithWhereUniqueWithoutServiziEwoInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.TipoPraticaWhereUniqueInput,
      Iterable<_i2.TipoPraticaWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.TipoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaUpdateWithWhereUniqueWithoutServiziEwoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.TipoPraticaUpdateManyWithWhereWithoutServiziEwoInput,
          Iterable<_i2.TipoPraticaUpdateManyWithWhereWithoutServiziEwoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.TipoPraticaScalarWhereInput,
      Iterable<_i2.TipoPraticaScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ServizioEwoUpdateWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutModuliContrattoInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
      };
}

class ServizioEwoUpsertWithWhereUniqueWithoutModuliContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithWhereUniqueWithoutModuliContrattoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ServizioEwoUpdateWithoutModuliContrattoInput,
      _i2.ServizioEwoUncheckedUpdateWithoutModuliContrattoInput> update;

  final _i1.PrismaUnion<_i2.ServizioEwoCreateWithoutModuliContrattoInput,
      _i2.ServizioEwoUncheckedCreateWithoutModuliContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ServizioEwoUpdateManyWithoutModuliContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithoutModuliContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateWithoutModuliContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ServizioEwoCreateWithoutModuliContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ServizioEwoUncheckedCreateWithoutModuliContrattoInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutModuliContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput,
          Iterable<_i2.ServizioEwoCreateOrConnectWithoutModuliContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpsertWithWhereUniqueWithoutModuliContrattoInput,
          Iterable<
              _i2.ServizioEwoUpsertWithWhereUniqueWithoutModuliContrattoInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateWithWhereUniqueWithoutModuliContrattoInput,
          Iterable<
              _i2.ServizioEwoUpdateWithWhereUniqueWithoutModuliContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutModuliContrattoInput,
          Iterable<
              _i2.ServizioEwoUpdateManyWithWhereWithoutModuliContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ModuloContrattoUpdateWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithoutFornitoreInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
    this.tipoModulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i2.ServizioEwoUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUpdateManyWithoutModuloNestedInput? contratti;

  final _i2
      .TipoModuloContrattoUpdateOneRequiredWithoutModuloContrattoNestedInput?
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoUpsertWithWhereUniqueWithoutFornitoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpsertWithWhereUniqueWithoutFornitoreInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutFornitoreInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutFornitoreInput> update;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutFornitoreInput,
      _i2.ModuloContrattoUncheckedCreateWithoutFornitoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ModuloContrattoUpdateManyWithoutFornitoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyWithoutFornitoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutFornitoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutFornitoreInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutFornitoreInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutFornitoreInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutFornitoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpsertWithWhereUniqueWithoutFornitoreInput,
          Iterable<
              _i2.ModuloContrattoUpsertWithWhereUniqueWithoutFornitoreInput>>?
      upsert;

  final _i2.ModuloContrattoCreateManyFornitoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateWithWhereUniqueWithoutFornitoreInput,
          Iterable<
              _i2.ModuloContrattoUpdateWithWhereUniqueWithoutFornitoreInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateManyWithWhereWithoutFornitoreInput,
          Iterable<
              _i2.ModuloContrattoUpdateManyWithWhereWithoutFornitoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class FornitoreUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.moduliContratto,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ModuloContrattoUpdateManyWithoutFornitoreNestedInput?
      moduliContratto;

  final _i2.ProdottoUpdateManyWithoutFornitoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreUncheckedUpdateWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedUpdateWithoutServiziEwoInput({
    this.id,
    this.nome,
    this.moduliContratto,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ModuloContrattoUncheckedUpdateManyWithoutFornitoreNestedInput?
      moduliContratto;

  final _i2.ProdottoUncheckedUpdateManyWithoutFornitoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreUpsertWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpsertWithoutServiziEwoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornitoreUpdateWithoutServiziEwoInput,
      _i2.FornitoreUncheckedUpdateWithoutServiziEwoInput> update;

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutServiziEwoInput,
      _i2.FornitoreUncheckedCreateWithoutServiziEwoInput> create;

  final _i2.FornitoreWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornitoreUpdateToOneWithWhereWithoutServiziEwoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateToOneWithWhereWithoutServiziEwoInput({
    this.where,
    required this.data,
  });

  final _i2.FornitoreWhereInput? where;

  final _i1.PrismaUnion<_i2.FornitoreUpdateWithoutServiziEwoInput,
      _i2.FornitoreUncheckedUpdateWithoutServiziEwoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornitoreCreateWithoutServiziEwoInput,
      _i2.FornitoreUncheckedCreateWithoutServiziEwoInput>? create;

  final _i2.FornitoreCreateOrConnectWithoutServiziEwoInput? connectOrCreate;

  final _i2.FornitoreUpsertWithoutServiziEwoInput? upsert;

  final _i2.FornitoreWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornitoreUpdateToOneWithWhereWithoutServiziEwoInput,
      _i1.PrismaUnion<_i2.FornitoreUpdateWithoutServiziEwoInput,
          _i2.FornitoreUncheckedUpdateWithoutServiziEwoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ServizioEwoUpdateWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateWithoutStatiPossibiliContrattiInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliContrattiInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliContrattiInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ServizioEwoWhereUniqueInput where;

  final _i1.PrismaUnion<
      _i2.ServizioEwoUpdateWithoutStatiPossibiliContrattiInput,
      _i2.ServizioEwoUncheckedUpdateWithoutStatiPossibiliContrattiInput> update;

  final _i1.PrismaUnion<
      _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput,
      _i2.ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ServizioEwoCreateWithoutStatiPossibiliContrattiInput>,
              _i1.PrismaUnion<
                  _i2
                  .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput,
                  Iterable<
                      _i2
                      .ServizioEwoUncheckedCreateWithoutStatiPossibiliContrattiInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoCreateOrConnectWithoutStatiPossibiliContrattiInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoUpsertWithWhereUniqueWithoutStatiPossibiliContrattiInput>>?
      upsert;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ServizioEwoWhereUniqueInput,
      Iterable<_i2.ServizioEwoWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoUpdateWithWhereUniqueWithoutStatiPossibiliContrattiInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliContrattiInput,
          Iterable<
              _i2
              .ServizioEwoUpdateManyWithWhereWithoutStatiPossibiliContrattiInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereInput,
      Iterable<_i2.ServizioEwoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithoutContrattiEnelLuceInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelGasUpdateManyWithoutStatoNestedInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedUpdateWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateWithoutContrattiEnelLuceInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUncheckedUpdateManyWithoutStatoNestedInput? contratti;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUpsertWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpsertWithoutContrattiEnelLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelLuceInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelLuceInput> update;

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelLuceInput> create;

  final _i2.StatoContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelLuceInput({
    this.where,
    required this.data,
  });

  final _i2.StatoContrattoWhereInput? where;

  final _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelLuceInput,
      _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoCreateWithoutContrattiEnelLuceInput,
      _i2.StatoContrattoUncheckedCreateWithoutContrattiEnelLuceInput>? create;

  final _i2.StatoContrattoCreateOrConnectWithoutContrattiEnelLuceInput?
      connectOrCreate;

  final _i2.StatoContrattoUpsertWithoutContrattiEnelLuceInput? upsert;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelLuceInput,
          _i1.PrismaUnion<_i2.StatoContrattoUpdateWithoutContrattiEnelLuceInput,
              _i2.StatoContrattoUncheckedUpdateWithoutContrattiEnelLuceInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelLuceUpdateWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateWithoutContrattoInput({
    this.uuid,
    this.stato,
    this.fornituraLuce,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      stato;

  final _i2.FornituraLuceUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      fornituraLuce;

  final _i2.OffertaUpdateOneWithoutContrattiEnelLuceNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceUpsertWithWhereUniqueWithoutContrattoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpsertWithWhereUniqueWithoutContrattoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceUpdateWithoutContrattoInput,
      _i2.ContrattoEnelLuceUncheckedUpdateWithoutContrattoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceCreateWithoutContrattoInput,
      _i2.ContrattoEnelLuceUncheckedCreateWithoutContrattoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateWithoutContrattoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoEnelLuceCreateWithoutContrattoInput>,
              _i1.PrismaUnion<
                  _i2.ContrattoEnelLuceUncheckedCreateWithoutContrattoInput,
                  Iterable<
                      _i2
                      .ContrattoEnelLuceUncheckedCreateWithoutContrattoInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput,
          Iterable<_i2.ContrattoEnelLuceCreateOrConnectWithoutContrattoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelLuceUpsertWithWhereUniqueWithoutContrattoInput>>?
      upsert;

  final _i2.ContrattoEnelLuceCreateManyContrattoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceWhereUniqueInput,
      Iterable<_i2.ContrattoEnelLuceWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateWithWhereUniqueWithoutContrattoInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutContrattoInput,
          Iterable<
              _i2.ContrattoEnelLuceUpdateManyWithWhereWithoutContrattoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ContrattoUpdateWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateWithoutStatoInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUpsertWithWhereUniqueWithoutStatoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpsertWithWhereUniqueWithoutStatoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithoutStatoInput,
      _i2.ContrattoUncheckedUpdateWithoutStatoInput> update;

  final _i1.PrismaUnion<_i2.ContrattoCreateWithoutStatoInput,
      _i2.ContrattoUncheckedCreateWithoutStatoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoUpdateManyWithoutStatoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateManyWithoutStatoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ContrattoCreateWithoutStatoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ContrattoCreateWithoutStatoInput>,
              _i1.PrismaUnion<_i2.ContrattoUncheckedCreateWithoutStatoInput,
                  Iterable<_i2.ContrattoUncheckedCreateWithoutStatoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ContrattoCreateOrConnectWithoutStatoInput,
      Iterable<_i2.ContrattoCreateOrConnectWithoutStatoInput>>? connectOrCreate;

  final _i1.PrismaUnion<_i2.ContrattoUpsertWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.ContrattoUpsertWithWhereUniqueWithoutStatoInput>>? upsert;

  final _i2.ContrattoCreateManyStatoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoWhereUniqueInput,
      Iterable<_i2.ContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ContrattoUpdateWithWhereUniqueWithoutStatoInput,
      Iterable<_i2.ContrattoUpdateWithWhereUniqueWithoutStatoInput>>? update;

  final _i1.PrismaUnion<_i2.ContrattoUpdateManyWithWhereWithoutStatoInput,
      Iterable<_i2.ContrattoUpdateManyWithWhereWithoutStatoInput>>? updateMany;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereInput,
      Iterable<_i2.ContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoContrattoUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutStatoNestedInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
      };
}

class StatoContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUncheckedUpdateManyWithoutStatoNestedInput? contratti;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
      };
}

class StatoContrattoUpsertWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpsertWithoutContrattiEnelXAssicurazioneInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>
      update;

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>
      create;

  final _i2.StatoContrattoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput({
    this.where,
    required this.data,
  });

  final _i2.StatoContrattoWhereInput? where;

  final _i1.PrismaUnion<
          _i2.StatoContrattoUpdateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>
      data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class StatoContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.StatoContrattoCreateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedCreateWithoutContrattiEnelXAssicurazioneInput>?
      create;

  final _i2
      .StatoContrattoCreateOrConnectWithoutContrattiEnelXAssicurazioneInput?
      connectOrCreate;

  final _i2.StatoContrattoUpsertWithoutContrattiEnelXAssicurazioneInput? upsert;

  final _i2.StatoContrattoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2
      .StatoContrattoUpdateToOneWithWhereWithoutContrattiEnelXAssicurazioneInput,
      _i1.PrismaUnion<
          _i2.StatoContrattoUpdateWithoutContrattiEnelXAssicurazioneInput,
          _i2
          .StatoContrattoUncheckedUpdateWithoutContrattiEnelXAssicurazioneInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ContrattoEnelXAssicurazioneUpdateWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateWithoutDomicilioInput({
    this.uuid,
    this.stato,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2
      .StatoContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      stato;

  final _i2
      .ContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelXAssicurazioneNestedInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutDomicilioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutDomicilioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ContrattoEnelXAssicurazioneWhereUniqueInput where;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneUpdateWithoutDomicilioInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedUpdateWithoutDomicilioInput>
      update;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput,
          _i2.ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput>
      create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1
      .PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput,
          _i1.PrismaUnion<
              Iterable<
                  _i2.ContrattoEnelXAssicurazioneCreateWithoutDomicilioInput>,
              _i1.PrismaUnion<
                  _i2
                  .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput,
                  Iterable<
                      _i2
                      .ContrattoEnelXAssicurazioneUncheckedCreateWithoutDomicilioInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneCreateOrConnectWithoutDomicilioInput>>?
      connectOrCreate;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpsertWithWhereUniqueWithoutDomicilioInput>>?
      upsert;

  final _i2.ContrattoEnelXAssicurazioneCreateManyDomicilioInputEnvelope?
      createMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneWhereUniqueInput>>? connect;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateWithWhereUniqueWithoutDomicilioInput>>?
      update;

  final _i1
      .PrismaUnion<
          _i2
          .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutDomicilioInput,
          Iterable<
              _i2
              .ContrattoEnelXAssicurazioneUpdateManyWithWhereWithoutDomicilioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ContrattoEnelXAssicurazioneScalarWhereInput,
      Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class DomicilioUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateWithoutSoggettoInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUpdateManyWithoutDomicilioNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUpsertWithWhereUniqueWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpsertWithWhereUniqueWithoutSoggettoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.DomicilioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithoutSoggettoInput,
      _i2.DomicilioUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.DomicilioCreateWithoutSoggettoInput,
      _i2.DomicilioUncheckedCreateWithoutSoggettoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class DomicilioUpdateManyWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateManyWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.DomicilioCreateWithoutSoggettoInput,
          _i1.PrismaUnion<
              Iterable<_i2.DomicilioCreateWithoutSoggettoInput>,
              _i1.PrismaUnion<_i2.DomicilioUncheckedCreateWithoutSoggettoInput,
                  Iterable<_i2.DomicilioUncheckedCreateWithoutSoggettoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.DomicilioCreateOrConnectWithoutSoggettoInput,
          Iterable<_i2.DomicilioCreateOrConnectWithoutSoggettoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.DomicilioUpsertWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.DomicilioUpsertWithWhereUniqueWithoutSoggettoInput>>? upsert;

  final _i2.DomicilioCreateManySoggettoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.DomicilioWhereUniqueInput,
      Iterable<_i2.DomicilioWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.DomicilioUpdateWithWhereUniqueWithoutSoggettoInput,
      Iterable<_i2.DomicilioUpdateWithWhereUniqueWithoutSoggettoInput>>? update;

  final _i1.PrismaUnion<_i2.DomicilioUpdateManyWithWhereWithoutSoggettoInput,
          Iterable<_i2.DomicilioUpdateManyWithWhereWithoutSoggettoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.DomicilioScalarWhereInput,
      Iterable<_i2.DomicilioScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class SoggettoUpdateWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutNumeriTelefonoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutNumeriTelefonoInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUpsertWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutNumeriTelefonoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutNumeriTelefonoInput,
      _i2.SoggettoUncheckedUpdateWithoutNumeriTelefonoInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutNumeriTelefonoInput,
      _i2.SoggettoUncheckedCreateWithoutNumeriTelefonoInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutNumeriTelefonoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutNumeriTelefonoInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutNumeriTelefonoInput,
      _i2.SoggettoUncheckedUpdateWithoutNumeriTelefonoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneWithoutNumeriTelefonoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneWithoutNumeriTelefonoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutNumeriTelefonoInput,
      _i2.SoggettoUncheckedCreateWithoutNumeriTelefonoInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutNumeriTelefonoInput? connectOrCreate;

  final _i2.SoggettoUpsertWithoutNumeriTelefonoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? delete;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutNumeriTelefonoInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutNumeriTelefonoInput,
          _i2.SoggettoUncheckedUpdateWithoutNumeriTelefonoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class NumeroTelefonoUpdateWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateWithoutLegaleRappresentateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggetto,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.SoggettoUpdateOneWithoutNumeriTelefonoNestedInput? soggetto;

  final _i2.ReferenteUpdateOneWithoutNumeroTelefonoNestedInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'referente': referente,
      };
}

class NumeroTelefonoUpsertWithoutLegaleRappresentateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpsertWithoutLegaleRappresentateInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoUpdateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedUpdateWithoutLegaleRappresentateInput> update;

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput> create;

  final _i2.NumeroTelefonoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class NumeroTelefonoUpdateOneWithoutLegaleRappresentateNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateOneWithoutLegaleRappresentateNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoCreateWithoutLegaleRappresentateInput,
      _i2.NumeroTelefonoUncheckedCreateWithoutLegaleRappresentateInput>? create;

  final _i2.NumeroTelefonoCreateOrConnectWithoutLegaleRappresentateInput?
      connectOrCreate;

  final _i2.NumeroTelefonoUpsertWithoutLegaleRappresentateInput? upsert;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoWhereInput>? delete;

  final _i2.NumeroTelefonoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.NumeroTelefonoUpdateToOneWithWhereWithoutLegaleRappresentateInput,
          _i1.PrismaUnion<
              _i2.NumeroTelefonoUpdateWithoutLegaleRappresentateInput,
              _i2
              .NumeroTelefonoUncheckedUpdateWithoutLegaleRappresentateInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class LegaleRappresentanteUpdateWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateWithoutSoggettoBusinessInfoInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUpdateOneWithoutLegaleRappresentateNestedInput?
      numeroTelefono;

  final _i2.IndirizzoEmailUpdateOneWithoutLegaleRappresentanteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteUpsertWithoutSoggettoBusinessInfoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpsertWithoutSoggettoBusinessInfoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteUpdateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedUpdateWithoutSoggettoBusinessInfoInput>
      update;

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput>
      create;

  final _i2.LegaleRappresentanteWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class LegaleRappresentanteUpdateOneWithoutSoggettoBusinessInfoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateOneWithoutSoggettoBusinessInfoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<
          _i2.LegaleRappresentanteCreateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedCreateWithoutSoggettoBusinessInfoInput>?
      create;

  final _i2.LegaleRappresentanteCreateOrConnectWithoutSoggettoBusinessInfoInput?
      connectOrCreate;

  final _i2.LegaleRappresentanteUpsertWithoutSoggettoBusinessInfoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteWhereInput>? delete;

  final _i2.LegaleRappresentanteWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2
      .LegaleRappresentanteUpdateToOneWithWhereWithoutSoggettoBusinessInfoInput,
      _i1.PrismaUnion<
          _i2.LegaleRappresentanteUpdateWithoutSoggettoBusinessInfoInput,
          _i2
          .LegaleRappresentanteUncheckedUpdateWithoutSoggettoBusinessInfoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoBusinessInfoUpdateWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateWithoutSoggettoInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i2.LegaleRappresentanteUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      legaleRappresentante;

  final _i2.ReferenteUpdateOneWithoutSoggettoBusinessInfoNestedInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
      };
}

class SoggettoBusinessInfoUpsertWithoutSoggettoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpsertWithoutSoggettoInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedUpdateWithoutSoggettoInput> update;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput> create;

  final _i2.SoggettoBusinessInfoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoCreateWithoutSoggettoInput,
      _i2.SoggettoBusinessInfoUncheckedCreateWithoutSoggettoInput>? create;

  final _i2.SoggettoBusinessInfoCreateOrConnectWithoutSoggettoInput?
      connectOrCreate;

  final _i2.SoggettoBusinessInfoUpsertWithoutSoggettoInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoWhereInput>? delete;

  final _i2.SoggettoBusinessInfoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoBusinessInfoUpdateToOneWithWhereWithoutSoggettoInput,
      _i1.PrismaUnion<_i2.SoggettoBusinessInfoUpdateWithoutSoggettoInput,
          _i2.SoggettoBusinessInfoUncheckedUpdateWithoutSoggettoInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class SoggettoUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
    this.privacy,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  final _i2.PrivacyUncheckedUpdateOneWithoutSoggettoNestedInput? privacy;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
        'privacy': privacy,
      };
}

class SoggettoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateManyInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoCountAggregateOutputType {
  const SoggettoCountAggregateOutputType({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.$all,
  });

  factory SoggettoCountAggregateOutputType.fromJson(Map json) =>
      SoggettoCountAggregateOutputType(
        uuid: json['uuid'],
        ragioneSociale: json['ragioneSociale'],
        iban: json['iban'],
        tipo: json['tipo'],
        negozioPreferitoUuid: json['negozioPreferitoUuid'],
        codiceFiscale: json['codiceFiscale'],
        note: json['note'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? ragioneSociale;

  final int? iban;

  final int? tipo;

  final int? negozioPreferitoUuid;

  final int? codiceFiscale;

  final int? note;

  final int? $all;
}

class SoggettoMinAggregateOutputType {
  const SoggettoMinAggregateOutputType({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  factory SoggettoMinAggregateOutputType.fromJson(Map json) =>
      SoggettoMinAggregateOutputType(
        uuid: json['uuid'],
        ragioneSociale: json['ragioneSociale'],
        iban: json['iban'],
        tipo: json['tipo'] != null
            ? _i3.TipoSoggetto.values.firstWhere((e) => e.name == json['tipo'])
            : null,
        negozioPreferitoUuid: json['negozioPreferitoUuid'],
        codiceFiscale: json['codiceFiscale'],
        note: json['note'],
      );

  final String? uuid;

  final String? ragioneSociale;

  final String? iban;

  final _i3.TipoSoggetto? tipo;

  final String? negozioPreferitoUuid;

  final String? codiceFiscale;

  final String? note;
}

class SoggettoMaxAggregateOutputType {
  const SoggettoMaxAggregateOutputType({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  factory SoggettoMaxAggregateOutputType.fromJson(Map json) =>
      SoggettoMaxAggregateOutputType(
        uuid: json['uuid'],
        ragioneSociale: json['ragioneSociale'],
        iban: json['iban'],
        tipo: json['tipo'] != null
            ? _i3.TipoSoggetto.values.firstWhere((e) => e.name == json['tipo'])
            : null,
        negozioPreferitoUuid: json['negozioPreferitoUuid'],
        codiceFiscale: json['codiceFiscale'],
        note: json['note'],
      );

  final String? uuid;

  final String? ragioneSociale;

  final String? iban;

  final _i3.TipoSoggetto? tipo;

  final String? negozioPreferitoUuid;

  final String? codiceFiscale;

  final String? note;
}

class SoggettoGroupByOutputType {
  const SoggettoGroupByOutputType({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SoggettoGroupByOutputType.fromJson(Map json) =>
      SoggettoGroupByOutputType(
        uuid: json['uuid'],
        ragioneSociale: json['ragioneSociale'],
        iban: json['iban'],
        tipo: json['tipo'] != null
            ? _i3.TipoSoggetto.values.firstWhere((e) => e.name == json['tipo'])
            : null,
        negozioPreferitoUuid: json['negozioPreferitoUuid'],
        codiceFiscale: json['codiceFiscale'],
        note: json['note'],
        $count: json['_count'] is Map
            ? _i2.SoggettoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SoggettoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SoggettoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? ragioneSociale;

  final String? iban;

  final _i3.TipoSoggetto? tipo;

  final String? negozioPreferitoUuid;

  final String? codiceFiscale;

  final String? note;

  final _i2.SoggettoCountAggregateOutputType? $count;

  final _i2.SoggettoMinAggregateOutputType? $min;

  final _i2.SoggettoMaxAggregateOutputType? $max;
}

class SoggettoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCountOrderByAggregateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? ragioneSociale;

  final _i2.SortOrder? iban;

  final _i2.SortOrder? tipo;

  final _i2.SortOrder? negozioPreferitoUuid;

  final _i2.SortOrder? codiceFiscale;

  final _i2.SortOrder? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoMaxOrderByAggregateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? ragioneSociale;

  final _i2.SortOrder? iban;

  final _i2.SortOrder? tipo;

  final _i2.SortOrder? negozioPreferitoUuid;

  final _i2.SortOrder? codiceFiscale;

  final _i2.SortOrder? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoMinOrderByAggregateInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? ragioneSociale;

  final _i2.SortOrder? iban;

  final _i2.SortOrder? tipo;

  final _i2.SortOrder? negozioPreferitoUuid;

  final _i2.SortOrder? codiceFiscale;

  final _i2.SortOrder? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoOrderByWithAggregationInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? ragioneSociale;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? iban;

  final _i2.SortOrder? tipo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      negozioPreferitoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? codiceFiscale;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? note;

  final _i2.SoggettoCountOrderByAggregateInput? $count;

  final _i2.SoggettoMaxOrderByAggregateInput? $max;

  final _i2.SoggettoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NestedStringWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<String, _i2.NestedStringWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedStringFilter? $min;

  final _i2.NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StringWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String, _i1.Reference<String>>? equals;

  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<String, _i2.NestedStringWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedStringFilter? $min;

  final _i2.NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedStringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NestedStringNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.search,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final String? search;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NestedStringNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'search': search,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedEnumTipoSoggettoWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoSoggettoWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoSoggetto, _i1.Reference<_i3.TipoSoggetto>>?
      equals;

  final Iterable<_i3.TipoSoggetto>? $in;

  final Iterable<_i3.TipoSoggetto>? notIn;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.NestedEnumTipoSoggettoWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoSoggettoFilter? $min;

  final _i2.NestedEnumTipoSoggettoFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumTipoSoggettoWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoSoggettoWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoSoggetto, _i1.Reference<_i3.TipoSoggetto>>?
      equals;

  final Iterable<_i3.TipoSoggetto>? $in;

  final Iterable<_i3.TipoSoggetto>? notIn;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.NestedEnumTipoSoggettoWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoSoggettoFilter? $min;

  final _i2.NestedEnumTipoSoggettoFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class SoggettoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final _i1.PrismaUnion<_i2.SoggettoScalarWhereWithAggregatesInput,
      Iterable<_i2.SoggettoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.SoggettoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.SoggettoScalarWhereWithAggregatesInput,
      Iterable<_i2.SoggettoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? ragioneSociale;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? iban;

  final _i1
      .PrismaUnion<_i2.EnumTipoSoggettoWithAggregatesFilter, _i3.TipoSoggetto>?
      tipo;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCountAggregateOutputTypeSelect({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.$all,
  });

  final bool? uuid;

  final bool? ragioneSociale;

  final bool? iban;

  final bool? tipo;

  final bool? negozioPreferitoUuid;

  final bool? codiceFiscale;

  final bool? note;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        '_all': $all,
      };
}

class SoggettoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoGroupByOutputTypeCountArgs({this.select});

  final _i2.SoggettoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoMinAggregateOutputTypeSelect({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final bool? uuid;

  final bool? ragioneSociale;

  final bool? iban;

  final bool? tipo;

  final bool? negozioPreferitoUuid;

  final bool? codiceFiscale;

  final bool? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoGroupByOutputTypeMinArgs({this.select});

  final _i2.SoggettoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoMaxAggregateOutputTypeSelect({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
  });

  final bool? uuid;

  final bool? ragioneSociale;

  final bool? iban;

  final bool? tipo;

  final bool? negozioPreferitoUuid;

  final bool? codiceFiscale;

  final bool? note;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
      };
}

class SoggettoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoGroupByOutputTypeMaxArgs({this.select});

  final _i2.SoggettoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoGroupByOutputTypeSelect({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? ragioneSociale;

  final bool? iban;

  final bool? tipo;

  final bool? negozioPreferitoUuid;

  final bool? codiceFiscale;

  final bool? note;

  final _i1.PrismaUnion<bool, _i2.SoggettoGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.SoggettoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SoggettoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateSoggetto {
  const AggregateSoggetto({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateSoggetto.fromJson(Map json) => AggregateSoggetto(
        $count: json['_count'] is Map
            ? _i2.SoggettoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SoggettoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SoggettoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SoggettoCountAggregateOutputType? $count;

  final _i2.SoggettoMinAggregateOutputType? $min;

  final _i2.SoggettoMaxAggregateOutputType? $max;
}

class AggregateSoggettoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoCountArgs({this.select});

  final _i2.SoggettoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSoggettoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoMinArgs({this.select});

  final _i2.SoggettoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSoggettoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoMaxArgs({this.select});

  final _i2.SoggettoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSoggettoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSoggettoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSoggettoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSoggettoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum PrivacyScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Privacy'),
  trattamento<bool>('trattamento', 'Privacy'),
  comunicazione<bool>('comunicazione', 'Privacy'),
  profilazione<bool>('profilazione', 'Privacy'),
  soggettoUuid<String>('soggettoUuid', 'Privacy');

  const PrivacyScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SoggettoCreateWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateWithoutPrivacyInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaCreateNestedManyWithoutSoggettoInput? praticheIntestate;

  final _i2.ContrattoCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailCreateNestedManyWithoutSoggettoInput? indirizziEmail;

  final _i2.NumeroTelefonoCreateNestedManyWithoutSoggettoInput? numeriTelefono;

  final _i2.NegozioCreateNestedOneWithoutSoggettiInput? negozioPreferito;

  final _i2.OrdineCreateNestedManyWithoutSoggettoInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutSoggettoInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class SoggettoUncheckedCreateWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedCreateWithoutPrivacyInput({
    this.uuid,
    required this.ragioneSociale,
    this.iban,
    required this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final String ragioneSociale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? iban;

  final _i3.TipoSoggetto tipo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioPreferitoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? codiceFiscale;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i2.SoggettoBusinessInfoUncheckedCreateNestedOneWithoutSoggettoInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedCreateNestedManyWithoutSoggettoInput? domicili;

  final _i2.PraticaUncheckedCreateNestedManyWithoutSoggettoInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutSoggettoInput? contratti;

  final _i2.IndirizzoEmailUncheckedCreateNestedManyWithoutSoggettoInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedCreateNestedManyWithoutSoggettoInput?
      numeriTelefono;

  final _i2.OrdineUncheckedCreateNestedManyWithoutSoggettoInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutSoggettoInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class SoggettoCreateOrConnectWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateOrConnectWithoutPrivacyInput({
    required this.where,
    required this.create,
  });

  final _i2.SoggettoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPrivacyInput,
      _i2.SoggettoUncheckedCreateWithoutPrivacyInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class SoggettoCreateNestedOneWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoCreateNestedOneWithoutPrivacyInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPrivacyInput,
      _i2.SoggettoUncheckedCreateWithoutPrivacyInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutPrivacyInput? connectOrCreate;

  final _i2.SoggettoWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class PrivacyCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCreateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggetto,
  });

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final _i2.SoggettoCreateNestedOneWithoutPrivacyInput? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggetto': soggetto,
      };
}

class PrivacyUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedCreateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCreateManyInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoUpdateWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateWithoutPrivacyInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.negozioPreferito,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUpdateManyWithoutSoggettoNestedInput? praticheIntestate;

  final _i2.ContrattoUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUpdateManyWithoutSoggettoNestedInput? indirizziEmail;

  final _i2.NumeroTelefonoUpdateManyWithoutSoggettoNestedInput? numeriTelefono;

  final _i2.NegozioUpdateOneWithoutSoggettiNestedInput? negozioPreferito;

  final _i2.OrdineUpdateManyWithoutSoggettoNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutSoggettoNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'negozioPreferito': negozioPreferito,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class SoggettoUncheckedUpdateWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUncheckedUpdateWithoutPrivacyInput({
    this.uuid,
    this.ragioneSociale,
    this.iban,
    this.tipo,
    this.negozioPreferitoUuid,
    this.codiceFiscale,
    this.note,
    this.soggettoBusinessInfo,
    this.domicili,
    this.praticheIntestate,
    this.contratti,
    this.indirizziEmail,
    this.numeriTelefono,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      ragioneSociale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? iban;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? tipo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioPreferitoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? codiceFiscale;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i2.SoggettoBusinessInfoUncheckedUpdateOneWithoutSoggettoNestedInput?
      soggettoBusinessInfo;

  final _i2.DomicilioUncheckedUpdateManyWithoutSoggettoNestedInput? domicili;

  final _i2.PraticaUncheckedUpdateManyWithoutSoggettoNestedInput?
      praticheIntestate;

  final _i2.ContrattoUncheckedUpdateManyWithoutSoggettoNestedInput? contratti;

  final _i2.IndirizzoEmailUncheckedUpdateManyWithoutSoggettoNestedInput?
      indirizziEmail;

  final _i2.NumeroTelefonoUncheckedUpdateManyWithoutSoggettoNestedInput?
      numeriTelefono;

  final _i2.OrdineUncheckedUpdateManyWithoutSoggettoNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutSoggettoNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'ragioneSociale': ragioneSociale,
        'iban': iban,
        'tipo': tipo,
        'negozioPreferitoUuid': negozioPreferitoUuid,
        'codiceFiscale': codiceFiscale,
        'note': note,
        'soggettoBusinessInfo': soggettoBusinessInfo,
        'domicili': domicili,
        'praticheIntestate': praticheIntestate,
        'contratti': contratti,
        'indirizziEmail': indirizziEmail,
        'numeriTelefono': numeriTelefono,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class SoggettoUpsertWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpsertWithoutPrivacyInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutPrivacyInput,
      _i2.SoggettoUncheckedUpdateWithoutPrivacyInput> update;

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPrivacyInput,
      _i2.SoggettoUncheckedCreateWithoutPrivacyInput> create;

  final _i2.SoggettoWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class SoggettoUpdateToOneWithWhereWithoutPrivacyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateToOneWithWhereWithoutPrivacyInput({
    this.where,
    required this.data,
  });

  final _i2.SoggettoWhereInput? where;

  final _i1.PrismaUnion<_i2.SoggettoUpdateWithoutPrivacyInput,
      _i2.SoggettoUncheckedUpdateWithoutPrivacyInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class SoggettoUpdateOneWithoutPrivacyNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoUpdateOneWithoutPrivacyNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.SoggettoCreateWithoutPrivacyInput,
      _i2.SoggettoUncheckedCreateWithoutPrivacyInput>? create;

  final _i2.SoggettoCreateOrConnectWithoutPrivacyInput? connectOrCreate;

  final _i2.SoggettoUpsertWithoutPrivacyInput? upsert;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? disconnect;

  final _i1.PrismaUnion<bool, _i2.SoggettoWhereInput>? delete;

  final _i2.SoggettoWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.SoggettoUpdateToOneWithWhereWithoutPrivacyInput,
      _i1.PrismaUnion<_i2.SoggettoUpdateWithoutPrivacyInput,
          _i2.SoggettoUncheckedUpdateWithoutPrivacyInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
      };
}

class PrivacyUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUpdateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggetto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? trattamento;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      comunicazione;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? profilazione;

  final _i2.SoggettoUpdateOneWithoutPrivacyNestedInput? soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggetto': soggetto,
      };
}

class PrivacyUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedUpdateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? trattamento;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      comunicazione;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? profilazione;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUpdateManyMutationInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? trattamento;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      comunicazione;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? profilazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
      };
}

class PrivacyUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyUncheckedUpdateManyInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? trattamento;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      comunicazione;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? profilazione;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyCountAggregateOutputType {
  const PrivacyCountAggregateOutputType({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.$all,
  });

  factory PrivacyCountAggregateOutputType.fromJson(Map json) =>
      PrivacyCountAggregateOutputType(
        uuid: json['uuid'],
        trattamento: json['trattamento'],
        comunicazione: json['comunicazione'],
        profilazione: json['profilazione'],
        soggettoUuid: json['soggettoUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? trattamento;

  final int? comunicazione;

  final int? profilazione;

  final int? soggettoUuid;

  final int? $all;
}

class PrivacyMinAggregateOutputType {
  const PrivacyMinAggregateOutputType({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  factory PrivacyMinAggregateOutputType.fromJson(Map json) =>
      PrivacyMinAggregateOutputType(
        uuid: json['uuid'],
        trattamento: json['trattamento'],
        comunicazione: json['comunicazione'],
        profilazione: json['profilazione'],
        soggettoUuid: json['soggettoUuid'],
      );

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final String? soggettoUuid;
}

class PrivacyMaxAggregateOutputType {
  const PrivacyMaxAggregateOutputType({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  factory PrivacyMaxAggregateOutputType.fromJson(Map json) =>
      PrivacyMaxAggregateOutputType(
        uuid: json['uuid'],
        trattamento: json['trattamento'],
        comunicazione: json['comunicazione'],
        profilazione: json['profilazione'],
        soggettoUuid: json['soggettoUuid'],
      );

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final String? soggettoUuid;
}

class PrivacyGroupByOutputType {
  const PrivacyGroupByOutputType({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory PrivacyGroupByOutputType.fromJson(Map json) =>
      PrivacyGroupByOutputType(
        uuid: json['uuid'],
        trattamento: json['trattamento'],
        comunicazione: json['comunicazione'],
        profilazione: json['profilazione'],
        soggettoUuid: json['soggettoUuid'],
        $count: json['_count'] is Map
            ? _i2.PrivacyCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PrivacyMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PrivacyMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final String? soggettoUuid;

  final _i2.PrivacyCountAggregateOutputType? $count;

  final _i2.PrivacyMinAggregateOutputType? $min;

  final _i2.PrivacyMaxAggregateOutputType? $max;
}

class PrivacyCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCountOrderByAggregateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? trattamento;

  final _i2.SortOrder? comunicazione;

  final _i2.SortOrder? profilazione;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyMaxOrderByAggregateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? trattamento;

  final _i2.SortOrder? comunicazione;

  final _i2.SortOrder? profilazione;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyMinOrderByAggregateInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? trattamento;

  final _i2.SortOrder? comunicazione;

  final _i2.SortOrder? profilazione;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyOrderByWithAggregationInput({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? trattamento;

  final _i2.SortOrder? comunicazione;

  final _i2.SortOrder? profilazione;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i2.PrivacyCountOrderByAggregateInput? $count;

  final _i2.PrivacyMaxOrderByAggregateInput? $max;

  final _i2.PrivacyMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NestedBoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class BoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class PrivacyScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<_i2.PrivacyScalarWhereWithAggregatesInput,
      Iterable<_i2.PrivacyScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.PrivacyScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.PrivacyScalarWhereWithAggregatesInput,
      Iterable<_i2.PrivacyScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? trattamento;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? comunicazione;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? profilazione;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyCountAggregateOutputTypeSelect({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final bool? soggettoUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
        '_all': $all,
      };
}

class PrivacyGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyGroupByOutputTypeCountArgs({this.select});

  final _i2.PrivacyCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PrivacyMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyMinAggregateOutputTypeSelect({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final bool? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final bool? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyGroupByOutputTypeMinArgs({this.select});

  final _i2.PrivacyMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PrivacyMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyMaxAggregateOutputTypeSelect({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
  });

  final bool? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final bool? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
      };
}

class PrivacyGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyGroupByOutputTypeMaxArgs({this.select});

  final _i2.PrivacyMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PrivacyGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PrivacyGroupByOutputTypeSelect({
    this.uuid,
    this.trattamento,
    this.comunicazione,
    this.profilazione,
    this.soggettoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? trattamento;

  final bool? comunicazione;

  final bool? profilazione;

  final bool? soggettoUuid;

  final _i1.PrismaUnion<bool, _i2.PrivacyGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.PrivacyGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.PrivacyGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'trattamento': trattamento,
        'comunicazione': comunicazione,
        'profilazione': profilazione,
        'soggettoUuid': soggettoUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregatePrivacy {
  const AggregatePrivacy({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregatePrivacy.fromJson(Map json) => AggregatePrivacy(
        $count: json['_count'] is Map
            ? _i2.PrivacyCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PrivacyMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PrivacyMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.PrivacyCountAggregateOutputType? $count;

  final _i2.PrivacyMinAggregateOutputType? $min;

  final _i2.PrivacyMaxAggregateOutputType? $max;
}

class AggregatePrivacyCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePrivacyCountArgs({this.select});

  final _i2.PrivacyCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePrivacyMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePrivacyMinArgs({this.select});

  final _i2.PrivacyMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePrivacyMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePrivacyMaxArgs({this.select});

  final _i2.PrivacyMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePrivacySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePrivacySelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregatePrivacyCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregatePrivacyMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregatePrivacyMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum SoggettoBusinessInfoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'SoggettoBusinessInfo'),
  rea<String>('rea', 'SoggettoBusinessInfo'),
  partitaIVA<String>('partitaIVA', 'SoggettoBusinessInfo'),
  sdi<String>('sdi', 'SoggettoBusinessInfo'),
  soggettoUuid<String>('soggettoUuid', 'SoggettoBusinessInfo');

  const SoggettoBusinessInfoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SoggettoBusinessInfoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
    required this.soggetto,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutSoggettoBusinessInfoInput?
      legaleRappresentante;

  final _i2.ReferenteCreateNestedOneWithoutSoggettoBusinessInfoInput? referente;

  final _i2.SoggettoCreateNestedOneWithoutSoggettoBusinessInfoInput soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedCreateInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    required this.soggettoUuid,
    this.legaleRappresentante,
    this.referente,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final String soggettoUuid;

  final _i2
      .LegaleRappresentanteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput?
      legaleRappresentante;

  final _i2.ReferenteUncheckedCreateNestedOneWithoutSoggettoBusinessInfoInput?
      referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
      };
}

class SoggettoBusinessInfoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCreateManyInput({
    this.uuid,
    this.rea,
    required this.partitaIVA,
    this.sdi,
    required this.soggettoUuid,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? rea;

  final String partitaIVA;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sdi;

  final String soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.legaleRappresentante,
    this.referente,
    this.soggetto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i2.LegaleRappresentanteUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      legaleRappresentante;

  final _i2.ReferenteUpdateOneWithoutSoggettoBusinessInfoNestedInput? referente;

  final _i2.SoggettoUpdateOneRequiredWithoutSoggettoBusinessInfoNestedInput?
      soggetto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
        'soggetto': soggetto,
      };
}

class SoggettoBusinessInfoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedUpdateInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.legaleRappresentante,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .LegaleRappresentanteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      legaleRappresentante;

  final _i2.ReferenteUncheckedUpdateOneWithoutSoggettoBusinessInfoNestedInput?
      referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentante': legaleRappresentante,
        'referente': referente,
      };
}

class SoggettoBusinessInfoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUpdateManyMutationInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
      };
}

class SoggettoBusinessInfoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoUncheckedUpdateManyInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      partitaIVA;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoCountAggregateOutputType {
  const SoggettoBusinessInfoCountAggregateOutputType({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.$all,
  });

  factory SoggettoBusinessInfoCountAggregateOutputType.fromJson(Map json) =>
      SoggettoBusinessInfoCountAggregateOutputType(
        uuid: json['uuid'],
        rea: json['rea'],
        partitaIVA: json['partitaIVA'],
        sdi: json['sdi'],
        soggettoUuid: json['soggettoUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? rea;

  final int? partitaIVA;

  final int? sdi;

  final int? soggettoUuid;

  final int? $all;
}

class SoggettoBusinessInfoMinAggregateOutputType {
  const SoggettoBusinessInfoMinAggregateOutputType({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  factory SoggettoBusinessInfoMinAggregateOutputType.fromJson(Map json) =>
      SoggettoBusinessInfoMinAggregateOutputType(
        uuid: json['uuid'],
        rea: json['rea'],
        partitaIVA: json['partitaIVA'],
        sdi: json['sdi'],
        soggettoUuid: json['soggettoUuid'],
      );

  final String? uuid;

  final String? rea;

  final String? partitaIVA;

  final String? sdi;

  final String? soggettoUuid;
}

class SoggettoBusinessInfoMaxAggregateOutputType {
  const SoggettoBusinessInfoMaxAggregateOutputType({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  factory SoggettoBusinessInfoMaxAggregateOutputType.fromJson(Map json) =>
      SoggettoBusinessInfoMaxAggregateOutputType(
        uuid: json['uuid'],
        rea: json['rea'],
        partitaIVA: json['partitaIVA'],
        sdi: json['sdi'],
        soggettoUuid: json['soggettoUuid'],
      );

  final String? uuid;

  final String? rea;

  final String? partitaIVA;

  final String? sdi;

  final String? soggettoUuid;
}

class SoggettoBusinessInfoGroupByOutputType {
  const SoggettoBusinessInfoGroupByOutputType({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory SoggettoBusinessInfoGroupByOutputType.fromJson(Map json) =>
      SoggettoBusinessInfoGroupByOutputType(
        uuid: json['uuid'],
        rea: json['rea'],
        partitaIVA: json['partitaIVA'],
        sdi: json['sdi'],
        soggettoUuid: json['soggettoUuid'],
        $count: json['_count'] is Map
            ? _i2.SoggettoBusinessInfoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SoggettoBusinessInfoMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SoggettoBusinessInfoMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final String? uuid;

  final String? rea;

  final String? partitaIVA;

  final String? sdi;

  final String? soggettoUuid;

  final _i2.SoggettoBusinessInfoCountAggregateOutputType? $count;

  final _i2.SoggettoBusinessInfoMinAggregateOutputType? $min;

  final _i2.SoggettoBusinessInfoMaxAggregateOutputType? $max;
}

class SoggettoBusinessInfoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCountOrderByAggregateInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? rea;

  final _i2.SortOrder? partitaIVA;

  final _i2.SortOrder? sdi;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoMaxOrderByAggregateInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? rea;

  final _i2.SortOrder? partitaIVA;

  final _i2.SortOrder? sdi;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoMinOrderByAggregateInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? rea;

  final _i2.SortOrder? partitaIVA;

  final _i2.SortOrder? sdi;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoOrderByWithAggregationInput({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? rea;

  final _i2.SortOrder? partitaIVA;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sdi;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SoggettoBusinessInfoCountOrderByAggregateInput? $count;

  final _i2.SoggettoBusinessInfoMaxOrderByAggregateInput? $max;

  final _i2.SoggettoBusinessInfoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class SoggettoBusinessInfoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoScalarWhereWithAggregatesInput,
      Iterable<_i2.SoggettoBusinessInfoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.SoggettoBusinessInfoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.SoggettoBusinessInfoScalarWhereWithAggregatesInput,
      Iterable<_i2.SoggettoBusinessInfoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? rea;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? partitaIVA;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sdi;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoCountAggregateOutputTypeSelect({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? rea;

  final bool? partitaIVA;

  final bool? sdi;

  final bool? soggettoUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        '_all': $all,
      };
}

class SoggettoBusinessInfoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoGroupByOutputTypeCountArgs({this.select});

  final _i2.SoggettoBusinessInfoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoBusinessInfoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoMinAggregateOutputTypeSelect({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final bool? uuid;

  final bool? rea;

  final bool? partitaIVA;

  final bool? sdi;

  final bool? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoGroupByOutputTypeMinArgs({this.select});

  final _i2.SoggettoBusinessInfoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoBusinessInfoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoMaxAggregateOutputTypeSelect({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
  });

  final bool? uuid;

  final bool? rea;

  final bool? partitaIVA;

  final bool? sdi;

  final bool? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
      };
}

class SoggettoBusinessInfoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoGroupByOutputTypeMaxArgs({this.select});

  final _i2.SoggettoBusinessInfoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SoggettoBusinessInfoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SoggettoBusinessInfoGroupByOutputTypeSelect({
    this.uuid,
    this.rea,
    this.partitaIVA,
    this.sdi,
    this.soggettoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? rea;

  final bool? partitaIVA;

  final bool? sdi;

  final bool? soggettoUuid;

  final _i1
      .PrismaUnion<bool, _i2.SoggettoBusinessInfoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.SoggettoBusinessInfoGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'rea': rea,
        'partitaIVA': partitaIVA,
        'sdi': sdi,
        'soggettoUuid': soggettoUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateSoggettoBusinessInfo {
  const AggregateSoggettoBusinessInfo({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateSoggettoBusinessInfo.fromJson(Map json) =>
      AggregateSoggettoBusinessInfo(
        $count: json['_count'] is Map
            ? _i2.SoggettoBusinessInfoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SoggettoBusinessInfoMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SoggettoBusinessInfoMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final _i2.SoggettoBusinessInfoCountAggregateOutputType? $count;

  final _i2.SoggettoBusinessInfoMinAggregateOutputType? $min;

  final _i2.SoggettoBusinessInfoMaxAggregateOutputType? $max;
}

class AggregateSoggettoBusinessInfoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoBusinessInfoCountArgs({this.select});

  final _i2.SoggettoBusinessInfoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSoggettoBusinessInfoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoBusinessInfoMinArgs({this.select});

  final _i2.SoggettoBusinessInfoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSoggettoBusinessInfoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoBusinessInfoMaxArgs({this.select});

  final _i2.SoggettoBusinessInfoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSoggettoBusinessInfoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSoggettoBusinessInfoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSoggettoBusinessInfoCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSoggettoBusinessInfoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSoggettoBusinessInfoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum LegaleRappresentanteScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'LegaleRappresentante'),
  nome<String>('nome', 'LegaleRappresentante'),
  cognome<String>('cognome', 'LegaleRappresentante'),
  soggettoBusinessInfoUuid<String>(
      'soggettoBusinessInfoUuid', 'LegaleRappresentante');

  const LegaleRappresentanteScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class LegaleRappresentanteCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
    required this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoCreateNestedOneWithoutLegaleRappresentateInput?
      numeroTelefono;

  final _i2.IndirizzoEmailCreateNestedOneWithoutLegaleRappresentanteInput?
      indirizzoEmail;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutLegaleRappresentanteInput
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedCreateInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  final _i2
      .NumeroTelefonoUncheckedCreateNestedOneWithoutLegaleRappresentateInput?
      numeroTelefono;

  final _i2
      .IndirizzoEmailUncheckedCreateNestedOneWithoutLegaleRappresentanteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCreateManyInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUpdateOneWithoutLegaleRappresentateNestedInput?
      numeroTelefono;

  final _i2.IndirizzoEmailUpdateOneWithoutLegaleRappresentanteNestedInput?
      indirizzoEmail;

  final _i2
      .SoggettoBusinessInfoUpdateOneRequiredWithoutLegaleRappresentanteNestedInput?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class LegaleRappresentanteUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedUpdateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  final _i2
      .NumeroTelefonoUncheckedUpdateOneWithoutLegaleRappresentateNestedInput?
      numeroTelefono;

  final _i2
      .IndirizzoEmailUncheckedUpdateOneWithoutLegaleRappresentanteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class LegaleRappresentanteUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUpdateManyMutationInput({
    this.uuid,
    this.nome,
    this.cognome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
      };
}

class LegaleRappresentanteUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteUncheckedUpdateManyInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteCountAggregateOutputType {
  const LegaleRappresentanteCountAggregateOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$all,
  });

  factory LegaleRappresentanteCountAggregateOutputType.fromJson(Map json) =>
      LegaleRappresentanteCountAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? nome;

  final int? cognome;

  final int? soggettoBusinessInfoUuid;

  final int? $all;
}

class LegaleRappresentanteMinAggregateOutputType {
  const LegaleRappresentanteMinAggregateOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  factory LegaleRappresentanteMinAggregateOutputType.fromJson(Map json) =>
      LegaleRappresentanteMinAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
      );

  final String? uuid;

  final String? nome;

  final String? cognome;

  final String? soggettoBusinessInfoUuid;
}

class LegaleRappresentanteMaxAggregateOutputType {
  const LegaleRappresentanteMaxAggregateOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  factory LegaleRappresentanteMaxAggregateOutputType.fromJson(Map json) =>
      LegaleRappresentanteMaxAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
      );

  final String? uuid;

  final String? nome;

  final String? cognome;

  final String? soggettoBusinessInfoUuid;
}

class LegaleRappresentanteGroupByOutputType {
  const LegaleRappresentanteGroupByOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory LegaleRappresentanteGroupByOutputType.fromJson(Map json) =>
      LegaleRappresentanteGroupByOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
        $count: json['_count'] is Map
            ? _i2.LegaleRappresentanteCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.LegaleRappresentanteMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.LegaleRappresentanteMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final String? uuid;

  final String? nome;

  final String? cognome;

  final String? soggettoBusinessInfoUuid;

  final _i2.LegaleRappresentanteCountAggregateOutputType? $count;

  final _i2.LegaleRappresentanteMinAggregateOutputType? $min;

  final _i2.LegaleRappresentanteMaxAggregateOutputType? $max;
}

class LegaleRappresentanteCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCountOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteMaxOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteMinOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteOrderByWithAggregationInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  final _i2.LegaleRappresentanteCountOrderByAggregateInput? $count;

  final _i2.LegaleRappresentanteMaxOrderByAggregateInput? $max;

  final _i2.LegaleRappresentanteMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class LegaleRappresentanteScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i1.PrismaUnion<_i2.LegaleRappresentanteScalarWhereWithAggregatesInput,
      Iterable<_i2.LegaleRappresentanteScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.LegaleRappresentanteScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.LegaleRappresentanteScalarWhereWithAggregatesInput,
      Iterable<_i2.LegaleRappresentanteScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? cognome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteCountAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        '_all': $all,
      };
}

class LegaleRappresentanteGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteGroupByOutputTypeCountArgs({this.select});

  final _i2.LegaleRappresentanteCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LegaleRappresentanteMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteMinAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteGroupByOutputTypeMinArgs({this.select});

  final _i2.LegaleRappresentanteMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LegaleRappresentanteMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteMaxAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class LegaleRappresentanteGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteGroupByOutputTypeMaxArgs({this.select});

  final _i2.LegaleRappresentanteMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LegaleRappresentanteGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LegaleRappresentanteGroupByOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  final _i1
      .PrismaUnion<bool, _i2.LegaleRappresentanteGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.LegaleRappresentanteGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateLegaleRappresentante {
  const AggregateLegaleRappresentante({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateLegaleRappresentante.fromJson(Map json) =>
      AggregateLegaleRappresentante(
        $count: json['_count'] is Map
            ? _i2.LegaleRappresentanteCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.LegaleRappresentanteMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.LegaleRappresentanteMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final _i2.LegaleRappresentanteCountAggregateOutputType? $count;

  final _i2.LegaleRappresentanteMinAggregateOutputType? $min;

  final _i2.LegaleRappresentanteMaxAggregateOutputType? $max;
}

class AggregateLegaleRappresentanteCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLegaleRappresentanteCountArgs({this.select});

  final _i2.LegaleRappresentanteCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateLegaleRappresentanteMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLegaleRappresentanteMinArgs({this.select});

  final _i2.LegaleRappresentanteMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateLegaleRappresentanteMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLegaleRappresentanteMaxArgs({this.select});

  final _i2.LegaleRappresentanteMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateLegaleRappresentanteSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLegaleRappresentanteSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateLegaleRappresentanteCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.AggregateLegaleRappresentanteMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateLegaleRappresentanteMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum ReferenteScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'Referente'),
  nome<String>('nome', 'Referente'),
  cognome<String>('cognome', 'Referente'),
  soggettoBusinessInfoUuid<String>('soggettoBusinessInfoUuid', 'Referente');

  const ReferenteScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ReferenteCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
    required this.soggettoBusinessInfo,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final _i2.NumeroTelefonoCreateNestedOneWithoutReferenteInput? numeroTelefono;

  final _i2.IndirizzoEmailCreateNestedOneWithoutReferenteInput? indirizzoEmail;

  final _i2.SoggettoBusinessInfoCreateNestedOneWithoutReferenteInput
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedCreateInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  final _i2.NumeroTelefonoUncheckedCreateNestedOneWithoutReferenteInput?
      numeroTelefono;

  final _i2.IndirizzoEmailUncheckedCreateNestedOneWithoutReferenteInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class ReferenteCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCreateManyInput({
    this.uuid,
    required this.nome,
    required this.cognome,
    required this.soggettoBusinessInfoUuid,
  });

  final String? uuid;

  final String nome;

  final String cognome;

  final String soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.numeroTelefono,
    this.indirizzoEmail,
    this.soggettoBusinessInfo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i2.NumeroTelefonoUpdateOneWithoutReferenteNestedInput? numeroTelefono;

  final _i2.IndirizzoEmailUpdateOneWithoutReferenteNestedInput? indirizzoEmail;

  final _i2.SoggettoBusinessInfoUpdateOneRequiredWithoutReferenteNestedInput?
      soggettoBusinessInfo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
        'soggettoBusinessInfo': soggettoBusinessInfo,
      };
}

class ReferenteUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedUpdateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.numeroTelefono,
    this.indirizzoEmail,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  final _i2.NumeroTelefonoUncheckedUpdateOneWithoutReferenteNestedInput?
      numeroTelefono;

  final _i2.IndirizzoEmailUncheckedUpdateOneWithoutReferenteNestedInput?
      indirizzoEmail;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        'numeroTelefono': numeroTelefono,
        'indirizzoEmail': indirizzoEmail,
      };
}

class ReferenteUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUpdateManyMutationInput({
    this.uuid,
    this.nome,
    this.cognome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
      };
}

class ReferenteUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteUncheckedUpdateManyInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? cognome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteCountAggregateOutputType {
  const ReferenteCountAggregateOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$all,
  });

  factory ReferenteCountAggregateOutputType.fromJson(Map json) =>
      ReferenteCountAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? nome;

  final int? cognome;

  final int? soggettoBusinessInfoUuid;

  final int? $all;
}

class ReferenteMinAggregateOutputType {
  const ReferenteMinAggregateOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  factory ReferenteMinAggregateOutputType.fromJson(Map json) =>
      ReferenteMinAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
      );

  final String? uuid;

  final String? nome;

  final String? cognome;

  final String? soggettoBusinessInfoUuid;
}

class ReferenteMaxAggregateOutputType {
  const ReferenteMaxAggregateOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  factory ReferenteMaxAggregateOutputType.fromJson(Map json) =>
      ReferenteMaxAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
      );

  final String? uuid;

  final String? nome;

  final String? cognome;

  final String? soggettoBusinessInfoUuid;
}

class ReferenteGroupByOutputType {
  const ReferenteGroupByOutputType({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ReferenteGroupByOutputType.fromJson(Map json) =>
      ReferenteGroupByOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        cognome: json['cognome'],
        soggettoBusinessInfoUuid: json['soggettoBusinessInfoUuid'],
        $count: json['_count'] is Map
            ? _i2.ReferenteCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ReferenteMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ReferenteMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? nome;

  final String? cognome;

  final String? soggettoBusinessInfoUuid;

  final _i2.ReferenteCountAggregateOutputType? $count;

  final _i2.ReferenteMinAggregateOutputType? $min;

  final _i2.ReferenteMaxAggregateOutputType? $max;
}

class ReferenteCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCountOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteMaxOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteMinOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteOrderByWithAggregationInput({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? cognome;

  final _i2.SortOrder? soggettoBusinessInfoUuid;

  final _i2.ReferenteCountOrderByAggregateInput? $count;

  final _i2.ReferenteMaxOrderByAggregateInput? $max;

  final _i2.ReferenteMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class ReferenteScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final _i1.PrismaUnion<_i2.ReferenteScalarWhereWithAggregatesInput,
      Iterable<_i2.ReferenteScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ReferenteScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ReferenteScalarWhereWithAggregatesInput,
      Iterable<_i2.ReferenteScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? cognome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteCountAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        '_all': $all,
      };
}

class ReferenteGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteGroupByOutputTypeCountArgs({this.select});

  final _i2.ReferenteCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReferenteMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteMinAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteGroupByOutputTypeMinArgs({this.select});

  final _i2.ReferenteMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReferenteMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteMaxAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
      };
}

class ReferenteGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteGroupByOutputTypeMaxArgs({this.select});

  final _i2.ReferenteMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ReferenteGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ReferenteGroupByOutputTypeSelect({
    this.uuid,
    this.nome,
    this.cognome,
    this.soggettoBusinessInfoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? nome;

  final bool? cognome;

  final bool? soggettoBusinessInfoUuid;

  final _i1.PrismaUnion<bool, _i2.ReferenteGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ReferenteGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ReferenteGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'cognome': cognome,
        'soggettoBusinessInfoUuid': soggettoBusinessInfoUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateReferente {
  const AggregateReferente({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateReferente.fromJson(Map json) => AggregateReferente(
        $count: json['_count'] is Map
            ? _i2.ReferenteCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ReferenteMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ReferenteMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ReferenteCountAggregateOutputType? $count;

  final _i2.ReferenteMinAggregateOutputType? $min;

  final _i2.ReferenteMaxAggregateOutputType? $max;
}

class AggregateReferenteCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReferenteCountArgs({this.select});

  final _i2.ReferenteCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReferenteMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReferenteMinArgs({this.select});

  final _i2.ReferenteMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReferenteMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReferenteMaxArgs({this.select});

  final _i2.ReferenteMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateReferenteSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateReferenteSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateReferenteCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateReferenteMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateReferenteMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class IndirizzoEmailCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.SoggettoCreateNestedOneWithoutIndirizziEmailInput? soggetto;

  final _i2.ReferenteCreateNestedOneWithoutIndirizzoEmailInput? referente;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutIndirizzoEmailInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedCreateInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCreateManyInput({
    this.uuid,
    required this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUpdateInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggetto,
    this.referente,
    this.legaleRappresentante,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.SoggettoUpdateOneWithoutIndirizziEmailNestedInput? soggetto;

  final _i2.ReferenteUpdateOneWithoutIndirizzoEmailNestedInput? referente;

  final _i2.LegaleRappresentanteUpdateOneWithoutIndirizzoEmailNestedInput?
      legaleRappresentante;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'referente': referente,
        'legaleRappresentante': legaleRappresentante,
      };
}

class IndirizzoEmailUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailUncheckedUpdateManyInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailCountAggregateOutputType {
  const IndirizzoEmailCountAggregateOutputType({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.$all,
  });

  factory IndirizzoEmailCountAggregateOutputType.fromJson(Map json) =>
      IndirizzoEmailCountAggregateOutputType(
        uuid: json['uuid'],
        indirizzo: json['indirizzo'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentanteUuid: json['legaleRappresentanteUuid'],
        referenteUuid: json['referenteUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? indirizzo;

  final int? etichetta;

  final int? soggettoUuid;

  final int? legaleRappresentanteUuid;

  final int? referenteUuid;

  final int? $all;
}

class IndirizzoEmailMinAggregateOutputType {
  const IndirizzoEmailMinAggregateOutputType({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  factory IndirizzoEmailMinAggregateOutputType.fromJson(Map json) =>
      IndirizzoEmailMinAggregateOutputType(
        uuid: json['uuid'],
        indirizzo: json['indirizzo'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentanteUuid: json['legaleRappresentanteUuid'],
        referenteUuid: json['referenteUuid'],
      );

  final String? uuid;

  final String? indirizzo;

  final String? etichetta;

  final String? soggettoUuid;

  final String? legaleRappresentanteUuid;

  final String? referenteUuid;
}

class IndirizzoEmailMaxAggregateOutputType {
  const IndirizzoEmailMaxAggregateOutputType({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  factory IndirizzoEmailMaxAggregateOutputType.fromJson(Map json) =>
      IndirizzoEmailMaxAggregateOutputType(
        uuid: json['uuid'],
        indirizzo: json['indirizzo'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentanteUuid: json['legaleRappresentanteUuid'],
        referenteUuid: json['referenteUuid'],
      );

  final String? uuid;

  final String? indirizzo;

  final String? etichetta;

  final String? soggettoUuid;

  final String? legaleRappresentanteUuid;

  final String? referenteUuid;
}

class IndirizzoEmailGroupByOutputType {
  const IndirizzoEmailGroupByOutputType({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory IndirizzoEmailGroupByOutputType.fromJson(Map json) =>
      IndirizzoEmailGroupByOutputType(
        uuid: json['uuid'],
        indirizzo: json['indirizzo'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentanteUuid: json['legaleRappresentanteUuid'],
        referenteUuid: json['referenteUuid'],
        $count: json['_count'] is Map
            ? _i2.IndirizzoEmailCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.IndirizzoEmailMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.IndirizzoEmailMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? indirizzo;

  final String? etichetta;

  final String? soggettoUuid;

  final String? legaleRappresentanteUuid;

  final String? referenteUuid;

  final _i2.IndirizzoEmailCountAggregateOutputType? $count;

  final _i2.IndirizzoEmailMinAggregateOutputType? $min;

  final _i2.IndirizzoEmailMaxAggregateOutputType? $max;
}

class IndirizzoEmailCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCountOrderByAggregateInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? indirizzo;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? legaleRappresentanteUuid;

  final _i2.SortOrder? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailMaxOrderByAggregateInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? indirizzo;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? legaleRappresentanteUuid;

  final _i2.SortOrder? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailMinOrderByAggregateInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? indirizzo;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? legaleRappresentanteUuid;

  final _i2.SortOrder? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailOrderByWithAggregationInput({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? indirizzo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      legaleRappresentanteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? referenteUuid;

  final _i2.IndirizzoEmailCountOrderByAggregateInput? $count;

  final _i2.IndirizzoEmailMaxOrderByAggregateInput? $max;

  final _i2.IndirizzoEmailMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class IndirizzoEmailScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalarWhereWithAggregatesInput,
      Iterable<_i2.IndirizzoEmailScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.IndirizzoEmailScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.IndirizzoEmailScalarWhereWithAggregatesInput,
      Iterable<_i2.IndirizzoEmailScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? legaleRappresentanteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailCountAggregateOutputTypeSelect({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? indirizzo;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentanteUuid;

  final bool? referenteUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        '_all': $all,
      };
}

class IndirizzoEmailGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailGroupByOutputTypeCountArgs({this.select});

  final _i2.IndirizzoEmailCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IndirizzoEmailMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailMinAggregateOutputTypeSelect({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final bool? uuid;

  final bool? indirizzo;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentanteUuid;

  final bool? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailGroupByOutputTypeMinArgs({this.select});

  final _i2.IndirizzoEmailMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IndirizzoEmailMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailMaxAggregateOutputTypeSelect({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
  });

  final bool? uuid;

  final bool? indirizzo;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentanteUuid;

  final bool? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
      };
}

class IndirizzoEmailGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailGroupByOutputTypeMaxArgs({this.select});

  final _i2.IndirizzoEmailMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IndirizzoEmailGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IndirizzoEmailGroupByOutputTypeSelect({
    this.uuid,
    this.indirizzo,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentanteUuid,
    this.referenteUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? indirizzo;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentanteUuid;

  final bool? referenteUuid;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.IndirizzoEmailGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'indirizzo': indirizzo,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentanteUuid': legaleRappresentanteUuid,
        'referenteUuid': referenteUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateIndirizzoEmail {
  const AggregateIndirizzoEmail({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateIndirizzoEmail.fromJson(Map json) => AggregateIndirizzoEmail(
        $count: json['_count'] is Map
            ? _i2.IndirizzoEmailCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.IndirizzoEmailMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.IndirizzoEmailMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.IndirizzoEmailCountAggregateOutputType? $count;

  final _i2.IndirizzoEmailMinAggregateOutputType? $min;

  final _i2.IndirizzoEmailMaxAggregateOutputType? $max;
}

class AggregateIndirizzoEmailCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIndirizzoEmailCountArgs({this.select});

  final _i2.IndirizzoEmailCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIndirizzoEmailMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIndirizzoEmailMinArgs({this.select});

  final _i2.IndirizzoEmailMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIndirizzoEmailMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIndirizzoEmailMaxArgs({this.select});

  final _i2.IndirizzoEmailMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIndirizzoEmailSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIndirizzoEmailSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateIndirizzoEmailCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateIndirizzoEmailMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateIndirizzoEmailMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NumeroTelefonoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.SoggettoCreateNestedOneWithoutNumeriTelefonoInput? soggetto;

  final _i2.LegaleRappresentanteCreateNestedOneWithoutNumeroTelefonoInput?
      legaleRappresentate;

  final _i2.ReferenteCreateNestedOneWithoutNumeroTelefonoInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class NumeroTelefonoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedCreateInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentateUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCreateManyInput({
    this.uuid,
    required this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final String? uuid;

  final String numero;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? legaleRappresentateUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUpdateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggetto,
    this.legaleRappresentate,
    this.referente,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.SoggettoUpdateOneWithoutNumeriTelefonoNestedInput? soggetto;

  final _i2.LegaleRappresentanteUpdateOneWithoutNumeroTelefonoNestedInput?
      legaleRappresentate;

  final _i2.ReferenteUpdateOneWithoutNumeroTelefonoNestedInput? referente;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggetto': soggetto,
        'legaleRappresentate': legaleRappresentate,
        'referente': referente,
      };
}

class NumeroTelefonoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoUncheckedUpdateManyInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? numero;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoCountAggregateOutputType {
  const NumeroTelefonoCountAggregateOutputType({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.$all,
  });

  factory NumeroTelefonoCountAggregateOutputType.fromJson(Map json) =>
      NumeroTelefonoCountAggregateOutputType(
        uuid: json['uuid'],
        numero: json['numero'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentateUuid: json['legaleRappresentateUuid'],
        referenteUuid: json['referenteUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? numero;

  final int? etichetta;

  final int? soggettoUuid;

  final int? legaleRappresentateUuid;

  final int? referenteUuid;

  final int? $all;
}

class NumeroTelefonoMinAggregateOutputType {
  const NumeroTelefonoMinAggregateOutputType({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  factory NumeroTelefonoMinAggregateOutputType.fromJson(Map json) =>
      NumeroTelefonoMinAggregateOutputType(
        uuid: json['uuid'],
        numero: json['numero'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentateUuid: json['legaleRappresentateUuid'],
        referenteUuid: json['referenteUuid'],
      );

  final String? uuid;

  final String? numero;

  final String? etichetta;

  final String? soggettoUuid;

  final String? legaleRappresentateUuid;

  final String? referenteUuid;
}

class NumeroTelefonoMaxAggregateOutputType {
  const NumeroTelefonoMaxAggregateOutputType({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  factory NumeroTelefonoMaxAggregateOutputType.fromJson(Map json) =>
      NumeroTelefonoMaxAggregateOutputType(
        uuid: json['uuid'],
        numero: json['numero'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentateUuid: json['legaleRappresentateUuid'],
        referenteUuid: json['referenteUuid'],
      );

  final String? uuid;

  final String? numero;

  final String? etichetta;

  final String? soggettoUuid;

  final String? legaleRappresentateUuid;

  final String? referenteUuid;
}

class NumeroTelefonoGroupByOutputType {
  const NumeroTelefonoGroupByOutputType({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NumeroTelefonoGroupByOutputType.fromJson(Map json) =>
      NumeroTelefonoGroupByOutputType(
        uuid: json['uuid'],
        numero: json['numero'],
        etichetta: json['etichetta'],
        soggettoUuid: json['soggettoUuid'],
        legaleRappresentateUuid: json['legaleRappresentateUuid'],
        referenteUuid: json['referenteUuid'],
        $count: json['_count'] is Map
            ? _i2.NumeroTelefonoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.NumeroTelefonoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.NumeroTelefonoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? numero;

  final String? etichetta;

  final String? soggettoUuid;

  final String? legaleRappresentateUuid;

  final String? referenteUuid;

  final _i2.NumeroTelefonoCountAggregateOutputType? $count;

  final _i2.NumeroTelefonoMinAggregateOutputType? $min;

  final _i2.NumeroTelefonoMaxAggregateOutputType? $max;
}

class NumeroTelefonoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCountOrderByAggregateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? numero;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? legaleRappresentateUuid;

  final _i2.SortOrder? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoMaxOrderByAggregateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? numero;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? legaleRappresentateUuid;

  final _i2.SortOrder? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoMinOrderByAggregateInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? numero;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? legaleRappresentateUuid;

  final _i2.SortOrder? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoOrderByWithAggregationInput({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? numero;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      legaleRappresentateUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? referenteUuid;

  final _i2.NumeroTelefonoCountOrderByAggregateInput? $count;

  final _i2.NumeroTelefonoMaxOrderByAggregateInput? $max;

  final _i2.NumeroTelefonoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NumeroTelefonoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalarWhereWithAggregatesInput,
      Iterable<_i2.NumeroTelefonoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.NumeroTelefonoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.NumeroTelefonoScalarWhereWithAggregatesInput,
      Iterable<_i2.NumeroTelefonoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? numero;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? legaleRappresentateUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoCountAggregateOutputTypeSelect({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? numero;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentateUuid;

  final bool? referenteUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        '_all': $all,
      };
}

class NumeroTelefonoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoGroupByOutputTypeCountArgs({this.select});

  final _i2.NumeroTelefonoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NumeroTelefonoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoMinAggregateOutputTypeSelect({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final bool? uuid;

  final bool? numero;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentateUuid;

  final bool? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoGroupByOutputTypeMinArgs({this.select});

  final _i2.NumeroTelefonoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NumeroTelefonoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoMaxAggregateOutputTypeSelect({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
  });

  final bool? uuid;

  final bool? numero;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentateUuid;

  final bool? referenteUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
      };
}

class NumeroTelefonoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoGroupByOutputTypeMaxArgs({this.select});

  final _i2.NumeroTelefonoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NumeroTelefonoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NumeroTelefonoGroupByOutputTypeSelect({
    this.uuid,
    this.numero,
    this.etichetta,
    this.soggettoUuid,
    this.legaleRappresentateUuid,
    this.referenteUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? numero;

  final bool? etichetta;

  final bool? soggettoUuid;

  final bool? legaleRappresentateUuid;

  final bool? referenteUuid;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.NumeroTelefonoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'numero': numero,
        'etichetta': etichetta,
        'soggettoUuid': soggettoUuid,
        'legaleRappresentateUuid': legaleRappresentateUuid,
        'referenteUuid': referenteUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateNumeroTelefono {
  const AggregateNumeroTelefono({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateNumeroTelefono.fromJson(Map json) => AggregateNumeroTelefono(
        $count: json['_count'] is Map
            ? _i2.NumeroTelefonoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.NumeroTelefonoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.NumeroTelefonoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.NumeroTelefonoCountAggregateOutputType? $count;

  final _i2.NumeroTelefonoMinAggregateOutputType? $min;

  final _i2.NumeroTelefonoMaxAggregateOutputType? $max;
}

class AggregateNumeroTelefonoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNumeroTelefonoCountArgs({this.select});

  final _i2.NumeroTelefonoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNumeroTelefonoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNumeroTelefonoMinArgs({this.select});

  final _i2.NumeroTelefonoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNumeroTelefonoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNumeroTelefonoMaxArgs({this.select});

  final _i2.NumeroTelefonoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNumeroTelefonoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNumeroTelefonoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateNumeroTelefonoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateNumeroTelefonoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateNumeroTelefonoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class DomicilioCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final _i2.SoggettoCreateNestedOneWithoutDomiciliInput soggetto;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineCreateNestedManyWithoutDomicilioInput? prodottiOrdinati;

  final _i2.LeadCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedCreateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedCreateNestedManyWithoutDomicilioInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutDomicilioInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedCreateNestedManyWithoutDomicilioInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedCreateNestedManyWithoutDomicilioInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCreateManyInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    required this.soggettoUuid,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? indirizzo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? numeroCivico;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? citta;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? cap;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? provincia;

  final String soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUpdateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggetto,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i2.SoggettoUpdateOneRequiredWithoutDomiciliNestedInput? soggetto;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUpdateManyWithoutDomicilioNestedInput? prodottiOrdinati;

  final _i2.LeadUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggetto': soggetto,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.contrattiEnelXAssicurazione,
    this.forniture,
    this.contrattiEnelFibra,
    this.prodottiOrdinati,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.FornituraUncheckedUpdateManyWithoutDomicilioNestedInput? forniture;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutDomicilioNestedInput?
      contrattiEnelFibra;

  final _i2.OrdineUncheckedUpdateManyWithoutDomicilioNestedInput?
      prodottiOrdinati;

  final _i2.LeadUncheckedUpdateManyWithoutDomicilioNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'forniture': forniture,
        'contrattiEnelFibra': contrattiEnelFibra,
        'prodottiOrdinati': prodottiOrdinati,
        'leads': leads,
      };
}

class DomicilioUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioUncheckedUpdateManyInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioCountAggregateOutputType {
  const DomicilioCountAggregateOutputType({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.$all,
  });

  factory DomicilioCountAggregateOutputType.fromJson(Map json) =>
      DomicilioCountAggregateOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        indirizzo: json['indirizzo'],
        numeroCivico: json['numeroCivico'],
        citta: json['citta'],
        cap: json['cap'],
        provincia: json['provincia'],
        soggettoUuid: json['soggettoUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? etichetta;

  final int? indirizzo;

  final int? numeroCivico;

  final int? citta;

  final int? cap;

  final int? provincia;

  final int? soggettoUuid;

  final int? $all;
}

class DomicilioMinAggregateOutputType {
  const DomicilioMinAggregateOutputType({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  factory DomicilioMinAggregateOutputType.fromJson(Map json) =>
      DomicilioMinAggregateOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        indirizzo: json['indirizzo'],
        numeroCivico: json['numeroCivico'],
        citta: json['citta'],
        cap: json['cap'],
        provincia: json['provincia'],
        soggettoUuid: json['soggettoUuid'],
      );

  final String? uuid;

  final String? etichetta;

  final String? indirizzo;

  final String? numeroCivico;

  final String? citta;

  final String? cap;

  final String? provincia;

  final String? soggettoUuid;
}

class DomicilioMaxAggregateOutputType {
  const DomicilioMaxAggregateOutputType({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  factory DomicilioMaxAggregateOutputType.fromJson(Map json) =>
      DomicilioMaxAggregateOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        indirizzo: json['indirizzo'],
        numeroCivico: json['numeroCivico'],
        citta: json['citta'],
        cap: json['cap'],
        provincia: json['provincia'],
        soggettoUuid: json['soggettoUuid'],
      );

  final String? uuid;

  final String? etichetta;

  final String? indirizzo;

  final String? numeroCivico;

  final String? citta;

  final String? cap;

  final String? provincia;

  final String? soggettoUuid;
}

class DomicilioGroupByOutputType {
  const DomicilioGroupByOutputType({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory DomicilioGroupByOutputType.fromJson(Map json) =>
      DomicilioGroupByOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        indirizzo: json['indirizzo'],
        numeroCivico: json['numeroCivico'],
        citta: json['citta'],
        cap: json['cap'],
        provincia: json['provincia'],
        soggettoUuid: json['soggettoUuid'],
        $count: json['_count'] is Map
            ? _i2.DomicilioCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DomicilioMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DomicilioMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? etichetta;

  final String? indirizzo;

  final String? numeroCivico;

  final String? citta;

  final String? cap;

  final String? provincia;

  final String? soggettoUuid;

  final _i2.DomicilioCountAggregateOutputType? $count;

  final _i2.DomicilioMinAggregateOutputType? $min;

  final _i2.DomicilioMaxAggregateOutputType? $max;
}

class DomicilioCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCountOrderByAggregateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? indirizzo;

  final _i2.SortOrder? numeroCivico;

  final _i2.SortOrder? citta;

  final _i2.SortOrder? cap;

  final _i2.SortOrder? provincia;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioMaxOrderByAggregateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? indirizzo;

  final _i2.SortOrder? numeroCivico;

  final _i2.SortOrder? citta;

  final _i2.SortOrder? cap;

  final _i2.SortOrder? provincia;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioMinOrderByAggregateInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? indirizzo;

  final _i2.SortOrder? numeroCivico;

  final _i2.SortOrder? citta;

  final _i2.SortOrder? cap;

  final _i2.SortOrder? provincia;

  final _i2.SortOrder? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioOrderByWithAggregationInput({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? indirizzo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? numeroCivico;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? citta;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? cap;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? provincia;

  final _i2.SortOrder? soggettoUuid;

  final _i2.DomicilioCountOrderByAggregateInput? $count;

  final _i2.DomicilioMaxOrderByAggregateInput? $max;

  final _i2.DomicilioMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class DomicilioScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final _i1.PrismaUnion<_i2.DomicilioScalarWhereWithAggregatesInput,
      Iterable<_i2.DomicilioScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.DomicilioScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.DomicilioScalarWhereWithAggregatesInput,
      Iterable<_i2.DomicilioScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? indirizzo;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? numeroCivico;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? citta;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? cap;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? provincia;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioCountAggregateOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? indirizzo;

  final bool? numeroCivico;

  final bool? citta;

  final bool? cap;

  final bool? provincia;

  final bool? soggettoUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        '_all': $all,
      };
}

class DomicilioGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioGroupByOutputTypeCountArgs({this.select});

  final _i2.DomicilioCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomicilioMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioMinAggregateOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? indirizzo;

  final bool? numeroCivico;

  final bool? citta;

  final bool? cap;

  final bool? provincia;

  final bool? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioGroupByOutputTypeMinArgs({this.select});

  final _i2.DomicilioMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomicilioMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioMaxAggregateOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? indirizzo;

  final bool? numeroCivico;

  final bool? citta;

  final bool? cap;

  final bool? provincia;

  final bool? soggettoUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
      };
}

class DomicilioGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioGroupByOutputTypeMaxArgs({this.select});

  final _i2.DomicilioMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DomicilioGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DomicilioGroupByOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.indirizzo,
    this.numeroCivico,
    this.citta,
    this.cap,
    this.provincia,
    this.soggettoUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? indirizzo;

  final bool? numeroCivico;

  final bool? citta;

  final bool? cap;

  final bool? provincia;

  final bool? soggettoUuid;

  final _i1.PrismaUnion<bool, _i2.DomicilioGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.DomicilioGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.DomicilioGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'indirizzo': indirizzo,
        'numeroCivico': numeroCivico,
        'citta': citta,
        'cap': cap,
        'provincia': provincia,
        'soggettoUuid': soggettoUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateDomicilio {
  const AggregateDomicilio({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateDomicilio.fromJson(Map json) => AggregateDomicilio(
        $count: json['_count'] is Map
            ? _i2.DomicilioCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DomicilioMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DomicilioMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.DomicilioCountAggregateOutputType? $count;

  final _i2.DomicilioMinAggregateOutputType? $min;

  final _i2.DomicilioMaxAggregateOutputType? $max;
}

class AggregateDomicilioCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomicilioCountArgs({this.select});

  final _i2.DomicilioCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDomicilioMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomicilioMinArgs({this.select});

  final _i2.DomicilioMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDomicilioMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomicilioMaxArgs({this.select});

  final _i2.DomicilioMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDomicilioSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDomicilioSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateDomicilioCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateDomicilioMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateDomicilioMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ServizioEwoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateInput({
    required this.id,
    required this.nome,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    required this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.FornitoreCreateNestedOneWithoutServiziEwoInput fornitore;

  final _i2.TipoPraticaCreateNestedManyWithoutServiziEwoInput? tipiPratiche;

  final _i2.FornituraCreateNestedManyWithoutServizioEwoInput? forniture;

  final _i2.StatoPraticaCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2.ModuloContrattoCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedCreateInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  final _i2.TipoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      tipiPratiche;

  final _i2.FornituraUncheckedCreateNestedManyWithoutServizioEwoInput?
      forniture;

  final _i2.StatoPraticaUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedCreateNestedManyWithoutServiziEwoInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedCreateNestedManyWithoutServizioEwoInput? offerte;

  final _i2
      .ModuloContrattoUncheckedCreateNestedManyWithoutServiziEwoCollegabiliInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCreateManyInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.tipoServizioEwo,
    required this.colore,
    required this.icona,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoServizioEwo tipoServizioEwo;

  final String colore;

  final String icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUpdateInput({
    this.id,
    this.nome,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.fornitore,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.FornitoreUpdateOneRequiredWithoutServiziEwoNestedInput? fornitore;

  final _i2.TipoPraticaUpdateManyWithoutServiziEwoNestedInput? tipiPratiche;

  final _i2.FornituraUpdateManyWithoutServizioEwoNestedInput? forniture;

  final _i2.StatoPraticaUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2.ModuloContrattoUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'fornitore': fornitore,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.tipiPratiche,
    this.forniture,
    this.statiPossibiliPratiche,
    this.statiPossibiliContratti,
    this.offerte,
    this.moduliContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  final _i2.TipoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      tipiPratiche;

  final _i2.FornituraUncheckedUpdateManyWithoutServizioEwoNestedInput?
      forniture;

  final _i2.StatoPraticaUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliPratiche;

  final _i2.StatoContrattoUncheckedUpdateManyWithoutServiziEwoNestedInput?
      statiPossibiliContratti;

  final _i2.OffertaUncheckedUpdateManyWithoutServizioEwoNestedInput? offerte;

  final _i2
      .ModuloContrattoUncheckedUpdateManyWithoutServiziEwoCollegabiliNestedInput?
      moduliContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        'tipiPratiche': tipiPratiche,
        'forniture': forniture,
        'statiPossibiliPratiche': statiPossibiliPratiche,
        'statiPossibiliContratti': statiPossibiliContratti,
        'offerte': offerte,
        'moduliContratto': moduliContratto,
      };
}

class ServizioEwoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoUncheckedUpdateManyInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.EnumTipoServizioEwoFieldUpdateOperationsInput>? tipoServizioEwo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoCountAggregateOutputType {
  const ServizioEwoCountAggregateOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.$all,
  });

  factory ServizioEwoCountAggregateOutputType.fromJson(Map json) =>
      ServizioEwoCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        tipoServizioEwo: json['tipoServizioEwo'],
        colore: json['colore'],
        icona: json['icona'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? fornitoreId;

  final int? tipoServizioEwo;

  final int? colore;

  final int? icona;

  final int? $all;
}

class ServizioEwoMinAggregateOutputType {
  const ServizioEwoMinAggregateOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  factory ServizioEwoMinAggregateOutputType.fromJson(Map json) =>
      ServizioEwoMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        tipoServizioEwo: json['tipoServizioEwo'] != null
            ? _i3.TipoServizioEwo.values
                .firstWhere((e) => e.name == json['tipoServizioEwo'])
            : null,
        colore: json['colore'],
        icona: json['icona'],
      );

  final String? id;

  final String? nome;

  final String? fornitoreId;

  final _i3.TipoServizioEwo? tipoServizioEwo;

  final String? colore;

  final String? icona;
}

class ServizioEwoMaxAggregateOutputType {
  const ServizioEwoMaxAggregateOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  factory ServizioEwoMaxAggregateOutputType.fromJson(Map json) =>
      ServizioEwoMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        tipoServizioEwo: json['tipoServizioEwo'] != null
            ? _i3.TipoServizioEwo.values
                .firstWhere((e) => e.name == json['tipoServizioEwo'])
            : null,
        colore: json['colore'],
        icona: json['icona'],
      );

  final String? id;

  final String? nome;

  final String? fornitoreId;

  final _i3.TipoServizioEwo? tipoServizioEwo;

  final String? colore;

  final String? icona;
}

class ServizioEwoGroupByOutputType {
  const ServizioEwoGroupByOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ServizioEwoGroupByOutputType.fromJson(Map json) =>
      ServizioEwoGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        tipoServizioEwo: json['tipoServizioEwo'] != null
            ? _i3.TipoServizioEwo.values
                .firstWhere((e) => e.name == json['tipoServizioEwo'])
            : null,
        colore: json['colore'],
        icona: json['icona'],
        $count: json['_count'] is Map
            ? _i2.ServizioEwoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ServizioEwoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ServizioEwoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final String? fornitoreId;

  final _i3.TipoServizioEwo? tipoServizioEwo;

  final String? colore;

  final String? icona;

  final _i2.ServizioEwoCountAggregateOutputType? $count;

  final _i2.ServizioEwoMinAggregateOutputType? $min;

  final _i2.ServizioEwoMaxAggregateOutputType? $max;
}

class ServizioEwoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCountOrderByAggregateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoServizioEwo;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoMaxOrderByAggregateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoServizioEwo;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoMinOrderByAggregateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoServizioEwo;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoServizioEwo;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? icona;

  final _i2.ServizioEwoCountOrderByAggregateInput? $count;

  final _i2.ServizioEwoMaxOrderByAggregateInput? $max;

  final _i2.ServizioEwoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NestedEnumTipoServizioEwoWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoServizioEwoWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<_i3.TipoServizioEwo, _i1.Reference<_i3.TipoServizioEwo>>?
      equals;

  final Iterable<_i3.TipoServizioEwo>? $in;

  final Iterable<_i3.TipoServizioEwo>? notIn;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.NestedEnumTipoServizioEwoWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoServizioEwoFilter? $min;

  final _i2.NestedEnumTipoServizioEwoFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumTipoServizioEwoWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoServizioEwoWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<_i3.TipoServizioEwo, _i1.Reference<_i3.TipoServizioEwo>>?
      equals;

  final Iterable<_i3.TipoServizioEwo>? $in;

  final Iterable<_i3.TipoServizioEwo>? notIn;

  final _i1.PrismaUnion<_i3.TipoServizioEwo,
      _i2.NestedEnumTipoServizioEwoWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoServizioEwoFilter? $min;

  final _i2.NestedEnumTipoServizioEwoFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ServizioEwoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereWithAggregatesInput,
      Iterable<_i2.ServizioEwoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ServizioEwoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ServizioEwoScalarWhereWithAggregatesInput,
      Iterable<_i2.ServizioEwoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.EnumTipoServizioEwoWithAggregatesFilter,
      _i3.TipoServizioEwo>? tipoServizioEwo;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? icona;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? tipoServizioEwo;

  final bool? colore;

  final bool? icona;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        '_all': $all,
      };
}

class ServizioEwoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoGroupByOutputTypeCountArgs({this.select});

  final _i2.ServizioEwoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ServizioEwoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? tipoServizioEwo;

  final bool? colore;

  final bool? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoGroupByOutputTypeMinArgs({this.select});

  final _i2.ServizioEwoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ServizioEwoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? tipoServizioEwo;

  final bool? colore;

  final bool? icona;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
      };
}

class ServizioEwoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoGroupByOutputTypeMaxArgs({this.select});

  final _i2.ServizioEwoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ServizioEwoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ServizioEwoGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.tipoServizioEwo,
    this.colore,
    this.icona,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? tipoServizioEwo;

  final bool? colore;

  final bool? icona;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ServizioEwoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'tipoServizioEwo': tipoServizioEwo,
        'colore': colore,
        'icona': icona,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateServizioEwo {
  const AggregateServizioEwo({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateServizioEwo.fromJson(Map json) => AggregateServizioEwo(
        $count: json['_count'] is Map
            ? _i2.ServizioEwoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ServizioEwoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ServizioEwoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ServizioEwoCountAggregateOutputType? $count;

  final _i2.ServizioEwoMinAggregateOutputType? $min;

  final _i2.ServizioEwoMaxAggregateOutputType? $max;
}

class AggregateServizioEwoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateServizioEwoCountArgs({this.select});

  final _i2.ServizioEwoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateServizioEwoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateServizioEwoMinArgs({this.select});

  final _i2.ServizioEwoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateServizioEwoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateServizioEwoMaxArgs({this.select});

  final _i2.ServizioEwoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateServizioEwoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateServizioEwoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateServizioEwoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateServizioEwoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateServizioEwoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class FornituraCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateInput({
    this.uuid,
    this.etichetta,
    required this.domicilio,
    required this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final _i2.DomicilioCreateNestedOneWithoutFornitureInput domicilio;

  final _i2.ServizioEwoCreateNestedOneWithoutFornitureInput servizioEwo;

  final _i2.FornituraLuceCreateNestedOneWithoutFornituraInput? fornituraLuce;

  final _i2.FornituraGasCreateNestedOneWithoutFornituraInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedCreateInput({
    this.uuid,
    this.etichetta,
    required this.domicilioUuid,
    required this.servizioEwoId,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String domicilioUuid;

  final String servizioEwoId;

  final _i2.FornituraLuceUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraLuce;

  final _i2.FornituraGasUncheckedCreateNestedOneWithoutFornituraInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCreateManyInput({
    this.uuid,
    this.etichetta,
    required this.domicilioUuid,
    required this.servizioEwoId,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? etichetta;

  final String domicilioUuid;

  final String servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUpdateInput({
    this.uuid,
    this.etichetta,
    this.domicilio,
    this.servizioEwo,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i2.DomicilioUpdateOneRequiredWithoutFornitureNestedInput? domicilio;

  final _i2.ServizioEwoUpdateOneRequiredWithoutFornitureNestedInput?
      servizioEwo;

  final _i2.FornituraLuceUpdateOneWithoutFornituraNestedInput? fornituraLuce;

  final _i2.FornituraGasUpdateOneWithoutFornituraNestedInput? fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilio': domicilio,
        'servizioEwo': servizioEwo,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.fornituraLuce,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.FornituraLuceUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraLuce;

  final _i2.FornituraGasUncheckedUpdateOneWithoutFornituraNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        'fornituraLuce': fornituraLuce,
        'fornituraGas': fornituraGas,
      };
}

class FornituraUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraUncheckedUpdateManyInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraCountAggregateOutputType {
  const FornituraCountAggregateOutputType({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.$all,
  });

  factory FornituraCountAggregateOutputType.fromJson(Map json) =>
      FornituraCountAggregateOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        domicilioUuid: json['domicilioUuid'],
        servizioEwoId: json['servizioEwoId'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? etichetta;

  final int? domicilioUuid;

  final int? servizioEwoId;

  final int? $all;
}

class FornituraMinAggregateOutputType {
  const FornituraMinAggregateOutputType({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  factory FornituraMinAggregateOutputType.fromJson(Map json) =>
      FornituraMinAggregateOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        domicilioUuid: json['domicilioUuid'],
        servizioEwoId: json['servizioEwoId'],
      );

  final String? uuid;

  final String? etichetta;

  final String? domicilioUuid;

  final String? servizioEwoId;
}

class FornituraMaxAggregateOutputType {
  const FornituraMaxAggregateOutputType({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  factory FornituraMaxAggregateOutputType.fromJson(Map json) =>
      FornituraMaxAggregateOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        domicilioUuid: json['domicilioUuid'],
        servizioEwoId: json['servizioEwoId'],
      );

  final String? uuid;

  final String? etichetta;

  final String? domicilioUuid;

  final String? servizioEwoId;
}

class FornituraGroupByOutputType {
  const FornituraGroupByOutputType({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.$count,
    this.$min,
    this.$max,
  });

  factory FornituraGroupByOutputType.fromJson(Map json) =>
      FornituraGroupByOutputType(
        uuid: json['uuid'],
        etichetta: json['etichetta'],
        domicilioUuid: json['domicilioUuid'],
        servizioEwoId: json['servizioEwoId'],
        $count: json['_count'] is Map
            ? _i2.FornituraCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornituraMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornituraMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? etichetta;

  final String? domicilioUuid;

  final String? servizioEwoId;

  final _i2.FornituraCountAggregateOutputType? $count;

  final _i2.FornituraMinAggregateOutputType? $min;

  final _i2.FornituraMaxAggregateOutputType? $max;
}

class FornituraCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCountOrderByAggregateInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraMaxOrderByAggregateInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraMinOrderByAggregateInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? etichetta;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraOrderByWithAggregationInput({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? etichetta;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? servizioEwoId;

  final _i2.FornituraCountOrderByAggregateInput? $count;

  final _i2.FornituraMaxOrderByAggregateInput? $max;

  final _i2.FornituraMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class FornituraScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<_i2.FornituraScalarWhereWithAggregatesInput,
      Iterable<_i2.FornituraScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.FornituraScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraScalarWhereWithAggregatesInput,
      Iterable<_i2.FornituraScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? etichetta;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraCountAggregateOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.$all,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? domicilioUuid;

  final bool? servizioEwoId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        '_all': $all,
      };
}

class FornituraGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGroupByOutputTypeCountArgs({this.select});

  final _i2.FornituraCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraMinAggregateOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? domicilioUuid;

  final bool? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGroupByOutputTypeMinArgs({this.select});

  final _i2.FornituraMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraMaxAggregateOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? domicilioUuid;

  final bool? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
      };
}

class FornituraGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGroupByOutputTypeMaxArgs({this.select});

  final _i2.FornituraMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGroupByOutputTypeSelect({
    this.uuid,
    this.etichetta,
    this.domicilioUuid,
    this.servizioEwoId,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? etichetta;

  final bool? domicilioUuid;

  final bool? servizioEwoId;

  final _i1.PrismaUnion<bool, _i2.FornituraGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.FornituraGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.FornituraGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'etichetta': etichetta,
        'domicilioUuid': domicilioUuid,
        'servizioEwoId': servizioEwoId,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateFornitura {
  const AggregateFornitura({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateFornitura.fromJson(Map json) => AggregateFornitura(
        $count: json['_count'] is Map
            ? _i2.FornituraCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornituraMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornituraMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.FornituraCountAggregateOutputType? $count;

  final _i2.FornituraMinAggregateOutputType? $min;

  final _i2.FornituraMaxAggregateOutputType? $max;
}

class AggregateFornituraCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraCountArgs({this.select});

  final _i2.FornituraCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraMinArgs({this.select});

  final _i2.FornituraMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraMaxArgs({this.select});

  final _i2.FornituraMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum FornituraLuceScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'FornituraLuce'),
  pod<String>('pod', 'FornituraLuce'),
  fornituraUuid<String>('fornituraUuid', 'FornituraLuce'),
  potenza<double>('potenza', 'FornituraLuce'),
  tensione<double>('tensione', 'FornituraLuce');

  const FornituraLuceScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornituraLuceCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateInput({
    this.uuid,
    required this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    required this.fornitura,
  });

  final String? uuid;

  final String pod;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ConsumoAnnuoLuceCreateNestedOneWithoutFornituraLuceInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutFornituraLuceInput?
      contrattiEnelLuce;

  final _i2.FornituraCreateNestedOneWithoutFornituraLuceInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedCreateInput({
    this.uuid,
    required this.pod,
    required this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
  });

  final String? uuid;

  final String pod;

  final String fornituraUuid;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ConsumoAnnuoLuceUncheckedCreateNestedOneWithoutFornituraLuceInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutFornituraLuceInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateManyInput({
    this.uuid,
    required this.pod,
    required this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final String? uuid;

  final String pod;

  final String fornituraUuid;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateInput({
    this.uuid,
    this.pod,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ConsumoAnnuoLuceUpdateOneWithoutFornituraLuceNestedInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceUpdateManyWithoutFornituraLuceNestedInput?
      contrattiEnelLuce;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraLuceNestedInput?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedUpdateInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.consumoAnnuoLuce,
    this.contrattiEnelLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ConsumoAnnuoLuceUncheckedUpdateOneWithoutFornituraLuceNestedInput?
      consumoAnnuoLuce;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceNestedInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'consumoAnnuoLuce': consumoAnnuoLuce,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateManyMutationInput({
    this.uuid,
    this.pod,
    this.potenza,
    this.tensione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedUpdateManyInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceCountAggregateOutputType {
  const FornituraLuceCountAggregateOutputType({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.$all,
  });

  factory FornituraLuceCountAggregateOutputType.fromJson(Map json) =>
      FornituraLuceCountAggregateOutputType(
        uuid: json['uuid'],
        pod: json['pod'],
        fornituraUuid: json['fornituraUuid'],
        potenza: json['potenza'],
        tensione: json['tensione'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? pod;

  final int? fornituraUuid;

  final int? potenza;

  final int? tensione;

  final int? $all;
}

class FornituraLuceAvgAggregateOutputType {
  const FornituraLuceAvgAggregateOutputType({
    this.potenza,
    this.tensione,
  });

  factory FornituraLuceAvgAggregateOutputType.fromJson(Map json) =>
      FornituraLuceAvgAggregateOutputType(
        potenza: json['potenza'],
        tensione: json['tensione'],
      );

  final double? potenza;

  final double? tensione;
}

class FornituraLuceSumAggregateOutputType {
  const FornituraLuceSumAggregateOutputType({
    this.potenza,
    this.tensione,
  });

  factory FornituraLuceSumAggregateOutputType.fromJson(Map json) =>
      FornituraLuceSumAggregateOutputType(
        potenza: json['potenza'],
        tensione: json['tensione'],
      );

  final double? potenza;

  final double? tensione;
}

class FornituraLuceMinAggregateOutputType {
  const FornituraLuceMinAggregateOutputType({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  factory FornituraLuceMinAggregateOutputType.fromJson(Map json) =>
      FornituraLuceMinAggregateOutputType(
        uuid: json['uuid'],
        pod: json['pod'],
        fornituraUuid: json['fornituraUuid'],
        potenza: json['potenza'],
        tensione: json['tensione'],
      );

  final String? uuid;

  final String? pod;

  final String? fornituraUuid;

  final double? potenza;

  final double? tensione;
}

class FornituraLuceMaxAggregateOutputType {
  const FornituraLuceMaxAggregateOutputType({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  factory FornituraLuceMaxAggregateOutputType.fromJson(Map json) =>
      FornituraLuceMaxAggregateOutputType(
        uuid: json['uuid'],
        pod: json['pod'],
        fornituraUuid: json['fornituraUuid'],
        potenza: json['potenza'],
        tensione: json['tensione'],
      );

  final String? uuid;

  final String? pod;

  final String? fornituraUuid;

  final double? potenza;

  final double? tensione;
}

class FornituraLuceGroupByOutputType {
  const FornituraLuceGroupByOutputType({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory FornituraLuceGroupByOutputType.fromJson(Map json) =>
      FornituraLuceGroupByOutputType(
        uuid: json['uuid'],
        pod: json['pod'],
        fornituraUuid: json['fornituraUuid'],
        potenza: json['potenza'],
        tensione: json['tensione'],
        $count: json['_count'] is Map
            ? _i2.FornituraLuceCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.FornituraLuceAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.FornituraLuceSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornituraLuceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornituraLuceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? pod;

  final String? fornituraUuid;

  final double? potenza;

  final double? tensione;

  final _i2.FornituraLuceCountAggregateOutputType? $count;

  final _i2.FornituraLuceAvgAggregateOutputType? $avg;

  final _i2.FornituraLuceSumAggregateOutputType? $sum;

  final _i2.FornituraLuceMinAggregateOutputType? $min;

  final _i2.FornituraLuceMaxAggregateOutputType? $max;
}

class FornituraLuceCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCountOrderByAggregateInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pod;

  final _i2.SortOrder? fornituraUuid;

  final _i2.SortOrder? potenza;

  final _i2.SortOrder? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceAvgOrderByAggregateInput({
    this.potenza,
    this.tensione,
  });

  final _i2.SortOrder? potenza;

  final _i2.SortOrder? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceMaxOrderByAggregateInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pod;

  final _i2.SortOrder? fornituraUuid;

  final _i2.SortOrder? potenza;

  final _i2.SortOrder? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceMinOrderByAggregateInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pod;

  final _i2.SortOrder? fornituraUuid;

  final _i2.SortOrder? potenza;

  final _i2.SortOrder? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceSumOrderByAggregateInput({
    this.potenza,
    this.tensione,
  });

  final _i2.SortOrder? potenza;

  final _i2.SortOrder? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceOrderByWithAggregationInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pod;

  final _i2.SortOrder? fornituraUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? potenza;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tensione;

  final _i2.FornituraLuceCountOrderByAggregateInput? $count;

  final _i2.FornituraLuceAvgOrderByAggregateInput? $avg;

  final _i2.FornituraLuceMaxOrderByAggregateInput? $max;

  final _i2.FornituraLuceMinOrderByAggregateInput? $min;

  final _i2.FornituraLuceSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedFloatNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i1.Reference<double>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NestedFloatNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedFloatNullableFilter? $sum;

  final _i2.NestedFloatNullableFilter? $min;

  final _i2.NestedFloatNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class FloatNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i1.Reference<double>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NestedFloatNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedFloatNullableFilter? $sum;

  final _i2.NestedFloatNullableFilter? $min;

  final _i2.NestedFloatNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class FornituraLuceScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceScalarWhereWithAggregatesInput,
      Iterable<_i2.FornituraLuceScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.FornituraLuceScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraLuceScalarWhereWithAggregatesInput,
      Iterable<_i2.FornituraLuceScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? pod;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? fornituraUuid;

  final _i1.PrismaUnion<_i2.FloatNullableWithAggregatesFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<_i2.FloatNullableWithAggregatesFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCountAggregateOutputTypeSelect({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.$all,
  });

  final bool? uuid;

  final bool? pod;

  final bool? fornituraUuid;

  final bool? potenza;

  final bool? tensione;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        '_all': $all,
      };
}

class FornituraLuceGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceGroupByOutputTypeCountArgs({this.select});

  final _i2.FornituraLuceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraLuceAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceAvgAggregateOutputTypeSelect({
    this.potenza,
    this.tensione,
  });

  final bool? potenza;

  final bool? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceGroupByOutputTypeAvgArgs({this.select});

  final _i2.FornituraLuceAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraLuceSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceSumAggregateOutputTypeSelect({
    this.potenza,
    this.tensione,
  });

  final bool? potenza;

  final bool? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceGroupByOutputTypeSumArgs({this.select});

  final _i2.FornituraLuceSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraLuceMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceMinAggregateOutputTypeSelect({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final bool? uuid;

  final bool? pod;

  final bool? fornituraUuid;

  final bool? potenza;

  final bool? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceGroupByOutputTypeMinArgs({this.select});

  final _i2.FornituraLuceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraLuceMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceMaxAggregateOutputTypeSelect({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
  });

  final bool? uuid;

  final bool? pod;

  final bool? fornituraUuid;

  final bool? potenza;

  final bool? tensione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
      };
}

class FornituraLuceGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceGroupByOutputTypeMaxArgs({this.select});

  final _i2.FornituraLuceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraLuceGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceGroupByOutputTypeSelect({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? pod;

  final bool? fornituraUuid;

  final bool? potenza;

  final bool? tensione;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.FornituraLuceGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateFornituraLuce {
  const AggregateFornituraLuce({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateFornituraLuce.fromJson(Map json) => AggregateFornituraLuce(
        $count: json['_count'] is Map
            ? _i2.FornituraLuceCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.FornituraLuceAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.FornituraLuceSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornituraLuceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornituraLuceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.FornituraLuceCountAggregateOutputType? $count;

  final _i2.FornituraLuceAvgAggregateOutputType? $avg;

  final _i2.FornituraLuceSumAggregateOutputType? $sum;

  final _i2.FornituraLuceMinAggregateOutputType? $min;

  final _i2.FornituraLuceMaxAggregateOutputType? $max;
}

class AggregateFornituraLuceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraLuceCountArgs({this.select});

  final _i2.FornituraLuceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraLuceAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraLuceAvgArgs({this.select});

  final _i2.FornituraLuceAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraLuceSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraLuceSumArgs({this.select});

  final _i2.FornituraLuceSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraLuceMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraLuceMinArgs({this.select});

  final _i2.FornituraLuceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraLuceMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraLuceMaxArgs({this.select});

  final _i2.FornituraLuceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraLuceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraLuceSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraLuceCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraLuceAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraLuceSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraLuceMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraLuceMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum ConsumoAnnuoLuceScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'ConsumoAnnuoLuce'),
  consumo<double>('consumo', 'ConsumoAnnuoLuce'),
  meseRiferimentoConsumoAnnuo<DateTime>(
      'meseRiferimentoConsumoAnnuo', 'ConsumoAnnuoLuce'),
  fornituraLuceUuid<String>('fornituraLuceUuid', 'ConsumoAnnuoLuce');

  const ConsumoAnnuoLuceScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornituraLuceCreateWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateWithoutConsumoAnnuoLuceInput({
    this.uuid,
    required this.pod,
    this.potenza,
    this.tensione,
    this.contrattiEnelLuce,
    required this.fornitura,
  });

  final String? uuid;

  final String pod;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutFornituraLuceInput?
      contrattiEnelLuce;

  final _i2.FornituraCreateNestedOneWithoutFornituraLuceInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceUncheckedCreateWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedCreateWithoutConsumoAnnuoLuceInput({
    this.uuid,
    required this.pod,
    required this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.contrattiEnelLuce,
  });

  final String? uuid;

  final String pod;

  final String fornituraUuid;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? potenza;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? tensione;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutFornituraLuceInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceCreateOrConnectWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateOrConnectWithoutConsumoAnnuoLuceInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraLuceWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutConsumoAnnuoLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutConsumoAnnuoLuceInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraLuceCreateNestedOneWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceCreateNestedOneWithoutConsumoAnnuoLuceInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutConsumoAnnuoLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutConsumoAnnuoLuceInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutConsumoAnnuoLuceInput?
      connectOrCreate;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ConsumoAnnuoLuceCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCreateInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
    required this.fornituraLuce,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  final _i2.FornituraLuceCreateNestedOneWithoutConsumoAnnuoLuceInput
      fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuce': fornituraLuce,
      };
}

class ConsumoAnnuoLuceUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedCreateInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
    required this.fornituraLuceUuid,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  final String fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCreateManyInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
    required this.fornituraLuceUuid,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  final String fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class FornituraLuceUpdateWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateWithoutConsumoAnnuoLuceInput({
    this.uuid,
    this.pod,
    this.potenza,
    this.tensione,
    this.contrattiEnelLuce,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ContrattoEnelLuceUpdateManyWithoutFornituraLuceNestedInput?
      contrattiEnelLuce;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraLuceNestedInput?
      fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'potenza': potenza,
        'tensione': tensione,
        'contrattiEnelLuce': contrattiEnelLuce,
        'fornitura': fornitura,
      };
}

class FornituraLuceUncheckedUpdateWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUncheckedUpdateWithoutConsumoAnnuoLuceInput({
    this.uuid,
    this.pod,
    this.fornituraUuid,
    this.potenza,
    this.tensione,
    this.contrattiEnelLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pod;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? potenza;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tensione;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutFornituraLuceNestedInput?
      contrattiEnelLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pod': pod,
        'fornituraUuid': fornituraUuid,
        'potenza': potenza,
        'tensione': tensione,
        'contrattiEnelLuce': contrattiEnelLuce,
      };
}

class FornituraLuceUpsertWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpsertWithoutConsumoAnnuoLuceInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutConsumoAnnuoLuceInput,
      _i2.FornituraLuceUncheckedUpdateWithoutConsumoAnnuoLuceInput> update;

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutConsumoAnnuoLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutConsumoAnnuoLuceInput> create;

  final _i2.FornituraLuceWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraLuceUpdateToOneWithWhereWithoutConsumoAnnuoLuceInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateToOneWithWhereWithoutConsumoAnnuoLuceInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraLuceWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutConsumoAnnuoLuceInput,
      _i2.FornituraLuceUncheckedUpdateWithoutConsumoAnnuoLuceInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraLuceUpdateOneRequiredWithoutConsumoAnnuoLuceNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraLuceUpdateOneRequiredWithoutConsumoAnnuoLuceNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraLuceCreateWithoutConsumoAnnuoLuceInput,
      _i2.FornituraLuceUncheckedCreateWithoutConsumoAnnuoLuceInput>? create;

  final _i2.FornituraLuceCreateOrConnectWithoutConsumoAnnuoLuceInput?
      connectOrCreate;

  final _i2.FornituraLuceUpsertWithoutConsumoAnnuoLuceInput? upsert;

  final _i2.FornituraLuceWhereUniqueInput? connect;

  final _i1.PrismaUnion<
          _i2.FornituraLuceUpdateToOneWithWhereWithoutConsumoAnnuoLuceInput,
          _i1.PrismaUnion<_i2.FornituraLuceUpdateWithoutConsumoAnnuoLuceInput,
              _i2.FornituraLuceUncheckedUpdateWithoutConsumoAnnuoLuceInput>>?
      update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ConsumoAnnuoLuceUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUpdateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuce,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  final _i2.FornituraLuceUpdateOneRequiredWithoutConsumoAnnuoLuceNestedInput?
      fornituraLuce;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuce': fornituraLuce,
      };
}

class ConsumoAnnuoLuceUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedUpdateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUpdateManyMutationInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoLuceUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceUncheckedUpdateManyInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceCountAggregateOutputType {
  const ConsumoAnnuoLuceCountAggregateOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.$all,
  });

  factory ConsumoAnnuoLuceCountAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoLuceCountAggregateOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? consumo;

  final int? meseRiferimentoConsumoAnnuo;

  final int? fornituraLuceUuid;

  final int? $all;
}

class ConsumoAnnuoLuceAvgAggregateOutputType {
  const ConsumoAnnuoLuceAvgAggregateOutputType({this.consumo});

  factory ConsumoAnnuoLuceAvgAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoLuceAvgAggregateOutputType(consumo: json['consumo']);

  final double? consumo;
}

class ConsumoAnnuoLuceSumAggregateOutputType {
  const ConsumoAnnuoLuceSumAggregateOutputType({this.consumo});

  factory ConsumoAnnuoLuceSumAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoLuceSumAggregateOutputType(consumo: json['consumo']);

  final double? consumo;
}

class ConsumoAnnuoLuceMinAggregateOutputType {
  const ConsumoAnnuoLuceMinAggregateOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  factory ConsumoAnnuoLuceMinAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoLuceMinAggregateOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
      );

  final String? uuid;

  final double? consumo;

  final DateTime? meseRiferimentoConsumoAnnuo;

  final String? fornituraLuceUuid;
}

class ConsumoAnnuoLuceMaxAggregateOutputType {
  const ConsumoAnnuoLuceMaxAggregateOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  factory ConsumoAnnuoLuceMaxAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoLuceMaxAggregateOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
      );

  final String? uuid;

  final double? consumo;

  final DateTime? meseRiferimentoConsumoAnnuo;

  final String? fornituraLuceUuid;
}

class ConsumoAnnuoLuceGroupByOutputType {
  const ConsumoAnnuoLuceGroupByOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ConsumoAnnuoLuceGroupByOutputType.fromJson(Map json) =>
      ConsumoAnnuoLuceGroupByOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
        $count: json['_count'] is Map
            ? _i2.ConsumoAnnuoLuceCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsumoAnnuoLuceAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsumoAnnuoLuceSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsumoAnnuoLuceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsumoAnnuoLuceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final double? consumo;

  final DateTime? meseRiferimentoConsumoAnnuo;

  final String? fornituraLuceUuid;

  final _i2.ConsumoAnnuoLuceCountAggregateOutputType? $count;

  final _i2.ConsumoAnnuoLuceAvgAggregateOutputType? $avg;

  final _i2.ConsumoAnnuoLuceSumAggregateOutputType? $sum;

  final _i2.ConsumoAnnuoLuceMinAggregateOutputType? $min;

  final _i2.ConsumoAnnuoLuceMaxAggregateOutputType? $max;
}

class ConsumoAnnuoLuceCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCountOrderByAggregateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceAvgOrderByAggregateInput({this.consumo});

  final _i2.SortOrder? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoLuceMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceMaxOrderByAggregateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceMinOrderByAggregateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceSumOrderByAggregateInput({this.consumo});

  final _i2.SortOrder? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoLuceOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceOrderByWithAggregationInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.ConsumoAnnuoLuceCountOrderByAggregateInput? $count;

  final _i2.ConsumoAnnuoLuceAvgOrderByAggregateInput? $avg;

  final _i2.ConsumoAnnuoLuceMaxOrderByAggregateInput? $max;

  final _i2.ConsumoAnnuoLuceMinOrderByAggregateInput? $min;

  final _i2.ConsumoAnnuoLuceSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedFloatWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<double, _i1.Reference<double>>? equals;

  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedFloatFilter? $sum;

  final _i2.NestedFloatFilter? $min;

  final _i2.NestedFloatFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class FloatWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FloatWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<double, _i1.Reference<double>>? equals;

  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedFloatFilter? $sum;

  final _i2.NestedFloatFilter? $min;

  final _i2.NestedFloatFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedDateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class DateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ConsumoAnnuoLuceScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceScalarWhereWithAggregatesInput,
      Iterable<_i2.ConsumoAnnuoLuceScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ConsumoAnnuoLuceScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoLuceScalarWhereWithAggregatesInput,
      Iterable<_i2.ConsumoAnnuoLuceScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? consumo;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceCountAggregateOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraLuceUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
        '_all': $all,
      };
}

class ConsumoAnnuoLuceGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsumoAnnuoLuceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoLuceAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceAvgAggregateOutputTypeSelect({this.consumo});

  final bool? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoLuceGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceGroupByOutputTypeAvgArgs({this.select});

  final _i2.ConsumoAnnuoLuceAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoLuceSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceSumAggregateOutputTypeSelect({this.consumo});

  final bool? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoLuceGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceGroupByOutputTypeSumArgs({this.select});

  final _i2.ConsumoAnnuoLuceSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoLuceMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceMinAggregateOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsumoAnnuoLuceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoLuceMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceMaxAggregateOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraLuceUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
      };
}

class ConsumoAnnuoLuceGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsumoAnnuoLuceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoLuceGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoLuceGroupByOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraLuceUuid,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraLuceUuid;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoLuceGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraLuceUuid': fornituraLuceUuid,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateConsumoAnnuoLuce {
  const AggregateConsumoAnnuoLuce({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateConsumoAnnuoLuce.fromJson(Map json) =>
      AggregateConsumoAnnuoLuce(
        $count: json['_count'] is Map
            ? _i2.ConsumoAnnuoLuceCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsumoAnnuoLuceAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsumoAnnuoLuceSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsumoAnnuoLuceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsumoAnnuoLuceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ConsumoAnnuoLuceCountAggregateOutputType? $count;

  final _i2.ConsumoAnnuoLuceAvgAggregateOutputType? $avg;

  final _i2.ConsumoAnnuoLuceSumAggregateOutputType? $sum;

  final _i2.ConsumoAnnuoLuceMinAggregateOutputType? $min;

  final _i2.ConsumoAnnuoLuceMaxAggregateOutputType? $max;
}

class AggregateConsumoAnnuoLuceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoLuceCountArgs({this.select});

  final _i2.ConsumoAnnuoLuceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoLuceAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoLuceAvgArgs({this.select});

  final _i2.ConsumoAnnuoLuceAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoLuceSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoLuceSumArgs({this.select});

  final _i2.ConsumoAnnuoLuceSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoLuceMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoLuceMinArgs({this.select});

  final _i2.ConsumoAnnuoLuceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoLuceMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoLuceMaxArgs({this.select});

  final _i2.ConsumoAnnuoLuceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoLuceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoLuceSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoLuceCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoLuceAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoLuceSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoLuceMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoLuceMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class FornituraGasCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateInput({
    this.uuid,
    required this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    required this.fornitura,
  });

  final String? uuid;

  final String pdr;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ClasseMisuratoreGasCreateNestedOneWithoutFornituraGasInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  final _i2.FornituraCreateNestedOneWithoutFornituraGasInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateInput({
    this.uuid,
    required this.pdr,
    required this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final String? uuid;

  final String pdr;

  final String fornituraUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classeMisuratoreGasId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ConsumoAnnuoGasUncheckedCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateManyInput({
    this.uuid,
    required this.pdr,
    required this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final String? uuid;

  final String pdr;

  final String fornituraUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classeMisuratoreGasId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateInput({
    this.uuid,
    this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ClasseMisuratoreGasUpdateOneWithoutFornituraGasNestedInput?
      classeMisuratore;

  final _i2.ConsumoAnnuoGasUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraGasNestedInput? fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ConsumoAnnuoGasUncheckedUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateManyMutationInput({
    this.uuid,
    this.pdr,
    this.matricolaContatore,
    this.remi,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateManyInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasCountAggregateOutputType {
  const FornituraGasCountAggregateOutputType({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.$all,
  });

  factory FornituraGasCountAggregateOutputType.fromJson(Map json) =>
      FornituraGasCountAggregateOutputType(
        uuid: json['uuid'],
        pdr: json['pdr'],
        fornituraUuid: json['fornituraUuid'],
        classeMisuratoreGasId: json['classeMisuratoreGasId'],
        matricolaContatore: json['matricolaContatore'],
        remi: json['remi'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? pdr;

  final int? fornituraUuid;

  final int? classeMisuratoreGasId;

  final int? matricolaContatore;

  final int? remi;

  final int? $all;
}

class FornituraGasMinAggregateOutputType {
  const FornituraGasMinAggregateOutputType({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  factory FornituraGasMinAggregateOutputType.fromJson(Map json) =>
      FornituraGasMinAggregateOutputType(
        uuid: json['uuid'],
        pdr: json['pdr'],
        fornituraUuid: json['fornituraUuid'],
        classeMisuratoreGasId: json['classeMisuratoreGasId'],
        matricolaContatore: json['matricolaContatore'],
        remi: json['remi'],
      );

  final String? uuid;

  final String? pdr;

  final String? fornituraUuid;

  final String? classeMisuratoreGasId;

  final String? matricolaContatore;

  final String? remi;
}

class FornituraGasMaxAggregateOutputType {
  const FornituraGasMaxAggregateOutputType({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  factory FornituraGasMaxAggregateOutputType.fromJson(Map json) =>
      FornituraGasMaxAggregateOutputType(
        uuid: json['uuid'],
        pdr: json['pdr'],
        fornituraUuid: json['fornituraUuid'],
        classeMisuratoreGasId: json['classeMisuratoreGasId'],
        matricolaContatore: json['matricolaContatore'],
        remi: json['remi'],
      );

  final String? uuid;

  final String? pdr;

  final String? fornituraUuid;

  final String? classeMisuratoreGasId;

  final String? matricolaContatore;

  final String? remi;
}

class FornituraGasGroupByOutputType {
  const FornituraGasGroupByOutputType({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.$count,
    this.$min,
    this.$max,
  });

  factory FornituraGasGroupByOutputType.fromJson(Map json) =>
      FornituraGasGroupByOutputType(
        uuid: json['uuid'],
        pdr: json['pdr'],
        fornituraUuid: json['fornituraUuid'],
        classeMisuratoreGasId: json['classeMisuratoreGasId'],
        matricolaContatore: json['matricolaContatore'],
        remi: json['remi'],
        $count: json['_count'] is Map
            ? _i2.FornituraGasCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornituraGasMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornituraGasMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? pdr;

  final String? fornituraUuid;

  final String? classeMisuratoreGasId;

  final String? matricolaContatore;

  final String? remi;

  final _i2.FornituraGasCountAggregateOutputType? $count;

  final _i2.FornituraGasMinAggregateOutputType? $min;

  final _i2.FornituraGasMaxAggregateOutputType? $max;
}

class FornituraGasCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCountOrderByAggregateInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pdr;

  final _i2.SortOrder? fornituraUuid;

  final _i2.SortOrder? classeMisuratoreGasId;

  final _i2.SortOrder? matricolaContatore;

  final _i2.SortOrder? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasMaxOrderByAggregateInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pdr;

  final _i2.SortOrder? fornituraUuid;

  final _i2.SortOrder? classeMisuratoreGasId;

  final _i2.SortOrder? matricolaContatore;

  final _i2.SortOrder? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasMinOrderByAggregateInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pdr;

  final _i2.SortOrder? fornituraUuid;

  final _i2.SortOrder? classeMisuratoreGasId;

  final _i2.SortOrder? matricolaContatore;

  final _i2.SortOrder? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasOrderByWithAggregationInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? pdr;

  final _i2.SortOrder? fornituraUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      classeMisuratoreGasId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? matricolaContatore;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? remi;

  final _i2.FornituraGasCountOrderByAggregateInput? $count;

  final _i2.FornituraGasMaxOrderByAggregateInput? $max;

  final _i2.FornituraGasMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class FornituraGasScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final _i1.PrismaUnion<_i2.FornituraGasScalarWhereWithAggregatesInput,
      Iterable<_i2.FornituraGasScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.FornituraGasScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraGasScalarWhereWithAggregatesInput,
      Iterable<_i2.FornituraGasScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? pdr;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? fornituraUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCountAggregateOutputTypeSelect({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.$all,
  });

  final bool? uuid;

  final bool? pdr;

  final bool? fornituraUuid;

  final bool? classeMisuratoreGasId;

  final bool? matricolaContatore;

  final bool? remi;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        '_all': $all,
      };
}

class FornituraGasGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasGroupByOutputTypeCountArgs({this.select});

  final _i2.FornituraGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraGasMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasMinAggregateOutputTypeSelect({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final bool? uuid;

  final bool? pdr;

  final bool? fornituraUuid;

  final bool? classeMisuratoreGasId;

  final bool? matricolaContatore;

  final bool? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasGroupByOutputTypeMinArgs({this.select});

  final _i2.FornituraGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraGasMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasMaxAggregateOutputTypeSelect({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final bool? uuid;

  final bool? pdr;

  final bool? fornituraUuid;

  final bool? classeMisuratoreGasId;

  final bool? matricolaContatore;

  final bool? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasGroupByOutputTypeMaxArgs({this.select});

  final _i2.FornituraGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornituraGasGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasGroupByOutputTypeSelect({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? pdr;

  final bool? fornituraUuid;

  final bool? classeMisuratoreGasId;

  final bool? matricolaContatore;

  final bool? remi;

  final _i1.PrismaUnion<bool, _i2.FornituraGasGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.FornituraGasGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.FornituraGasGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateFornituraGas {
  const AggregateFornituraGas({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateFornituraGas.fromJson(Map json) => AggregateFornituraGas(
        $count: json['_count'] is Map
            ? _i2.FornituraGasCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornituraGasMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornituraGasMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.FornituraGasCountAggregateOutputType? $count;

  final _i2.FornituraGasMinAggregateOutputType? $min;

  final _i2.FornituraGasMaxAggregateOutputType? $max;
}

class AggregateFornituraGasCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraGasCountArgs({this.select});

  final _i2.FornituraGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraGasMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraGasMinArgs({this.select});

  final _i2.FornituraGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraGasMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraGasMaxArgs({this.select});

  final _i2.FornituraGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornituraGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornituraGasSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraGasCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraGasMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateFornituraGasMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum ConsumoAnnuoGasScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'ConsumoAnnuoGas'),
  consumo<double>('consumo', 'ConsumoAnnuoGas'),
  meseRiferimentoConsumoAnnuo<DateTime>(
      'meseRiferimentoConsumoAnnuo', 'ConsumoAnnuoGas'),
  fornituraGasUuid<String>('fornituraGasUuid', 'ConsumoAnnuoGas');

  const ConsumoAnnuoGasScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornituraGasCreateWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateWithoutConsumoAnnuoGasInput({
    this.uuid,
    required this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.contrattiEnelGas,
    required this.fornitura,
  });

  final String? uuid;

  final String pdr;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ClasseMisuratoreGasCreateNestedOneWithoutFornituraGasInput?
      classeMisuratore;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  final _i2.FornituraCreateNestedOneWithoutFornituraGasInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedCreateWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateWithoutConsumoAnnuoGasInput({
    this.uuid,
    required this.pdr,
    required this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.contrattiEnelGas,
  });

  final String? uuid;

  final String pdr;

  final String fornituraUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? classeMisuratoreGasId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasCreateOrConnectWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateOrConnectWithoutConsumoAnnuoGasInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutConsumoAnnuoGasInput,
      _i2.FornituraGasUncheckedCreateWithoutConsumoAnnuoGasInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraGasCreateNestedOneWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateNestedOneWithoutConsumoAnnuoGasInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutConsumoAnnuoGasInput,
      _i2.FornituraGasUncheckedCreateWithoutConsumoAnnuoGasInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutConsumoAnnuoGasInput?
      connectOrCreate;

  final _i2.FornituraGasWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class ConsumoAnnuoGasCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCreateInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
    required this.fornituraGas,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  final _i2.FornituraGasCreateNestedOneWithoutConsumoAnnuoGasInput fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGas': fornituraGas,
      };
}

class ConsumoAnnuoGasUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedCreateInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
    required this.fornituraGasUuid,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  final String fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCreateManyInput({
    this.uuid,
    required this.consumo,
    required this.meseRiferimentoConsumoAnnuo,
    required this.fornituraGasUuid,
  });

  final String? uuid;

  final double consumo;

  final DateTime meseRiferimentoConsumoAnnuo;

  final String fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class FornituraGasUpdateWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateWithoutConsumoAnnuoGasInput({
    this.uuid,
    this.pdr,
    this.matricolaContatore,
    this.remi,
    this.classeMisuratore,
    this.contrattiEnelGas,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ClasseMisuratoreGasUpdateOneWithoutFornituraGasNestedInput?
      classeMisuratore;

  final _i2.ContrattoEnelGasUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraGasNestedInput? fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'classeMisuratore': classeMisuratore,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedUpdateWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateWithoutConsumoAnnuoGasInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
    this.contrattiEnelGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasUpsertWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpsertWithoutConsumoAnnuoGasInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutConsumoAnnuoGasInput,
      _i2.FornituraGasUncheckedUpdateWithoutConsumoAnnuoGasInput> update;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutConsumoAnnuoGasInput,
      _i2.FornituraGasUncheckedCreateWithoutConsumoAnnuoGasInput> create;

  final _i2.FornituraGasWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class FornituraGasUpdateToOneWithWhereWithoutConsumoAnnuoGasInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateToOneWithWhereWithoutConsumoAnnuoGasInput({
    this.where,
    required this.data,
  });

  final _i2.FornituraGasWhereInput? where;

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutConsumoAnnuoGasInput,
      _i2.FornituraGasUncheckedUpdateWithoutConsumoAnnuoGasInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraGasUpdateOneRequiredWithoutConsumoAnnuoGasNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateOneRequiredWithoutConsumoAnnuoGasNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutConsumoAnnuoGasInput,
      _i2.FornituraGasUncheckedCreateWithoutConsumoAnnuoGasInput>? create;

  final _i2.FornituraGasCreateOrConnectWithoutConsumoAnnuoGasInput?
      connectOrCreate;

  final _i2.FornituraGasUpsertWithoutConsumoAnnuoGasInput? upsert;

  final _i2.FornituraGasWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.FornituraGasUpdateToOneWithWhereWithoutConsumoAnnuoGasInput,
      _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutConsumoAnnuoGasInput,
          _i2.FornituraGasUncheckedUpdateWithoutConsumoAnnuoGasInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class ConsumoAnnuoGasUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUpdateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  final _i2.FornituraGasUpdateOneRequiredWithoutConsumoAnnuoGasNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGas': fornituraGas,
      };
}

class ConsumoAnnuoGasUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedUpdateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUpdateManyMutationInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
      };
}

class ConsumoAnnuoGasUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasUncheckedUpdateManyInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? consumo;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasCountAggregateOutputType {
  const ConsumoAnnuoGasCountAggregateOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.$all,
  });

  factory ConsumoAnnuoGasCountAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoGasCountAggregateOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraGasUuid: json['fornituraGasUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? consumo;

  final int? meseRiferimentoConsumoAnnuo;

  final int? fornituraGasUuid;

  final int? $all;
}

class ConsumoAnnuoGasAvgAggregateOutputType {
  const ConsumoAnnuoGasAvgAggregateOutputType({this.consumo});

  factory ConsumoAnnuoGasAvgAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoGasAvgAggregateOutputType(consumo: json['consumo']);

  final double? consumo;
}

class ConsumoAnnuoGasSumAggregateOutputType {
  const ConsumoAnnuoGasSumAggregateOutputType({this.consumo});

  factory ConsumoAnnuoGasSumAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoGasSumAggregateOutputType(consumo: json['consumo']);

  final double? consumo;
}

class ConsumoAnnuoGasMinAggregateOutputType {
  const ConsumoAnnuoGasMinAggregateOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  factory ConsumoAnnuoGasMinAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoGasMinAggregateOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraGasUuid: json['fornituraGasUuid'],
      );

  final String? uuid;

  final double? consumo;

  final DateTime? meseRiferimentoConsumoAnnuo;

  final String? fornituraGasUuid;
}

class ConsumoAnnuoGasMaxAggregateOutputType {
  const ConsumoAnnuoGasMaxAggregateOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  factory ConsumoAnnuoGasMaxAggregateOutputType.fromJson(Map json) =>
      ConsumoAnnuoGasMaxAggregateOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraGasUuid: json['fornituraGasUuid'],
      );

  final String? uuid;

  final double? consumo;

  final DateTime? meseRiferimentoConsumoAnnuo;

  final String? fornituraGasUuid;
}

class ConsumoAnnuoGasGroupByOutputType {
  const ConsumoAnnuoGasGroupByOutputType({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ConsumoAnnuoGasGroupByOutputType.fromJson(Map json) =>
      ConsumoAnnuoGasGroupByOutputType(
        uuid: json['uuid'],
        consumo: json['consumo'],
        meseRiferimentoConsumoAnnuo: json['meseRiferimentoConsumoAnnuo'],
        fornituraGasUuid: json['fornituraGasUuid'],
        $count: json['_count'] is Map
            ? _i2.ConsumoAnnuoGasCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsumoAnnuoGasAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsumoAnnuoGasSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsumoAnnuoGasMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsumoAnnuoGasMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final double? consumo;

  final DateTime? meseRiferimentoConsumoAnnuo;

  final String? fornituraGasUuid;

  final _i2.ConsumoAnnuoGasCountAggregateOutputType? $count;

  final _i2.ConsumoAnnuoGasAvgAggregateOutputType? $avg;

  final _i2.ConsumoAnnuoGasSumAggregateOutputType? $sum;

  final _i2.ConsumoAnnuoGasMinAggregateOutputType? $min;

  final _i2.ConsumoAnnuoGasMaxAggregateOutputType? $max;
}

class ConsumoAnnuoGasCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCountOrderByAggregateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasAvgOrderByAggregateInput({this.consumo});

  final _i2.SortOrder? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoGasMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasMaxOrderByAggregateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasMinOrderByAggregateInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasSumOrderByAggregateInput({this.consumo});

  final _i2.SortOrder? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoGasOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasOrderByWithAggregationInput({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? consumo;

  final _i2.SortOrder? meseRiferimentoConsumoAnnuo;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.ConsumoAnnuoGasCountOrderByAggregateInput? $count;

  final _i2.ConsumoAnnuoGasAvgOrderByAggregateInput? $avg;

  final _i2.ConsumoAnnuoGasMaxOrderByAggregateInput? $max;

  final _i2.ConsumoAnnuoGasMinOrderByAggregateInput? $min;

  final _i2.ConsumoAnnuoGasSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ConsumoAnnuoGasScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasScalarWhereWithAggregatesInput,
      Iterable<_i2.ConsumoAnnuoGasScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ConsumoAnnuoGasScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ConsumoAnnuoGasScalarWhereWithAggregatesInput,
      Iterable<_i2.ConsumoAnnuoGasScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? consumo;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      meseRiferimentoConsumoAnnuo;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasCountAggregateOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraGasUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
        '_all': $all,
      };
}

class ConsumoAnnuoGasGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasGroupByOutputTypeCountArgs({this.select});

  final _i2.ConsumoAnnuoGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoGasAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasAvgAggregateOutputTypeSelect({this.consumo});

  final bool? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoGasGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasGroupByOutputTypeAvgArgs({this.select});

  final _i2.ConsumoAnnuoGasAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoGasSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasSumAggregateOutputTypeSelect({this.consumo});

  final bool? consumo;

  @override
  Map<String, dynamic> toJson() => {'consumo': consumo};
}

class ConsumoAnnuoGasGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasGroupByOutputTypeSumArgs({this.select});

  final _i2.ConsumoAnnuoGasSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoGasMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasMinAggregateOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasGroupByOutputTypeMinArgs({this.select});

  final _i2.ConsumoAnnuoGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoGasMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasMaxAggregateOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraGasUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
      };
}

class ConsumoAnnuoGasGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasGroupByOutputTypeMaxArgs({this.select});

  final _i2.ConsumoAnnuoGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ConsumoAnnuoGasGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ConsumoAnnuoGasGroupByOutputTypeSelect({
    this.uuid,
    this.consumo,
    this.meseRiferimentoConsumoAnnuo,
    this.fornituraGasUuid,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? consumo;

  final bool? meseRiferimentoConsumoAnnuo;

  final bool? fornituraGasUuid;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ConsumoAnnuoGasGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'consumo': consumo,
        'meseRiferimentoConsumoAnnuo': meseRiferimentoConsumoAnnuo,
        'fornituraGasUuid': fornituraGasUuid,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateConsumoAnnuoGas {
  const AggregateConsumoAnnuoGas({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateConsumoAnnuoGas.fromJson(Map json) =>
      AggregateConsumoAnnuoGas(
        $count: json['_count'] is Map
            ? _i2.ConsumoAnnuoGasCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ConsumoAnnuoGasAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ConsumoAnnuoGasSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ConsumoAnnuoGasMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ConsumoAnnuoGasMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ConsumoAnnuoGasCountAggregateOutputType? $count;

  final _i2.ConsumoAnnuoGasAvgAggregateOutputType? $avg;

  final _i2.ConsumoAnnuoGasSumAggregateOutputType? $sum;

  final _i2.ConsumoAnnuoGasMinAggregateOutputType? $min;

  final _i2.ConsumoAnnuoGasMaxAggregateOutputType? $max;
}

class AggregateConsumoAnnuoGasCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoGasCountArgs({this.select});

  final _i2.ConsumoAnnuoGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoGasAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoGasAvgArgs({this.select});

  final _i2.ConsumoAnnuoGasAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoGasSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoGasSumArgs({this.select});

  final _i2.ConsumoAnnuoGasSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoGasMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoGasMinArgs({this.select});

  final _i2.ConsumoAnnuoGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoGasMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoGasMaxArgs({this.select});

  final _i2.ConsumoAnnuoGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateConsumoAnnuoGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateConsumoAnnuoGasSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoGasCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoGasAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoGasSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoGasMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateConsumoAnnuoGasMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    required this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiInput stato;

  final _i2.SoggettoCreateNestedOneWithoutContrattiInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutContrattiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutContrattiInput? negozio;

  final _i2.PraticaCreateNestedOneWithoutContrattoInput? pratica;

  final _i2.ModuloContrattoCreateNestedOneWithoutContrattiInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedCreateInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutContrattoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCreateManyInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    required this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAttivazione;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? trend;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataCessazione;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? mesiDurata;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  final String statoContrattoId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? praticaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUpdateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.stato,
    this.soggetto,
    this.utente,
    this.negozio,
    this.pratica,
    this.modulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i2.ContrattoEnelLuceUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiNestedInput? stato;

  final _i2.SoggettoUpdateOneWithoutContrattiNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutContrattiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutContrattiNestedInput? negozio;

  final _i2.PraticaUpdateOneWithoutContrattoNestedInput? pratica;

  final _i2.ModuloContrattoUpdateOneWithoutContrattiNestedInput? modulo;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'stato': stato,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'pratica': pratica,
        'modulo': modulo,
      };
}

class ContrattoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutContrattoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class ContrattoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoUncheckedUpdateManyInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? bollettaWeb;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? rid;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCountAggregateOutputType {
  const ContrattoCountAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.$all,
  });

  factory ContrattoCountAggregateOutputType.fromJson(Map json) =>
      ContrattoCountAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        dataAttivazione: json['dataAttivazione'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
        trend: json['trend'],
        nota: json['nota'],
        marketingEnelEnergia: json['marketingEnelEnergia'],
        marketingGruppoEnel: json['marketingGruppoEnel'],
        profilazioneEnelEnergia: json['profilazioneEnelEnergia'],
        bollettaWeb: json['bollettaWeb'],
        rid: json['rid'],
        dataCessazione: json['dataCessazione'],
        mesiDurata: json['mesiDurata'],
        offertaUuid: json['offertaUuid'],
        statoContrattoId: json['statoContrattoId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        praticaUuid: json['praticaUuid'],
        moduloContrattoId: json['moduloContrattoId'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? codice;

  final int? dataInserimento;

  final int? dataAttivazione;

  final int? ultimoAggiornamentoStato;

  final int? trend;

  final int? nota;

  final int? marketingEnelEnergia;

  final int? marketingGruppoEnel;

  final int? profilazioneEnelEnergia;

  final int? bollettaWeb;

  final int? rid;

  final int? dataCessazione;

  final int? mesiDurata;

  final int? offertaUuid;

  final int? statoContrattoId;

  final int? soggettoUuid;

  final int? utenteUuid;

  final int? negozioCodice;

  final int? praticaUuid;

  final int? moduloContrattoId;

  final int? $all;
}

class ContrattoAvgAggregateOutputType {
  const ContrattoAvgAggregateOutputType({this.mesiDurata});

  factory ContrattoAvgAggregateOutputType.fromJson(Map json) =>
      ContrattoAvgAggregateOutputType(mesiDurata: json['mesiDurata']);

  final double? mesiDurata;
}

class ContrattoSumAggregateOutputType {
  const ContrattoSumAggregateOutputType({this.mesiDurata});

  factory ContrattoSumAggregateOutputType.fromJson(Map json) =>
      ContrattoSumAggregateOutputType(mesiDurata: json['mesiDurata']);

  final int? mesiDurata;
}

class ContrattoMinAggregateOutputType {
  const ContrattoMinAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  factory ContrattoMinAggregateOutputType.fromJson(Map json) =>
      ContrattoMinAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        dataAttivazione: json['dataAttivazione'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
        trend: json['trend'],
        nota: json['nota'],
        marketingEnelEnergia: json['marketingEnelEnergia'],
        marketingGruppoEnel: json['marketingGruppoEnel'],
        profilazioneEnelEnergia: json['profilazioneEnelEnergia'],
        bollettaWeb: json['bollettaWeb'],
        rid: json['rid'],
        dataCessazione: json['dataCessazione'],
        mesiDurata: json['mesiDurata'],
        offertaUuid: json['offertaUuid'],
        statoContrattoId: json['statoContrattoId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        praticaUuid: json['praticaUuid'],
        moduloContrattoId: json['moduloContrattoId'],
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final DateTime? dataAttivazione;

  final DateTime? ultimoAggiornamentoStato;

  final bool? trend;

  final String? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final DateTime? dataCessazione;

  final int? mesiDurata;

  final String? offertaUuid;

  final String? statoContrattoId;

  final String? soggettoUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? praticaUuid;

  final String? moduloContrattoId;
}

class ContrattoMaxAggregateOutputType {
  const ContrattoMaxAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  factory ContrattoMaxAggregateOutputType.fromJson(Map json) =>
      ContrattoMaxAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        dataAttivazione: json['dataAttivazione'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
        trend: json['trend'],
        nota: json['nota'],
        marketingEnelEnergia: json['marketingEnelEnergia'],
        marketingGruppoEnel: json['marketingGruppoEnel'],
        profilazioneEnelEnergia: json['profilazioneEnelEnergia'],
        bollettaWeb: json['bollettaWeb'],
        rid: json['rid'],
        dataCessazione: json['dataCessazione'],
        mesiDurata: json['mesiDurata'],
        offertaUuid: json['offertaUuid'],
        statoContrattoId: json['statoContrattoId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        praticaUuid: json['praticaUuid'],
        moduloContrattoId: json['moduloContrattoId'],
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final DateTime? dataAttivazione;

  final DateTime? ultimoAggiornamentoStato;

  final bool? trend;

  final String? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final DateTime? dataCessazione;

  final int? mesiDurata;

  final String? offertaUuid;

  final String? statoContrattoId;

  final String? soggettoUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? praticaUuid;

  final String? moduloContrattoId;
}

class ContrattoGroupByOutputType {
  const ContrattoGroupByOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ContrattoGroupByOutputType.fromJson(Map json) =>
      ContrattoGroupByOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        dataAttivazione: json['dataAttivazione'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
        trend: json['trend'],
        nota: json['nota'],
        marketingEnelEnergia: json['marketingEnelEnergia'],
        marketingGruppoEnel: json['marketingGruppoEnel'],
        profilazioneEnelEnergia: json['profilazioneEnelEnergia'],
        bollettaWeb: json['bollettaWeb'],
        rid: json['rid'],
        dataCessazione: json['dataCessazione'],
        mesiDurata: json['mesiDurata'],
        offertaUuid: json['offertaUuid'],
        statoContrattoId: json['statoContrattoId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        praticaUuid: json['praticaUuid'],
        moduloContrattoId: json['moduloContrattoId'],
        $count: json['_count'] is Map
            ? _i2.ContrattoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ContrattoAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ContrattoSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final DateTime? dataAttivazione;

  final DateTime? ultimoAggiornamentoStato;

  final bool? trend;

  final String? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final DateTime? dataCessazione;

  final int? mesiDurata;

  final String? offertaUuid;

  final String? statoContrattoId;

  final String? soggettoUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? praticaUuid;

  final String? moduloContrattoId;

  final _i2.ContrattoCountAggregateOutputType? $count;

  final _i2.ContrattoAvgAggregateOutputType? $avg;

  final _i2.ContrattoSumAggregateOutputType? $sum;

  final _i2.ContrattoMinAggregateOutputType? $min;

  final _i2.ContrattoMaxAggregateOutputType? $max;
}

class ContrattoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCountOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? dataAttivazione;

  final _i2.SortOrder? ultimoAggiornamentoStato;

  final _i2.SortOrder? trend;

  final _i2.SortOrder? nota;

  final _i2.SortOrder? marketingEnelEnergia;

  final _i2.SortOrder? marketingGruppoEnel;

  final _i2.SortOrder? profilazioneEnelEnergia;

  final _i2.SortOrder? bollettaWeb;

  final _i2.SortOrder? rid;

  final _i2.SortOrder? dataCessazione;

  final _i2.SortOrder? mesiDurata;

  final _i2.SortOrder? offertaUuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? praticaUuid;

  final _i2.SortOrder? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoAvgOrderByAggregateInput({this.mesiDurata});

  final _i2.SortOrder? mesiDurata;

  @override
  Map<String, dynamic> toJson() => {'mesiDurata': mesiDurata};
}

class ContrattoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoMaxOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? dataAttivazione;

  final _i2.SortOrder? ultimoAggiornamentoStato;

  final _i2.SortOrder? trend;

  final _i2.SortOrder? nota;

  final _i2.SortOrder? marketingEnelEnergia;

  final _i2.SortOrder? marketingGruppoEnel;

  final _i2.SortOrder? profilazioneEnelEnergia;

  final _i2.SortOrder? bollettaWeb;

  final _i2.SortOrder? rid;

  final _i2.SortOrder? dataCessazione;

  final _i2.SortOrder? mesiDurata;

  final _i2.SortOrder? offertaUuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? praticaUuid;

  final _i2.SortOrder? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoMinOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? dataAttivazione;

  final _i2.SortOrder? ultimoAggiornamentoStato;

  final _i2.SortOrder? trend;

  final _i2.SortOrder? nota;

  final _i2.SortOrder? marketingEnelEnergia;

  final _i2.SortOrder? marketingGruppoEnel;

  final _i2.SortOrder? profilazioneEnelEnergia;

  final _i2.SortOrder? bollettaWeb;

  final _i2.SortOrder? rid;

  final _i2.SortOrder? dataCessazione;

  final _i2.SortOrder? mesiDurata;

  final _i2.SortOrder? offertaUuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? praticaUuid;

  final _i2.SortOrder? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoSumOrderByAggregateInput({this.mesiDurata});

  final _i2.SortOrder? mesiDurata;

  @override
  Map<String, dynamic> toJson() => {'mesiDurata': mesiDurata};
}

class ContrattoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoOrderByWithAggregationInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataAttivazione;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      ultimoAggiornamentoStato;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? trend;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? nota;

  final _i2.SortOrder? marketingEnelEnergia;

  final _i2.SortOrder? marketingGruppoEnel;

  final _i2.SortOrder? profilazioneEnelEnergia;

  final _i2.SortOrder? bollettaWeb;

  final _i2.SortOrder? rid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataCessazione;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? mesiDurata;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.SortOrder? statoContrattoId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? praticaUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduloContrattoId;

  final _i2.ContrattoCountOrderByAggregateInput? $count;

  final _i2.ContrattoAvgOrderByAggregateInput? $avg;

  final _i2.ContrattoMaxOrderByAggregateInput? $max;

  final _i2.ContrattoMinOrderByAggregateInput? $min;

  final _i2.ContrattoSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedDateTimeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDateTimeNullableFilter? $min;

  final _i2.NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class DateTimeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDateTimeNullableFilter? $min;

  final _i2.NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedBoolNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolNullableWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedBoolNullableFilter? $min;

  final _i2.NestedBoolNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class BoolNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolNullableWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedBoolNullableFilter? $min;

  final _i2.NestedBoolNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedIntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class IntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ContrattoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAttivazione;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? trend;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>?
      marketingEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>?
      marketingGruppoEnel;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>?
      profilazioneEnelEnergia;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? bollettaWeb;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? rid;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataCessazione;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? mesiDurata;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      statoContrattoId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? praticaUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoCountAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.$all,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? dataAttivazione;

  final bool? ultimoAggiornamentoStato;

  final bool? trend;

  final bool? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final bool? dataCessazione;

  final bool? mesiDurata;

  final bool? offertaUuid;

  final bool? statoContrattoId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? praticaUuid;

  final bool? moduloContrattoId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        '_all': $all,
      };
}

class ContrattoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoGroupByOutputTypeCountArgs({this.select});

  final _i2.ContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoAvgAggregateOutputTypeSelect({this.mesiDurata});

  final bool? mesiDurata;

  @override
  Map<String, dynamic> toJson() => {'mesiDurata': mesiDurata};
}

class ContrattoGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoGroupByOutputTypeAvgArgs({this.select});

  final _i2.ContrattoAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoSumAggregateOutputTypeSelect({this.mesiDurata});

  final bool? mesiDurata;

  @override
  Map<String, dynamic> toJson() => {'mesiDurata': mesiDurata};
}

class ContrattoGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoGroupByOutputTypeSumArgs({this.select});

  final _i2.ContrattoSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoMinAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? dataAttivazione;

  final bool? ultimoAggiornamentoStato;

  final bool? trend;

  final bool? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final bool? dataCessazione;

  final bool? mesiDurata;

  final bool? offertaUuid;

  final bool? statoContrattoId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? praticaUuid;

  final bool? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoGroupByOutputTypeMinArgs({this.select});

  final _i2.ContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoMaxAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? dataAttivazione;

  final bool? ultimoAggiornamentoStato;

  final bool? trend;

  final bool? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final bool? dataCessazione;

  final bool? mesiDurata;

  final bool? offertaUuid;

  final bool? statoContrattoId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? praticaUuid;

  final bool? moduloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
      };
}

class ContrattoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoGroupByOutputTypeMaxArgs({this.select});

  final _i2.ContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoGroupByOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.dataAttivazione,
    this.ultimoAggiornamentoStato,
    this.trend,
    this.nota,
    this.marketingEnelEnergia,
    this.marketingGruppoEnel,
    this.profilazioneEnelEnergia,
    this.bollettaWeb,
    this.rid,
    this.dataCessazione,
    this.mesiDurata,
    this.offertaUuid,
    this.statoContrattoId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.praticaUuid,
    this.moduloContrattoId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? dataAttivazione;

  final bool? ultimoAggiornamentoStato;

  final bool? trend;

  final bool? nota;

  final bool? marketingEnelEnergia;

  final bool? marketingGruppoEnel;

  final bool? profilazioneEnelEnergia;

  final bool? bollettaWeb;

  final bool? rid;

  final bool? dataCessazione;

  final bool? mesiDurata;

  final bool? offertaUuid;

  final bool? statoContrattoId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? praticaUuid;

  final bool? moduloContrattoId;

  final _i1.PrismaUnion<bool, _i2.ContrattoGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ContrattoGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ContrattoGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ContrattoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ContrattoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'dataAttivazione': dataAttivazione,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'trend': trend,
        'nota': nota,
        'marketingEnelEnergia': marketingEnelEnergia,
        'marketingGruppoEnel': marketingGruppoEnel,
        'profilazioneEnelEnergia': profilazioneEnelEnergia,
        'bollettaWeb': bollettaWeb,
        'rid': rid,
        'dataCessazione': dataCessazione,
        'mesiDurata': mesiDurata,
        'offertaUuid': offertaUuid,
        'statoContrattoId': statoContrattoId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'praticaUuid': praticaUuid,
        'moduloContrattoId': moduloContrattoId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateContratto {
  const AggregateContratto({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateContratto.fromJson(Map json) => AggregateContratto(
        $count: json['_count'] is Map
            ? _i2.ContrattoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ContrattoAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ContrattoSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ContrattoCountAggregateOutputType? $count;

  final _i2.ContrattoAvgAggregateOutputType? $avg;

  final _i2.ContrattoSumAggregateOutputType? $sum;

  final _i2.ContrattoMinAggregateOutputType? $min;

  final _i2.ContrattoMaxAggregateOutputType? $max;
}

class AggregateContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoCountArgs({this.select});

  final _i2.ContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoAvgArgs({this.select});

  final _i2.ContrattoAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoSumArgs({this.select});

  final _i2.ContrattoSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoMinArgs({this.select});

  final _i2.ContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoMaxArgs({this.select});

  final _i2.ContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ModuloContrattoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
    required this.fornitore,
    required this.tipoModulo,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final _i2.ServizioEwoCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.ContrattoCreateNestedManyWithoutModuloInput? contratti;

  final _i2.FornitoreCreateNestedOneWithoutModuliContrattoInput fornitore;

  final _i2.TipoModuloContrattoCreateNestedOneWithoutModuloContrattoInput
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.clienteTarget,
    required this.canale,
    required this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final String tipoModuloContrattoId;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutModuloInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateManyInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.clienteTarget,
    required this.canale,
    required this.tipoModuloContrattoId,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final String tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
    this.tipoModulo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i2.ServizioEwoUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUpdateManyWithoutModuloNestedInput? contratti;

  final _i2.FornitoreUpdateOneRequiredWithoutModuliContrattoNestedInput?
      fornitore;

  final _i2
      .TipoModuloContrattoUpdateOneRequiredWithoutModuloContrattoNestedInput?
      tipoModulo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
        'tipoModulo': tipoModulo,
      };
}

class ModuloContrattoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUncheckedUpdateManyWithoutModuloNestedInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoCountAggregateOutputType {
  const ModuloContrattoCountAggregateOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.$all,
  });

  factory ModuloContrattoCountAggregateOutputType.fromJson(Map json) =>
      ModuloContrattoCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        clienteTarget: json['clienteTarget'],
        canale: json['canale'],
        tipoModuloContrattoId: json['tipoModuloContrattoId'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? fornitoreId;

  final int? clienteTarget;

  final int? canale;

  final int? tipoModuloContrattoId;

  final int? $all;
}

class ModuloContrattoMinAggregateOutputType {
  const ModuloContrattoMinAggregateOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  factory ModuloContrattoMinAggregateOutputType.fromJson(Map json) =>
      ModuloContrattoMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        clienteTarget: json['clienteTarget'] != null
            ? _i3.TipoSoggetto.values
                .firstWhere((e) => e.name == json['clienteTarget'])
            : null,
        canale: json['canale'] != null
            ? _i3.Canale.values.firstWhere((e) => e.name == json['canale'])
            : null,
        tipoModuloContrattoId: json['tipoModuloContrattoId'],
      );

  final String? id;

  final String? nome;

  final String? fornitoreId;

  final _i3.TipoSoggetto? clienteTarget;

  final _i3.Canale? canale;

  final String? tipoModuloContrattoId;
}

class ModuloContrattoMaxAggregateOutputType {
  const ModuloContrattoMaxAggregateOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  factory ModuloContrattoMaxAggregateOutputType.fromJson(Map json) =>
      ModuloContrattoMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        clienteTarget: json['clienteTarget'] != null
            ? _i3.TipoSoggetto.values
                .firstWhere((e) => e.name == json['clienteTarget'])
            : null,
        canale: json['canale'] != null
            ? _i3.Canale.values.firstWhere((e) => e.name == json['canale'])
            : null,
        tipoModuloContrattoId: json['tipoModuloContrattoId'],
      );

  final String? id;

  final String? nome;

  final String? fornitoreId;

  final _i3.TipoSoggetto? clienteTarget;

  final _i3.Canale? canale;

  final String? tipoModuloContrattoId;
}

class ModuloContrattoGroupByOutputType {
  const ModuloContrattoGroupByOutputType({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ModuloContrattoGroupByOutputType.fromJson(Map json) =>
      ModuloContrattoGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        fornitoreId: json['fornitoreId'],
        clienteTarget: json['clienteTarget'] != null
            ? _i3.TipoSoggetto.values
                .firstWhere((e) => e.name == json['clienteTarget'])
            : null,
        canale: json['canale'] != null
            ? _i3.Canale.values.firstWhere((e) => e.name == json['canale'])
            : null,
        tipoModuloContrattoId: json['tipoModuloContrattoId'],
        $count: json['_count'] is Map
            ? _i2.ModuloContrattoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ModuloContrattoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ModuloContrattoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final String? fornitoreId;

  final _i3.TipoSoggetto? clienteTarget;

  final _i3.Canale? canale;

  final String? tipoModuloContrattoId;

  final _i2.ModuloContrattoCountAggregateOutputType? $count;

  final _i2.ModuloContrattoMinAggregateOutputType? $min;

  final _i2.ModuloContrattoMaxAggregateOutputType? $max;
}

class ModuloContrattoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCountOrderByAggregateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? clienteTarget;

  final _i2.SortOrder? canale;

  final _i2.SortOrder? tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoMaxOrderByAggregateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? clienteTarget;

  final _i2.SortOrder? canale;

  final _i2.SortOrder? tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoMinOrderByAggregateInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? clienteTarget;

  final _i2.SortOrder? canale;

  final _i2.SortOrder? tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? clienteTarget;

  final _i2.SortOrder? canale;

  final _i2.SortOrder? tipoModuloContrattoId;

  final _i2.ModuloContrattoCountOrderByAggregateInput? $count;

  final _i2.ModuloContrattoMaxOrderByAggregateInput? $max;

  final _i2.ModuloContrattoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NestedEnumCanaleWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumCanaleWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.Canale, _i1.Reference<_i3.Canale>>? equals;

  final Iterable<_i3.Canale>? $in;

  final Iterable<_i3.Canale>? notIn;

  final _i1.PrismaUnion<_i3.Canale, _i2.NestedEnumCanaleWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumCanaleFilter? $min;

  final _i2.NestedEnumCanaleFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumCanaleWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumCanaleWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.Canale, _i1.Reference<_i3.Canale>>? equals;

  final Iterable<_i3.Canale>? $in;

  final Iterable<_i3.Canale>? notIn;

  final _i1.PrismaUnion<_i3.Canale, _i2.NestedEnumCanaleWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumCanaleFilter? $min;

  final _i2.NestedEnumCanaleFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ModuloContrattoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.ModuloContrattoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ModuloContrattoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.ModuloContrattoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? fornitoreId;

  final _i1
      .PrismaUnion<_i2.EnumTipoSoggettoWithAggregatesFilter, _i3.TipoSoggetto>?
      clienteTarget;

  final _i1.PrismaUnion<_i2.EnumCanaleWithAggregatesFilter, _i3.Canale>? canale;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? clienteTarget;

  final bool? canale;

  final bool? tipoModuloContrattoId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        '_all': $all,
      };
}

class ModuloContrattoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoGroupByOutputTypeCountArgs({this.select});

  final _i2.ModuloContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModuloContrattoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? clienteTarget;

  final bool? canale;

  final bool? tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoGroupByOutputTypeMinArgs({this.select});

  final _i2.ModuloContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModuloContrattoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? clienteTarget;

  final bool? canale;

  final bool? tipoModuloContrattoId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
      };
}

class ModuloContrattoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoGroupByOutputTypeMaxArgs({this.select});

  final _i2.ModuloContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModuloContrattoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.tipoModuloContrattoId,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final bool? fornitoreId;

  final bool? clienteTarget;

  final bool? canale;

  final bool? tipoModuloContrattoId;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ModuloContrattoGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'tipoModuloContrattoId': tipoModuloContrattoId,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateModuloContratto {
  const AggregateModuloContratto({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateModuloContratto.fromJson(Map json) =>
      AggregateModuloContratto(
        $count: json['_count'] is Map
            ? _i2.ModuloContrattoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ModuloContrattoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ModuloContrattoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ModuloContrattoCountAggregateOutputType? $count;

  final _i2.ModuloContrattoMinAggregateOutputType? $min;

  final _i2.ModuloContrattoMaxAggregateOutputType? $max;
}

class AggregateModuloContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModuloContrattoCountArgs({this.select});

  final _i2.ModuloContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModuloContrattoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModuloContrattoMinArgs({this.select});

  final _i2.ModuloContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModuloContrattoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModuloContrattoMaxArgs({this.select});

  final _i2.ModuloContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModuloContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModuloContrattoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateModuloContrattoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateModuloContrattoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateModuloContrattoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum TipoModuloContrattoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'TipoModuloContratto'),
  nome<String>('nome', 'TipoModuloContratto'),
  numeroOfferteCollegabili<int>(
      'numeroOfferteCollegabili', 'TipoModuloContratto');

  const TipoModuloContrattoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ModuloContrattoCreateWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateWithoutTipoModuloInput({
    required this.id,
    required this.nome,
    required this.clienteTarget,
    required this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
    required this.fornitore,
  });

  final String id;

  final String nome;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final _i2.ServizioEwoCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.ContrattoCreateNestedManyWithoutModuloInput? contratti;

  final _i2.FornitoreCreateNestedOneWithoutModuliContrattoInput fornitore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
      };
}

class ModuloContrattoUncheckedCreateWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateWithoutTipoModuloInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.clienteTarget,
    required this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutModuliContrattoInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutModuloInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoCreateOrConnectWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateOrConnectWithoutTipoModuloInput({
    required this.where,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutTipoModuloInput,
      _i2.ModuloContrattoUncheckedCreateWithoutTipoModuloInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ModuloContrattoCreateManyTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateManyTipoModuloInput({
    required this.id,
    required this.nome,
    required this.fornitoreId,
    required this.clienteTarget,
    required this.canale,
  });

  final String id;

  final String nome;

  final String fornitoreId;

  final _i3.TipoSoggetto clienteTarget;

  final _i3.Canale canale;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
      };
}

class ModuloContrattoCreateManyTipoModuloInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateManyTipoModuloInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateManyTipoModuloInput,
      Iterable<_i2.ModuloContrattoCreateManyTipoModuloInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ModuloContrattoCreateNestedManyWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoCreateNestedManyWithoutTipoModuloInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutTipoModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutTipoModuloInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutTipoModuloInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutTipoModuloInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput>>?
      connectOrCreate;

  final _i2.ModuloContrattoCreateManyTipoModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class TipoModuloContrattoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCreateInput({
    required this.id,
    required this.nome,
    required this.numeroOfferteCollegabili,
    this.moduloContratto,
  });

  final String id;

  final String nome;

  final int numeroOfferteCollegabili;

  final _i2.ModuloContrattoCreateNestedManyWithoutTipoModuloInput?
      moduloContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
      };
}

class ModuloContrattoUncheckedCreateNestedManyWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedCreateNestedManyWithoutTipoModuloInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutTipoModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutTipoModuloInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutTipoModuloInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutTipoModuloInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput>>?
      connectOrCreate;

  final _i2.ModuloContrattoCreateManyTipoModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class TipoModuloContrattoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUncheckedCreateInput({
    required this.id,
    required this.nome,
    required this.numeroOfferteCollegabili,
    this.moduloContratto,
  });

  final String id;

  final String nome;

  final int numeroOfferteCollegabili;

  final _i2.ModuloContrattoUncheckedCreateNestedManyWithoutTipoModuloInput?
      moduloContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
      };
}

class TipoModuloContrattoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCreateManyInput({
    required this.id,
    required this.nome,
    required this.numeroOfferteCollegabili,
  });

  final String id;

  final String nome;

  final int numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class ModuloContrattoUpdateWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithoutTipoModuloInput({
    this.id,
    this.nome,
    this.clienteTarget,
    this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
    this.fornitore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i2.ServizioEwoUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUpdateManyWithoutModuloNestedInput? contratti;

  final _i2.FornitoreUpdateOneRequiredWithoutModuliContrattoNestedInput?
      fornitore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
        'fornitore': fornitore,
      };
}

class ModuloContrattoUncheckedUpdateWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateWithoutTipoModuloInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
    this.serviziEwoCollegabili,
    this.contratti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutModuliContrattoNestedInput?
      serviziEwoCollegabili;

  final _i2.ContrattoUncheckedUpdateManyWithoutModuloNestedInput? contratti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
        'serviziEwoCollegabili': serviziEwoCollegabili,
        'contratti': contratti,
      };
}

class ModuloContrattoUpsertWithWhereUniqueWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpsertWithWhereUniqueWithoutTipoModuloInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutTipoModuloInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutTipoModuloInput> update;

  final _i1.PrismaUnion<_i2.ModuloContrattoCreateWithoutTipoModuloInput,
      _i2.ModuloContrattoUncheckedCreateWithoutTipoModuloInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ModuloContrattoUpdateWithWhereUniqueWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateWithWhereUniqueWithoutTipoModuloInput({
    required this.where,
    required this.data,
  });

  final _i2.ModuloContrattoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateWithoutTipoModuloInput,
      _i2.ModuloContrattoUncheckedUpdateWithoutTipoModuloInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoUncheckedUpdateManyWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyWithoutTipoModuloInput({
    this.id,
    this.nome,
    this.fornitoreId,
    this.clienteTarget,
    this.canale,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<_i3.TipoSoggetto,
      _i2.EnumTipoSoggettoFieldUpdateOperationsInput>? clienteTarget;

  final _i1.PrismaUnion<_i3.Canale, _i2.EnumCanaleFieldUpdateOperationsInput>?
      canale;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'fornitoreId': fornitoreId,
        'clienteTarget': clienteTarget,
        'canale': canale,
      };
}

class ModuloContrattoUpdateManyWithWhereWithoutTipoModuloInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyWithWhereWithoutTipoModuloInput({
    required this.where,
    required this.data,
  });

  final _i2.ModuloContrattoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ModuloContrattoUpdateManyMutationInput,
      _i2.ModuloContrattoUncheckedUpdateManyWithoutTipoModuloInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ModuloContrattoUpdateManyWithoutTipoModuloNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUpdateManyWithoutTipoModuloNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutTipoModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutTipoModuloInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutTipoModuloInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutTipoModuloInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpsertWithWhereUniqueWithoutTipoModuloInput,
          Iterable<
              _i2.ModuloContrattoUpsertWithWhereUniqueWithoutTipoModuloInput>>?
      upsert;

  final _i2.ModuloContrattoCreateManyTipoModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateWithWhereUniqueWithoutTipoModuloInput,
          Iterable<
              _i2.ModuloContrattoUpdateWithWhereUniqueWithoutTipoModuloInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateManyWithWhereWithoutTipoModuloInput,
          Iterable<
              _i2.ModuloContrattoUpdateManyWithWhereWithoutTipoModuloInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoModuloContrattoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUpdateInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.moduloContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      numeroOfferteCollegabili;

  final _i2.ModuloContrattoUpdateManyWithoutTipoModuloNestedInput?
      moduloContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
      };
}

class ModuloContrattoUncheckedUpdateManyWithoutTipoModuloNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModuloContrattoUncheckedUpdateManyWithoutTipoModuloNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateWithoutTipoModuloInput,
          _i1.PrismaUnion<
              Iterable<_i2.ModuloContrattoCreateWithoutTipoModuloInput>,
              _i1.PrismaUnion<
                  _i2.ModuloContrattoUncheckedCreateWithoutTipoModuloInput,
                  Iterable<
                      _i2
                      .ModuloContrattoUncheckedCreateWithoutTipoModuloInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput,
          Iterable<_i2.ModuloContrattoCreateOrConnectWithoutTipoModuloInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpsertWithWhereUniqueWithoutTipoModuloInput,
          Iterable<
              _i2.ModuloContrattoUpsertWithWhereUniqueWithoutTipoModuloInput>>?
      upsert;

  final _i2.ModuloContrattoCreateManyTipoModuloInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ModuloContrattoWhereUniqueInput,
      Iterable<_i2.ModuloContrattoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateWithWhereUniqueWithoutTipoModuloInput,
          Iterable<
              _i2.ModuloContrattoUpdateWithWhereUniqueWithoutTipoModuloInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.ModuloContrattoUpdateManyWithWhereWithoutTipoModuloInput,
          Iterable<
              _i2.ModuloContrattoUpdateManyWithWhereWithoutTipoModuloInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ModuloContrattoScalarWhereInput,
      Iterable<_i2.ModuloContrattoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoModuloContrattoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUncheckedUpdateInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.moduloContratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      numeroOfferteCollegabili;

  final _i2.ModuloContrattoUncheckedUpdateManyWithoutTipoModuloNestedInput?
      moduloContratto;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        'ModuloContratto': moduloContratto,
      };
}

class TipoModuloContrattoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUpdateManyMutationInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoUncheckedUpdateManyInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>?
      numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoCountAggregateOutputType {
  const TipoModuloContrattoCountAggregateOutputType({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.$all,
  });

  factory TipoModuloContrattoCountAggregateOutputType.fromJson(Map json) =>
      TipoModuloContrattoCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        numeroOfferteCollegabili: json['numeroOfferteCollegabili'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? numeroOfferteCollegabili;

  final int? $all;
}

class TipoModuloContrattoAvgAggregateOutputType {
  const TipoModuloContrattoAvgAggregateOutputType(
      {this.numeroOfferteCollegabili});

  factory TipoModuloContrattoAvgAggregateOutputType.fromJson(Map json) =>
      TipoModuloContrattoAvgAggregateOutputType(
          numeroOfferteCollegabili: json['numeroOfferteCollegabili']);

  final double? numeroOfferteCollegabili;
}

class TipoModuloContrattoSumAggregateOutputType {
  const TipoModuloContrattoSumAggregateOutputType(
      {this.numeroOfferteCollegabili});

  factory TipoModuloContrattoSumAggregateOutputType.fromJson(Map json) =>
      TipoModuloContrattoSumAggregateOutputType(
          numeroOfferteCollegabili: json['numeroOfferteCollegabili']);

  final int? numeroOfferteCollegabili;
}

class TipoModuloContrattoMinAggregateOutputType {
  const TipoModuloContrattoMinAggregateOutputType({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  factory TipoModuloContrattoMinAggregateOutputType.fromJson(Map json) =>
      TipoModuloContrattoMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        numeroOfferteCollegabili: json['numeroOfferteCollegabili'],
      );

  final String? id;

  final String? nome;

  final int? numeroOfferteCollegabili;
}

class TipoModuloContrattoMaxAggregateOutputType {
  const TipoModuloContrattoMaxAggregateOutputType({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  factory TipoModuloContrattoMaxAggregateOutputType.fromJson(Map json) =>
      TipoModuloContrattoMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        numeroOfferteCollegabili: json['numeroOfferteCollegabili'],
      );

  final String? id;

  final String? nome;

  final int? numeroOfferteCollegabili;
}

class TipoModuloContrattoGroupByOutputType {
  const TipoModuloContrattoGroupByOutputType({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory TipoModuloContrattoGroupByOutputType.fromJson(Map json) =>
      TipoModuloContrattoGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        numeroOfferteCollegabili: json['numeroOfferteCollegabili'],
        $count: json['_count'] is Map
            ? _i2.TipoModuloContrattoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.TipoModuloContrattoAvgAggregateOutputType.fromJson(
                json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.TipoModuloContrattoSumAggregateOutputType.fromJson(
                json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.TipoModuloContrattoMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.TipoModuloContrattoMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final int? numeroOfferteCollegabili;

  final _i2.TipoModuloContrattoCountAggregateOutputType? $count;

  final _i2.TipoModuloContrattoAvgAggregateOutputType? $avg;

  final _i2.TipoModuloContrattoSumAggregateOutputType? $sum;

  final _i2.TipoModuloContrattoMinAggregateOutputType? $min;

  final _i2.TipoModuloContrattoMaxAggregateOutputType? $max;
}

class TipoModuloContrattoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCountOrderByAggregateInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoAvgOrderByAggregateInput(
      {this.numeroOfferteCollegabili});

  final _i2.SortOrder? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() =>
      {'numeroOfferteCollegabili': numeroOfferteCollegabili};
}

class TipoModuloContrattoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoMaxOrderByAggregateInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoMinOrderByAggregateInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoSumOrderByAggregateInput(
      {this.numeroOfferteCollegabili});

  final _i2.SortOrder? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() =>
      {'numeroOfferteCollegabili': numeroOfferteCollegabili};
}

class TipoModuloContrattoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? numeroOfferteCollegabili;

  final _i2.TipoModuloContrattoCountOrderByAggregateInput? $count;

  final _i2.TipoModuloContrattoAvgOrderByAggregateInput? $avg;

  final _i2.TipoModuloContrattoMaxOrderByAggregateInput? $max;

  final _i2.TipoModuloContrattoMinOrderByAggregateInput? $min;

  final _i2.TipoModuloContrattoSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedIntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class IntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class TipoModuloContrattoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final _i1.PrismaUnion<_i2.TipoModuloContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.TipoModuloContrattoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.TipoModuloContrattoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.TipoModuloContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.TipoModuloContrattoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>?
      numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? numeroOfferteCollegabili;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        '_all': $all,
      };
}

class TipoModuloContrattoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoGroupByOutputTypeCountArgs({this.select});

  final _i2.TipoModuloContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoModuloContrattoAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoAvgAggregateOutputTypeSelect(
      {this.numeroOfferteCollegabili});

  final bool? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() =>
      {'numeroOfferteCollegabili': numeroOfferteCollegabili};
}

class TipoModuloContrattoGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoGroupByOutputTypeAvgArgs({this.select});

  final _i2.TipoModuloContrattoAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoModuloContrattoSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoSumAggregateOutputTypeSelect(
      {this.numeroOfferteCollegabili});

  final bool? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() =>
      {'numeroOfferteCollegabili': numeroOfferteCollegabili};
}

class TipoModuloContrattoGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoGroupByOutputTypeSumArgs({this.select});

  final _i2.TipoModuloContrattoSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoModuloContrattoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final bool? id;

  final bool? nome;

  final bool? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoGroupByOutputTypeMinArgs({this.select});

  final _i2.TipoModuloContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoModuloContrattoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
  });

  final bool? id;

  final bool? nome;

  final bool? numeroOfferteCollegabili;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
      };
}

class TipoModuloContrattoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoGroupByOutputTypeMaxArgs({this.select});

  final _i2.TipoModuloContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoModuloContrattoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoModuloContrattoGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.numeroOfferteCollegabili,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final bool? numeroOfferteCollegabili;

  final _i1
      .PrismaUnion<bool, _i2.TipoModuloContrattoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.TipoModuloContrattoGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'numeroOfferteCollegabili': numeroOfferteCollegabili,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateTipoModuloContratto {
  const AggregateTipoModuloContratto({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateTipoModuloContratto.fromJson(Map json) =>
      AggregateTipoModuloContratto(
        $count: json['_count'] is Map
            ? _i2.TipoModuloContrattoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.TipoModuloContrattoAvgAggregateOutputType.fromJson(
                json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.TipoModuloContrattoSumAggregateOutputType.fromJson(
                json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.TipoModuloContrattoMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.TipoModuloContrattoMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final _i2.TipoModuloContrattoCountAggregateOutputType? $count;

  final _i2.TipoModuloContrattoAvgAggregateOutputType? $avg;

  final _i2.TipoModuloContrattoSumAggregateOutputType? $sum;

  final _i2.TipoModuloContrattoMinAggregateOutputType? $min;

  final _i2.TipoModuloContrattoMaxAggregateOutputType? $max;
}

class AggregateTipoModuloContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoModuloContrattoCountArgs({this.select});

  final _i2.TipoModuloContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoModuloContrattoAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoModuloContrattoAvgArgs({this.select});

  final _i2.TipoModuloContrattoAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoModuloContrattoSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoModuloContrattoSumArgs({this.select});

  final _i2.TipoModuloContrattoSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoModuloContrattoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoModuloContrattoMinArgs({this.select});

  final _i2.TipoModuloContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoModuloContrattoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoModuloContrattoMaxArgs({this.select});

  final _i2.TipoModuloContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoModuloContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoModuloContrattoSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateTipoModuloContrattoCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoModuloContrattoAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoModuloContrattoSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoModuloContrattoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoModuloContrattoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class StatoContrattoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoCreateNestedManyWithoutStatoInput? contratti;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutStatoInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final String id;

  final String nome;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutStatoInput? contratti;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliContrattiInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutStatoInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUpdateInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUpdateManyWithoutStatoNestedInput? contratti;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutStatoNestedInput? contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateInput({
    this.id,
    this.nome,
    this.contratti,
    this.serviziEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ContrattoUncheckedUpdateManyWithoutStatoNestedInput? contratti;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliContrattiNestedInput?
      serviziEwo;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutStatoNestedInput?
      contrattiEnelXAssicurazione;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'contratti': contratti,
        'serviziEwo': serviziEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
      };
}

class StatoContrattoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoCountAggregateOutputType {
  const StatoContrattoCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory StatoContrattoCountAggregateOutputType.fromJson(Map json) =>
      StatoContrattoCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class StatoContrattoMinAggregateOutputType {
  const StatoContrattoMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory StatoContrattoMinAggregateOutputType.fromJson(Map json) =>
      StatoContrattoMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class StatoContrattoMaxAggregateOutputType {
  const StatoContrattoMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory StatoContrattoMaxAggregateOutputType.fromJson(Map json) =>
      StatoContrattoMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class StatoContrattoGroupByOutputType {
  const StatoContrattoGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StatoContrattoGroupByOutputType.fromJson(Map json) =>
      StatoContrattoGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.StatoContrattoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoContrattoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoContrattoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.StatoContrattoCountAggregateOutputType? $count;

  final _i2.StatoContrattoMinAggregateOutputType? $min;

  final _i2.StatoContrattoMaxAggregateOutputType? $max;
}

class StatoContrattoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.StatoContrattoCountOrderByAggregateInput? $count;

  final _i2.StatoContrattoMaxOrderByAggregateInput? $max;

  final _i2.StatoContrattoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class StatoContrattoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.StatoContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoContrattoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.StatoContrattoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.StatoContrattoScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoContrattoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class StatoContrattoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoGroupByOutputTypeCountArgs({this.select});

  final _i2.StatoContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoContrattoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoGroupByOutputTypeMinArgs({this.select});

  final _i2.StatoContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoContrattoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoContrattoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoGroupByOutputTypeMaxArgs({this.select});

  final _i2.StatoContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoContrattoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoContrattoGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.StatoContrattoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateStatoContratto {
  const AggregateStatoContratto({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateStatoContratto.fromJson(Map json) => AggregateStatoContratto(
        $count: json['_count'] is Map
            ? _i2.StatoContrattoCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoContrattoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoContrattoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.StatoContrattoCountAggregateOutputType? $count;

  final _i2.StatoContrattoMinAggregateOutputType? $min;

  final _i2.StatoContrattoMaxAggregateOutputType? $max;
}

class AggregateStatoContrattoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoContrattoCountArgs({this.select});

  final _i2.StatoContrattoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoContrattoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoContrattoMinArgs({this.select});

  final _i2.StatoContrattoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoContrattoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoContrattoMaxArgs({this.select});

  final _i2.StatoContrattoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoContrattoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoContrattoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateStatoContrattoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoContrattoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoContrattoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class OffertaCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final _i2.ServizioEwoCreateNestedOneWithoutOfferteInput servizioEwo;

  final _i2.ContrattoEnelLuceCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaCreateNestedManyWithoutInclusaInOfferteInput? offerteIncluse;

  final _i2.OffertaCreateNestedManyWithoutOfferteIncluseInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedCreateInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedCreateNestedManyWithoutOffertaInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedCreateNestedManyWithoutInclusaInOfferteInput?
      offerteIncluse;

  final _i2.OffertaUncheckedCreateNestedManyWithoutOfferteIncluseInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCreateManyInput({
    this.uuid,
    required this.nome,
    required this.dataFineOfferta,
    required this.dataInizioOfferta,
    required this.servizioEwoId,
  });

  final String? uuid;

  final String nome;

  final DateTime dataFineOfferta;

  final DateTime dataInizioOfferta;

  final String servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUpdateInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwo,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i2.ServizioEwoUpdateOneRequiredWithoutOfferteNestedInput? servizioEwo;

  final _i2.ContrattoEnelLuceUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2.ContrattoEnelXAssicurazioneUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUpdateManyWithoutInclusaInOfferteNestedInput? offerteIncluse;

  final _i2.OffertaUpdateManyWithoutOfferteIncluseNestedInput? inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwo': servizioEwo,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.contrattiEnelLuce,
    this.contrattiEnelGas,
    this.contrattiEnelFibra,
    this.contrattiEnelXAssicurazione,
    this.offerteIncluse,
    this.inclusaInOfferte,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  final _i2.ContrattoEnelLuceUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelLuce;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelGas;

  final _i2.ContrattoEnelFibraUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelFibra;

  final _i2
      .ContrattoEnelXAssicurazioneUncheckedUpdateManyWithoutOffertaNestedInput?
      contrattiEnelXAssicurazione;

  final _i2.OffertaUncheckedUpdateManyWithoutInclusaInOfferteNestedInput?
      offerteIncluse;

  final _i2.OffertaUncheckedUpdateManyWithoutOfferteIncluseNestedInput?
      inclusaInOfferte;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        'contrattiEnelLuce': contrattiEnelLuce,
        'contrattiEnelGas': contrattiEnelGas,
        'contrattiEnelFibra': contrattiEnelFibra,
        'contrattiEnelXAssicurazione': contrattiEnelXAssicurazione,
        'offerteIncluse': offerteIncluse,
        'inclusaInOfferte': inclusaInOfferte,
      };
}

class OffertaUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaUncheckedUpdateManyInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataFineOfferta;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInizioOfferta;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaCountAggregateOutputType {
  const OffertaCountAggregateOutputType({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.$all,
  });

  factory OffertaCountAggregateOutputType.fromJson(Map json) =>
      OffertaCountAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataFineOfferta: json['dataFineOfferta'],
        dataInizioOfferta: json['dataInizioOfferta'],
        servizioEwoId: json['servizioEwoId'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? nome;

  final int? dataFineOfferta;

  final int? dataInizioOfferta;

  final int? servizioEwoId;

  final int? $all;
}

class OffertaMinAggregateOutputType {
  const OffertaMinAggregateOutputType({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  factory OffertaMinAggregateOutputType.fromJson(Map json) =>
      OffertaMinAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataFineOfferta: json['dataFineOfferta'],
        dataInizioOfferta: json['dataInizioOfferta'],
        servizioEwoId: json['servizioEwoId'],
      );

  final String? uuid;

  final String? nome;

  final DateTime? dataFineOfferta;

  final DateTime? dataInizioOfferta;

  final String? servizioEwoId;
}

class OffertaMaxAggregateOutputType {
  const OffertaMaxAggregateOutputType({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  factory OffertaMaxAggregateOutputType.fromJson(Map json) =>
      OffertaMaxAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataFineOfferta: json['dataFineOfferta'],
        dataInizioOfferta: json['dataInizioOfferta'],
        servizioEwoId: json['servizioEwoId'],
      );

  final String? uuid;

  final String? nome;

  final DateTime? dataFineOfferta;

  final DateTime? dataInizioOfferta;

  final String? servizioEwoId;
}

class OffertaGroupByOutputType {
  const OffertaGroupByOutputType({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.$count,
    this.$min,
    this.$max,
  });

  factory OffertaGroupByOutputType.fromJson(Map json) =>
      OffertaGroupByOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataFineOfferta: json['dataFineOfferta'],
        dataInizioOfferta: json['dataInizioOfferta'],
        servizioEwoId: json['servizioEwoId'],
        $count: json['_count'] is Map
            ? _i2.OffertaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OffertaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OffertaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? nome;

  final DateTime? dataFineOfferta;

  final DateTime? dataInizioOfferta;

  final String? servizioEwoId;

  final _i2.OffertaCountAggregateOutputType? $count;

  final _i2.OffertaMinAggregateOutputType? $min;

  final _i2.OffertaMaxAggregateOutputType? $max;
}

class OffertaCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCountOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataFineOfferta;

  final _i2.SortOrder? dataInizioOfferta;

  final _i2.SortOrder? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaMaxOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataFineOfferta;

  final _i2.SortOrder? dataInizioOfferta;

  final _i2.SortOrder? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaMinOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataFineOfferta;

  final _i2.SortOrder? dataInizioOfferta;

  final _i2.SortOrder? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaOrderByWithAggregationInput({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataFineOfferta;

  final _i2.SortOrder? dataInizioOfferta;

  final _i2.SortOrder? servizioEwoId;

  final _i2.OffertaCountOrderByAggregateInput? $count;

  final _i2.OffertaMaxOrderByAggregateInput? $max;

  final _i2.OffertaMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class OffertaScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final _i1.PrismaUnion<_i2.OffertaScalarWhereWithAggregatesInput,
      Iterable<_i2.OffertaScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OffertaScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OffertaScalarWhereWithAggregatesInput,
      Iterable<_i2.OffertaScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      dataFineOfferta;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      dataInizioOfferta;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaCountAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.$all,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataFineOfferta;

  final bool? dataInizioOfferta;

  final bool? servizioEwoId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        '_all': $all,
      };
}

class OffertaGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaGroupByOutputTypeCountArgs({this.select});

  final _i2.OffertaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OffertaMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaMinAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataFineOfferta;

  final bool? dataInizioOfferta;

  final bool? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaGroupByOutputTypeMinArgs({this.select});

  final _i2.OffertaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OffertaMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaMaxAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataFineOfferta;

  final bool? dataInizioOfferta;

  final bool? servizioEwoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
      };
}

class OffertaGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaGroupByOutputTypeMaxArgs({this.select});

  final _i2.OffertaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OffertaGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OffertaGroupByOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataFineOfferta,
    this.dataInizioOfferta,
    this.servizioEwoId,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataFineOfferta;

  final bool? dataInizioOfferta;

  final bool? servizioEwoId;

  final _i1.PrismaUnion<bool, _i2.OffertaGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.OffertaGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OffertaGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataFineOfferta': dataFineOfferta,
        'dataInizioOfferta': dataInizioOfferta,
        'servizioEwoId': servizioEwoId,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOfferta {
  const AggregateOfferta({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateOfferta.fromJson(Map json) => AggregateOfferta(
        $count: json['_count'] is Map
            ? _i2.OffertaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OffertaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OffertaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OffertaCountAggregateOutputType? $count;

  final _i2.OffertaMinAggregateOutputType? $min;

  final _i2.OffertaMaxAggregateOutputType? $max;
}

class AggregateOffertaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOffertaCountArgs({this.select});

  final _i2.OffertaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOffertaMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOffertaMinArgs({this.select});

  final _i2.OffertaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOffertaMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOffertaMaxArgs({this.select});

  final _i2.OffertaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOffertaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOffertaSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOffertaCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOffertaMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOffertaMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class PraticaCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    required this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaCreateNestedOneWithoutPraticheInput tipoPratica;

  final _i2.SoggettoCreateNestedOneWithoutPraticheIntestateInput? soggetto;

  final _i2.UtenteCreateNestedOneWithoutPraticheInput? utente;

  final _i2.NegozioCreateNestedOneWithoutPraticheInput? negozio;

  final _i2.StatoPraticaCreateNestedOneWithoutPraticheInput? stato;

  final _i2.ContrattoCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedCreateInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutPraticaInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCreateManyInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final String tipoPraticaId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoPraticaId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUpdateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.ultimoAggiornamentoStato,
    this.tipoPratica,
    this.soggetto,
    this.utente,
    this.negozio,
    this.stato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.TipoPraticaUpdateOneRequiredWithoutPraticheNestedInput? tipoPratica;

  final _i2.SoggettoUpdateOneWithoutPraticheIntestateNestedInput? soggetto;

  final _i2.UtenteUpdateOneWithoutPraticheNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutPraticheNestedInput? negozio;

  final _i2.StatoPraticaUpdateOneWithoutPraticheNestedInput? stato;

  final _i2.ContrattoUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'tipoPratica': tipoPratica,
        'soggetto': soggetto,
        'utente': utente,
        'negozio': negozio,
        'stato': stato,
        'contratto': contratto,
      };
}

class PraticaUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.contratto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  final _i2.ContrattoUncheckedUpdateManyWithoutPraticaNestedInput? contratto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        'contratto': contratto,
      };
}

class PraticaUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaUncheckedUpdateManyInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoPraticaId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCountAggregateOutputType {
  const PraticaCountAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.$all,
  });

  factory PraticaCountAggregateOutputType.fromJson(Map json) =>
      PraticaCountAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        tipoPraticaId: json['tipoPraticaId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        statoPraticaId: json['statoPraticaId'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? codice;

  final int? dataInserimento;

  final int? tipoPraticaId;

  final int? soggettoUuid;

  final int? utenteUuid;

  final int? negozioCodice;

  final int? statoPraticaId;

  final int? ultimoAggiornamentoStato;

  final int? $all;
}

class PraticaMinAggregateOutputType {
  const PraticaMinAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  factory PraticaMinAggregateOutputType.fromJson(Map json) =>
      PraticaMinAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        tipoPraticaId: json['tipoPraticaId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        statoPraticaId: json['statoPraticaId'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final String? tipoPraticaId;

  final String? soggettoUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? statoPraticaId;

  final DateTime? ultimoAggiornamentoStato;
}

class PraticaMaxAggregateOutputType {
  const PraticaMaxAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  factory PraticaMaxAggregateOutputType.fromJson(Map json) =>
      PraticaMaxAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        tipoPraticaId: json['tipoPraticaId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        statoPraticaId: json['statoPraticaId'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final String? tipoPraticaId;

  final String? soggettoUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? statoPraticaId;

  final DateTime? ultimoAggiornamentoStato;
}

class PraticaGroupByOutputType {
  const PraticaGroupByOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.$count,
    this.$min,
    this.$max,
  });

  factory PraticaGroupByOutputType.fromJson(Map json) =>
      PraticaGroupByOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        tipoPraticaId: json['tipoPraticaId'],
        soggettoUuid: json['soggettoUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        statoPraticaId: json['statoPraticaId'],
        ultimoAggiornamentoStato: json['ultimoAggiornamentoStato'],
        $count: json['_count'] is Map
            ? _i2.PraticaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PraticaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PraticaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final String? tipoPraticaId;

  final String? soggettoUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? statoPraticaId;

  final DateTime? ultimoAggiornamentoStato;

  final _i2.PraticaCountAggregateOutputType? $count;

  final _i2.PraticaMinAggregateOutputType? $min;

  final _i2.PraticaMaxAggregateOutputType? $max;
}

class PraticaCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCountOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? tipoPraticaId;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? statoPraticaId;

  final _i2.SortOrder? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaMaxOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? tipoPraticaId;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? statoPraticaId;

  final _i2.SortOrder? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaMinOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? tipoPraticaId;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? statoPraticaId;

  final _i2.SortOrder? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaOrderByWithAggregationInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? tipoPraticaId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? statoPraticaId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>?
      ultimoAggiornamentoStato;

  final _i2.PraticaCountOrderByAggregateInput? $count;

  final _i2.PraticaMaxOrderByAggregateInput? $max;

  final _i2.PraticaMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class PraticaScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final _i1.PrismaUnion<_i2.PraticaScalarWhereWithAggregatesInput,
      Iterable<_i2.PraticaScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.PraticaScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.PraticaScalarWhereWithAggregatesInput,
      Iterable<_i2.PraticaScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      dataInserimento;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? tipoPraticaId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoPraticaId;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaCountAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.$all,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? tipoPraticaId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? statoPraticaId;

  final bool? ultimoAggiornamentoStato;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        '_all': $all,
      };
}

class PraticaGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaGroupByOutputTypeCountArgs({this.select});

  final _i2.PraticaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PraticaMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaMinAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? tipoPraticaId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? statoPraticaId;

  final bool? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaGroupByOutputTypeMinArgs({this.select});

  final _i2.PraticaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PraticaMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaMaxAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? tipoPraticaId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? statoPraticaId;

  final bool? ultimoAggiornamentoStato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
      };
}

class PraticaGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaGroupByOutputTypeMaxArgs({this.select});

  final _i2.PraticaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class PraticaGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const PraticaGroupByOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.tipoPraticaId,
    this.soggettoUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.statoPraticaId,
    this.ultimoAggiornamentoStato,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? tipoPraticaId;

  final bool? soggettoUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? statoPraticaId;

  final bool? ultimoAggiornamentoStato;

  final _i1.PrismaUnion<bool, _i2.PraticaGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.PraticaGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.PraticaGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'tipoPraticaId': tipoPraticaId,
        'soggettoUuid': soggettoUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'statoPraticaId': statoPraticaId,
        'ultimoAggiornamentoStato': ultimoAggiornamentoStato,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregatePratica {
  const AggregatePratica({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregatePratica.fromJson(Map json) => AggregatePratica(
        $count: json['_count'] is Map
            ? _i2.PraticaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.PraticaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.PraticaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.PraticaCountAggregateOutputType? $count;

  final _i2.PraticaMinAggregateOutputType? $min;

  final _i2.PraticaMaxAggregateOutputType? $max;
}

class AggregatePraticaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePraticaCountArgs({this.select});

  final _i2.PraticaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePraticaMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePraticaMinArgs({this.select});

  final _i2.PraticaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePraticaMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePraticaMaxArgs({this.select});

  final _i2.PraticaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregatePraticaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregatePraticaSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregatePraticaCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregatePraticaMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregatePraticaMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class TipoPraticaCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.pratiche,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutTipiPraticheInput? serviziEwo;

  final _i2.PraticaCreateNestedManyWithoutTipoPraticaInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

class TipoPraticaUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.pratiche,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutTipiPraticheInput?
      serviziEwo;

  final _i2.PraticaUncheckedCreateNestedManyWithoutTipoPraticaInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

class TipoPraticaCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUpdateInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.pratiche,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutTipiPraticheNestedInput? serviziEwo;

  final _i2.PraticaUpdateManyWithoutTipoPraticaNestedInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

class TipoPraticaUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedUpdateInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.pratiche,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutTipiPraticheNestedInput?
      serviziEwo;

  final _i2.PraticaUncheckedUpdateManyWithoutTipoPraticaNestedInput? pratiche;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'pratiche': pratiche,
      };
}

class TipoPraticaUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaCountAggregateOutputType {
  const TipoPraticaCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory TipoPraticaCountAggregateOutputType.fromJson(Map json) =>
      TipoPraticaCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class TipoPraticaMinAggregateOutputType {
  const TipoPraticaMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory TipoPraticaMinAggregateOutputType.fromJson(Map json) =>
      TipoPraticaMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class TipoPraticaMaxAggregateOutputType {
  const TipoPraticaMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory TipoPraticaMaxAggregateOutputType.fromJson(Map json) =>
      TipoPraticaMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class TipoPraticaGroupByOutputType {
  const TipoPraticaGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory TipoPraticaGroupByOutputType.fromJson(Map json) =>
      TipoPraticaGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.TipoPraticaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.TipoPraticaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.TipoPraticaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.TipoPraticaCountAggregateOutputType? $count;

  final _i2.TipoPraticaMinAggregateOutputType? $min;

  final _i2.TipoPraticaMaxAggregateOutputType? $max;
}

class TipoPraticaCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.TipoPraticaCountOrderByAggregateInput? $count;

  final _i2.TipoPraticaMaxOrderByAggregateInput? $max;

  final _i2.TipoPraticaMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class TipoPraticaScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.TipoPraticaScalarWhereWithAggregatesInput,
      Iterable<_i2.TipoPraticaScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.TipoPraticaScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.TipoPraticaScalarWhereWithAggregatesInput,
      Iterable<_i2.TipoPraticaScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class TipoPraticaGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaGroupByOutputTypeCountArgs({this.select});

  final _i2.TipoPraticaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoPraticaMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaGroupByOutputTypeMinArgs({this.select});

  final _i2.TipoPraticaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoPraticaMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoPraticaGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaGroupByOutputTypeMaxArgs({this.select});

  final _i2.TipoPraticaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoPraticaGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoPraticaGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.TipoPraticaGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateTipoPratica {
  const AggregateTipoPratica({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateTipoPratica.fromJson(Map json) => AggregateTipoPratica(
        $count: json['_count'] is Map
            ? _i2.TipoPraticaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.TipoPraticaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.TipoPraticaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.TipoPraticaCountAggregateOutputType? $count;

  final _i2.TipoPraticaMinAggregateOutputType? $min;

  final _i2.TipoPraticaMaxAggregateOutputType? $max;
}

class AggregateTipoPraticaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoPraticaCountArgs({this.select});

  final _i2.TipoPraticaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoPraticaMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoPraticaMinArgs({this.select});

  final _i2.TipoPraticaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoPraticaMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoPraticaMaxArgs({this.select});

  final _i2.TipoPraticaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoPraticaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoPraticaSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateTipoPraticaCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoPraticaMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoPraticaMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StatoPraticaCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateInput({
    required this.id,
    required this.nome,
    this.pratiche,
    this.serviziEwo,
  });

  final String id;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutStatoInput? pratiche;

  final _i2.ServizioEwoCreateNestedManyWithoutStatiPossibiliPraticheInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.pratiche,
    this.serviziEwo,
  });

  final String id;

  final String nome;

  final _i2.PraticaUncheckedCreateNestedManyWithoutStatoInput? pratiche;

  final _i2
      .ServizioEwoUncheckedCreateNestedManyWithoutStatiPossibiliPraticheInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUpdateInput({
    this.id,
    this.nome,
    this.pratiche,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutStatoNestedInput? pratiche;

  final _i2.ServizioEwoUpdateManyWithoutStatiPossibiliPraticheNestedInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedUpdateInput({
    this.id,
    this.nome,
    this.pratiche,
    this.serviziEwo,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUncheckedUpdateManyWithoutStatoNestedInput? pratiche;

  final _i2
      .ServizioEwoUncheckedUpdateManyWithoutStatiPossibiliPraticheNestedInput?
      serviziEwo;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'pratiche': pratiche,
        'serviziEwo': serviziEwo,
      };
}

class StatoPraticaUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaCountAggregateOutputType {
  const StatoPraticaCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory StatoPraticaCountAggregateOutputType.fromJson(Map json) =>
      StatoPraticaCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class StatoPraticaMinAggregateOutputType {
  const StatoPraticaMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory StatoPraticaMinAggregateOutputType.fromJson(Map json) =>
      StatoPraticaMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class StatoPraticaMaxAggregateOutputType {
  const StatoPraticaMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory StatoPraticaMaxAggregateOutputType.fromJson(Map json) =>
      StatoPraticaMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class StatoPraticaGroupByOutputType {
  const StatoPraticaGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StatoPraticaGroupByOutputType.fromJson(Map json) =>
      StatoPraticaGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.StatoPraticaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoPraticaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoPraticaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.StatoPraticaCountAggregateOutputType? $count;

  final _i2.StatoPraticaMinAggregateOutputType? $min;

  final _i2.StatoPraticaMaxAggregateOutputType? $max;
}

class StatoPraticaCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.StatoPraticaCountOrderByAggregateInput? $count;

  final _i2.StatoPraticaMaxOrderByAggregateInput? $max;

  final _i2.StatoPraticaMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class StatoPraticaScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.StatoPraticaScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoPraticaScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.StatoPraticaScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.StatoPraticaScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoPraticaScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class StatoPraticaGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaGroupByOutputTypeCountArgs({this.select});

  final _i2.StatoPraticaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoPraticaMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaGroupByOutputTypeMinArgs({this.select});

  final _i2.StatoPraticaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoPraticaMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class StatoPraticaGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaGroupByOutputTypeMaxArgs({this.select});

  final _i2.StatoPraticaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoPraticaGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoPraticaGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.StatoPraticaGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateStatoPratica {
  const AggregateStatoPratica({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateStatoPratica.fromJson(Map json) => AggregateStatoPratica(
        $count: json['_count'] is Map
            ? _i2.StatoPraticaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoPraticaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoPraticaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.StatoPraticaCountAggregateOutputType? $count;

  final _i2.StatoPraticaMinAggregateOutputType? $min;

  final _i2.StatoPraticaMaxAggregateOutputType? $max;
}

class AggregateStatoPraticaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoPraticaCountArgs({this.select});

  final _i2.StatoPraticaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoPraticaMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoPraticaMinArgs({this.select});

  final _i2.StatoPraticaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoPraticaMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoPraticaMaxArgs({this.select});

  final _i2.StatoPraticaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoPraticaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoPraticaSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateStatoPraticaCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoPraticaMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoPraticaMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoEnelLuceCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateInput({
    this.uuid,
    required this.stato,
    required this.fornituraLuce,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelLuceInput stato;

  final _i2.FornituraLuceCreateNestedOneWithoutContrattiEnelLuceInput
      fornituraLuce;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelLuceInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelLuceInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedCreateInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraLuceUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraLuceUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCreateManyInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraLuceUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraLuceUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUpdateInput({
    this.uuid,
    this.stato,
    this.fornituraLuce,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      stato;

  final _i2.FornituraLuceUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      fornituraLuce;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelLuceNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelLuceNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraLuce': fornituraLuce,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelLuceUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceUncheckedUpdateManyInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCountAggregateOutputType {
  const ContrattoEnelLuceCountAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$all,
  });

  factory ContrattoEnelLuceCountAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelLuceCountAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? statoContrattoId;

  final int? fornituraLuceUuid;

  final int? contrattoUuid;

  final int? offertaUuid;

  final int? $all;
}

class ContrattoEnelLuceMinAggregateOutputType {
  const ContrattoEnelLuceMinAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelLuceMinAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelLuceMinAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? fornituraLuceUuid;

  final String? contrattoUuid;

  final String? offertaUuid;
}

class ContrattoEnelLuceMaxAggregateOutputType {
  const ContrattoEnelLuceMaxAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelLuceMaxAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelLuceMaxAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? fornituraLuceUuid;

  final String? contrattoUuid;

  final String? offertaUuid;
}

class ContrattoEnelLuceGroupByOutputType {
  const ContrattoEnelLuceGroupByOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ContrattoEnelLuceGroupByOutputType.fromJson(Map json) =>
      ContrattoEnelLuceGroupByOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraLuceUuid: json['fornituraLuceUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelLuceCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelLuceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelLuceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? fornituraLuceUuid;

  final String? contrattoUuid;

  final String? offertaUuid;

  final _i2.ContrattoEnelLuceCountAggregateOutputType? $count;

  final _i2.ContrattoEnelLuceMinAggregateOutputType? $min;

  final _i2.ContrattoEnelLuceMaxAggregateOutputType? $max;
}

class ContrattoEnelLuceCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCountOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceMaxOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceMinOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceOrderByWithAggregationInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraLuceUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.ContrattoEnelLuceCountOrderByAggregateInput? $count;

  final _i2.ContrattoEnelLuceMaxOrderByAggregateInput? $max;

  final _i2.ContrattoEnelLuceMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class ContrattoEnelLuceScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ContrattoEnelLuceScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelLuceScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoEnelLuceScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      statoContrattoId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      fornituraLuceUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceCountAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraLuceUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        '_all': $all,
      };
}

class ContrattoEnelLuceGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceGroupByOutputTypeCountArgs({this.select});

  final _i2.ContrattoEnelLuceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelLuceMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceMinAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraLuceUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceGroupByOutputTypeMinArgs({this.select});

  final _i2.ContrattoEnelLuceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelLuceMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceMaxAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraLuceUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelLuceGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceGroupByOutputTypeMaxArgs({this.select});

  final _i2.ContrattoEnelLuceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelLuceGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelLuceGroupByOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraLuceUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraLuceUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelLuceGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraLuceUuid': fornituraLuceUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateContrattoEnelLuce {
  const AggregateContrattoEnelLuce({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateContrattoEnelLuce.fromJson(Map json) =>
      AggregateContrattoEnelLuce(
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelLuceCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelLuceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelLuceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ContrattoEnelLuceCountAggregateOutputType? $count;

  final _i2.ContrattoEnelLuceMinAggregateOutputType? $min;

  final _i2.ContrattoEnelLuceMaxAggregateOutputType? $max;
}

class AggregateContrattoEnelLuceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelLuceCountArgs({this.select});

  final _i2.ContrattoEnelLuceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelLuceMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelLuceMinArgs({this.select});

  final _i2.ContrattoEnelLuceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelLuceMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelLuceMaxArgs({this.select});

  final _i2.ContrattoEnelLuceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelLuceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelLuceSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelLuceCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelLuceMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelLuceMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoEnelGasCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateInput({
    this.uuid,
    required this.stato,
    required this.fornituraGas,
    required this.contratto,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelGasInput stato;

  final _i2.FornituraGasCreateNestedOneWithoutContrattiEnelGasInput
      fornituraGas;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelGasInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelGasInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedCreateInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraGasUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraGasUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCreateManyInput({
    this.uuid,
    required this.statoContrattoId,
    required this.fornituraGasUuid,
    required this.contrattoUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String fornituraGasUuid;

  final String contrattoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUpdateInput({
    this.uuid,
    this.stato,
    this.fornituraGas,
    this.contratto,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      stato;

  final _i2.FornituraGasUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      fornituraGas;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelGasNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelGasNestedInput? offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'fornituraGas': fornituraGas,
        'contratto': contratto,
        'offerta': offerta,
      };
}

class ContrattoEnelGasUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasUncheckedUpdateManyInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraGasUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCountAggregateOutputType {
  const ContrattoEnelGasCountAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$all,
  });

  factory ContrattoEnelGasCountAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelGasCountAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraGasUuid: json['fornituraGasUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? statoContrattoId;

  final int? fornituraGasUuid;

  final int? contrattoUuid;

  final int? offertaUuid;

  final int? $all;
}

class ContrattoEnelGasMinAggregateOutputType {
  const ContrattoEnelGasMinAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelGasMinAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelGasMinAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraGasUuid: json['fornituraGasUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? fornituraGasUuid;

  final String? contrattoUuid;

  final String? offertaUuid;
}

class ContrattoEnelGasMaxAggregateOutputType {
  const ContrattoEnelGasMaxAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelGasMaxAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelGasMaxAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraGasUuid: json['fornituraGasUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? fornituraGasUuid;

  final String? contrattoUuid;

  final String? offertaUuid;
}

class ContrattoEnelGasGroupByOutputType {
  const ContrattoEnelGasGroupByOutputType({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ContrattoEnelGasGroupByOutputType.fromJson(Map json) =>
      ContrattoEnelGasGroupByOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        fornituraGasUuid: json['fornituraGasUuid'],
        contrattoUuid: json['contrattoUuid'],
        offertaUuid: json['offertaUuid'],
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelGasCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelGasMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelGasMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? fornituraGasUuid;

  final String? contrattoUuid;

  final String? offertaUuid;

  final _i2.ContrattoEnelGasCountAggregateOutputType? $count;

  final _i2.ContrattoEnelGasMinAggregateOutputType? $min;

  final _i2.ContrattoEnelGasMaxAggregateOutputType? $max;
}

class ContrattoEnelGasCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCountOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasMaxOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasMinOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasOrderByWithAggregationInput({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? fornituraGasUuid;

  final _i2.SortOrder? contrattoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.ContrattoEnelGasCountOrderByAggregateInput? $count;

  final _i2.ContrattoEnelGasMaxOrderByAggregateInput? $max;

  final _i2.ContrattoEnelGasMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class ContrattoEnelGasScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ContrattoEnelGasScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelGasScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoEnelGasScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      statoContrattoId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      fornituraGasUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasCountAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraGasUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        '_all': $all,
      };
}

class ContrattoEnelGasGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasGroupByOutputTypeCountArgs({this.select});

  final _i2.ContrattoEnelGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelGasMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasMinAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraGasUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasGroupByOutputTypeMinArgs({this.select});

  final _i2.ContrattoEnelGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelGasMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasMaxAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraGasUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelGasGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasGroupByOutputTypeMaxArgs({this.select});

  final _i2.ContrattoEnelGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelGasGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelGasGroupByOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.fornituraGasUuid,
    this.contrattoUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? fornituraGasUuid;

  final bool? contrattoUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelGasGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'fornituraGasUuid': fornituraGasUuid,
        'contrattoUuid': contrattoUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateContrattoEnelGas {
  const AggregateContrattoEnelGas({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateContrattoEnelGas.fromJson(Map json) =>
      AggregateContrattoEnelGas(
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelGasCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelGasMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelGasMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ContrattoEnelGasCountAggregateOutputType? $count;

  final _i2.ContrattoEnelGasMinAggregateOutputType? $min;

  final _i2.ContrattoEnelGasMaxAggregateOutputType? $max;
}

class AggregateContrattoEnelGasCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelGasCountArgs({this.select});

  final _i2.ContrattoEnelGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelGasMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelGasMinArgs({this.select});

  final _i2.ContrattoEnelGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelGasMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelGasMaxArgs({this.select});

  final _i2.ContrattoEnelGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelGasSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelGasCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelGasMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelGasMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoEnelXAssicurazioneCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateInput({
    this.uuid,
    required this.stato,
    required this.contratto,
    required this.domicilio,
    this.offerta,
  });

  final String? uuid;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      contratto;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelXAssicurazioneInput
      domicilio;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelXAssicurazioneInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedCreateInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final String domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCreateManyInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final String domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUpdateInput({
    this.uuid,
    this.stato,
    this.contratto,
    this.domicilio,
    this.offerta,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i2
      .StatoContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      stato;

  final _i2
      .ContrattoUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      contratto;

  final _i2
      .DomicilioUpdateOneRequiredWithoutContrattiEnelXAssicurazioneNestedInput?
      domicilio;

  final _i2.OffertaUpdateOneWithoutContrattiEnelXAssicurazioneNestedInput?
      offerta;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'stato': stato,
        'contratto': contratto,
        'domicilio': domicilio,
        'offerta': offerta,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneUncheckedUpdateManyInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCountAggregateOutputType {
  const ContrattoEnelXAssicurazioneCountAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.$all,
  });

  factory ContrattoEnelXAssicurazioneCountAggregateOutputType.fromJson(
          Map json) =>
      ContrattoEnelXAssicurazioneCountAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? statoContrattoId;

  final int? contrattoUuid;

  final int? domicilioUuid;

  final int? offertaUuid;

  final int? $all;
}

class ContrattoEnelXAssicurazioneMinAggregateOutputType {
  const ContrattoEnelXAssicurazioneMinAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelXAssicurazioneMinAggregateOutputType.fromJson(
          Map json) =>
      ContrattoEnelXAssicurazioneMinAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? contrattoUuid;

  final String? domicilioUuid;

  final String? offertaUuid;
}

class ContrattoEnelXAssicurazioneMaxAggregateOutputType {
  const ContrattoEnelXAssicurazioneMaxAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelXAssicurazioneMaxAggregateOutputType.fromJson(
          Map json) =>
      ContrattoEnelXAssicurazioneMaxAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? contrattoUuid;

  final String? domicilioUuid;

  final String? offertaUuid;
}

class ContrattoEnelXAssicurazioneGroupByOutputType {
  const ContrattoEnelXAssicurazioneGroupByOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ContrattoEnelXAssicurazioneGroupByOutputType.fromJson(Map json) =>
      ContrattoEnelXAssicurazioneGroupByOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelXAssicurazioneCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelXAssicurazioneMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelXAssicurazioneMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? contrattoUuid;

  final String? domicilioUuid;

  final String? offertaUuid;

  final _i2.ContrattoEnelXAssicurazioneCountAggregateOutputType? $count;

  final _i2.ContrattoEnelXAssicurazioneMinAggregateOutputType? $min;

  final _i2.ContrattoEnelXAssicurazioneMaxAggregateOutputType? $max;
}

class ContrattoEnelXAssicurazioneCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCountOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneMaxOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneMinOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneOrderByWithAggregationInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.ContrattoEnelXAssicurazioneCountOrderByAggregateInput? $count;

  final _i2.ContrattoEnelXAssicurazioneMaxOrderByAggregateInput? $max;

  final _i2.ContrattoEnelXAssicurazioneMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput,
      Iterable<
          _i2.ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput>?
      OR;

  final _i1.PrismaUnion<
      _i2.ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput,
      Iterable<
          _i2.ContrattoEnelXAssicurazioneScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      statoContrattoId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneCountAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        '_all': $all,
      };
}

class ContrattoEnelXAssicurazioneGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneGroupByOutputTypeCountArgs({this.select});

  final _i2.ContrattoEnelXAssicurazioneCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelXAssicurazioneMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneMinAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneGroupByOutputTypeMinArgs({this.select});

  final _i2.ContrattoEnelXAssicurazioneMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelXAssicurazioneMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneMaxAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelXAssicurazioneGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneGroupByOutputTypeMaxArgs({this.select});

  final _i2.ContrattoEnelXAssicurazioneMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelXAssicurazioneGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelXAssicurazioneGroupByOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.domicilioUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool,
      _i2.ContrattoEnelXAssicurazioneGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool,
      _i2.ContrattoEnelXAssicurazioneGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool,
      _i2.ContrattoEnelXAssicurazioneGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateContrattoEnelXAssicurazione {
  const AggregateContrattoEnelXAssicurazione({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateContrattoEnelXAssicurazione.fromJson(Map json) =>
      AggregateContrattoEnelXAssicurazione(
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelXAssicurazioneCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelXAssicurazioneMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelXAssicurazioneMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final _i2.ContrattoEnelXAssicurazioneCountAggregateOutputType? $count;

  final _i2.ContrattoEnelXAssicurazioneMinAggregateOutputType? $min;

  final _i2.ContrattoEnelXAssicurazioneMaxAggregateOutputType? $max;
}

class AggregateContrattoEnelXAssicurazioneCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelXAssicurazioneCountArgs({this.select});

  final _i2.ContrattoEnelXAssicurazioneCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelXAssicurazioneMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelXAssicurazioneMinArgs({this.select});

  final _i2.ContrattoEnelXAssicurazioneMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelXAssicurazioneMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelXAssicurazioneMaxArgs({this.select});

  final _i2.ContrattoEnelXAssicurazioneMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelXAssicurazioneSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelXAssicurazioneSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<bool, _i2.AggregateContrattoEnelXAssicurazioneCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelXAssicurazioneMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelXAssicurazioneMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoEnelFibraCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateInput({
    this.uuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    required this.stato,
    required this.contratto,
    this.offerta,
    this.domicilio,
  });

  final String? uuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoCreateNestedOneWithoutContrattiEnelFibraInput stato;

  final _i2.ContrattoCreateNestedOneWithoutContrattiEnelFibraInput contratto;

  final _i2.OffertaCreateNestedOneWithoutContrattiEnelFibraInput? offerta;

  final _i2.DomicilioCreateNestedOneWithoutContrattiEnelFibraInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedCreateInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCreateManyInput({
    this.uuid,
    required this.statoContrattoId,
    required this.contrattoUuid,
    required this.servizioContrattoEnelFibra,
    required this.tipoContrattoEnelFibra,
    required this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final String? uuid;

  final String statoContrattoId;

  final String contrattoUuid;

  final _i3.ServizioContrattoEnelFibra servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUpdateInput({
    this.uuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.stato,
    this.contratto,
    this.offerta,
    this.domicilio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i2.StatoContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      stato;

  final _i2.ContrattoUpdateOneRequiredWithoutContrattiEnelFibraNestedInput?
      contratto;

  final _i2.OffertaUpdateOneWithoutContrattiEnelFibraNestedInput? offerta;

  final _i2.DomicilioUpdateOneWithoutContrattiEnelFibraNestedInput? domicilio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'stato': stato,
        'contratto': contratto,
        'offerta': offerta,
        'domicilio': domicilio,
      };
}

class ContrattoEnelFibraUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraUncheckedUpdateManyInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoContrattoId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      contrattoUuid;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
          _i2.EnumServizioContrattoEnelFibraFieldUpdateOperationsInput>?
      servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
          _i2.EnumTipoContrattoEnelFibraFieldUpdateOperationsInput>?
      tipoContrattoEnelFibra;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
          _i2.EnumTecnologiaContrattoEnelFibraFieldUpdateOperationsInput>?
      tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCountAggregateOutputType {
  const ContrattoEnelFibraCountAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.$all,
  });

  factory ContrattoEnelFibraCountAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelFibraCountAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        servizioContrattoEnelFibra: json['servizioContrattoEnelFibra'],
        tipoContrattoEnelFibra: json['tipoContrattoEnelFibra'],
        tecnologiaContrattoEnelFibra: json['tecnologiaContrattoEnelFibra'],
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? statoContrattoId;

  final int? contrattoUuid;

  final int? servizioContrattoEnelFibra;

  final int? tipoContrattoEnelFibra;

  final int? tecnologiaContrattoEnelFibra;

  final int? domicilioUuid;

  final int? offertaUuid;

  final int? $all;
}

class ContrattoEnelFibraMinAggregateOutputType {
  const ContrattoEnelFibraMinAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelFibraMinAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelFibraMinAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        servizioContrattoEnelFibra: json['servizioContrattoEnelFibra'] != null
            ? _i3.ServizioContrattoEnelFibra.values
                .firstWhere((e) => e.name == json['servizioContrattoEnelFibra'])
            : null,
        tipoContrattoEnelFibra: json['tipoContrattoEnelFibra'] != null
            ? _i3.TipoContrattoEnelFibra.values
                .firstWhere((e) => e.name == json['tipoContrattoEnelFibra'])
            : null,
        tecnologiaContrattoEnelFibra:
            json['tecnologiaContrattoEnelFibra'] != null
                ? _i3.TecnologiaContrattoEnelFibra.values.firstWhere(
                    (e) => e.name == json['tecnologiaContrattoEnelFibra'])
                : null,
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? contrattoUuid;

  final _i3.ServizioContrattoEnelFibra? servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra? tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra? tecnologiaContrattoEnelFibra;

  final String? domicilioUuid;

  final String? offertaUuid;
}

class ContrattoEnelFibraMaxAggregateOutputType {
  const ContrattoEnelFibraMaxAggregateOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  factory ContrattoEnelFibraMaxAggregateOutputType.fromJson(Map json) =>
      ContrattoEnelFibraMaxAggregateOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        servizioContrattoEnelFibra: json['servizioContrattoEnelFibra'] != null
            ? _i3.ServizioContrattoEnelFibra.values
                .firstWhere((e) => e.name == json['servizioContrattoEnelFibra'])
            : null,
        tipoContrattoEnelFibra: json['tipoContrattoEnelFibra'] != null
            ? _i3.TipoContrattoEnelFibra.values
                .firstWhere((e) => e.name == json['tipoContrattoEnelFibra'])
            : null,
        tecnologiaContrattoEnelFibra:
            json['tecnologiaContrattoEnelFibra'] != null
                ? _i3.TecnologiaContrattoEnelFibra.values.firstWhere(
                    (e) => e.name == json['tecnologiaContrattoEnelFibra'])
                : null,
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? contrattoUuid;

  final _i3.ServizioContrattoEnelFibra? servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra? tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra? tecnologiaContrattoEnelFibra;

  final String? domicilioUuid;

  final String? offertaUuid;
}

class ContrattoEnelFibraGroupByOutputType {
  const ContrattoEnelFibraGroupByOutputType({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ContrattoEnelFibraGroupByOutputType.fromJson(Map json) =>
      ContrattoEnelFibraGroupByOutputType(
        uuid: json['uuid'],
        statoContrattoId: json['statoContrattoId'],
        contrattoUuid: json['contrattoUuid'],
        servizioContrattoEnelFibra: json['servizioContrattoEnelFibra'] != null
            ? _i3.ServizioContrattoEnelFibra.values
                .firstWhere((e) => e.name == json['servizioContrattoEnelFibra'])
            : null,
        tipoContrattoEnelFibra: json['tipoContrattoEnelFibra'] != null
            ? _i3.TipoContrattoEnelFibra.values
                .firstWhere((e) => e.name == json['tipoContrattoEnelFibra'])
            : null,
        tecnologiaContrattoEnelFibra:
            json['tecnologiaContrattoEnelFibra'] != null
                ? _i3.TecnologiaContrattoEnelFibra.values.firstWhere(
                    (e) => e.name == json['tecnologiaContrattoEnelFibra'])
                : null,
        domicilioUuid: json['domicilioUuid'],
        offertaUuid: json['offertaUuid'],
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelFibraCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelFibraMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelFibraMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final String? uuid;

  final String? statoContrattoId;

  final String? contrattoUuid;

  final _i3.ServizioContrattoEnelFibra? servizioContrattoEnelFibra;

  final _i3.TipoContrattoEnelFibra? tipoContrattoEnelFibra;

  final _i3.TecnologiaContrattoEnelFibra? tecnologiaContrattoEnelFibra;

  final String? domicilioUuid;

  final String? offertaUuid;

  final _i2.ContrattoEnelFibraCountAggregateOutputType? $count;

  final _i2.ContrattoEnelFibraMinAggregateOutputType? $min;

  final _i2.ContrattoEnelFibraMaxAggregateOutputType? $max;
}

class ContrattoEnelFibraCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCountOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? servizioContrattoEnelFibra;

  final _i2.SortOrder? tipoContrattoEnelFibra;

  final _i2.SortOrder? tecnologiaContrattoEnelFibra;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraMaxOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? servizioContrattoEnelFibra;

  final _i2.SortOrder? tipoContrattoEnelFibra;

  final _i2.SortOrder? tecnologiaContrattoEnelFibra;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraMinOrderByAggregateInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? servizioContrattoEnelFibra;

  final _i2.SortOrder? tipoContrattoEnelFibra;

  final _i2.SortOrder? tecnologiaContrattoEnelFibra;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraOrderByWithAggregationInput({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? statoContrattoId;

  final _i2.SortOrder? contrattoUuid;

  final _i2.SortOrder? servizioContrattoEnelFibra;

  final _i2.SortOrder? tipoContrattoEnelFibra;

  final _i2.SortOrder? tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? domicilioUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? offertaUuid;

  final _i2.ContrattoEnelFibraCountOrderByAggregateInput? $count;

  final _i2.ContrattoEnelFibraMaxOrderByAggregateInput? $max;

  final _i2.ContrattoEnelFibraMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NestedEnumServizioContrattoEnelFibraWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumServizioContrattoEnelFibraWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i1.Reference<_i3.ServizioContrattoEnelFibra>>? equals;

  final Iterable<_i3.ServizioContrattoEnelFibra>? $in;

  final Iterable<_i3.ServizioContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i2.NestedEnumServizioContrattoEnelFibraWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumServizioContrattoEnelFibraFilter? $min;

  final _i2.NestedEnumServizioContrattoEnelFibraFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumServizioContrattoEnelFibraWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumServizioContrattoEnelFibraWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i1.Reference<_i3.ServizioContrattoEnelFibra>>? equals;

  final Iterable<_i3.ServizioContrattoEnelFibra>? $in;

  final Iterable<_i3.ServizioContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.ServizioContrattoEnelFibra,
      _i2.NestedEnumServizioContrattoEnelFibraWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumServizioContrattoEnelFibraFilter? $min;

  final _i2.NestedEnumServizioContrattoEnelFibraFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedEnumTipoContrattoEnelFibraWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoContrattoEnelFibraWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i1.Reference<_i3.TipoContrattoEnelFibra>>? equals;

  final Iterable<_i3.TipoContrattoEnelFibra>? $in;

  final Iterable<_i3.TipoContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i2.NestedEnumTipoContrattoEnelFibraWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoContrattoEnelFibraFilter? $min;

  final _i2.NestedEnumTipoContrattoEnelFibraFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumTipoContrattoEnelFibraWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoContrattoEnelFibraWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i1.Reference<_i3.TipoContrattoEnelFibra>>? equals;

  final Iterable<_i3.TipoContrattoEnelFibra>? $in;

  final Iterable<_i3.TipoContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TipoContrattoEnelFibra,
      _i2.NestedEnumTipoContrattoEnelFibraWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoContrattoEnelFibraFilter? $min;

  final _i2.NestedEnumTipoContrattoEnelFibraFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedEnumTecnologiaContrattoEnelFibraWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTecnologiaContrattoEnelFibraWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i1.Reference<_i3.TecnologiaContrattoEnelFibra>>? equals;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? $in;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i2.NestedEnumTecnologiaContrattoEnelFibraWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTecnologiaContrattoEnelFibraFilter? $min;

  final _i2.NestedEnumTecnologiaContrattoEnelFibraFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumTecnologiaContrattoEnelFibraWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTecnologiaContrattoEnelFibraWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i1.Reference<_i3.TecnologiaContrattoEnelFibra>>? equals;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? $in;

  final Iterable<_i3.TecnologiaContrattoEnelFibra>? notIn;

  final _i1.PrismaUnion<_i3.TecnologiaContrattoEnelFibra,
      _i2.NestedEnumTecnologiaContrattoEnelFibraWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTecnologiaContrattoEnelFibraFilter? $min;

  final _i2.NestedEnumTecnologiaContrattoEnelFibraFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ContrattoEnelFibraScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ContrattoEnelFibraScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ContrattoEnelFibraScalarWhereWithAggregatesInput,
      Iterable<_i2.ContrattoEnelFibraScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      statoContrattoId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? contrattoUuid;

  final _i1.PrismaUnion<_i2.EnumServizioContrattoEnelFibraWithAggregatesFilter,
      _i3.ServizioContrattoEnelFibra>? servizioContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.EnumTipoContrattoEnelFibraWithAggregatesFilter,
      _i3.TipoContrattoEnelFibra>? tipoContrattoEnelFibra;

  final _i1.PrismaUnion<
      _i2.EnumTecnologiaContrattoEnelFibraWithAggregatesFilter,
      _i3.TecnologiaContrattoEnelFibra>? tecnologiaContrattoEnelFibra;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraCountAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? servizioContrattoEnelFibra;

  final bool? tipoContrattoEnelFibra;

  final bool? tecnologiaContrattoEnelFibra;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        '_all': $all,
      };
}

class ContrattoEnelFibraGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraGroupByOutputTypeCountArgs({this.select});

  final _i2.ContrattoEnelFibraCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelFibraMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraMinAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? servizioContrattoEnelFibra;

  final bool? tipoContrattoEnelFibra;

  final bool? tecnologiaContrattoEnelFibra;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraGroupByOutputTypeMinArgs({this.select});

  final _i2.ContrattoEnelFibraMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelFibraMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraMaxAggregateOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? servizioContrattoEnelFibra;

  final bool? tipoContrattoEnelFibra;

  final bool? tecnologiaContrattoEnelFibra;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
      };
}

class ContrattoEnelFibraGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraGroupByOutputTypeMaxArgs({this.select});

  final _i2.ContrattoEnelFibraMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ContrattoEnelFibraGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ContrattoEnelFibraGroupByOutputTypeSelect({
    this.uuid,
    this.statoContrattoId,
    this.contrattoUuid,
    this.servizioContrattoEnelFibra,
    this.tipoContrattoEnelFibra,
    this.tecnologiaContrattoEnelFibra,
    this.domicilioUuid,
    this.offertaUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? statoContrattoId;

  final bool? contrattoUuid;

  final bool? servizioContrattoEnelFibra;

  final bool? tipoContrattoEnelFibra;

  final bool? tecnologiaContrattoEnelFibra;

  final bool? domicilioUuid;

  final bool? offertaUuid;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ContrattoEnelFibraGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'statoContrattoId': statoContrattoId,
        'contrattoUuid': contrattoUuid,
        'servizioContrattoEnelFibra': servizioContrattoEnelFibra,
        'tipoContrattoEnelFibra': tipoContrattoEnelFibra,
        'tecnologiaContrattoEnelFibra': tecnologiaContrattoEnelFibra,
        'domicilioUuid': domicilioUuid,
        'offertaUuid': offertaUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateContrattoEnelFibra {
  const AggregateContrattoEnelFibra({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateContrattoEnelFibra.fromJson(Map json) =>
      AggregateContrattoEnelFibra(
        $count: json['_count'] is Map
            ? _i2.ContrattoEnelFibraCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ContrattoEnelFibraMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ContrattoEnelFibraMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final _i2.ContrattoEnelFibraCountAggregateOutputType? $count;

  final _i2.ContrattoEnelFibraMinAggregateOutputType? $min;

  final _i2.ContrattoEnelFibraMaxAggregateOutputType? $max;
}

class AggregateContrattoEnelFibraCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelFibraCountArgs({this.select});

  final _i2.ContrattoEnelFibraCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelFibraMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelFibraMinArgs({this.select});

  final _i2.ContrattoEnelFibraMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelFibraMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelFibraMaxArgs({this.select});

  final _i2.ContrattoEnelFibraMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateContrattoEnelFibraSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateContrattoEnelFibraSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelFibraCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelFibraMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateContrattoEnelFibraMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum ClasseMisuratoreGasScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  portataMin<double>('portataMin', 'ClasseMisuratoreGas'),
  portataNominale<double>('portataNominale', 'ClasseMisuratoreGas'),
  portataMax<double>('portataMax', 'ClasseMisuratoreGas'),
  id<String>('id', 'ClasseMisuratoreGas'),
  classe<String>('classe', 'ClasseMisuratoreGas');

  const ClasseMisuratoreGasScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornituraGasCreateWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateWithoutClasseMisuratoreInput({
    this.uuid,
    required this.pdr,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    required this.fornitura,
  });

  final String? uuid;

  final String pdr;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ConsumoAnnuoGasCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  final _i2.FornituraCreateNestedOneWithoutFornituraGasInput fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedCreateWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateWithoutClasseMisuratoreInput({
    this.uuid,
    required this.pdr,
    required this.fornituraUuid,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final String? uuid;

  final String pdr;

  final String fornituraUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  final _i2.ConsumoAnnuoGasUncheckedCreateNestedOneWithoutFornituraGasInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUncheckedCreateNestedManyWithoutFornituraGasInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasCreateOrConnectWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateOrConnectWithoutClasseMisuratoreInput({
    required this.where,
    required this.create,
  });

  final _i2.FornituraGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutClasseMisuratoreInput,
      _i2.FornituraGasUncheckedCreateWithoutClasseMisuratoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class FornituraGasCreateManyClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateManyClasseMisuratoreInput({
    this.uuid,
    required this.pdr,
    required this.fornituraUuid,
    this.matricolaContatore,
    this.remi,
  });

  final String? uuid;

  final String pdr;

  final String fornituraUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? matricolaContatore;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasCreateManyClasseMisuratoreInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateManyClasseMisuratoreInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.FornituraGasCreateManyClasseMisuratoreInput,
      Iterable<_i2.FornituraGasCreateManyClasseMisuratoreInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class FornituraGasCreateNestedManyWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasCreateNestedManyWithoutClasseMisuratoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateWithoutClasseMisuratoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraGasCreateWithoutClasseMisuratoreInput>,
              _i1.PrismaUnion<
                  _i2.FornituraGasUncheckedCreateWithoutClasseMisuratoreInput,
                  Iterable<
                      _i2
                      .FornituraGasUncheckedCreateWithoutClasseMisuratoreInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput,
          Iterable<
              _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput>>?
      connectOrCreate;

  final _i2.FornituraGasCreateManyClasseMisuratoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ClasseMisuratoreGasCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCreateInput({
    required this.portataMin,
    required this.portataNominale,
    required this.portataMax,
    required this.id,
    required this.classe,
    this.fornituraGas,
  });

  final double portataMin;

  final double portataNominale;

  final double portataMax;

  final String id;

  final String classe;

  final _i2.FornituraGasCreateNestedManyWithoutClasseMisuratoreInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
      };
}

class FornituraGasUncheckedCreateNestedManyWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedCreateNestedManyWithoutClasseMisuratoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateWithoutClasseMisuratoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraGasCreateWithoutClasseMisuratoreInput>,
              _i1.PrismaUnion<
                  _i2.FornituraGasUncheckedCreateWithoutClasseMisuratoreInput,
                  Iterable<
                      _i2
                      .FornituraGasUncheckedCreateWithoutClasseMisuratoreInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput,
          Iterable<
              _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput>>?
      connectOrCreate;

  final _i2.FornituraGasCreateManyClasseMisuratoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ClasseMisuratoreGasUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUncheckedCreateInput({
    required this.portataMin,
    required this.portataNominale,
    required this.portataMax,
    required this.id,
    required this.classe,
    this.fornituraGas,
  });

  final double portataMin;

  final double portataNominale;

  final double portataMax;

  final String id;

  final String classe;

  final _i2.FornituraGasUncheckedCreateNestedManyWithoutClasseMisuratoreInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
      };
}

class ClasseMisuratoreGasCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCreateManyInput({
    required this.portataMin,
    required this.portataNominale,
    required this.portataMax,
    required this.id,
    required this.classe,
  });

  final double portataMin;

  final double portataNominale;

  final double portataMax;

  final String id;

  final String classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class FornituraGasUpdateWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateWithoutClasseMisuratoreInput({
    this.uuid,
    this.pdr,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
    this.fornitura,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ConsumoAnnuoGasUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  final _i2.FornituraUpdateOneRequiredWithoutFornituraGasNestedInput? fornitura;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
        'fornitura': fornitura,
      };
}

class FornituraGasUncheckedUpdateWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateWithoutClasseMisuratoreInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.matricolaContatore,
    this.remi,
    this.consumoAnnuoGas,
    this.contrattiEnelGas,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  final _i2.ConsumoAnnuoGasUncheckedUpdateOneWithoutFornituraGasNestedInput?
      consumoAnnuoGas;

  final _i2.ContrattoEnelGasUncheckedUpdateManyWithoutFornituraGasNestedInput?
      contrattiEnelGas;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
        'consumoAnnuoGas': consumoAnnuoGas,
        'contrattiEnelGas': contrattiEnelGas,
      };
}

class FornituraGasUpsertWithWhereUniqueWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpsertWithWhereUniqueWithoutClasseMisuratoreInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.FornituraGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutClasseMisuratoreInput,
      _i2.FornituraGasUncheckedUpdateWithoutClasseMisuratoreInput> update;

  final _i1.PrismaUnion<_i2.FornituraGasCreateWithoutClasseMisuratoreInput,
      _i2.FornituraGasUncheckedCreateWithoutClasseMisuratoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class FornituraGasUpdateWithWhereUniqueWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateWithWhereUniqueWithoutClasseMisuratoreInput({
    required this.where,
    required this.data,
  });

  final _i2.FornituraGasWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.FornituraGasUpdateWithoutClasseMisuratoreInput,
      _i2.FornituraGasUncheckedUpdateWithoutClasseMisuratoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraGasScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.classeMisuratoreGasId,
    this.matricolaContatore,
    this.remi,
  });

  final _i1.PrismaUnion<_i2.FornituraGasScalarWhereInput,
      Iterable<_i2.FornituraGasScalarWhereInput>>? AND;

  final Iterable<_i2.FornituraGasScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.FornituraGasScalarWhereInput,
      Iterable<_i2.FornituraGasScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringFilter, String>? pdr;

  final _i1.PrismaUnion<_i2.StringFilter, String>? fornituraUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? classeMisuratoreGasId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'classeMisuratoreGasId': classeMisuratoreGasId,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasUncheckedUpdateManyWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateManyWithoutClasseMisuratoreInput({
    this.uuid,
    this.pdr,
    this.fornituraUuid,
    this.matricolaContatore,
    this.remi,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? pdr;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornituraUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? matricolaContatore;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? remi;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'pdr': pdr,
        'fornituraUuid': fornituraUuid,
        'matricolaContatore': matricolaContatore,
        'remi': remi,
      };
}

class FornituraGasUpdateManyWithWhereWithoutClasseMisuratoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateManyWithWhereWithoutClasseMisuratoreInput({
    required this.where,
    required this.data,
  });

  final _i2.FornituraGasScalarWhereInput where;

  final _i1.PrismaUnion<_i2.FornituraGasUpdateManyMutationInput,
      _i2.FornituraGasUncheckedUpdateManyWithoutClasseMisuratoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class FornituraGasUpdateManyWithoutClasseMisuratoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUpdateManyWithoutClasseMisuratoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateWithoutClasseMisuratoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraGasCreateWithoutClasseMisuratoreInput>,
              _i1.PrismaUnion<
                  _i2.FornituraGasUncheckedCreateWithoutClasseMisuratoreInput,
                  Iterable<
                      _i2
                      .FornituraGasUncheckedCreateWithoutClasseMisuratoreInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput,
          Iterable<
              _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.FornituraGasUpsertWithWhereUniqueWithoutClasseMisuratoreInput,
          Iterable<
              _i2
              .FornituraGasUpsertWithWhereUniqueWithoutClasseMisuratoreInput>>?
      upsert;

  final _i2.FornituraGasCreateManyClasseMisuratoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.FornituraGasUpdateWithWhereUniqueWithoutClasseMisuratoreInput,
          Iterable<
              _i2
              .FornituraGasUpdateWithWhereUniqueWithoutClasseMisuratoreInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.FornituraGasUpdateManyWithWhereWithoutClasseMisuratoreInput,
          Iterable<
              _i2.FornituraGasUpdateManyWithWhereWithoutClasseMisuratoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.FornituraGasScalarWhereInput,
      Iterable<_i2.FornituraGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ClasseMisuratoreGasUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUpdateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMin;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataNominale;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMax;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? classe;

  final _i2.FornituraGasUpdateManyWithoutClasseMisuratoreNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
      };
}

class FornituraGasUncheckedUpdateManyWithoutClasseMisuratoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornituraGasUncheckedUpdateManyWithoutClasseMisuratoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateWithoutClasseMisuratoreInput,
          _i1.PrismaUnion<
              Iterable<_i2.FornituraGasCreateWithoutClasseMisuratoreInput>,
              _i1.PrismaUnion<
                  _i2.FornituraGasUncheckedCreateWithoutClasseMisuratoreInput,
                  Iterable<
                      _i2
                      .FornituraGasUncheckedCreateWithoutClasseMisuratoreInput>>>>?
      create;

  final _i1.PrismaUnion<
          _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput,
          Iterable<
              _i2.FornituraGasCreateOrConnectWithoutClasseMisuratoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.FornituraGasUpsertWithWhereUniqueWithoutClasseMisuratoreInput,
          Iterable<
              _i2
              .FornituraGasUpsertWithWhereUniqueWithoutClasseMisuratoreInput>>?
      upsert;

  final _i2.FornituraGasCreateManyClasseMisuratoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.FornituraGasWhereUniqueInput,
      Iterable<_i2.FornituraGasWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.FornituraGasUpdateWithWhereUniqueWithoutClasseMisuratoreInput,
          Iterable<
              _i2
              .FornituraGasUpdateWithWhereUniqueWithoutClasseMisuratoreInput>>?
      update;

  final _i1.PrismaUnion<
          _i2.FornituraGasUpdateManyWithWhereWithoutClasseMisuratoreInput,
          Iterable<
              _i2.FornituraGasUpdateManyWithWhereWithoutClasseMisuratoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.FornituraGasScalarWhereInput,
      Iterable<_i2.FornituraGasScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ClasseMisuratoreGasUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUncheckedUpdateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.fornituraGas,
  });

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMin;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataNominale;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMax;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? classe;

  final _i2.FornituraGasUncheckedUpdateManyWithoutClasseMisuratoreNestedInput?
      fornituraGas;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        'fornituraGas': fornituraGas,
      };
}

class ClasseMisuratoreGasUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUpdateManyMutationInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMin;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataNominale;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMax;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasUncheckedUpdateManyInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMin;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataNominale;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>?
      portataMax;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasCountAggregateOutputType {
  const ClasseMisuratoreGasCountAggregateOutputType({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.$all,
  });

  factory ClasseMisuratoreGasCountAggregateOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasCountAggregateOutputType(
        portataMin: json['portataMin'],
        portataNominale: json['portataNominale'],
        portataMax: json['portataMax'],
        id: json['id'],
        classe: json['classe'],
        $all: json['_all'],
      );

  final int? portataMin;

  final int? portataNominale;

  final int? portataMax;

  final int? id;

  final int? classe;

  final int? $all;
}

class ClasseMisuratoreGasAvgAggregateOutputType {
  const ClasseMisuratoreGasAvgAggregateOutputType({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
  });

  factory ClasseMisuratoreGasAvgAggregateOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasAvgAggregateOutputType(
        portataMin: json['portataMin'],
        portataNominale: json['portataNominale'],
        portataMax: json['portataMax'],
      );

  final double? portataMin;

  final double? portataNominale;

  final double? portataMax;
}

class ClasseMisuratoreGasSumAggregateOutputType {
  const ClasseMisuratoreGasSumAggregateOutputType({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
  });

  factory ClasseMisuratoreGasSumAggregateOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasSumAggregateOutputType(
        portataMin: json['portataMin'],
        portataNominale: json['portataNominale'],
        portataMax: json['portataMax'],
      );

  final double? portataMin;

  final double? portataNominale;

  final double? portataMax;
}

class ClasseMisuratoreGasMinAggregateOutputType {
  const ClasseMisuratoreGasMinAggregateOutputType({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  factory ClasseMisuratoreGasMinAggregateOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasMinAggregateOutputType(
        portataMin: json['portataMin'],
        portataNominale: json['portataNominale'],
        portataMax: json['portataMax'],
        id: json['id'],
        classe: json['classe'],
      );

  final double? portataMin;

  final double? portataNominale;

  final double? portataMax;

  final String? id;

  final String? classe;
}

class ClasseMisuratoreGasMaxAggregateOutputType {
  const ClasseMisuratoreGasMaxAggregateOutputType({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  factory ClasseMisuratoreGasMaxAggregateOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasMaxAggregateOutputType(
        portataMin: json['portataMin'],
        portataNominale: json['portataNominale'],
        portataMax: json['portataMax'],
        id: json['id'],
        classe: json['classe'],
      );

  final double? portataMin;

  final double? portataNominale;

  final double? portataMax;

  final String? id;

  final String? classe;
}

class ClasseMisuratoreGasGroupByOutputType {
  const ClasseMisuratoreGasGroupByOutputType({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ClasseMisuratoreGasGroupByOutputType.fromJson(Map json) =>
      ClasseMisuratoreGasGroupByOutputType(
        portataMin: json['portataMin'],
        portataNominale: json['portataNominale'],
        portataMax: json['portataMax'],
        id: json['id'],
        classe: json['classe'],
        $count: json['_count'] is Map
            ? _i2.ClasseMisuratoreGasCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ClasseMisuratoreGasAvgAggregateOutputType.fromJson(
                json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ClasseMisuratoreGasSumAggregateOutputType.fromJson(
                json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ClasseMisuratoreGasMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ClasseMisuratoreGasMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final double? portataMin;

  final double? portataNominale;

  final double? portataMax;

  final String? id;

  final String? classe;

  final _i2.ClasseMisuratoreGasCountAggregateOutputType? $count;

  final _i2.ClasseMisuratoreGasAvgAggregateOutputType? $avg;

  final _i2.ClasseMisuratoreGasSumAggregateOutputType? $sum;

  final _i2.ClasseMisuratoreGasMinAggregateOutputType? $min;

  final _i2.ClasseMisuratoreGasMaxAggregateOutputType? $max;
}

class ClasseMisuratoreGasCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCountOrderByAggregateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  final _i2.SortOrder? id;

  final _i2.SortOrder? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasAvgOrderByAggregateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
      };
}

class ClasseMisuratoreGasMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasMaxOrderByAggregateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  final _i2.SortOrder? id;

  final _i2.SortOrder? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasMinOrderByAggregateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  final _i2.SortOrder? id;

  final _i2.SortOrder? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasSumOrderByAggregateInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
      };
}

class ClasseMisuratoreGasOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasOrderByWithAggregationInput({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? portataMin;

  final _i2.SortOrder? portataNominale;

  final _i2.SortOrder? portataMax;

  final _i2.SortOrder? id;

  final _i2.SortOrder? classe;

  final _i2.ClasseMisuratoreGasCountOrderByAggregateInput? $count;

  final _i2.ClasseMisuratoreGasAvgOrderByAggregateInput? $avg;

  final _i2.ClasseMisuratoreGasMaxOrderByAggregateInput? $max;

  final _i2.ClasseMisuratoreGasMinOrderByAggregateInput? $min;

  final _i2.ClasseMisuratoreGasSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ClasseMisuratoreGasScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasScalarWhereWithAggregatesInput,
      Iterable<_i2.ClasseMisuratoreGasScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ClasseMisuratoreGasScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ClasseMisuratoreGasScalarWhereWithAggregatesInput,
      Iterable<_i2.ClasseMisuratoreGasScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? portataMin;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? portataNominale;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? portataMax;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? classe;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasCountAggregateOutputTypeSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.$all,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  final bool? id;

  final bool? classe;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        '_all': $all,
      };
}

class ClasseMisuratoreGasGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasGroupByOutputTypeCountArgs({this.select});

  final _i2.ClasseMisuratoreGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClasseMisuratoreGasAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasAvgAggregateOutputTypeSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
      };
}

class ClasseMisuratoreGasGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasGroupByOutputTypeAvgArgs({this.select});

  final _i2.ClasseMisuratoreGasAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClasseMisuratoreGasSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasSumAggregateOutputTypeSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
      };
}

class ClasseMisuratoreGasGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasGroupByOutputTypeSumArgs({this.select});

  final _i2.ClasseMisuratoreGasSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClasseMisuratoreGasMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasMinAggregateOutputTypeSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  final bool? id;

  final bool? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasGroupByOutputTypeMinArgs({this.select});

  final _i2.ClasseMisuratoreGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClasseMisuratoreGasMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasMaxAggregateOutputTypeSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  final bool? id;

  final bool? classe;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
      };
}

class ClasseMisuratoreGasGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasGroupByOutputTypeMaxArgs({this.select});

  final _i2.ClasseMisuratoreGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ClasseMisuratoreGasGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ClasseMisuratoreGasGroupByOutputTypeSelect({
    this.portataMin,
    this.portataNominale,
    this.portataMax,
    this.id,
    this.classe,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? portataMin;

  final bool? portataNominale;

  final bool? portataMax;

  final bool? id;

  final bool? classe;

  final _i1
      .PrismaUnion<bool, _i2.ClasseMisuratoreGasGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.ClasseMisuratoreGasGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'portataMin': portataMin,
        'portataNominale': portataNominale,
        'portataMax': portataMax,
        'id': id,
        'classe': classe,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateClasseMisuratoreGas {
  const AggregateClasseMisuratoreGas({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateClasseMisuratoreGas.fromJson(Map json) =>
      AggregateClasseMisuratoreGas(
        $count: json['_count'] is Map
            ? _i2.ClasseMisuratoreGasCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ClasseMisuratoreGasAvgAggregateOutputType.fromJson(
                json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ClasseMisuratoreGasSumAggregateOutputType.fromJson(
                json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ClasseMisuratoreGasMinAggregateOutputType.fromJson(
                json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ClasseMisuratoreGasMaxAggregateOutputType.fromJson(
                json['_max'])
            : null,
      );

  final _i2.ClasseMisuratoreGasCountAggregateOutputType? $count;

  final _i2.ClasseMisuratoreGasAvgAggregateOutputType? $avg;

  final _i2.ClasseMisuratoreGasSumAggregateOutputType? $sum;

  final _i2.ClasseMisuratoreGasMinAggregateOutputType? $min;

  final _i2.ClasseMisuratoreGasMaxAggregateOutputType? $max;
}

class AggregateClasseMisuratoreGasCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClasseMisuratoreGasCountArgs({this.select});

  final _i2.ClasseMisuratoreGasCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClasseMisuratoreGasAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClasseMisuratoreGasAvgArgs({this.select});

  final _i2.ClasseMisuratoreGasAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClasseMisuratoreGasSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClasseMisuratoreGasSumArgs({this.select});

  final _i2.ClasseMisuratoreGasSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClasseMisuratoreGasMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClasseMisuratoreGasMinArgs({this.select});

  final _i2.ClasseMisuratoreGasMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClasseMisuratoreGasMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClasseMisuratoreGasMaxArgs({this.select});

  final _i2.ClasseMisuratoreGasMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateClasseMisuratoreGasSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateClasseMisuratoreGasSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateClasseMisuratoreGasCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.AggregateClasseMisuratoreGasAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateClasseMisuratoreGasSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateClasseMisuratoreGasMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateClasseMisuratoreGasMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum FornitoreScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Fornitore'),
  nome<String>('nome', 'Fornitore');

  const FornitoreScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class FornitoreCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoCreateNestedManyWithoutFornitoreInput? serviziEwo;

  final _i2.ModuloContrattoCreateNestedManyWithoutFornitoreInput?
      moduliContratto;

  final _i2.ProdottoCreateNestedManyWithoutFornitoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ServizioEwoUncheckedCreateNestedManyWithoutFornitoreInput?
      serviziEwo;

  final _i2.ModuloContrattoUncheckedCreateNestedManyWithoutFornitoreInput?
      moduliContratto;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutFornitoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUpdateManyWithoutFornitoreNestedInput? serviziEwo;

  final _i2.ModuloContrattoUpdateManyWithoutFornitoreNestedInput?
      moduliContratto;

  final _i2.ProdottoUpdateManyWithoutFornitoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedUpdateInput({
    this.id,
    this.nome,
    this.serviziEwo,
    this.moduliContratto,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ServizioEwoUncheckedUpdateManyWithoutFornitoreNestedInput?
      serviziEwo;

  final _i2.ModuloContrattoUncheckedUpdateManyWithoutFornitoreNestedInput?
      moduliContratto;

  final _i2.ProdottoUncheckedUpdateManyWithoutFornitoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'serviziEwo': serviziEwo,
        'moduliContratto': moduliContratto,
        'prodotti': prodotti,
      };
}

class FornitoreUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreCountAggregateOutputType {
  const FornitoreCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory FornitoreCountAggregateOutputType.fromJson(Map json) =>
      FornitoreCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class FornitoreMinAggregateOutputType {
  const FornitoreMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory FornitoreMinAggregateOutputType.fromJson(Map json) =>
      FornitoreMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class FornitoreMaxAggregateOutputType {
  const FornitoreMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory FornitoreMaxAggregateOutputType.fromJson(Map json) =>
      FornitoreMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class FornitoreGroupByOutputType {
  const FornitoreGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory FornitoreGroupByOutputType.fromJson(Map json) =>
      FornitoreGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.FornitoreCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornitoreMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornitoreMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.FornitoreCountAggregateOutputType? $count;

  final _i2.FornitoreMinAggregateOutputType? $min;

  final _i2.FornitoreMaxAggregateOutputType? $max;
}

class FornitoreCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.FornitoreCountOrderByAggregateInput? $count;

  final _i2.FornitoreMaxOrderByAggregateInput? $max;

  final _i2.FornitoreMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class FornitoreScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.FornitoreScalarWhereWithAggregatesInput,
      Iterable<_i2.FornitoreScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.FornitoreScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.FornitoreScalarWhereWithAggregatesInput,
      Iterable<_i2.FornitoreScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class FornitoreCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class FornitoreGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreGroupByOutputTypeCountArgs({this.select});

  final _i2.FornitoreCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornitoreMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreGroupByOutputTypeMinArgs({this.select});

  final _i2.FornitoreMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornitoreMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class FornitoreGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreGroupByOutputTypeMaxArgs({this.select});

  final _i2.FornitoreMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class FornitoreGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const FornitoreGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.FornitoreGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.FornitoreGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.FornitoreGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateFornitore {
  const AggregateFornitore({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateFornitore.fromJson(Map json) => AggregateFornitore(
        $count: json['_count'] is Map
            ? _i2.FornitoreCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.FornitoreMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.FornitoreMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.FornitoreCountAggregateOutputType? $count;

  final _i2.FornitoreMinAggregateOutputType? $min;

  final _i2.FornitoreMaxAggregateOutputType? $max;
}

class AggregateFornitoreCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornitoreCountArgs({this.select});

  final _i2.FornitoreCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornitoreMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornitoreMinArgs({this.select});

  final _i2.FornitoreMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornitoreMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornitoreMaxArgs({this.select});

  final _i2.FornitoreMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateFornitoreSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateFornitoreSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateFornitoreCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateFornitoreMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateFornitoreMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class OrdineCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    required this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    required this.utente,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.StatoOrdineCreateNestedOneWithoutOrdiniInput? statoOrdine;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statoOrdineId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.statoOrdine,
    this.lead,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.StatoOrdineUpdateOneWithoutOrdiniNestedInput? statoOrdine;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOrdine': statoOrdine,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCountAggregateOutputType {
  const OrdineCountAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.$all,
  });

  factory OrdineCountAggregateOutputType.fromJson(Map json) =>
      OrdineCountAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        valore: json['valore'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOrdineId: json['statoOrdineId'],
        leadUuid: json['leadUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? codice;

  final int? dataInserimento;

  final int? valore;

  final int? soggettoUuid;

  final int? domicilioUuid;

  final int? statoOrdineId;

  final int? leadUuid;

  final int? utenteUuid;

  final int? negozioCodice;

  final int? $all;
}

class OrdineAvgAggregateOutputType {
  const OrdineAvgAggregateOutputType({this.valore});

  factory OrdineAvgAggregateOutputType.fromJson(Map json) =>
      OrdineAvgAggregateOutputType(valore: json['valore']);

  final double? valore;
}

class OrdineSumAggregateOutputType {
  const OrdineSumAggregateOutputType({this.valore});

  factory OrdineSumAggregateOutputType.fromJson(Map json) =>
      OrdineSumAggregateOutputType(valore: json['valore']);

  final double? valore;
}

class OrdineMinAggregateOutputType {
  const OrdineMinAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  factory OrdineMinAggregateOutputType.fromJson(Map json) =>
      OrdineMinAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        valore: json['valore'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOrdineId: json['statoOrdineId'],
        leadUuid: json['leadUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final double? valore;

  final String? soggettoUuid;

  final String? domicilioUuid;

  final String? statoOrdineId;

  final String? leadUuid;

  final String? utenteUuid;

  final String? negozioCodice;
}

class OrdineMaxAggregateOutputType {
  const OrdineMaxAggregateOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  factory OrdineMaxAggregateOutputType.fromJson(Map json) =>
      OrdineMaxAggregateOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        valore: json['valore'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOrdineId: json['statoOrdineId'],
        leadUuid: json['leadUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final double? valore;

  final String? soggettoUuid;

  final String? domicilioUuid;

  final String? statoOrdineId;

  final String? leadUuid;

  final String? utenteUuid;

  final String? negozioCodice;
}

class OrdineGroupByOutputType {
  const OrdineGroupByOutputType({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory OrdineGroupByOutputType.fromJson(Map json) => OrdineGroupByOutputType(
        uuid: json['uuid'],
        codice: json['codice'],
        dataInserimento: json['dataInserimento'],
        valore: json['valore'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOrdineId: json['statoOrdineId'],
        leadUuid: json['leadUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        $count: json['_count'] is Map
            ? _i2.OrdineCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrdineAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrdineSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrdineMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrdineMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? codice;

  final DateTime? dataInserimento;

  final double? valore;

  final String? soggettoUuid;

  final String? domicilioUuid;

  final String? statoOrdineId;

  final String? leadUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final _i2.OrdineCountAggregateOutputType? $count;

  final _i2.OrdineAvgAggregateOutputType? $avg;

  final _i2.OrdineSumAggregateOutputType? $sum;

  final _i2.OrdineMinAggregateOutputType? $min;

  final _i2.OrdineMaxAggregateOutputType? $max;
}

class OrdineCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCountOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? valore;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? statoOrdineId;

  final _i2.SortOrder? leadUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineAvgOrderByAggregateInput({this.valore});

  final _i2.SortOrder? valore;

  @override
  Map<String, dynamic> toJson() => {'valore': valore};
}

class OrdineMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineMaxOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? valore;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? statoOrdineId;

  final _i2.SortOrder? leadUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineMinOrderByAggregateInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? valore;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? statoOrdineId;

  final _i2.SortOrder? leadUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineSumOrderByAggregateInput({this.valore});

  final _i2.SortOrder? valore;

  @override
  Map<String, dynamic> toJson() => {'valore': valore};
}

class OrdineOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineOrderByWithAggregationInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? codice;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? valore;

  final _i2.SortOrder? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? domicilioUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? statoOrdineId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? leadUuid;

  final _i2.SortOrder? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i2.OrdineCountOrderByAggregateInput? $count;

  final _i2.OrdineAvgOrderByAggregateInput? $avg;

  final _i2.OrdineMaxOrderByAggregateInput? $max;

  final _i2.OrdineMinOrderByAggregateInput? $min;

  final _i2.OrdineSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class OrdineScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<_i2.OrdineScalarWhereWithAggregatesInput,
      Iterable<_i2.OrdineScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OrdineScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereWithAggregatesInput,
      Iterable<_i2.OrdineScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? codice;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>?
      dataInserimento;

  final _i1.PrismaUnion<_i2.FloatWithAggregatesFilter, double>? valore;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statoOrdineId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCountAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.$all,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? valore;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOrdineId;

  final bool? leadUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        '_all': $all,
      };
}

class OrdineGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineGroupByOutputTypeCountArgs({this.select});

  final _i2.OrdineCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdineAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineAvgAggregateOutputTypeSelect({this.valore});

  final bool? valore;

  @override
  Map<String, dynamic> toJson() => {'valore': valore};
}

class OrdineGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineGroupByOutputTypeAvgArgs({this.select});

  final _i2.OrdineAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdineSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineSumAggregateOutputTypeSelect({this.valore});

  final bool? valore;

  @override
  Map<String, dynamic> toJson() => {'valore': valore};
}

class OrdineGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineGroupByOutputTypeSumArgs({this.select});

  final _i2.OrdineSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdineMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineMinAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? valore;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOrdineId;

  final bool? leadUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineGroupByOutputTypeMinArgs({this.select});

  final _i2.OrdineMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdineMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineMaxAggregateOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? valore;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOrdineId;

  final bool? leadUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineGroupByOutputTypeMaxArgs({this.select});

  final _i2.OrdineMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdineGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineGroupByOutputTypeSelect({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOrdineId,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? codice;

  final bool? dataInserimento;

  final bool? valore;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOrdineId;

  final bool? leadUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final _i1.PrismaUnion<bool, _i2.OrdineGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.OrdineGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.OrdineGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.OrdineGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OrdineGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOrdineId': statoOrdineId,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOrdine {
  const AggregateOrdine({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateOrdine.fromJson(Map json) => AggregateOrdine(
        $count: json['_count'] is Map
            ? _i2.OrdineCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrdineAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrdineSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrdineMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrdineMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OrdineCountAggregateOutputType? $count;

  final _i2.OrdineAvgAggregateOutputType? $avg;

  final _i2.OrdineSumAggregateOutputType? $sum;

  final _i2.OrdineMinAggregateOutputType? $min;

  final _i2.OrdineMaxAggregateOutputType? $max;
}

class AggregateOrdineCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdineCountArgs({this.select});

  final _i2.OrdineCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdineAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdineAvgArgs({this.select});

  final _i2.OrdineAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdineSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdineSumArgs({this.select});

  final _i2.OrdineSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdineMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdineMinArgs({this.select});

  final _i2.OrdineMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdineMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdineMaxArgs({this.select});

  final _i2.OrdineMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdineSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdineSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOrdineCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdineAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdineSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdineMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdineMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum StatoOrdineScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'StatoOrdine'),
  nome<String>('nome', 'StatoOrdine'),
  tipoStato<_i3.TipoStato>('tipoStato', 'StatoOrdine'),
  ordine<int>('ordine', 'StatoOrdine'),
  colore<String>('colore', 'StatoOrdine');

  const StatoOrdineScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OrdineCreateWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateWithoutStatoOrdineInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    this.prodotti,
    required this.soggetto,
    this.domicilio,
    this.lead,
    required this.utente,
    this.negozio,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final _i2.ProdottoCreateNestedManyWithoutProdottiOrdinatiInput? prodotti;

  final _i2.SoggettoCreateNestedOneWithoutProdottiOrdinatiInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutProdottiOrdinatiInput? domicilio;

  final _i2.LeadCreateNestedOneWithoutOrdineInput? lead;

  final _i2.UtenteCreateNestedOneWithoutOrdiniInput utente;

  final _i2.NegozioCreateNestedOneWithoutOrdineInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUncheckedCreateWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateWithoutStatoOrdineInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProdottiOrdinatiInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineCreateOrConnectWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateOrConnectWithoutStatoOrdineInput({
    required this.where,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutStatoOrdineInput,
      _i2.OrdineUncheckedCreateWithoutStatoOrdineInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class OrdineCreateManyStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyStatoOrdineInput({
    this.uuid,
    required this.codice,
    this.dataInserimento,
    required this.valore,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.leadUuid,
    required this.utenteUuid,
    this.negozioCodice,
  });

  final String? uuid;

  final String codice;

  final DateTime? dataInserimento;

  final double valore;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineCreateManyStatoOrdineInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateManyStatoOrdineInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.OrdineCreateManyStatoOrdineInput,
      Iterable<_i2.OrdineCreateManyStatoOrdineInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class OrdineCreateNestedManyWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineCreateNestedManyWithoutStatoOrdineInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutStatoOrdineInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutStatoOrdineInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput>>?
      connectOrCreate;

  final _i2.OrdineCreateManyStatoOrdineInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoOrdineCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCreateInput({
    required this.id,
    required this.nome,
    required this.tipoStato,
    required this.ordine,
    required this.colore,
    this.ordini,
  });

  final String id;

  final String nome;

  final _i3.TipoStato tipoStato;

  final int ordine;

  final String colore;

  final _i2.OrdineCreateNestedManyWithoutStatoOrdineInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
      };
}

class OrdineUncheckedCreateNestedManyWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedCreateNestedManyWithoutStatoOrdineInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutStatoOrdineInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutStatoOrdineInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput>>?
      connectOrCreate;

  final _i2.OrdineCreateManyStatoOrdineInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoOrdineUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUncheckedCreateInput({
    required this.id,
    required this.nome,
    required this.tipoStato,
    required this.ordine,
    required this.colore,
    this.ordini,
  });

  final String id;

  final String nome;

  final _i3.TipoStato tipoStato;

  final int ordine;

  final String colore;

  final _i2.OrdineUncheckedCreateNestedManyWithoutStatoOrdineInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
      };
}

class StatoOrdineCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCreateManyInput({
    required this.id,
    required this.nome,
    required this.tipoStato,
    required this.ordine,
    required this.colore,
  });

  final String id;

  final String nome;

  final _i3.TipoStato tipoStato;

  final int ordine;

  final String colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class OrdineUpdateWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithoutStatoOrdineInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.prodotti,
    this.soggetto,
    this.domicilio,
    this.lead,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i2.ProdottoUpdateManyWithoutProdottiOrdinatiNestedInput? prodotti;

  final _i2.SoggettoUpdateOneRequiredWithoutProdottiOrdinatiNestedInput?
      soggetto;

  final _i2.DomicilioUpdateOneWithoutProdottiOrdinatiNestedInput? domicilio;

  final _i2.LeadUpdateOneWithoutOrdineNestedInput? lead;

  final _i2.UtenteUpdateOneRequiredWithoutOrdiniNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutOrdineNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'prodotti': prodotti,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'lead': lead,
        'utente': utente,
        'negozio': negozio,
      };
}

class OrdineUncheckedUpdateWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateWithoutStatoOrdineInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i2.ProdottoUncheckedUpdateManyWithoutProdottiOrdinatiNestedInput?
      prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'prodotti': prodotti,
      };
}

class OrdineUpsertWithWhereUniqueWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpsertWithWhereUniqueWithoutStatoOrdineInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutStatoOrdineInput,
      _i2.OrdineUncheckedUpdateWithoutStatoOrdineInput> update;

  final _i1.PrismaUnion<_i2.OrdineCreateWithoutStatoOrdineInput,
      _i2.OrdineUncheckedCreateWithoutStatoOrdineInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class OrdineUpdateWithWhereUniqueWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateWithWhereUniqueWithoutStatoOrdineInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithoutStatoOrdineInput,
      _i2.OrdineUncheckedUpdateWithoutStatoOrdineInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUncheckedUpdateManyWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutStatoOrdineInput({
    this.uuid,
    this.codice,
    this.dataInserimento,
    this.valore,
    this.soggettoUuid,
    this.domicilioUuid,
    this.leadUuid,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      dataInserimento;

  final _i1.PrismaUnion<double, _i2.FloatFieldUpdateOperationsInput>? valore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'codice': codice,
        'dataInserimento': dataInserimento,
        'valore': valore,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'leadUuid': leadUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class OrdineUpdateManyWithWhereWithoutStatoOrdineInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithWhereWithoutStatoOrdineInput({
    required this.where,
    required this.data,
  });

  final _i2.OrdineScalarWhereInput where;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyMutationInput,
      _i2.OrdineUncheckedUpdateManyWithoutStatoOrdineInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class OrdineUpdateManyWithoutStatoOrdineNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUpdateManyWithoutStatoOrdineNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutStatoOrdineInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutStatoOrdineInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutStatoOrdineInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutStatoOrdineInput>>? upsert;

  final _i2.OrdineCreateManyStatoOrdineInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutStatoOrdineInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutStatoOrdineInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutStatoOrdineInput,
          Iterable<_i2.OrdineUpdateManyWithWhereWithoutStatoOrdineInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoOrdineUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUpdateInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.ordini,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.EnumTipoStatoFieldUpdateOperationsInput>?
      tipoStato;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i2.OrdineUpdateManyWithoutStatoOrdineNestedInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
      };
}

class OrdineUncheckedUpdateManyWithoutStatoOrdineNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdineUncheckedUpdateManyWithoutStatoOrdineNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.OrdineCreateWithoutStatoOrdineInput,
          _i1.PrismaUnion<
              Iterable<_i2.OrdineCreateWithoutStatoOrdineInput>,
              _i1.PrismaUnion<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput,
                  Iterable<_i2.OrdineUncheckedCreateWithoutStatoOrdineInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput,
          Iterable<_i2.OrdineCreateOrConnectWithoutStatoOrdineInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.OrdineUpsertWithWhereUniqueWithoutStatoOrdineInput,
      Iterable<_i2.OrdineUpsertWithWhereUniqueWithoutStatoOrdineInput>>? upsert;

  final _i2.OrdineCreateManyStatoOrdineInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.OrdineWhereUniqueInput,
      Iterable<_i2.OrdineWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.OrdineUpdateWithWhereUniqueWithoutStatoOrdineInput,
      Iterable<_i2.OrdineUpdateWithWhereUniqueWithoutStatoOrdineInput>>? update;

  final _i1.PrismaUnion<_i2.OrdineUpdateManyWithWhereWithoutStatoOrdineInput,
          Iterable<_i2.OrdineUpdateManyWithWhereWithoutStatoOrdineInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.OrdineScalarWhereInput,
      Iterable<_i2.OrdineScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoOrdineUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUncheckedUpdateInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.ordini,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.EnumTipoStatoFieldUpdateOperationsInput>?
      tipoStato;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i2.OrdineUncheckedUpdateManyWithoutStatoOrdineNestedInput? ordini;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'ordini': ordini,
      };
}

class StatoOrdineUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUpdateManyMutationInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.EnumTipoStatoFieldUpdateOperationsInput>?
      tipoStato;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineUncheckedUpdateManyInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.EnumTipoStatoFieldUpdateOperationsInput>?
      tipoStato;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineCountAggregateOutputType {
  const StatoOrdineCountAggregateOutputType({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.$all,
  });

  factory StatoOrdineCountAggregateOutputType.fromJson(Map json) =>
      StatoOrdineCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        tipoStato: json['tipoStato'],
        ordine: json['ordine'],
        colore: json['colore'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? tipoStato;

  final int? ordine;

  final int? colore;

  final int? $all;
}

class StatoOrdineAvgAggregateOutputType {
  const StatoOrdineAvgAggregateOutputType({this.ordine});

  factory StatoOrdineAvgAggregateOutputType.fromJson(Map json) =>
      StatoOrdineAvgAggregateOutputType(ordine: json['ordine']);

  final double? ordine;
}

class StatoOrdineSumAggregateOutputType {
  const StatoOrdineSumAggregateOutputType({this.ordine});

  factory StatoOrdineSumAggregateOutputType.fromJson(Map json) =>
      StatoOrdineSumAggregateOutputType(ordine: json['ordine']);

  final int? ordine;
}

class StatoOrdineMinAggregateOutputType {
  const StatoOrdineMinAggregateOutputType({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  factory StatoOrdineMinAggregateOutputType.fromJson(Map json) =>
      StatoOrdineMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        tipoStato: json['tipoStato'] != null
            ? _i3.TipoStato.values
                .firstWhere((e) => e.name == json['tipoStato'])
            : null,
        ordine: json['ordine'],
        colore: json['colore'],
      );

  final String? id;

  final String? nome;

  final _i3.TipoStato? tipoStato;

  final int? ordine;

  final String? colore;
}

class StatoOrdineMaxAggregateOutputType {
  const StatoOrdineMaxAggregateOutputType({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  factory StatoOrdineMaxAggregateOutputType.fromJson(Map json) =>
      StatoOrdineMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        tipoStato: json['tipoStato'] != null
            ? _i3.TipoStato.values
                .firstWhere((e) => e.name == json['tipoStato'])
            : null,
        ordine: json['ordine'],
        colore: json['colore'],
      );

  final String? id;

  final String? nome;

  final _i3.TipoStato? tipoStato;

  final int? ordine;

  final String? colore;
}

class StatoOrdineGroupByOutputType {
  const StatoOrdineGroupByOutputType({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory StatoOrdineGroupByOutputType.fromJson(Map json) =>
      StatoOrdineGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        tipoStato: json['tipoStato'] != null
            ? _i3.TipoStato.values
                .firstWhere((e) => e.name == json['tipoStato'])
            : null,
        ordine: json['ordine'],
        colore: json['colore'],
        $count: json['_count'] is Map
            ? _i2.StatoOrdineCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.StatoOrdineAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.StatoOrdineSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoOrdineMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoOrdineMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i3.TipoStato? tipoStato;

  final int? ordine;

  final String? colore;

  final _i2.StatoOrdineCountAggregateOutputType? $count;

  final _i2.StatoOrdineAvgAggregateOutputType? $avg;

  final _i2.StatoOrdineSumAggregateOutputType? $sum;

  final _i2.StatoOrdineMinAggregateOutputType? $min;

  final _i2.StatoOrdineMaxAggregateOutputType? $max;
}

class StatoOrdineCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCountOrderByAggregateInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineAvgOrderByAggregateInput({this.ordine});

  final _i2.SortOrder? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOrdineMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineMaxOrderByAggregateInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineMinOrderByAggregateInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineSumOrderByAggregateInput({this.ordine});

  final _i2.SortOrder? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOrdineOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  final _i2.StatoOrdineCountOrderByAggregateInput? $count;

  final _i2.StatoOrdineAvgOrderByAggregateInput? $avg;

  final _i2.StatoOrdineMaxOrderByAggregateInput? $max;

  final _i2.StatoOrdineMinOrderByAggregateInput? $min;

  final _i2.StatoOrdineSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedEnumTipoStatoWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoStatoWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoStato, _i1.Reference<_i3.TipoStato>>? equals;

  final Iterable<_i3.TipoStato>? $in;

  final Iterable<_i3.TipoStato>? notIn;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.NestedEnumTipoStatoWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoStatoFilter? $min;

  final _i2.NestedEnumTipoStatoFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumTipoStatoWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoStatoWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoStato, _i1.Reference<_i3.TipoStato>>? equals;

  final Iterable<_i3.TipoStato>? $in;

  final Iterable<_i3.TipoStato>? notIn;

  final _i1
      .PrismaUnion<_i3.TipoStato, _i2.NestedEnumTipoStatoWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumTipoStatoFilter? $min;

  final _i2.NestedEnumTipoStatoFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StatoOrdineScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final _i1.PrismaUnion<_i2.StatoOrdineScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoOrdineScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.StatoOrdineScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.StatoOrdineScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoOrdineScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.EnumTipoStatoWithAggregatesFilter, _i3.TipoStato>?
      tipoStato;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? ordine;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? colore;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        '_all': $all,
      };
}

class StatoOrdineGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineGroupByOutputTypeCountArgs({this.select});

  final _i2.StatoOrdineCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOrdineAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineAvgAggregateOutputTypeSelect({this.ordine});

  final bool? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOrdineGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineGroupByOutputTypeAvgArgs({this.select});

  final _i2.StatoOrdineAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOrdineSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineSumAggregateOutputTypeSelect({this.ordine});

  final bool? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOrdineGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineGroupByOutputTypeSumArgs({this.select});

  final _i2.StatoOrdineSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOrdineMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final bool? id;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineGroupByOutputTypeMinArgs({this.select});

  final _i2.StatoOrdineMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOrdineMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
  });

  final bool? id;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
      };
}

class StatoOrdineGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineGroupByOutputTypeMaxArgs({this.select});

  final _i2.StatoOrdineMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOrdineGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOrdineGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.StatoOrdineGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateStatoOrdine {
  const AggregateStatoOrdine({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateStatoOrdine.fromJson(Map json) => AggregateStatoOrdine(
        $count: json['_count'] is Map
            ? _i2.StatoOrdineCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.StatoOrdineAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.StatoOrdineSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoOrdineMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoOrdineMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.StatoOrdineCountAggregateOutputType? $count;

  final _i2.StatoOrdineAvgAggregateOutputType? $avg;

  final _i2.StatoOrdineSumAggregateOutputType? $sum;

  final _i2.StatoOrdineMinAggregateOutputType? $min;

  final _i2.StatoOrdineMaxAggregateOutputType? $max;
}

class AggregateStatoOrdineCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOrdineCountArgs({this.select});

  final _i2.StatoOrdineCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOrdineAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOrdineAvgArgs({this.select});

  final _i2.StatoOrdineAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOrdineSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOrdineSumArgs({this.select});

  final _i2.StatoOrdineSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOrdineMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOrdineMinArgs({this.select});

  final _i2.StatoOrdineMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOrdineMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOrdineMaxArgs({this.select});

  final _i2.StatoOrdineMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOrdineSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOrdineSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOrdineCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOrdineAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOrdineSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOrdineMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOrdineMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProdottoCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttore,
    this.prodottiOrdinati,
    required this.fornitore,
    required this.tipoProdotto,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final _i2.ProduttoreCreateNestedOneWithoutProdottiInput produttore;

  final _i2.OrdineCreateNestedManyWithoutProdottiInput? prodottiOrdinati;

  final _i2.FornitoreCreateNestedOneWithoutProdottiInput fornitore;

  final _i2.TipoProdottoCreateNestedOneWithoutProdottiInput tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.fornitoreId,
    required this.tipoProdottoId,
    this.prodottiOrdinati,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String fornitoreId;

  final String tipoProdottoId;

  final _i2.OrdineUncheckedCreateNestedManyWithoutProdottiInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.fornitoreId,
    required this.tipoProdottoId,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String fornitoreId;

  final String tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i2.ProduttoreUpdateOneRequiredWithoutProdottiNestedInput? produttore;

  final _i2.OrdineUpdateManyWithoutProdottiNestedInput? prodottiOrdinati;

  final _i2.FornitoreUpdateOneRequiredWithoutProdottiNestedInput? fornitore;

  final _i2.TipoProdottoUpdateOneRequiredWithoutProdottiNestedInput?
      tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.prodottiOrdinati,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  final _i2.OrdineUncheckedUpdateManyWithoutProdottiNestedInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoCountAggregateOutputType {
  const ProdottoCountAggregateOutputType({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.$all,
  });

  factory ProdottoCountAggregateOutputType.fromJson(Map json) =>
      ProdottoCountAggregateOutputType(
        uuid: json['uuid'],
        modello: json['modello'],
        prezzo: json['prezzo'],
        vendibileDal: json['vendibileDal'],
        vendibileAl: json['vendibileAl'],
        produttoreId: json['produttoreId'],
        fornitoreId: json['fornitoreId'],
        tipoProdottoId: json['tipoProdottoId'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? modello;

  final int? prezzo;

  final int? vendibileDal;

  final int? vendibileAl;

  final int? produttoreId;

  final int? fornitoreId;

  final int? tipoProdottoId;

  final int? $all;
}

class ProdottoAvgAggregateOutputType {
  const ProdottoAvgAggregateOutputType({this.prezzo});

  factory ProdottoAvgAggregateOutputType.fromJson(Map json) =>
      ProdottoAvgAggregateOutputType(prezzo: json['prezzo']);

  final double? prezzo;
}

class ProdottoSumAggregateOutputType {
  const ProdottoSumAggregateOutputType({this.prezzo});

  factory ProdottoSumAggregateOutputType.fromJson(Map json) =>
      ProdottoSumAggregateOutputType(prezzo: json['prezzo']);

  final double? prezzo;
}

class ProdottoMinAggregateOutputType {
  const ProdottoMinAggregateOutputType({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  factory ProdottoMinAggregateOutputType.fromJson(Map json) =>
      ProdottoMinAggregateOutputType(
        uuid: json['uuid'],
        modello: json['modello'],
        prezzo: json['prezzo'],
        vendibileDal: json['vendibileDal'],
        vendibileAl: json['vendibileAl'],
        produttoreId: json['produttoreId'],
        fornitoreId: json['fornitoreId'],
        tipoProdottoId: json['tipoProdottoId'],
      );

  final String? uuid;

  final String? modello;

  final double? prezzo;

  final DateTime? vendibileDal;

  final DateTime? vendibileAl;

  final String? produttoreId;

  final String? fornitoreId;

  final String? tipoProdottoId;
}

class ProdottoMaxAggregateOutputType {
  const ProdottoMaxAggregateOutputType({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  factory ProdottoMaxAggregateOutputType.fromJson(Map json) =>
      ProdottoMaxAggregateOutputType(
        uuid: json['uuid'],
        modello: json['modello'],
        prezzo: json['prezzo'],
        vendibileDal: json['vendibileDal'],
        vendibileAl: json['vendibileAl'],
        produttoreId: json['produttoreId'],
        fornitoreId: json['fornitoreId'],
        tipoProdottoId: json['tipoProdottoId'],
      );

  final String? uuid;

  final String? modello;

  final double? prezzo;

  final DateTime? vendibileDal;

  final DateTime? vendibileAl;

  final String? produttoreId;

  final String? fornitoreId;

  final String? tipoProdottoId;
}

class ProdottoGroupByOutputType {
  const ProdottoGroupByOutputType({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProdottoGroupByOutputType.fromJson(Map json) =>
      ProdottoGroupByOutputType(
        uuid: json['uuid'],
        modello: json['modello'],
        prezzo: json['prezzo'],
        vendibileDal: json['vendibileDal'],
        vendibileAl: json['vendibileAl'],
        produttoreId: json['produttoreId'],
        fornitoreId: json['fornitoreId'],
        tipoProdottoId: json['tipoProdottoId'],
        $count: json['_count'] is Map
            ? _i2.ProdottoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProdottoAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProdottoSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProdottoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProdottoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? modello;

  final double? prezzo;

  final DateTime? vendibileDal;

  final DateTime? vendibileAl;

  final String? produttoreId;

  final String? fornitoreId;

  final String? tipoProdottoId;

  final _i2.ProdottoCountAggregateOutputType? $count;

  final _i2.ProdottoAvgAggregateOutputType? $avg;

  final _i2.ProdottoSumAggregateOutputType? $sum;

  final _i2.ProdottoMinAggregateOutputType? $min;

  final _i2.ProdottoMaxAggregateOutputType? $max;
}

class ProdottoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCountOrderByAggregateInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? modello;

  final _i2.SortOrder? prezzo;

  final _i2.SortOrder? vendibileDal;

  final _i2.SortOrder? vendibileAl;

  final _i2.SortOrder? produttoreId;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoAvgOrderByAggregateInput({this.prezzo});

  final _i2.SortOrder? prezzo;

  @override
  Map<String, dynamic> toJson() => {'prezzo': prezzo};
}

class ProdottoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoMaxOrderByAggregateInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? modello;

  final _i2.SortOrder? prezzo;

  final _i2.SortOrder? vendibileDal;

  final _i2.SortOrder? vendibileAl;

  final _i2.SortOrder? produttoreId;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoMinOrderByAggregateInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? modello;

  final _i2.SortOrder? prezzo;

  final _i2.SortOrder? vendibileDal;

  final _i2.SortOrder? vendibileAl;

  final _i2.SortOrder? produttoreId;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoSumOrderByAggregateInput({this.prezzo});

  final _i2.SortOrder? prezzo;

  @override
  Map<String, dynamic> toJson() => {'prezzo': prezzo};
}

class ProdottoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoOrderByWithAggregationInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? modello;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? prezzo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendibileDal;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendibileAl;

  final _i2.SortOrder? produttoreId;

  final _i2.SortOrder? fornitoreId;

  final _i2.SortOrder? tipoProdottoId;

  final _i2.ProdottoCountOrderByAggregateInput? $count;

  final _i2.ProdottoAvgOrderByAggregateInput? $avg;

  final _i2.ProdottoMaxOrderByAggregateInput? $max;

  final _i2.ProdottoMinOrderByAggregateInput? $min;

  final _i2.ProdottoSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ProdottoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereWithAggregatesInput,
      Iterable<_i2.ProdottoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProdottoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereWithAggregatesInput,
      Iterable<_i2.ProdottoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? modello;

  final _i1.PrismaUnion<_i2.FloatNullableWithAggregatesFilter,
      _i1.PrismaUnion<double, _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? produttoreId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? fornitoreId;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCountAggregateOutputTypeSelect({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.$all,
  });

  final bool? uuid;

  final bool? modello;

  final bool? prezzo;

  final bool? vendibileDal;

  final bool? vendibileAl;

  final bool? produttoreId;

  final bool? fornitoreId;

  final bool? tipoProdottoId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        '_all': $all,
      };
}

class ProdottoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoGroupByOutputTypeCountArgs({this.select});

  final _i2.ProdottoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProdottoAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoAvgAggregateOutputTypeSelect({this.prezzo});

  final bool? prezzo;

  @override
  Map<String, dynamic> toJson() => {'prezzo': prezzo};
}

class ProdottoGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProdottoAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProdottoSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoSumAggregateOutputTypeSelect({this.prezzo});

  final bool? prezzo;

  @override
  Map<String, dynamic> toJson() => {'prezzo': prezzo};
}

class ProdottoGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoGroupByOutputTypeSumArgs({this.select});

  final _i2.ProdottoSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProdottoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoMinAggregateOutputTypeSelect({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final bool? uuid;

  final bool? modello;

  final bool? prezzo;

  final bool? vendibileDal;

  final bool? vendibileAl;

  final bool? produttoreId;

  final bool? fornitoreId;

  final bool? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoGroupByOutputTypeMinArgs({this.select});

  final _i2.ProdottoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProdottoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoMaxAggregateOutputTypeSelect({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final bool? uuid;

  final bool? modello;

  final bool? prezzo;

  final bool? vendibileDal;

  final bool? vendibileAl;

  final bool? produttoreId;

  final bool? fornitoreId;

  final bool? tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProdottoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProdottoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoGroupByOutputTypeSelect({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.tipoProdottoId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? modello;

  final bool? prezzo;

  final bool? vendibileDal;

  final bool? vendibileAl;

  final bool? produttoreId;

  final bool? fornitoreId;

  final bool? tipoProdottoId;

  final _i1.PrismaUnion<bool, _i2.ProdottoGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ProdottoGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ProdottoGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ProdottoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ProdottoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProdotto {
  const AggregateProdotto({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProdotto.fromJson(Map json) => AggregateProdotto(
        $count: json['_count'] is Map
            ? _i2.ProdottoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProdottoAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProdottoSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProdottoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProdottoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProdottoCountAggregateOutputType? $count;

  final _i2.ProdottoAvgAggregateOutputType? $avg;

  final _i2.ProdottoSumAggregateOutputType? $sum;

  final _i2.ProdottoMinAggregateOutputType? $min;

  final _i2.ProdottoMaxAggregateOutputType? $max;
}

class AggregateProdottoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProdottoCountArgs({this.select});

  final _i2.ProdottoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProdottoAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProdottoAvgArgs({this.select});

  final _i2.ProdottoAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProdottoSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProdottoSumArgs({this.select});

  final _i2.ProdottoSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProdottoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProdottoMinArgs({this.select});

  final _i2.ProdottoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProdottoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProdottoMaxArgs({this.select});

  final _i2.ProdottoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProdottoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProdottoSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProdottoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProdottoAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProdottoSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProdottoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProdottoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum TipoProdottoScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'TipoProdotto'),
  nome<String>('nome', 'TipoProdotto');

  const TipoProdottoScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProdottoCreateWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateWithoutTipoProdottoInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttore,
    this.prodottiOrdinati,
    required this.fornitore,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final _i2.ProduttoreCreateNestedOneWithoutProdottiInput produttore;

  final _i2.OrdineCreateNestedManyWithoutProdottiInput? prodottiOrdinati;

  final _i2.FornitoreCreateNestedOneWithoutProdottiInput fornitore;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
      };
}

class ProdottoUncheckedCreateWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateWithoutTipoProdottoInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.fornitoreId,
    this.prodottiOrdinati,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String fornitoreId;

  final _i2.OrdineUncheckedCreateNestedManyWithoutProdottiInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoCreateOrConnectWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateOrConnectWithoutTipoProdottoInput({
    required this.where,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutTipoProdottoInput,
      _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProdottoCreateManyTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyTipoProdottoInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.produttoreId,
    required this.fornitoreId,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String produttoreId;

  final String fornitoreId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
      };
}

class ProdottoCreateManyTipoProdottoInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyTipoProdottoInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ProdottoCreateManyTipoProdottoInput,
      Iterable<_i2.ProdottoCreateManyTipoProdottoInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ProdottoCreateNestedManyWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateNestedManyWithoutTipoProdottoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutTipoProdottoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutTipoProdottoInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput,
                  Iterable<
                      _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput>>?
      connectOrCreate;

  final _i2.ProdottoCreateManyTipoProdottoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class TipoProdottoCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCreateInput({
    required this.id,
    required this.nome,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ProdottoCreateNestedManyWithoutTipoProdottoInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProdottoUncheckedCreateNestedManyWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateNestedManyWithoutTipoProdottoInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutTipoProdottoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutTipoProdottoInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput,
                  Iterable<
                      _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput>>?
      connectOrCreate;

  final _i2.ProdottoCreateManyTipoProdottoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class TipoProdottoUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutTipoProdottoInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class TipoProdottoCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProdottoUpdateWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithoutTipoProdottoInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttore,
    this.prodottiOrdinati,
    this.fornitore,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i2.ProduttoreUpdateOneRequiredWithoutProdottiNestedInput? produttore;

  final _i2.OrdineUpdateManyWithoutProdottiNestedInput? prodottiOrdinati;

  final _i2.FornitoreUpdateOneRequiredWithoutProdottiNestedInput? fornitore;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttore': produttore,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
      };
}

class ProdottoUncheckedUpdateWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateWithoutTipoProdottoInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
    this.prodottiOrdinati,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i2.OrdineUncheckedUpdateManyWithoutProdottiNestedInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoUpsertWithWhereUniqueWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpsertWithWhereUniqueWithoutTipoProdottoInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutTipoProdottoInput,
      _i2.ProdottoUncheckedUpdateWithoutTipoProdottoInput> update;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutTipoProdottoInput,
      _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProdottoUpdateWithWhereUniqueWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithWhereUniqueWithoutTipoProdottoInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutTipoProdottoInput,
      _i2.ProdottoUncheckedUpdateWithoutTipoProdottoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUncheckedUpdateManyWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutTipoProdottoInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.produttoreId,
    this.fornitoreId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      produttoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'produttoreId': produttoreId,
        'fornitoreId': fornitoreId,
      };
}

class ProdottoUpdateManyWithWhereWithoutTipoProdottoInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithWhereWithoutTipoProdottoInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyMutationInput,
      _i2.ProdottoUncheckedUpdateManyWithoutTipoProdottoInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUpdateManyWithoutTipoProdottoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithoutTipoProdottoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutTipoProdottoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutTipoProdottoInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput,
                  Iterable<
                      _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProdottoUpsertWithWhereUniqueWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoUpsertWithWhereUniqueWithoutTipoProdottoInput>>?
      upsert;

  final _i2.ProdottoCreateManyTipoProdottoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProdottoUpdateWithWhereUniqueWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoUpdateWithWhereUniqueWithoutTipoProdottoInput>>?
      update;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyWithWhereWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoUpdateManyWithWhereWithoutTipoProdottoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoProdottoUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUpdateInput({
    this.id,
    this.nome,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ProdottoUpdateManyWithoutTipoProdottoNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProdottoUncheckedUpdateManyWithoutTipoProdottoNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutTipoProdottoNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.ProdottoCreateWithoutTipoProdottoInput,
          _i1.PrismaUnion<
              Iterable<_i2.ProdottoCreateWithoutTipoProdottoInput>,
              _i1.PrismaUnion<
                  _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput,
                  Iterable<
                      _i2.ProdottoUncheckedCreateWithoutTipoProdottoInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutTipoProdottoInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.ProdottoUpsertWithWhereUniqueWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoUpsertWithWhereUniqueWithoutTipoProdottoInput>>?
      upsert;

  final _i2.ProdottoCreateManyTipoProdottoInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.ProdottoUpdateWithWhereUniqueWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoUpdateWithWhereUniqueWithoutTipoProdottoInput>>?
      update;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyWithWhereWithoutTipoProdottoInput,
          Iterable<_i2.ProdottoUpdateManyWithWhereWithoutTipoProdottoInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class TipoProdottoUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUncheckedUpdateInput({
    this.id,
    this.nome,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ProdottoUncheckedUpdateManyWithoutTipoProdottoNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class TipoProdottoUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoCountAggregateOutputType {
  const TipoProdottoCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory TipoProdottoCountAggregateOutputType.fromJson(Map json) =>
      TipoProdottoCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class TipoProdottoMinAggregateOutputType {
  const TipoProdottoMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory TipoProdottoMinAggregateOutputType.fromJson(Map json) =>
      TipoProdottoMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class TipoProdottoMaxAggregateOutputType {
  const TipoProdottoMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory TipoProdottoMaxAggregateOutputType.fromJson(Map json) =>
      TipoProdottoMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class TipoProdottoGroupByOutputType {
  const TipoProdottoGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory TipoProdottoGroupByOutputType.fromJson(Map json) =>
      TipoProdottoGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.TipoProdottoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.TipoProdottoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.TipoProdottoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.TipoProdottoCountAggregateOutputType? $count;

  final _i2.TipoProdottoMinAggregateOutputType? $min;

  final _i2.TipoProdottoMaxAggregateOutputType? $max;
}

class TipoProdottoCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.TipoProdottoCountOrderByAggregateInput? $count;

  final _i2.TipoProdottoMaxOrderByAggregateInput? $max;

  final _i2.TipoProdottoMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class TipoProdottoScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.TipoProdottoScalarWhereWithAggregatesInput,
      Iterable<_i2.TipoProdottoScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.TipoProdottoScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.TipoProdottoScalarWhereWithAggregatesInput,
      Iterable<_i2.TipoProdottoScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class TipoProdottoGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoGroupByOutputTypeCountArgs({this.select});

  final _i2.TipoProdottoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoProdottoMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoGroupByOutputTypeMinArgs({this.select});

  final _i2.TipoProdottoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoProdottoMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class TipoProdottoGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoGroupByOutputTypeMaxArgs({this.select});

  final _i2.TipoProdottoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class TipoProdottoGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const TipoProdottoGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.TipoProdottoGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.TipoProdottoGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.TipoProdottoGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateTipoProdotto {
  const AggregateTipoProdotto({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateTipoProdotto.fromJson(Map json) => AggregateTipoProdotto(
        $count: json['_count'] is Map
            ? _i2.TipoProdottoCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.TipoProdottoMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.TipoProdottoMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.TipoProdottoCountAggregateOutputType? $count;

  final _i2.TipoProdottoMinAggregateOutputType? $min;

  final _i2.TipoProdottoMaxAggregateOutputType? $max;
}

class AggregateTipoProdottoCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoProdottoCountArgs({this.select});

  final _i2.TipoProdottoCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoProdottoMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoProdottoMinArgs({this.select});

  final _i2.TipoProdottoMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoProdottoMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoProdottoMaxArgs({this.select});

  final _i2.TipoProdottoMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateTipoProdottoSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateTipoProdottoSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateTipoProdottoCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoProdottoMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateTipoProdottoMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum ProduttoreScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'Produttore'),
  nome<String>('nome', 'Produttore');

  const ProduttoreScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProdottoCreateWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateWithoutProduttoreInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.prodottiOrdinati,
    required this.fornitore,
    required this.tipoProdotto,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final _i2.OrdineCreateNestedManyWithoutProdottiInput? prodottiOrdinati;

  final _i2.FornitoreCreateNestedOneWithoutProdottiInput fornitore;

  final _i2.TipoProdottoCreateNestedOneWithoutProdottiInput tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoUncheckedCreateWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateWithoutProduttoreInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.fornitoreId,
    required this.tipoProdottoId,
    this.prodottiOrdinati,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String fornitoreId;

  final String tipoProdottoId;

  final _i2.OrdineUncheckedCreateNestedManyWithoutProdottiInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoCreateOrConnectWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateOrConnectWithoutProduttoreInput({
    required this.where,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutProduttoreInput,
      _i2.ProdottoUncheckedCreateWithoutProduttoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class ProdottoCreateManyProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyProduttoreInput({
    this.uuid,
    required this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    required this.fornitoreId,
    required this.tipoProdottoId,
  });

  final String? uuid;

  final String modello;

  final _i1.PrismaUnion<double, _i1.PrismaNull>? prezzo;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileDal;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? vendibileAl;

  final String fornitoreId;

  final String tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoCreateManyProduttoreInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateManyProduttoreInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.ProdottoCreateManyProduttoreInput,
      Iterable<_i2.ProdottoCreateManyProduttoreInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class ProdottoCreateNestedManyWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoCreateNestedManyWithoutProduttoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.ProdottoCreateWithoutProduttoreInput,
      _i1.PrismaUnion<
          Iterable<_i2.ProdottoCreateWithoutProduttoreInput>,
          _i1.PrismaUnion<
              _i2.ProdottoUncheckedCreateWithoutProduttoreInput,
              Iterable<
                  _i2.ProdottoUncheckedCreateWithoutProduttoreInput>>>>? create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProduttoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProduttoreInput>>?
      connectOrCreate;

  final _i2.ProdottoCreateManyProduttoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProduttoreCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCreateInput({
    required this.id,
    required this.nome,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ProdottoCreateNestedManyWithoutProduttoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProdottoUncheckedCreateNestedManyWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedCreateNestedManyWithoutProduttoreInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.ProdottoCreateWithoutProduttoreInput,
      _i1.PrismaUnion<
          Iterable<_i2.ProdottoCreateWithoutProduttoreInput>,
          _i1.PrismaUnion<
              _i2.ProdottoUncheckedCreateWithoutProduttoreInput,
              Iterable<
                  _i2.ProdottoUncheckedCreateWithoutProduttoreInput>>>>? create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProduttoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProduttoreInput>>?
      connectOrCreate;

  final _i2.ProdottoCreateManyProduttoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ProduttoreUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.prodotti,
  });

  final String id;

  final String nome;

  final _i2.ProdottoUncheckedCreateNestedManyWithoutProduttoreInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProduttoreCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProdottoUpdateWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithoutProduttoreInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.prodottiOrdinati,
    this.fornitore,
    this.tipoProdotto,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i2.OrdineUpdateManyWithoutProdottiNestedInput? prodottiOrdinati;

  final _i2.FornitoreUpdateOneRequiredWithoutProdottiNestedInput? fornitore;

  final _i2.TipoProdottoUpdateOneRequiredWithoutProdottiNestedInput?
      tipoProdotto;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'prodottiOrdinati': prodottiOrdinati,
        'fornitore': fornitore,
        'tipoProdotto': tipoProdotto,
      };
}

class ProdottoUncheckedUpdateWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateWithoutProduttoreInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.fornitoreId,
    this.tipoProdottoId,
    this.prodottiOrdinati,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  final _i2.OrdineUncheckedUpdateManyWithoutProdottiNestedInput?
      prodottiOrdinati;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
        'prodottiOrdinati': prodottiOrdinati,
      };
}

class ProdottoUpsertWithWhereUniqueWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpsertWithWhereUniqueWithoutProduttoreInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutProduttoreInput,
      _i2.ProdottoUncheckedUpdateWithoutProduttoreInput> update;

  final _i1.PrismaUnion<_i2.ProdottoCreateWithoutProduttoreInput,
      _i2.ProdottoUncheckedCreateWithoutProduttoreInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class ProdottoUpdateWithWhereUniqueWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateWithWhereUniqueWithoutProduttoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithoutProduttoreInput,
      _i2.ProdottoUncheckedUpdateWithoutProduttoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUncheckedUpdateManyWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutProduttoreInput({
    this.uuid,
    this.modello,
    this.prezzo,
    this.vendibileDal,
    this.vendibileAl,
    this.fornitoreId,
    this.tipoProdottoId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? modello;

  final _i1.PrismaUnion<
      double,
      _i1.PrismaUnion<_i2.NullableFloatFieldUpdateOperationsInput,
          _i1.PrismaNull>>? prezzo;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileDal;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendibileAl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      fornitoreId;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      tipoProdottoId;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'modello': modello,
        'prezzo': prezzo,
        'vendibileDal': vendibileDal,
        'vendibileAl': vendibileAl,
        'fornitoreId': fornitoreId,
        'tipoProdottoId': tipoProdottoId,
      };
}

class ProdottoUpdateManyWithWhereWithoutProduttoreInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithWhereWithoutProduttoreInput({
    required this.where,
    required this.data,
  });

  final _i2.ProdottoScalarWhereInput where;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyMutationInput,
      _i2.ProdottoUncheckedUpdateManyWithoutProduttoreInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class ProdottoUpdateManyWithoutProduttoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUpdateManyWithoutProduttoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.ProdottoCreateWithoutProduttoreInput,
      _i1.PrismaUnion<
          Iterable<_i2.ProdottoCreateWithoutProduttoreInput>,
          _i1.PrismaUnion<
              _i2.ProdottoUncheckedCreateWithoutProduttoreInput,
              Iterable<
                  _i2.ProdottoUncheckedCreateWithoutProduttoreInput>>>>? create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProduttoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProduttoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ProdottoUpsertWithWhereUniqueWithoutProduttoreInput,
          Iterable<_i2.ProdottoUpsertWithWhereUniqueWithoutProduttoreInput>>?
      upsert;

  final _i2.ProdottoCreateManyProduttoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithWhereUniqueWithoutProduttoreInput,
          Iterable<_i2.ProdottoUpdateWithWhereUniqueWithoutProduttoreInput>>?
      update;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyWithWhereWithoutProduttoreInput,
          Iterable<_i2.ProdottoUpdateManyWithWhereWithoutProduttoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProduttoreUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUpdateInput({
    this.id,
    this.nome,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ProdottoUpdateManyWithoutProduttoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProdottoUncheckedUpdateManyWithoutProduttoreNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProdottoUncheckedUpdateManyWithoutProduttoreNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.ProdottoCreateWithoutProduttoreInput,
      _i1.PrismaUnion<
          Iterable<_i2.ProdottoCreateWithoutProduttoreInput>,
          _i1.PrismaUnion<
              _i2.ProdottoUncheckedCreateWithoutProduttoreInput,
              Iterable<
                  _i2.ProdottoUncheckedCreateWithoutProduttoreInput>>>>? create;

  final _i1.PrismaUnion<_i2.ProdottoCreateOrConnectWithoutProduttoreInput,
          Iterable<_i2.ProdottoCreateOrConnectWithoutProduttoreInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.ProdottoUpsertWithWhereUniqueWithoutProduttoreInput,
          Iterable<_i2.ProdottoUpsertWithWhereUniqueWithoutProduttoreInput>>?
      upsert;

  final _i2.ProdottoCreateManyProduttoreInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.ProdottoWhereUniqueInput,
      Iterable<_i2.ProdottoWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.ProdottoUpdateWithWhereUniqueWithoutProduttoreInput,
          Iterable<_i2.ProdottoUpdateWithWhereUniqueWithoutProduttoreInput>>?
      update;

  final _i1.PrismaUnion<_i2.ProdottoUpdateManyWithWhereWithoutProduttoreInput,
          Iterable<_i2.ProdottoUpdateManyWithWhereWithoutProduttoreInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.ProdottoScalarWhereInput,
      Iterable<_i2.ProdottoScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ProduttoreUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUncheckedUpdateInput({
    this.id,
    this.nome,
    this.prodotti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.ProdottoUncheckedUpdateManyWithoutProduttoreNestedInput? prodotti;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'prodotti': prodotti,
      };
}

class ProduttoreUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreCountAggregateOutputType {
  const ProduttoreCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory ProduttoreCountAggregateOutputType.fromJson(Map json) =>
      ProduttoreCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class ProduttoreMinAggregateOutputType {
  const ProduttoreMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory ProduttoreMinAggregateOutputType.fromJson(Map json) =>
      ProduttoreMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class ProduttoreMaxAggregateOutputType {
  const ProduttoreMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory ProduttoreMaxAggregateOutputType.fromJson(Map json) =>
      ProduttoreMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class ProduttoreGroupByOutputType {
  const ProduttoreGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ProduttoreGroupByOutputType.fromJson(Map json) =>
      ProduttoreGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.ProduttoreCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProduttoreMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProduttoreMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.ProduttoreCountAggregateOutputType? $count;

  final _i2.ProduttoreMinAggregateOutputType? $min;

  final _i2.ProduttoreMaxAggregateOutputType? $max;
}

class ProduttoreCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ProduttoreCountOrderByAggregateInput? $count;

  final _i2.ProduttoreMaxOrderByAggregateInput? $max;

  final _i2.ProduttoreMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class ProduttoreScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.ProduttoreScalarWhereWithAggregatesInput,
      Iterable<_i2.ProduttoreScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProduttoreScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProduttoreScalarWhereWithAggregatesInput,
      Iterable<_i2.ProduttoreScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class ProduttoreCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class ProduttoreGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreGroupByOutputTypeCountArgs({this.select});

  final _i2.ProduttoreCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProduttoreMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreGroupByOutputTypeMinArgs({this.select});

  final _i2.ProduttoreMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProduttoreMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ProduttoreGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProduttoreMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProduttoreGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProduttoreGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.ProduttoreGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ProduttoreGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ProduttoreGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProduttore {
  const AggregateProduttore({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateProduttore.fromJson(Map json) => AggregateProduttore(
        $count: json['_count'] is Map
            ? _i2.ProduttoreCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProduttoreMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProduttoreMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProduttoreCountAggregateOutputType? $count;

  final _i2.ProduttoreMinAggregateOutputType? $min;

  final _i2.ProduttoreMaxAggregateOutputType? $max;
}

class AggregateProduttoreCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProduttoreCountArgs({this.select});

  final _i2.ProduttoreCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProduttoreMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProduttoreMinArgs({this.select});

  final _i2.ProduttoreMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProduttoreMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProduttoreMaxArgs({this.select});

  final _i2.ProduttoreMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProduttoreSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProduttoreSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProduttoreCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProduttoreMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProduttoreMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class UtenteCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    required this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final String nomeVisualizzato;

  final _i2.NegozioCreateNestedOneWithoutUtentiInput? negozio;

  final _i2.ContrattoCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaCreateNestedManyWithoutAgentiInput? opportunitaAssegnate;

  final _i2.OrdineCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedCreateInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutUtenteInput? contratti;

  final _i2.PraticaUncheckedCreateNestedManyWithoutUtenteInput? pratiche;

  final _i2.IngressiUncheckedCreateNestedManyWithoutUtenteInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutUtenteInput? leadsGestiti;

  final _i2.LeadUncheckedCreateNestedManyWithoutAgenteInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutGestoriLeadInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedCreateNestedManyWithoutAgentiInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedCreateNestedManyWithoutUtenteInput? ordini;

  final _i2.HistoryUncheckedCreateNestedManyWithoutUtenteInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCreateManyInput({
    this.uuid,
    this.firebaseUid,
    required this.email,
    required this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    required this.nomeVisualizzato,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? firebaseUid;

  final String email;

  final _i3.RuoloUtente ruolo;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? photoUrl;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final String nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUpdateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.nomeVisualizzato,
    this.negozio,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.NegozioUpdateOneWithoutUtentiNestedInput? negozio;

  final _i2.ContrattoUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUpdateManyWithoutAgentiNestedInput? opportunitaAssegnate;

  final _i2.OrdineUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'nomeVisualizzato': nomeVisualizzato,
        'negozio': negozio,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.contratti,
    this.pratiche,
    this.ingressi,
    this.leadsGestiti,
    this.leadsAssegnati,
    this.opportunitaGestite,
    this.opportunitaAssegnate,
    this.ordini,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  final _i2.ContrattoUncheckedUpdateManyWithoutUtenteNestedInput? contratti;

  final _i2.PraticaUncheckedUpdateManyWithoutUtenteNestedInput? pratiche;

  final _i2.IngressiUncheckedUpdateManyWithoutUtenteNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutUtenteNestedInput? leadsGestiti;

  final _i2.LeadUncheckedUpdateManyWithoutAgenteNestedInput? leadsAssegnati;

  final _i2.OpportunitaUncheckedUpdateManyWithoutGestoriLeadNestedInput?
      opportunitaGestite;

  final _i2.OpportunitaUncheckedUpdateManyWithoutAgentiNestedInput?
      opportunitaAssegnate;

  final _i2.OrdineUncheckedUpdateManyWithoutUtenteNestedInput? ordini;

  final _i2.HistoryUncheckedUpdateManyWithoutUtenteNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        'contratti': contratti,
        'pratiche': pratiche,
        'ingressi': ingressi,
        'leadsGestiti': leadsGestiti,
        'leadsAssegnati': leadsAssegnati,
        'opportunitaGestite': opportunitaGestite,
        'opportunitaAssegnate': opportunitaAssegnate,
        'ordini': ordini,
        'history': history,
      };
}

class UtenteUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteUncheckedUpdateManyInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? email;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.EnumRuoloUtenteFieldUpdateOperationsInput>? ruolo;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteCountAggregateOutputType {
  const UtenteCountAggregateOutputType({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.$all,
  });

  factory UtenteCountAggregateOutputType.fromJson(Map json) =>
      UtenteCountAggregateOutputType(
        uuid: json['uuid'],
        firebaseUid: json['firebaseUid'],
        email: json['email'],
        ruolo: json['ruolo'],
        photoUrl: json['photoUrl'],
        negozioCodice: json['negozioCodice'],
        nomeVisualizzato: json['nomeVisualizzato'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? firebaseUid;

  final int? email;

  final int? ruolo;

  final int? photoUrl;

  final int? negozioCodice;

  final int? nomeVisualizzato;

  final int? $all;
}

class UtenteMinAggregateOutputType {
  const UtenteMinAggregateOutputType({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  factory UtenteMinAggregateOutputType.fromJson(Map json) =>
      UtenteMinAggregateOutputType(
        uuid: json['uuid'],
        firebaseUid: json['firebaseUid'],
        email: json['email'],
        ruolo: json['ruolo'] != null
            ? _i3.RuoloUtente.values.firstWhere((e) => e.name == json['ruolo'])
            : null,
        photoUrl: json['photoUrl'],
        negozioCodice: json['negozioCodice'],
        nomeVisualizzato: json['nomeVisualizzato'],
      );

  final String? uuid;

  final String? firebaseUid;

  final String? email;

  final _i3.RuoloUtente? ruolo;

  final String? photoUrl;

  final String? negozioCodice;

  final String? nomeVisualizzato;
}

class UtenteMaxAggregateOutputType {
  const UtenteMaxAggregateOutputType({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  factory UtenteMaxAggregateOutputType.fromJson(Map json) =>
      UtenteMaxAggregateOutputType(
        uuid: json['uuid'],
        firebaseUid: json['firebaseUid'],
        email: json['email'],
        ruolo: json['ruolo'] != null
            ? _i3.RuoloUtente.values.firstWhere((e) => e.name == json['ruolo'])
            : null,
        photoUrl: json['photoUrl'],
        negozioCodice: json['negozioCodice'],
        nomeVisualizzato: json['nomeVisualizzato'],
      );

  final String? uuid;

  final String? firebaseUid;

  final String? email;

  final _i3.RuoloUtente? ruolo;

  final String? photoUrl;

  final String? negozioCodice;

  final String? nomeVisualizzato;
}

class UtenteGroupByOutputType {
  const UtenteGroupByOutputType({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.$count,
    this.$min,
    this.$max,
  });

  factory UtenteGroupByOutputType.fromJson(Map json) => UtenteGroupByOutputType(
        uuid: json['uuid'],
        firebaseUid: json['firebaseUid'],
        email: json['email'],
        ruolo: json['ruolo'] != null
            ? _i3.RuoloUtente.values.firstWhere((e) => e.name == json['ruolo'])
            : null,
        photoUrl: json['photoUrl'],
        negozioCodice: json['negozioCodice'],
        nomeVisualizzato: json['nomeVisualizzato'],
        $count: json['_count'] is Map
            ? _i2.UtenteCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UtenteMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UtenteMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? firebaseUid;

  final String? email;

  final _i3.RuoloUtente? ruolo;

  final String? photoUrl;

  final String? negozioCodice;

  final String? nomeVisualizzato;

  final _i2.UtenteCountAggregateOutputType? $count;

  final _i2.UtenteMinAggregateOutputType? $min;

  final _i2.UtenteMaxAggregateOutputType? $max;
}

class UtenteCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCountOrderByAggregateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? firebaseUid;

  final _i2.SortOrder? email;

  final _i2.SortOrder? ruolo;

  final _i2.SortOrder? photoUrl;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteMaxOrderByAggregateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? firebaseUid;

  final _i2.SortOrder? email;

  final _i2.SortOrder? ruolo;

  final _i2.SortOrder? photoUrl;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteMinOrderByAggregateInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? firebaseUid;

  final _i2.SortOrder? email;

  final _i2.SortOrder? ruolo;

  final _i2.SortOrder? photoUrl;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteOrderByWithAggregationInput({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? firebaseUid;

  final _i2.SortOrder? email;

  final _i2.SortOrder? ruolo;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? photoUrl;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i2.SortOrder? nomeVisualizzato;

  final _i2.UtenteCountOrderByAggregateInput? $count;

  final _i2.UtenteMaxOrderByAggregateInput? $max;

  final _i2.UtenteMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NestedEnumRuoloUtenteWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumRuoloUtenteWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.RuoloUtente, _i1.Reference<_i3.RuoloUtente>>?
      equals;

  final Iterable<_i3.RuoloUtente>? $in;

  final Iterable<_i3.RuoloUtente>? notIn;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.NestedEnumRuoloUtenteWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumRuoloUtenteFilter? $min;

  final _i2.NestedEnumRuoloUtenteFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumRuoloUtenteWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumRuoloUtenteWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.RuoloUtente, _i1.Reference<_i3.RuoloUtente>>?
      equals;

  final Iterable<_i3.RuoloUtente>? $in;

  final Iterable<_i3.RuoloUtente>? notIn;

  final _i1.PrismaUnion<_i3.RuoloUtente,
      _i2.NestedEnumRuoloUtenteWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedEnumRuoloUtenteFilter? $min;

  final _i2.NestedEnumRuoloUtenteFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class UtenteScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final _i1.PrismaUnion<_i2.UtenteScalarWhereWithAggregatesInput,
      Iterable<_i2.UtenteScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.UtenteScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.UtenteScalarWhereWithAggregatesInput,
      Iterable<_i2.UtenteScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? firebaseUid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? email;

  final _i1
      .PrismaUnion<_i2.EnumRuoloUtenteWithAggregatesFilter, _i3.RuoloUtente>?
      ruolo;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? photoUrl;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteCountAggregateOutputTypeSelect({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.$all,
  });

  final bool? uuid;

  final bool? firebaseUid;

  final bool? email;

  final bool? ruolo;

  final bool? photoUrl;

  final bool? negozioCodice;

  final bool? nomeVisualizzato;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        '_all': $all,
      };
}

class UtenteGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteGroupByOutputTypeCountArgs({this.select});

  final _i2.UtenteCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UtenteMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteMinAggregateOutputTypeSelect({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final bool? uuid;

  final bool? firebaseUid;

  final bool? email;

  final bool? ruolo;

  final bool? photoUrl;

  final bool? negozioCodice;

  final bool? nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteGroupByOutputTypeMinArgs({this.select});

  final _i2.UtenteMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UtenteMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteMaxAggregateOutputTypeSelect({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
  });

  final bool? uuid;

  final bool? firebaseUid;

  final bool? email;

  final bool? ruolo;

  final bool? photoUrl;

  final bool? negozioCodice;

  final bool? nomeVisualizzato;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
      };
}

class UtenteGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteGroupByOutputTypeMaxArgs({this.select});

  final _i2.UtenteMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UtenteGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UtenteGroupByOutputTypeSelect({
    this.uuid,
    this.firebaseUid,
    this.email,
    this.ruolo,
    this.photoUrl,
    this.negozioCodice,
    this.nomeVisualizzato,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? firebaseUid;

  final bool? email;

  final bool? ruolo;

  final bool? photoUrl;

  final bool? negozioCodice;

  final bool? nomeVisualizzato;

  final _i1.PrismaUnion<bool, _i2.UtenteGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.UtenteGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.UtenteGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'firebaseUid': firebaseUid,
        'email': email,
        'ruolo': ruolo,
        'photoUrl': photoUrl,
        'negozioCodice': negozioCodice,
        'nomeVisualizzato': nomeVisualizzato,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateUtente {
  const AggregateUtente({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateUtente.fromJson(Map json) => AggregateUtente(
        $count: json['_count'] is Map
            ? _i2.UtenteCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UtenteMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UtenteMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.UtenteCountAggregateOutputType? $count;

  final _i2.UtenteMinAggregateOutputType? $min;

  final _i2.UtenteMaxAggregateOutputType? $max;
}

class AggregateUtenteCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUtenteCountArgs({this.select});

  final _i2.UtenteCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUtenteMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUtenteMinArgs({this.select});

  final _i2.UtenteMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUtenteMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUtenteMaxArgs({this.select});

  final _i2.UtenteMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUtenteSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUtenteSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateUtenteCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUtenteMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUtenteMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NegozioCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    required this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.ZonaNegozioCreateNestedOneWithoutNegoziInput zonaNegozio;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateManyInput({
    required this.codice,
    required this.nome,
    required this.zonaNegozioId,
  });

  final String codice;

  final String nome;

  final String zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.zonaNegozio,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.ZonaNegozioUpdateOneRequiredWithoutNegoziNestedInput? zonaNegozio;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'zonaNegozio': zonaNegozio,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateManyMutationInput({
    this.codice,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
      };
}

class NegozioUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateManyInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioCountAggregateOutputType {
  const NegozioCountAggregateOutputType({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.$all,
  });

  factory NegozioCountAggregateOutputType.fromJson(Map json) =>
      NegozioCountAggregateOutputType(
        codice: json['codice'],
        nome: json['nome'],
        zonaNegozioId: json['zonaNegozioId'],
        $all: json['_all'],
      );

  final int? codice;

  final int? nome;

  final int? zonaNegozioId;

  final int? $all;
}

class NegozioMinAggregateOutputType {
  const NegozioMinAggregateOutputType({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  factory NegozioMinAggregateOutputType.fromJson(Map json) =>
      NegozioMinAggregateOutputType(
        codice: json['codice'],
        nome: json['nome'],
        zonaNegozioId: json['zonaNegozioId'],
      );

  final String? codice;

  final String? nome;

  final String? zonaNegozioId;
}

class NegozioMaxAggregateOutputType {
  const NegozioMaxAggregateOutputType({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  factory NegozioMaxAggregateOutputType.fromJson(Map json) =>
      NegozioMaxAggregateOutputType(
        codice: json['codice'],
        nome: json['nome'],
        zonaNegozioId: json['zonaNegozioId'],
      );

  final String? codice;

  final String? nome;

  final String? zonaNegozioId;
}

class NegozioGroupByOutputType {
  const NegozioGroupByOutputType({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NegozioGroupByOutputType.fromJson(Map json) =>
      NegozioGroupByOutputType(
        codice: json['codice'],
        nome: json['nome'],
        zonaNegozioId: json['zonaNegozioId'],
        $count: json['_count'] is Map
            ? _i2.NegozioCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.NegozioMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.NegozioMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? codice;

  final String? nome;

  final String? zonaNegozioId;

  final _i2.NegozioCountAggregateOutputType? $count;

  final _i2.NegozioMinAggregateOutputType? $min;

  final _i2.NegozioMaxAggregateOutputType? $max;
}

class NegozioCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCountOrderByAggregateInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final _i2.SortOrder? codice;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioMaxOrderByAggregateInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final _i2.SortOrder? codice;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioMinOrderByAggregateInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final _i2.SortOrder? codice;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioOrderByWithAggregationInput({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? codice;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? zonaNegozioId;

  final _i2.NegozioCountOrderByAggregateInput? $count;

  final _i2.NegozioMaxOrderByAggregateInput? $max;

  final _i2.NegozioMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class NegozioScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final _i1.PrismaUnion<_i2.NegozioScalarWhereWithAggregatesInput,
      Iterable<_i2.NegozioScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.NegozioScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.NegozioScalarWhereWithAggregatesInput,
      Iterable<_i2.NegozioScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? codice;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCountAggregateOutputTypeSelect({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.$all,
  });

  final bool? codice;

  final bool? nome;

  final bool? zonaNegozioId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        '_all': $all,
      };
}

class NegozioGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioGroupByOutputTypeCountArgs({this.select});

  final _i2.NegozioCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NegozioMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioMinAggregateOutputTypeSelect({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final bool? codice;

  final bool? nome;

  final bool? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioGroupByOutputTypeMinArgs({this.select});

  final _i2.NegozioMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NegozioMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioMaxAggregateOutputTypeSelect({
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final bool? codice;

  final bool? nome;

  final bool? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioGroupByOutputTypeMaxArgs({this.select});

  final _i2.NegozioMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class NegozioGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioGroupByOutputTypeSelect({
    this.codice,
    this.nome,
    this.zonaNegozioId,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? codice;

  final bool? nome;

  final bool? zonaNegozioId;

  final _i1.PrismaUnion<bool, _i2.NegozioGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.NegozioGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.NegozioGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateNegozio {
  const AggregateNegozio({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateNegozio.fromJson(Map json) => AggregateNegozio(
        $count: json['_count'] is Map
            ? _i2.NegozioCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.NegozioMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.NegozioMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.NegozioCountAggregateOutputType? $count;

  final _i2.NegozioMinAggregateOutputType? $min;

  final _i2.NegozioMaxAggregateOutputType? $max;
}

class AggregateNegozioCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNegozioCountArgs({this.select});

  final _i2.NegozioCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNegozioMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNegozioMinArgs({this.select});

  final _i2.NegozioMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNegozioMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNegozioMaxArgs({this.select});

  final _i2.NegozioMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateNegozioSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateNegozioSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateNegozioCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateNegozioMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateNegozioMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class IngressiCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.utente,
    required this.negozio,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final _i2.UtenteCreateNestedOneWithoutIngressiInput utente;

  final _i2.NegozioCreateNestedOneWithoutIngressiInput negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utente': utente,
        'negozio': negozio,
      };
}

class IngressiUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedCreateInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.utenteUuid,
    required this.negozioCodice,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final String utenteUuid;

  final String negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCreateManyInput({
    this.uuid,
    required this.data,
    required this.clienti,
    required this.nonClienti,
    required this.utenteUuid,
    required this.negozioCodice,
  });

  final String? uuid;

  final DateTime data;

  final int clienti;

  final int nonClienti;

  final String utenteUuid;

  final String negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUpdateInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utente,
    this.negozio,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i2.UtenteUpdateOneRequiredWithoutIngressiNestedInput? utente;

  final _i2.NegozioUpdateOneRequiredWithoutIngressiNestedInput? negozio;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utente': utente,
        'negozio': negozio,
      };
}

class IngressiUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiUncheckedUpdateManyInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>? data;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? clienti;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? nonClienti;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiCountAggregateOutputType {
  const IngressiCountAggregateOutputType({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.$all,
  });

  factory IngressiCountAggregateOutputType.fromJson(Map json) =>
      IngressiCountAggregateOutputType(
        uuid: json['uuid'],
        data: json['data'],
        clienti: json['clienti'],
        nonClienti: json['nonClienti'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? data;

  final int? clienti;

  final int? nonClienti;

  final int? utenteUuid;

  final int? negozioCodice;

  final int? $all;
}

class IngressiAvgAggregateOutputType {
  const IngressiAvgAggregateOutputType({
    this.clienti,
    this.nonClienti,
  });

  factory IngressiAvgAggregateOutputType.fromJson(Map json) =>
      IngressiAvgAggregateOutputType(
        clienti: json['clienti'],
        nonClienti: json['nonClienti'],
      );

  final double? clienti;

  final double? nonClienti;
}

class IngressiSumAggregateOutputType {
  const IngressiSumAggregateOutputType({
    this.clienti,
    this.nonClienti,
  });

  factory IngressiSumAggregateOutputType.fromJson(Map json) =>
      IngressiSumAggregateOutputType(
        clienti: json['clienti'],
        nonClienti: json['nonClienti'],
      );

  final int? clienti;

  final int? nonClienti;
}

class IngressiMinAggregateOutputType {
  const IngressiMinAggregateOutputType({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  factory IngressiMinAggregateOutputType.fromJson(Map json) =>
      IngressiMinAggregateOutputType(
        uuid: json['uuid'],
        data: json['data'],
        clienti: json['clienti'],
        nonClienti: json['nonClienti'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
      );

  final String? uuid;

  final DateTime? data;

  final int? clienti;

  final int? nonClienti;

  final String? utenteUuid;

  final String? negozioCodice;
}

class IngressiMaxAggregateOutputType {
  const IngressiMaxAggregateOutputType({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  factory IngressiMaxAggregateOutputType.fromJson(Map json) =>
      IngressiMaxAggregateOutputType(
        uuid: json['uuid'],
        data: json['data'],
        clienti: json['clienti'],
        nonClienti: json['nonClienti'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
      );

  final String? uuid;

  final DateTime? data;

  final int? clienti;

  final int? nonClienti;

  final String? utenteUuid;

  final String? negozioCodice;
}

class IngressiGroupByOutputType {
  const IngressiGroupByOutputType({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory IngressiGroupByOutputType.fromJson(Map json) =>
      IngressiGroupByOutputType(
        uuid: json['uuid'],
        data: json['data'],
        clienti: json['clienti'],
        nonClienti: json['nonClienti'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        $count: json['_count'] is Map
            ? _i2.IngressiCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.IngressiAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.IngressiSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.IngressiMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.IngressiMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final DateTime? data;

  final int? clienti;

  final int? nonClienti;

  final String? utenteUuid;

  final String? negozioCodice;

  final _i2.IngressiCountAggregateOutputType? $count;

  final _i2.IngressiAvgAggregateOutputType? $avg;

  final _i2.IngressiSumAggregateOutputType? $sum;

  final _i2.IngressiMinAggregateOutputType? $min;

  final _i2.IngressiMaxAggregateOutputType? $max;
}

class IngressiCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCountOrderByAggregateInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? data;

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiAvgOrderByAggregateInput({
    this.clienti,
    this.nonClienti,
  });

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  @override
  Map<String, dynamic> toJson() => {
        'clienti': clienti,
        'nonClienti': nonClienti,
      };
}

class IngressiMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiMaxOrderByAggregateInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? data;

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiMinOrderByAggregateInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? data;

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiSumOrderByAggregateInput({
    this.clienti,
    this.nonClienti,
  });

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  @override
  Map<String, dynamic> toJson() => {
        'clienti': clienti,
        'nonClienti': nonClienti,
      };
}

class IngressiOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiOrderByWithAggregationInput({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? data;

  final _i2.SortOrder? clienti;

  final _i2.SortOrder? nonClienti;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.IngressiCountOrderByAggregateInput? $count;

  final _i2.IngressiAvgOrderByAggregateInput? $avg;

  final _i2.IngressiMaxOrderByAggregateInput? $max;

  final _i2.IngressiMinOrderByAggregateInput? $min;

  final _i2.IngressiSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class IngressiScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final _i1.PrismaUnion<_i2.IngressiScalarWhereWithAggregatesInput,
      Iterable<_i2.IngressiScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.IngressiScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.IngressiScalarWhereWithAggregatesInput,
      Iterable<_i2.IngressiScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? data;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? clienti;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? nonClienti;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiCountAggregateOutputTypeSelect({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.$all,
  });

  final bool? uuid;

  final bool? data;

  final bool? clienti;

  final bool? nonClienti;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        '_all': $all,
      };
}

class IngressiGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiGroupByOutputTypeCountArgs({this.select});

  final _i2.IngressiCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IngressiAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiAvgAggregateOutputTypeSelect({
    this.clienti,
    this.nonClienti,
  });

  final bool? clienti;

  final bool? nonClienti;

  @override
  Map<String, dynamic> toJson() => {
        'clienti': clienti,
        'nonClienti': nonClienti,
      };
}

class IngressiGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiGroupByOutputTypeAvgArgs({this.select});

  final _i2.IngressiAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IngressiSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiSumAggregateOutputTypeSelect({
    this.clienti,
    this.nonClienti,
  });

  final bool? clienti;

  final bool? nonClienti;

  @override
  Map<String, dynamic> toJson() => {
        'clienti': clienti,
        'nonClienti': nonClienti,
      };
}

class IngressiGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiGroupByOutputTypeSumArgs({this.select});

  final _i2.IngressiSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IngressiMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiMinAggregateOutputTypeSelect({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final bool? uuid;

  final bool? data;

  final bool? clienti;

  final bool? nonClienti;

  final bool? utenteUuid;

  final bool? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiGroupByOutputTypeMinArgs({this.select});

  final _i2.IngressiMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IngressiMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiMaxAggregateOutputTypeSelect({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
  });

  final bool? uuid;

  final bool? data;

  final bool? clienti;

  final bool? nonClienti;

  final bool? utenteUuid;

  final bool? negozioCodice;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
      };
}

class IngressiGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiGroupByOutputTypeMaxArgs({this.select});

  final _i2.IngressiMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class IngressiGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IngressiGroupByOutputTypeSelect({
    this.uuid,
    this.data,
    this.clienti,
    this.nonClienti,
    this.utenteUuid,
    this.negozioCodice,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? data;

  final bool? clienti;

  final bool? nonClienti;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final _i1.PrismaUnion<bool, _i2.IngressiGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.IngressiGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.IngressiGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.IngressiGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.IngressiGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'data': data,
        'clienti': clienti,
        'nonClienti': nonClienti,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateIngressi {
  const AggregateIngressi({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateIngressi.fromJson(Map json) => AggregateIngressi(
        $count: json['_count'] is Map
            ? _i2.IngressiCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.IngressiAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.IngressiSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.IngressiMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.IngressiMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.IngressiCountAggregateOutputType? $count;

  final _i2.IngressiAvgAggregateOutputType? $avg;

  final _i2.IngressiSumAggregateOutputType? $sum;

  final _i2.IngressiMinAggregateOutputType? $min;

  final _i2.IngressiMaxAggregateOutputType? $max;
}

class AggregateIngressiCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIngressiCountArgs({this.select});

  final _i2.IngressiCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIngressiAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIngressiAvgArgs({this.select});

  final _i2.IngressiAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIngressiSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIngressiSumArgs({this.select});

  final _i2.IngressiSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIngressiMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIngressiMinArgs({this.select});

  final _i2.IngressiMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIngressiMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIngressiMaxArgs({this.select});

  final _i2.IngressiMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateIngressiSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateIngressiSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateIngressiCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateIngressiAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateIngressiSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateIngressiMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateIngressiMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum ZonaNegozioScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<String>('id', 'ZonaNegozio'),
  nome<String>('nome', 'ZonaNegozio');

  const ZonaNegozioScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class NegozioCreateWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateWithoutZonaNegozioInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoCreateNestedManyWithoutNegozioPreferitoInput? soggetti;

  final _i2.IngressiCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedCreateWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateWithoutZonaNegozioInput({
    required this.codice,
    required this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final String codice;

  final String nome;

  final _i2.PraticaUncheckedCreateNestedManyWithoutNegozioInput? pratiche;

  final _i2.UtenteUncheckedCreateNestedManyWithoutNegozioInput? utenti;

  final _i2.ContrattoUncheckedCreateNestedManyWithoutNegozioInput? contratti;

  final _i2.SoggettoUncheckedCreateNestedManyWithoutNegozioPreferitoInput?
      soggetti;

  final _i2.IngressiUncheckedCreateNestedManyWithoutNegozioInput? ingressi;

  final _i2.LeadUncheckedCreateNestedManyWithoutNegozioInput? leads;

  final _i2.OrdineUncheckedCreateNestedManyWithoutNegozioInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioCreateOrConnectWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateOrConnectWithoutZonaNegozioInput({
    required this.where,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutZonaNegozioInput,
      _i2.NegozioUncheckedCreateWithoutZonaNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class NegozioCreateManyZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateManyZonaNegozioInput({
    required this.codice,
    required this.nome,
  });

  final String codice;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
      };
}

class NegozioCreateManyZonaNegozioInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateManyZonaNegozioInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.NegozioCreateManyZonaNegozioInput,
      Iterable<_i2.NegozioCreateManyZonaNegozioInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class NegozioCreateNestedManyWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioCreateNestedManyWithoutZonaNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.NegozioCreateWithoutZonaNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.NegozioCreateWithoutZonaNegozioInput>,
          _i1.PrismaUnion<
              _i2.NegozioUncheckedCreateWithoutZonaNegozioInput,
              Iterable<
                  _i2.NegozioUncheckedCreateWithoutZonaNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput,
          Iterable<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput>>?
      connectOrCreate;

  final _i2.NegozioCreateManyZonaNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ZonaNegozioCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCreateInput({
    required this.id,
    required this.nome,
    this.negozi,
  });

  final String id;

  final String nome;

  final _i2.NegozioCreateNestedManyWithoutZonaNegozioInput? negozi;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'negozi': negozi,
      };
}

class NegozioUncheckedCreateNestedManyWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedCreateNestedManyWithoutZonaNegozioInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
      _i2.NegozioCreateWithoutZonaNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.NegozioCreateWithoutZonaNegozioInput>,
          _i1.PrismaUnion<
              _i2.NegozioUncheckedCreateWithoutZonaNegozioInput,
              Iterable<
                  _i2.NegozioUncheckedCreateWithoutZonaNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput,
          Iterable<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput>>?
      connectOrCreate;

  final _i2.NegozioCreateManyZonaNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class ZonaNegozioUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUncheckedCreateInput({
    required this.id,
    required this.nome,
    this.negozi,
  });

  final String id;

  final String nome;

  final _i2.NegozioUncheckedCreateNestedManyWithoutZonaNegozioInput? negozi;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'negozi': negozi,
      };
}

class ZonaNegozioCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCreateManyInput({
    required this.id,
    required this.nome,
  });

  final String id;

  final String nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class NegozioUpdateWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithoutZonaNegozioInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUpdateManyWithoutNegozioPreferitoNestedInput? soggetti;

  final _i2.IngressiUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUncheckedUpdateWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateWithoutZonaNegozioInput({
    this.codice,
    this.nome,
    this.pratiche,
    this.utenti,
    this.contratti,
    this.soggetti,
    this.ingressi,
    this.leads,
    this.ordine,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.PraticaUncheckedUpdateManyWithoutNegozioNestedInput? pratiche;

  final _i2.UtenteUncheckedUpdateManyWithoutNegozioNestedInput? utenti;

  final _i2.ContrattoUncheckedUpdateManyWithoutNegozioNestedInput? contratti;

  final _i2.SoggettoUncheckedUpdateManyWithoutNegozioPreferitoNestedInput?
      soggetti;

  final _i2.IngressiUncheckedUpdateManyWithoutNegozioNestedInput? ingressi;

  final _i2.LeadUncheckedUpdateManyWithoutNegozioNestedInput? leads;

  final _i2.OrdineUncheckedUpdateManyWithoutNegozioNestedInput? ordine;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
        'pratiche': pratiche,
        'utenti': utenti,
        'contratti': contratti,
        'soggetti': soggetti,
        'ingressi': ingressi,
        'leads': leads,
        'Ordine': ordine,
      };
}

class NegozioUpsertWithWhereUniqueWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpsertWithWhereUniqueWithoutZonaNegozioInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutZonaNegozioInput,
      _i2.NegozioUncheckedUpdateWithoutZonaNegozioInput> update;

  final _i1.PrismaUnion<_i2.NegozioCreateWithoutZonaNegozioInput,
      _i2.NegozioUncheckedCreateWithoutZonaNegozioInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class NegozioUpdateWithWhereUniqueWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateWithWhereUniqueWithoutZonaNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.NegozioWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithoutZonaNegozioInput,
      _i2.NegozioUncheckedUpdateWithoutZonaNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioScalarWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.codice,
    this.nome,
    this.zonaNegozioId,
  });

  final _i1.PrismaUnion<_i2.NegozioScalarWhereInput,
      Iterable<_i2.NegozioScalarWhereInput>>? AND;

  final Iterable<_i2.NegozioScalarWhereInput>? OR;

  final _i1.PrismaUnion<_i2.NegozioScalarWhereInput,
      Iterable<_i2.NegozioScalarWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringFilter, String>? codice;

  final _i1.PrismaUnion<_i2.StringFilter, String>? nome;

  final _i1.PrismaUnion<_i2.StringFilter, String>? zonaNegozioId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'codice': codice,
        'nome': nome,
        'zonaNegozioId': zonaNegozioId,
      };
}

class NegozioUncheckedUpdateManyWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateManyWithoutZonaNegozioInput({
    this.codice,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? codice;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'codice': codice,
        'nome': nome,
      };
}

class NegozioUpdateManyWithWhereWithoutZonaNegozioInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateManyWithWhereWithoutZonaNegozioInput({
    required this.where,
    required this.data,
  });

  final _i2.NegozioScalarWhereInput where;

  final _i1.PrismaUnion<_i2.NegozioUpdateManyMutationInput,
      _i2.NegozioUncheckedUpdateManyWithoutZonaNegozioInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class NegozioUpdateManyWithoutZonaNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUpdateManyWithoutZonaNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.NegozioCreateWithoutZonaNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.NegozioCreateWithoutZonaNegozioInput>,
          _i1.PrismaUnion<
              _i2.NegozioUncheckedCreateWithoutZonaNegozioInput,
              Iterable<
                  _i2.NegozioUncheckedCreateWithoutZonaNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput,
          Iterable<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.NegozioUpsertWithWhereUniqueWithoutZonaNegozioInput,
          Iterable<_i2.NegozioUpsertWithWhereUniqueWithoutZonaNegozioInput>>?
      upsert;

  final _i2.NegozioCreateManyZonaNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithWhereUniqueWithoutZonaNegozioInput,
          Iterable<_i2.NegozioUpdateWithWhereUniqueWithoutZonaNegozioInput>>?
      update;

  final _i1.PrismaUnion<_i2.NegozioUpdateManyWithWhereWithoutZonaNegozioInput,
          Iterable<_i2.NegozioUpdateManyWithWhereWithoutZonaNegozioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.NegozioScalarWhereInput,
      Iterable<_i2.NegozioScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ZonaNegozioUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUpdateInput({
    this.id,
    this.nome,
    this.negozi,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.NegozioUpdateManyWithoutZonaNegozioNestedInput? negozi;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'negozi': negozi,
      };
}

class NegozioUncheckedUpdateManyWithoutZonaNegozioNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NegozioUncheckedUpdateManyWithoutZonaNegozioNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
      _i2.NegozioCreateWithoutZonaNegozioInput,
      _i1.PrismaUnion<
          Iterable<_i2.NegozioCreateWithoutZonaNegozioInput>,
          _i1.PrismaUnion<
              _i2.NegozioUncheckedCreateWithoutZonaNegozioInput,
              Iterable<
                  _i2.NegozioUncheckedCreateWithoutZonaNegozioInput>>>>? create;

  final _i1.PrismaUnion<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput,
          Iterable<_i2.NegozioCreateOrConnectWithoutZonaNegozioInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<_i2.NegozioUpsertWithWhereUniqueWithoutZonaNegozioInput,
          Iterable<_i2.NegozioUpsertWithWhereUniqueWithoutZonaNegozioInput>>?
      upsert;

  final _i2.NegozioCreateManyZonaNegozioInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.NegozioWhereUniqueInput,
      Iterable<_i2.NegozioWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<_i2.NegozioUpdateWithWhereUniqueWithoutZonaNegozioInput,
          Iterable<_i2.NegozioUpdateWithWhereUniqueWithoutZonaNegozioInput>>?
      update;

  final _i1.PrismaUnion<_i2.NegozioUpdateManyWithWhereWithoutZonaNegozioInput,
          Iterable<_i2.NegozioUpdateManyWithWhereWithoutZonaNegozioInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.NegozioScalarWhereInput,
      Iterable<_i2.NegozioScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class ZonaNegozioUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUncheckedUpdateInput({
    this.id,
    this.nome,
    this.negozi,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i2.NegozioUncheckedUpdateManyWithoutZonaNegozioNestedInput? negozi;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        'negozi': negozi,
      };
}

class ZonaNegozioUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUpdateManyMutationInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioUncheckedUpdateManyInput({
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioCountAggregateOutputType {
  const ZonaNegozioCountAggregateOutputType({
    this.id,
    this.nome,
    this.$all,
  });

  factory ZonaNegozioCountAggregateOutputType.fromJson(Map json) =>
      ZonaNegozioCountAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
        $all: json['_all'],
      );

  final int? id;

  final int? nome;

  final int? $all;
}

class ZonaNegozioMinAggregateOutputType {
  const ZonaNegozioMinAggregateOutputType({
    this.id,
    this.nome,
  });

  factory ZonaNegozioMinAggregateOutputType.fromJson(Map json) =>
      ZonaNegozioMinAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class ZonaNegozioMaxAggregateOutputType {
  const ZonaNegozioMaxAggregateOutputType({
    this.id,
    this.nome,
  });

  factory ZonaNegozioMaxAggregateOutputType.fromJson(Map json) =>
      ZonaNegozioMaxAggregateOutputType(
        id: json['id'],
        nome: json['nome'],
      );

  final String? id;

  final String? nome;
}

class ZonaNegozioGroupByOutputType {
  const ZonaNegozioGroupByOutputType({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  factory ZonaNegozioGroupByOutputType.fromJson(Map json) =>
      ZonaNegozioGroupByOutputType(
        id: json['id'],
        nome: json['nome'],
        $count: json['_count'] is Map
            ? _i2.ZonaNegozioCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ZonaNegozioMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ZonaNegozioMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? id;

  final String? nome;

  final _i2.ZonaNegozioCountAggregateOutputType? $count;

  final _i2.ZonaNegozioMinAggregateOutputType? $min;

  final _i2.ZonaNegozioMaxAggregateOutputType? $max;
}

class ZonaNegozioCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCountOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioMaxOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioMinOrderByAggregateInput({
    this.id,
    this.nome,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioOrderByWithAggregationInput({
    this.id,
    this.nome,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? nome;

  final _i2.ZonaNegozioCountOrderByAggregateInput? $count;

  final _i2.ZonaNegozioMaxOrderByAggregateInput? $max;

  final _i2.ZonaNegozioMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class ZonaNegozioScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.nome,
  });

  final _i1.PrismaUnion<_i2.ZonaNegozioScalarWhereWithAggregatesInput,
      Iterable<_i2.ZonaNegozioScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ZonaNegozioScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ZonaNegozioScalarWhereWithAggregatesInput,
      Iterable<_i2.ZonaNegozioScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? id;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioCountAggregateOutputTypeSelect({
    this.id,
    this.nome,
    this.$all,
  });

  final bool? id;

  final bool? nome;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_all': $all,
      };
}

class ZonaNegozioGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioGroupByOutputTypeCountArgs({this.select});

  final _i2.ZonaNegozioCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonaNegozioMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioMinAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioGroupByOutputTypeMinArgs({this.select});

  final _i2.ZonaNegozioMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonaNegozioMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioMaxAggregateOutputTypeSelect({
    this.id,
    this.nome,
  });

  final bool? id;

  final bool? nome;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
      };
}

class ZonaNegozioGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioGroupByOutputTypeMaxArgs({this.select});

  final _i2.ZonaNegozioMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonaNegozioGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonaNegozioGroupByOutputTypeSelect({
    this.id,
    this.nome,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? nome;

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ZonaNegozioGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'nome': nome,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateZonaNegozio {
  const AggregateZonaNegozio({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateZonaNegozio.fromJson(Map json) => AggregateZonaNegozio(
        $count: json['_count'] is Map
            ? _i2.ZonaNegozioCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ZonaNegozioMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ZonaNegozioMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ZonaNegozioCountAggregateOutputType? $count;

  final _i2.ZonaNegozioMinAggregateOutputType? $min;

  final _i2.ZonaNegozioMaxAggregateOutputType? $max;
}

class AggregateZonaNegozioCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonaNegozioCountArgs({this.select});

  final _i2.ZonaNegozioCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonaNegozioMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonaNegozioMinArgs({this.select});

  final _i2.ZonaNegozioMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonaNegozioMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonaNegozioMaxArgs({this.select});

  final _i2.ZonaNegozioMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonaNegozioSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonaNegozioSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateZonaNegozioCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateZonaNegozioMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateZonaNegozioMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class LeadCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    required this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.StatoOpportunitaCreateNestedOneWithoutLeadsInput statoOpportunita;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    required this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final String statoOpportunitaUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.statoOpportunita,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.StatoOpportunitaUpdateOneRequiredWithoutLeadsNestedInput?
      statoOpportunita;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'statoOpportunita': statoOpportunita,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCountAggregateOutputType {
  const LeadCountAggregateOutputType({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.$all,
  });

  factory LeadCountAggregateOutputType.fromJson(Map json) =>
      LeadCountAggregateOutputType(
        uuid: json['uuid'],
        opportunitaUuid: json['opportunitaUuid'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOpportunitaUuid: json['statoOpportunitaUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        agenteUuid: json['agenteUuid'],
        appuntamenti: json['appuntamenti'],
        form: json['form'],
        dataInserimento: json['dataInserimento'],
        dataScadenza: json['dataScadenza'],
        dataAppuntamento: json['dataAppuntamento'],
        nota: json['nota'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? opportunitaUuid;

  final int? soggettoUuid;

  final int? domicilioUuid;

  final int? statoOpportunitaUuid;

  final int? utenteUuid;

  final int? negozioCodice;

  final int? agenteUuid;

  final int? appuntamenti;

  final int? form;

  final int? dataInserimento;

  final int? dataScadenza;

  final int? dataAppuntamento;

  final int? nota;

  final int? $all;
}

class LeadMinAggregateOutputType {
  const LeadMinAggregateOutputType({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  factory LeadMinAggregateOutputType.fromJson(Map json) =>
      LeadMinAggregateOutputType(
        uuid: json['uuid'],
        opportunitaUuid: json['opportunitaUuid'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOpportunitaUuid: json['statoOpportunitaUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        agenteUuid: json['agenteUuid'],
        appuntamenti: json['appuntamenti'],
        form: json['form'],
        dataInserimento: json['dataInserimento'],
        dataScadenza: json['dataScadenza'],
        dataAppuntamento: json['dataAppuntamento'],
        nota: json['nota'],
      );

  final String? uuid;

  final String? opportunitaUuid;

  final String? soggettoUuid;

  final String? domicilioUuid;

  final String? statoOpportunitaUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? agenteUuid;

  final String? appuntamenti;

  final String? form;

  final DateTime? dataInserimento;

  final DateTime? dataScadenza;

  final DateTime? dataAppuntamento;

  final String? nota;
}

class LeadMaxAggregateOutputType {
  const LeadMaxAggregateOutputType({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  factory LeadMaxAggregateOutputType.fromJson(Map json) =>
      LeadMaxAggregateOutputType(
        uuid: json['uuid'],
        opportunitaUuid: json['opportunitaUuid'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOpportunitaUuid: json['statoOpportunitaUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        agenteUuid: json['agenteUuid'],
        appuntamenti: json['appuntamenti'],
        form: json['form'],
        dataInserimento: json['dataInserimento'],
        dataScadenza: json['dataScadenza'],
        dataAppuntamento: json['dataAppuntamento'],
        nota: json['nota'],
      );

  final String? uuid;

  final String? opportunitaUuid;

  final String? soggettoUuid;

  final String? domicilioUuid;

  final String? statoOpportunitaUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? agenteUuid;

  final String? appuntamenti;

  final String? form;

  final DateTime? dataInserimento;

  final DateTime? dataScadenza;

  final DateTime? dataAppuntamento;

  final String? nota;
}

class LeadGroupByOutputType {
  const LeadGroupByOutputType({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.$count,
    this.$min,
    this.$max,
  });

  factory LeadGroupByOutputType.fromJson(Map json) => LeadGroupByOutputType(
        uuid: json['uuid'],
        opportunitaUuid: json['opportunitaUuid'],
        soggettoUuid: json['soggettoUuid'],
        domicilioUuid: json['domicilioUuid'],
        statoOpportunitaUuid: json['statoOpportunitaUuid'],
        utenteUuid: json['utenteUuid'],
        negozioCodice: json['negozioCodice'],
        agenteUuid: json['agenteUuid'],
        appuntamenti: json['appuntamenti'],
        form: json['form'],
        dataInserimento: json['dataInserimento'],
        dataScadenza: json['dataScadenza'],
        dataAppuntamento: json['dataAppuntamento'],
        nota: json['nota'],
        $count: json['_count'] is Map
            ? _i2.LeadCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.LeadMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.LeadMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? opportunitaUuid;

  final String? soggettoUuid;

  final String? domicilioUuid;

  final String? statoOpportunitaUuid;

  final String? utenteUuid;

  final String? negozioCodice;

  final String? agenteUuid;

  final String? appuntamenti;

  final String? form;

  final DateTime? dataInserimento;

  final DateTime? dataScadenza;

  final DateTime? dataAppuntamento;

  final String? nota;

  final _i2.LeadCountAggregateOutputType? $count;

  final _i2.LeadMinAggregateOutputType? $min;

  final _i2.LeadMaxAggregateOutputType? $max;
}

class LeadCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCountOrderByAggregateInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? statoOpportunitaUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? agenteUuid;

  final _i2.SortOrder? appuntamenti;

  final _i2.SortOrder? form;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? dataScadenza;

  final _i2.SortOrder? dataAppuntamento;

  final _i2.SortOrder? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadMaxOrderByAggregateInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? statoOpportunitaUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? agenteUuid;

  final _i2.SortOrder? appuntamenti;

  final _i2.SortOrder? form;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? dataScadenza;

  final _i2.SortOrder? dataAppuntamento;

  final _i2.SortOrder? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadMinOrderByAggregateInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.SortOrder? soggettoUuid;

  final _i2.SortOrder? domicilioUuid;

  final _i2.SortOrder? statoOpportunitaUuid;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? negozioCodice;

  final _i2.SortOrder? agenteUuid;

  final _i2.SortOrder? appuntamenti;

  final _i2.SortOrder? form;

  final _i2.SortOrder? dataInserimento;

  final _i2.SortOrder? dataScadenza;

  final _i2.SortOrder? dataAppuntamento;

  final _i2.SortOrder? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadOrderByWithAggregationInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.SortOrder? soggettoUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? domicilioUuid;

  final _i2.SortOrder? statoOpportunitaUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? negozioCodice;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? agenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? appuntamenti;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? form;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataInserimento;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataScadenza;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataAppuntamento;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? nota;

  final _i2.LeadCountOrderByAggregateInput? $count;

  final _i2.LeadMaxOrderByAggregateInput? $max;

  final _i2.LeadMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class LeadScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<_i2.LeadScalarWhereWithAggregatesInput,
      Iterable<_i2.LeadScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.LeadScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.LeadScalarWhereWithAggregatesInput,
      Iterable<_i2.LeadScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      opportunitaUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? soggettoUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      statoOpportunitaUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCountAggregateOutputTypeSelect({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.$all,
  });

  final bool? uuid;

  final bool? opportunitaUuid;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOpportunitaUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? agenteUuid;

  final bool? appuntamenti;

  final bool? form;

  final bool? dataInserimento;

  final bool? dataScadenza;

  final bool? dataAppuntamento;

  final bool? nota;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        '_all': $all,
      };
}

class LeadGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadGroupByOutputTypeCountArgs({this.select});

  final _i2.LeadCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LeadMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadMinAggregateOutputTypeSelect({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final bool? uuid;

  final bool? opportunitaUuid;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOpportunitaUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? agenteUuid;

  final bool? appuntamenti;

  final bool? form;

  final bool? dataInserimento;

  final bool? dataScadenza;

  final bool? dataAppuntamento;

  final bool? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadGroupByOutputTypeMinArgs({this.select});

  final _i2.LeadMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LeadMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadMaxAggregateOutputTypeSelect({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final bool? uuid;

  final bool? opportunitaUuid;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOpportunitaUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? agenteUuid;

  final bool? appuntamenti;

  final bool? form;

  final bool? dataInserimento;

  final bool? dataScadenza;

  final bool? dataAppuntamento;

  final bool? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadGroupByOutputTypeMaxArgs({this.select});

  final _i2.LeadMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class LeadGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadGroupByOutputTypeSelect({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.statoOpportunitaUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? opportunitaUuid;

  final bool? soggettoUuid;

  final bool? domicilioUuid;

  final bool? statoOpportunitaUuid;

  final bool? utenteUuid;

  final bool? negozioCodice;

  final bool? agenteUuid;

  final bool? appuntamenti;

  final bool? form;

  final bool? dataInserimento;

  final bool? dataScadenza;

  final bool? dataAppuntamento;

  final bool? nota;

  final _i1.PrismaUnion<bool, _i2.LeadGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.LeadGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.LeadGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'statoOpportunitaUuid': statoOpportunitaUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateLead {
  const AggregateLead({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateLead.fromJson(Map json) => AggregateLead(
        $count: json['_count'] is Map
            ? _i2.LeadCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.LeadMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.LeadMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.LeadCountAggregateOutputType? $count;

  final _i2.LeadMinAggregateOutputType? $min;

  final _i2.LeadMaxAggregateOutputType? $max;
}

class AggregateLeadCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLeadCountArgs({this.select});

  final _i2.LeadCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateLeadMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLeadMinArgs({this.select});

  final _i2.LeadMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateLeadMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLeadMaxArgs({this.select});

  final _i2.LeadMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateLeadSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateLeadSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateLeadCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateLeadMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateLeadMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class OpportunitaCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.LeadCreateNestedManyWithoutOpportunitaInput? leads;

  final _i2.UtenteCreateNestedManyWithoutOpportunitaGestiteInput? gestoriLead;

  final _i2.UtenteCreateNestedManyWithoutOpportunitaAssegnateInput? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedCreateInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i2.LeadUncheckedCreateNestedManyWithoutOpportunitaInput? leads;

  final _i2.UtenteUncheckedCreateNestedManyWithoutOpportunitaGestiteInput?
      gestoriLead;

  final _i2.UtenteUncheckedCreateNestedManyWithoutOpportunitaAssegnateInput?
      agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCreateManyInput({
    this.uuid,
    required this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInizio;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataFine;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUpdateInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.LeadUpdateManyWithoutOpportunitaNestedInput? leads;

  final _i2.UtenteUpdateManyWithoutOpportunitaGestiteNestedInput? gestoriLead;

  final _i2.UtenteUpdateManyWithoutOpportunitaAssegnateNestedInput? agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.leads,
    this.gestoriLead,
    this.agenti,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i2.LeadUncheckedUpdateManyWithoutOpportunitaNestedInput? leads;

  final _i2.UtenteUncheckedUpdateManyWithoutOpportunitaGestiteNestedInput?
      gestoriLead;

  final _i2.UtenteUncheckedUpdateManyWithoutOpportunitaAssegnateNestedInput?
      agenti;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        'leads': leads,
        'gestoriLead': gestoriLead,
        'agenti': agenti,
      };
}

class OpportunitaUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaUncheckedUpdateManyInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaCountAggregateOutputType {
  const OpportunitaCountAggregateOutputType({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.$all,
  });

  factory OpportunitaCountAggregateOutputType.fromJson(Map json) =>
      OpportunitaCountAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataInizio: json['dataInizio'],
        dataFine: json['dataFine'],
        form: json['form'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? nome;

  final int? dataInizio;

  final int? dataFine;

  final int? form;

  final int? $all;
}

class OpportunitaMinAggregateOutputType {
  const OpportunitaMinAggregateOutputType({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  factory OpportunitaMinAggregateOutputType.fromJson(Map json) =>
      OpportunitaMinAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataInizio: json['dataInizio'],
        dataFine: json['dataFine'],
        form: json['form'],
      );

  final String? uuid;

  final String? nome;

  final DateTime? dataInizio;

  final DateTime? dataFine;

  final String? form;
}

class OpportunitaMaxAggregateOutputType {
  const OpportunitaMaxAggregateOutputType({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  factory OpportunitaMaxAggregateOutputType.fromJson(Map json) =>
      OpportunitaMaxAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataInizio: json['dataInizio'],
        dataFine: json['dataFine'],
        form: json['form'],
      );

  final String? uuid;

  final String? nome;

  final DateTime? dataInizio;

  final DateTime? dataFine;

  final String? form;
}

class OpportunitaGroupByOutputType {
  const OpportunitaGroupByOutputType({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.$count,
    this.$min,
    this.$max,
  });

  factory OpportunitaGroupByOutputType.fromJson(Map json) =>
      OpportunitaGroupByOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        dataInizio: json['dataInizio'],
        dataFine: json['dataFine'],
        form: json['form'],
        $count: json['_count'] is Map
            ? _i2.OpportunitaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OpportunitaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OpportunitaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? nome;

  final DateTime? dataInizio;

  final DateTime? dataFine;

  final String? form;

  final _i2.OpportunitaCountAggregateOutputType? $count;

  final _i2.OpportunitaMinAggregateOutputType? $min;

  final _i2.OpportunitaMaxAggregateOutputType? $max;
}

class OpportunitaCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCountOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataInizio;

  final _i2.SortOrder? dataFine;

  final _i2.SortOrder? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaMaxOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataInizio;

  final _i2.SortOrder? dataFine;

  final _i2.SortOrder? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaMinOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? dataInizio;

  final _i2.SortOrder? dataFine;

  final _i2.SortOrder? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaOrderByWithAggregationInput({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataInizio;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? dataFine;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? form;

  final _i2.OpportunitaCountOrderByAggregateInput? $count;

  final _i2.OpportunitaMaxOrderByAggregateInput? $max;

  final _i2.OpportunitaMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class OpportunitaScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereWithAggregatesInput,
      Iterable<_i2.OpportunitaScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OpportunitaScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OpportunitaScalarWhereWithAggregatesInput,
      Iterable<_i2.OpportunitaScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataInizio;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? dataFine;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? form;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaCountAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.$all,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataInizio;

  final bool? dataFine;

  final bool? form;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        '_all': $all,
      };
}

class OpportunitaGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaGroupByOutputTypeCountArgs({this.select});

  final _i2.OpportunitaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OpportunitaMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaMinAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataInizio;

  final bool? dataFine;

  final bool? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaGroupByOutputTypeMinArgs({this.select});

  final _i2.OpportunitaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OpportunitaMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaMaxAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataInizio;

  final bool? dataFine;

  final bool? form;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
      };
}

class OpportunitaGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaGroupByOutputTypeMaxArgs({this.select});

  final _i2.OpportunitaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OpportunitaGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OpportunitaGroupByOutputTypeSelect({
    this.uuid,
    this.nome,
    this.dataInizio,
    this.dataFine,
    this.form,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? nome;

  final bool? dataInizio;

  final bool? dataFine;

  final bool? form;

  final _i1.PrismaUnion<bool, _i2.OpportunitaGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.OpportunitaGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OpportunitaGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'dataInizio': dataInizio,
        'dataFine': dataFine,
        'form': form,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOpportunita {
  const AggregateOpportunita({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateOpportunita.fromJson(Map json) => AggregateOpportunita(
        $count: json['_count'] is Map
            ? _i2.OpportunitaCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OpportunitaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OpportunitaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OpportunitaCountAggregateOutputType? $count;

  final _i2.OpportunitaMinAggregateOutputType? $min;

  final _i2.OpportunitaMaxAggregateOutputType? $max;
}

class AggregateOpportunitaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOpportunitaCountArgs({this.select});

  final _i2.OpportunitaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOpportunitaMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOpportunitaMinArgs({this.select});

  final _i2.OpportunitaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOpportunitaMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOpportunitaMaxArgs({this.select});

  final _i2.OpportunitaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOpportunitaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOpportunitaSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOpportunitaCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOpportunitaMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOpportunitaMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum StatoOpportunitaScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  uuid<String>('uuid', 'StatoOpportunita'),
  nome<String>('nome', 'StatoOpportunita'),
  tipoStato<_i3.TipoStato>('tipoStato', 'StatoOpportunita'),
  ordine<int>('ordine', 'StatoOpportunita'),
  colore<String>('colore', 'StatoOpportunita'),
  opportunitaUuid<String>('opportunitaUuid', 'StatoOpportunita');

  const StatoOpportunitaScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class LeadCreateWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateWithoutStatoOpportunitaInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    required this.opportunita,
    required this.soggetto,
    this.domicilio,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OpportunitaCreateNestedOneWithoutLeadsInput opportunita;

  final _i2.SoggettoCreateNestedOneWithoutLeadsInput soggetto;

  final _i2.DomicilioCreateNestedOneWithoutLeadsInput? domicilio;

  final _i2.UtenteCreateNestedOneWithoutLeadsGestitiInput? utente;

  final _i2.NegozioCreateNestedOneWithoutLeadsInput? negozio;

  final _i2.UtenteCreateNestedOneWithoutLeadsAssegnatiInput? agente;

  final _i2.OrdineCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedCreateWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateWithoutStatoOpportunitaInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  final _i2.OrdineUncheckedCreateNestedManyWithoutLeadInput? ordine;

  final _i2.HistoryUncheckedCreateNestedManyWithoutLeadInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadCreateOrConnectWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateOrConnectWithoutStatoOpportunitaInput({
    required this.where,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutStatoOpportunitaInput,
      _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class LeadCreateManyStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyStatoOpportunitaInput({
    this.uuid,
    required this.opportunitaUuid,
    required this.soggettoUuid,
    this.domicilioUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final String? uuid;

  final String opportunitaUuid;

  final String soggettoUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? domicilioUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? negozioCodice;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? agenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? appuntamenti;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? form;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataInserimento;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataScadenza;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? dataAppuntamento;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadCreateManyStatoOpportunitaInputEnvelope
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateManyStatoOpportunitaInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  final _i1.PrismaUnion<_i2.LeadCreateManyStatoOpportunitaInput,
      Iterable<_i2.LeadCreateManyStatoOpportunitaInput>> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'skipDuplicates': skipDuplicates,
      };
}

class LeadCreateNestedManyWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadCreateNestedManyWithoutStatoOpportunitaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutStatoOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutStatoOpportunitaInput>,
              _i1.PrismaUnion<
                  _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput,
                  Iterable<
                      _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput>>?
      connectOrCreate;

  final _i2.LeadCreateManyStatoOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoOpportunitaCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCreateInput({
    this.uuid,
    required this.nome,
    this.tipoStato,
    this.ordine,
    required this.colore,
    required this.opportunitaUuid,
    this.leads,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>? tipoStato;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? ordine;

  final String colore;

  final String opportunitaUuid;

  final _i2.LeadCreateNestedManyWithoutStatoOpportunitaInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
      };
}

class LeadUncheckedCreateNestedManyWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedCreateNestedManyWithoutStatoOpportunitaInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutStatoOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutStatoOpportunitaInput>,
              _i1.PrismaUnion<
                  _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput,
                  Iterable<
                      _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput>>?
      connectOrCreate;

  final _i2.LeadCreateManyStatoOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'createMany': createMany,
        'connect': connect,
      };
}

class StatoOpportunitaUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUncheckedCreateInput({
    this.uuid,
    required this.nome,
    this.tipoStato,
    this.ordine,
    required this.colore,
    required this.opportunitaUuid,
    this.leads,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>? tipoStato;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? ordine;

  final String colore;

  final String opportunitaUuid;

  final _i2.LeadUncheckedCreateNestedManyWithoutStatoOpportunitaInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
      };
}

class StatoOpportunitaCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCreateManyInput({
    this.uuid,
    required this.nome,
    this.tipoStato,
    this.ordine,
    required this.colore,
    required this.opportunitaUuid,
  });

  final String? uuid;

  final String nome;

  final _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>? tipoStato;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? ordine;

  final String colore;

  final String opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class LeadUpdateWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithoutStatoOpportunitaInput({
    this.uuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.opportunita,
    this.soggetto,
    this.domicilio,
    this.utente,
    this.negozio,
    this.agente,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OpportunitaUpdateOneRequiredWithoutLeadsNestedInput? opportunita;

  final _i2.SoggettoUpdateOneRequiredWithoutLeadsNestedInput? soggetto;

  final _i2.DomicilioUpdateOneWithoutLeadsNestedInput? domicilio;

  final _i2.UtenteUpdateOneWithoutLeadsGestitiNestedInput? utente;

  final _i2.NegozioUpdateOneWithoutLeadsNestedInput? negozio;

  final _i2.UtenteUpdateOneWithoutLeadsAssegnatiNestedInput? agente;

  final _i2.OrdineUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'opportunita': opportunita,
        'soggetto': soggetto,
        'domicilio': domicilio,
        'utente': utente,
        'negozio': negozio,
        'agente': agente,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUncheckedUpdateWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateWithoutStatoOpportunitaInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
    this.ordine,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  final _i2.OrdineUncheckedUpdateManyWithoutLeadNestedInput? ordine;

  final _i2.HistoryUncheckedUpdateManyWithoutLeadNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
        'ordine': ordine,
        'history': history,
      };
}

class LeadUpsertWithWhereUniqueWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpsertWithWhereUniqueWithoutStatoOpportunitaInput({
    required this.where,
    required this.update,
    required this.create,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutStatoOpportunitaInput,
      _i2.LeadUncheckedUpdateWithoutStatoOpportunitaInput> update;

  final _i1.PrismaUnion<_i2.LeadCreateWithoutStatoOpportunitaInput,
      _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'update': update,
        'create': create,
      };
}

class LeadUpdateWithWhereUniqueWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateWithWhereUniqueWithoutStatoOpportunitaInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateWithoutStatoOpportunitaInput,
      _i2.LeadUncheckedUpdateWithoutStatoOpportunitaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUncheckedUpdateManyWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutStatoOpportunitaInput({
    this.uuid,
    this.opportunitaUuid,
    this.soggettoUuid,
    this.domicilioUuid,
    this.utenteUuid,
    this.negozioCodice,
    this.agenteUuid,
    this.appuntamenti,
    this.form,
    this.dataInserimento,
    this.dataScadenza,
    this.dataAppuntamento,
    this.nota,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      soggettoUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? domicilioUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? negozioCodice;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? agenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? appuntamenti;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? form;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataInserimento;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataScadenza;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? dataAppuntamento;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? nota;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'opportunitaUuid': opportunitaUuid,
        'soggettoUuid': soggettoUuid,
        'domicilioUuid': domicilioUuid,
        'utenteUuid': utenteUuid,
        'negozioCodice': negozioCodice,
        'agenteUuid': agenteUuid,
        'appuntamenti': appuntamenti,
        'form': form,
        'dataInserimento': dataInserimento,
        'dataScadenza': dataScadenza,
        'dataAppuntamento': dataAppuntamento,
        'nota': nota,
      };
}

class LeadUpdateManyWithWhereWithoutStatoOpportunitaInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithWhereWithoutStatoOpportunitaInput({
    required this.where,
    required this.data,
  });

  final _i2.LeadScalarWhereInput where;

  final _i1.PrismaUnion<_i2.LeadUpdateManyMutationInput,
      _i2.LeadUncheckedUpdateManyWithoutStatoOpportunitaInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class LeadUpdateManyWithoutStatoOpportunitaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUpdateManyWithoutStatoOpportunitaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutStatoOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutStatoOpportunitaInput>,
              _i1.PrismaUnion<
                  _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput,
                  Iterable<
                      _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.LeadUpsertWithWhereUniqueWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadUpsertWithWhereUniqueWithoutStatoOpportunitaInput>>?
      upsert;

  final _i2.LeadCreateManyStatoOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.LeadUpdateWithWhereUniqueWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadUpdateWithWhereUniqueWithoutStatoOpportunitaInput>>?
      update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadUpdateManyWithWhereWithoutStatoOpportunitaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoOpportunitaUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUpdateInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NullableEnumTipoStatoFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i2.LeadUpdateManyWithoutStatoOpportunitaNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
      };
}

class LeadUncheckedUpdateManyWithoutStatoOpportunitaNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const LeadUncheckedUpdateManyWithoutStatoOpportunitaNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  final _i1.PrismaUnion<
          _i2.LeadCreateWithoutStatoOpportunitaInput,
          _i1.PrismaUnion<
              Iterable<_i2.LeadCreateWithoutStatoOpportunitaInput>,
              _i1.PrismaUnion<
                  _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput,
                  Iterable<
                      _i2.LeadUncheckedCreateWithoutStatoOpportunitaInput>>>>?
      create;

  final _i1.PrismaUnion<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadCreateOrConnectWithoutStatoOpportunitaInput>>?
      connectOrCreate;

  final _i1.PrismaUnion<
          _i2.LeadUpsertWithWhereUniqueWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadUpsertWithWhereUniqueWithoutStatoOpportunitaInput>>?
      upsert;

  final _i2.LeadCreateManyStatoOpportunitaInputEnvelope? createMany;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? set;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? disconnect;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? delete;

  final _i1.PrismaUnion<_i2.LeadWhereUniqueInput,
      Iterable<_i2.LeadWhereUniqueInput>>? connect;

  final _i1.PrismaUnion<
          _i2.LeadUpdateWithWhereUniqueWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadUpdateWithWhereUniqueWithoutStatoOpportunitaInput>>?
      update;

  final _i1.PrismaUnion<_i2.LeadUpdateManyWithWhereWithoutStatoOpportunitaInput,
          Iterable<_i2.LeadUpdateManyWithWhereWithoutStatoOpportunitaInput>>?
      updateMany;

  final _i1.PrismaUnion<_i2.LeadScalarWhereInput,
      Iterable<_i2.LeadScalarWhereInput>>? deleteMany;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'createMany': createMany,
        'set': set,
        'disconnect': disconnect,
        'delete': delete,
        'connect': connect,
        'update': update,
        'updateMany': updateMany,
        'deleteMany': deleteMany,
      };
}

class StatoOpportunitaUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUncheckedUpdateInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.leads,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NullableEnumTipoStatoFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  final _i2.LeadUncheckedUpdateManyWithoutStatoOpportunitaNestedInput? leads;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        'leads': leads,
      };
}

class StatoOpportunitaUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUpdateManyMutationInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NullableEnumTipoStatoFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaUncheckedUpdateManyInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? nome;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NullableEnumTipoStatoFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? colore;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaCountAggregateOutputType {
  const StatoOpportunitaCountAggregateOutputType({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.$all,
  });

  factory StatoOpportunitaCountAggregateOutputType.fromJson(Map json) =>
      StatoOpportunitaCountAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        tipoStato: json['tipoStato'],
        ordine: json['ordine'],
        colore: json['colore'],
        opportunitaUuid: json['opportunitaUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? nome;

  final int? tipoStato;

  final int? ordine;

  final int? colore;

  final int? opportunitaUuid;

  final int? $all;
}

class StatoOpportunitaAvgAggregateOutputType {
  const StatoOpportunitaAvgAggregateOutputType({this.ordine});

  factory StatoOpportunitaAvgAggregateOutputType.fromJson(Map json) =>
      StatoOpportunitaAvgAggregateOutputType(ordine: json['ordine']);

  final double? ordine;
}

class StatoOpportunitaSumAggregateOutputType {
  const StatoOpportunitaSumAggregateOutputType({this.ordine});

  factory StatoOpportunitaSumAggregateOutputType.fromJson(Map json) =>
      StatoOpportunitaSumAggregateOutputType(ordine: json['ordine']);

  final int? ordine;
}

class StatoOpportunitaMinAggregateOutputType {
  const StatoOpportunitaMinAggregateOutputType({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  factory StatoOpportunitaMinAggregateOutputType.fromJson(Map json) =>
      StatoOpportunitaMinAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        tipoStato: json['tipoStato'] != null
            ? _i3.TipoStato.values
                .firstWhere((e) => e.name == json['tipoStato'])
            : null,
        ordine: json['ordine'],
        colore: json['colore'],
        opportunitaUuid: json['opportunitaUuid'],
      );

  final String? uuid;

  final String? nome;

  final _i3.TipoStato? tipoStato;

  final int? ordine;

  final String? colore;

  final String? opportunitaUuid;
}

class StatoOpportunitaMaxAggregateOutputType {
  const StatoOpportunitaMaxAggregateOutputType({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  factory StatoOpportunitaMaxAggregateOutputType.fromJson(Map json) =>
      StatoOpportunitaMaxAggregateOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        tipoStato: json['tipoStato'] != null
            ? _i3.TipoStato.values
                .firstWhere((e) => e.name == json['tipoStato'])
            : null,
        ordine: json['ordine'],
        colore: json['colore'],
        opportunitaUuid: json['opportunitaUuid'],
      );

  final String? uuid;

  final String? nome;

  final _i3.TipoStato? tipoStato;

  final int? ordine;

  final String? colore;

  final String? opportunitaUuid;
}

class StatoOpportunitaGroupByOutputType {
  const StatoOpportunitaGroupByOutputType({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory StatoOpportunitaGroupByOutputType.fromJson(Map json) =>
      StatoOpportunitaGroupByOutputType(
        uuid: json['uuid'],
        nome: json['nome'],
        tipoStato: json['tipoStato'] != null
            ? _i3.TipoStato.values
                .firstWhere((e) => e.name == json['tipoStato'])
            : null,
        ordine: json['ordine'],
        colore: json['colore'],
        opportunitaUuid: json['opportunitaUuid'],
        $count: json['_count'] is Map
            ? _i2.StatoOpportunitaCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.StatoOpportunitaAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.StatoOpportunitaSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoOpportunitaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoOpportunitaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final String? nome;

  final _i3.TipoStato? tipoStato;

  final int? ordine;

  final String? colore;

  final String? opportunitaUuid;

  final _i2.StatoOpportunitaCountAggregateOutputType? $count;

  final _i2.StatoOpportunitaAvgAggregateOutputType? $avg;

  final _i2.StatoOpportunitaSumAggregateOutputType? $sum;

  final _i2.StatoOpportunitaMinAggregateOutputType? $min;

  final _i2.StatoOpportunitaMaxAggregateOutputType? $max;
}

class StatoOpportunitaCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCountOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaAvgOrderByAggregateInput({this.ordine});

  final _i2.SortOrder? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOpportunitaMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaMaxOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaMinOrderByAggregateInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i2.SortOrder? tipoStato;

  final _i2.SortOrder? ordine;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaSumOrderByAggregateInput({this.ordine});

  final _i2.SortOrder? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOpportunitaOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaOrderByWithAggregationInput({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? nome;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tipoStato;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? ordine;

  final _i2.SortOrder? colore;

  final _i2.SortOrder? opportunitaUuid;

  final _i2.StatoOpportunitaCountOrderByAggregateInput? $count;

  final _i2.StatoOpportunitaAvgOrderByAggregateInput? $avg;

  final _i2.StatoOpportunitaMaxOrderByAggregateInput? $max;

  final _i2.StatoOpportunitaMinOrderByAggregateInput? $min;

  final _i2.StatoOpportunitaSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedEnumTipoStatoNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedEnumTipoStatoNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoStato,
      _i1.PrismaUnion<_i1.Reference<_i3.TipoStato>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NestedEnumTipoStatoNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedEnumTipoStatoNullableFilter? $min;

  final _i2.NestedEnumTipoStatoNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class EnumTipoStatoNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EnumTipoStatoNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i3.TipoStato,
      _i1.PrismaUnion<_i1.Reference<_i3.TipoStato>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i3.TipoStato>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<
      _i3.TipoStato,
      _i1.PrismaUnion<_i2.NestedEnumTipoStatoNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedEnumTipoStatoNullableFilter? $min;

  final _i2.NestedEnumTipoStatoNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StatoOpportunitaScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final _i1.PrismaUnion<_i2.StatoOpportunitaScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoOpportunitaScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.StatoOpportunitaScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.StatoOpportunitaScalarWhereWithAggregatesInput,
      Iterable<_i2.StatoOpportunitaScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? nome;

  final _i1.PrismaUnion<_i2.EnumTipoStatoNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i3.TipoStato, _i1.PrismaNull>>? tipoStato;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? ordine;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? colore;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>?
      opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaCountAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final bool? opportunitaUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        '_all': $all,
      };
}

class StatoOpportunitaGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaGroupByOutputTypeCountArgs({this.select});

  final _i2.StatoOpportunitaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOpportunitaAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaAvgAggregateOutputTypeSelect({this.ordine});

  final bool? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOpportunitaGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaGroupByOutputTypeAvgArgs({this.select});

  final _i2.StatoOpportunitaAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOpportunitaSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaSumAggregateOutputTypeSelect({this.ordine});

  final bool? ordine;

  @override
  Map<String, dynamic> toJson() => {'ordine': ordine};
}

class StatoOpportunitaGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaGroupByOutputTypeSumArgs({this.select});

  final _i2.StatoOpportunitaSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOpportunitaMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaMinAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final bool? uuid;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final bool? opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaGroupByOutputTypeMinArgs({this.select});

  final _i2.StatoOpportunitaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOpportunitaMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaMaxAggregateOutputTypeSelect({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
  });

  final bool? uuid;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final bool? opportunitaUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
      };
}

class StatoOpportunitaGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaGroupByOutputTypeMaxArgs({this.select});

  final _i2.StatoOpportunitaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StatoOpportunitaGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StatoOpportunitaGroupByOutputTypeSelect({
    this.uuid,
    this.nome,
    this.tipoStato,
    this.ordine,
    this.colore,
    this.opportunitaUuid,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? nome;

  final bool? tipoStato;

  final bool? ordine;

  final bool? colore;

  final bool? opportunitaUuid;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.StatoOpportunitaGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'nome': nome,
        'tipoStato': tipoStato,
        'ordine': ordine,
        'colore': colore,
        'opportunitaUuid': opportunitaUuid,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateStatoOpportunita {
  const AggregateStatoOpportunita({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateStatoOpportunita.fromJson(Map json) =>
      AggregateStatoOpportunita(
        $count: json['_count'] is Map
            ? _i2.StatoOpportunitaCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.StatoOpportunitaAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.StatoOpportunitaSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StatoOpportunitaMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StatoOpportunitaMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.StatoOpportunitaCountAggregateOutputType? $count;

  final _i2.StatoOpportunitaAvgAggregateOutputType? $avg;

  final _i2.StatoOpportunitaSumAggregateOutputType? $sum;

  final _i2.StatoOpportunitaMinAggregateOutputType? $min;

  final _i2.StatoOpportunitaMaxAggregateOutputType? $max;
}

class AggregateStatoOpportunitaCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOpportunitaCountArgs({this.select});

  final _i2.StatoOpportunitaCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOpportunitaAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOpportunitaAvgArgs({this.select});

  final _i2.StatoOpportunitaAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOpportunitaSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOpportunitaSumArgs({this.select});

  final _i2.StatoOpportunitaSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOpportunitaMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOpportunitaMinArgs({this.select});

  final _i2.StatoOpportunitaMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOpportunitaMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOpportunitaMaxArgs({this.select});

  final _i2.StatoOpportunitaMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStatoOpportunitaSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStatoOpportunitaSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOpportunitaCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOpportunitaAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOpportunitaSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOpportunitaMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateStatoOpportunitaMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class HistoryCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.comment,
    this.attachment,
    required this.utente,
    this.lead,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i2.HistoryCommentCreateNestedOneWithoutHistoryInput? comment;

  final _i2.HistoryAttachmentCreateNestedOneWithoutHistoryInput? attachment;

  final _i2.UtenteCreateNestedOneWithoutHistoryInput utente;

  final _i2.LeadCreateNestedOneWithoutHistoryInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    required this.utenteUuid,
    this.leadUuid,
    this.comment,
    this.attachment,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final _i2.HistoryCommentUncheckedCreateNestedOneWithoutHistoryInput? comment;

  final _i2.HistoryAttachmentUncheckedCreateNestedOneWithoutHistoryInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
      };
}

class HistoryCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateManyInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    required this.utenteUuid,
    this.leadUuid,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.comment,
    this.attachment,
    this.utente,
    this.lead,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i2.HistoryCommentUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.HistoryAttachmentUpdateOneWithoutHistoryNestedInput? attachment;

  final _i2.UtenteUpdateOneRequiredWithoutHistoryNestedInput? utente;

  final _i2.LeadUpdateOneWithoutHistoryNestedInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.comment,
    this.attachment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i2.HistoryCommentUncheckedUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.HistoryAttachmentUncheckedUpdateOneWithoutHistoryNestedInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
        'attachment': attachment,
      };
}

class HistoryUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateManyInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryCountAggregateOutputType {
  const HistoryCountAggregateOutputType({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.$all,
  });

  factory HistoryCountAggregateOutputType.fromJson(Map json) =>
      HistoryCountAggregateOutputType(
        uuid: json['uuid'],
        timestamp: json['timestamp'],
        event: json['event'],
        utenteUuid: json['utenteUuid'],
        leadUuid: json['leadUuid'],
        $all: json['_all'],
      );

  final int? uuid;

  final int? timestamp;

  final int? event;

  final int? utenteUuid;

  final int? leadUuid;

  final int? $all;
}

class HistoryMinAggregateOutputType {
  const HistoryMinAggregateOutputType({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  factory HistoryMinAggregateOutputType.fromJson(Map json) =>
      HistoryMinAggregateOutputType(
        uuid: json['uuid'],
        timestamp: json['timestamp'],
        event: json['event'],
        utenteUuid: json['utenteUuid'],
        leadUuid: json['leadUuid'],
      );

  final String? uuid;

  final DateTime? timestamp;

  final String? event;

  final String? utenteUuid;

  final String? leadUuid;
}

class HistoryMaxAggregateOutputType {
  const HistoryMaxAggregateOutputType({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  factory HistoryMaxAggregateOutputType.fromJson(Map json) =>
      HistoryMaxAggregateOutputType(
        uuid: json['uuid'],
        timestamp: json['timestamp'],
        event: json['event'],
        utenteUuid: json['utenteUuid'],
        leadUuid: json['leadUuid'],
      );

  final String? uuid;

  final DateTime? timestamp;

  final String? event;

  final String? utenteUuid;

  final String? leadUuid;
}

class HistoryGroupByOutputType {
  const HistoryGroupByOutputType({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory HistoryGroupByOutputType.fromJson(Map json) =>
      HistoryGroupByOutputType(
        uuid: json['uuid'],
        timestamp: json['timestamp'],
        event: json['event'],
        utenteUuid: json['utenteUuid'],
        leadUuid: json['leadUuid'],
        $count: json['_count'] is Map
            ? _i2.HistoryCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.HistoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.HistoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? uuid;

  final DateTime? timestamp;

  final String? event;

  final String? utenteUuid;

  final String? leadUuid;

  final _i2.HistoryCountAggregateOutputType? $count;

  final _i2.HistoryMinAggregateOutputType? $min;

  final _i2.HistoryMaxAggregateOutputType? $max;
}

class HistoryCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCountOrderByAggregateInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? timestamp;

  final _i2.SortOrder? event;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryMaxOrderByAggregateInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? timestamp;

  final _i2.SortOrder? event;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryMinOrderByAggregateInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? timestamp;

  final _i2.SortOrder? event;

  final _i2.SortOrder? utenteUuid;

  final _i2.SortOrder? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryOrderByWithAggregationInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? timestamp;

  final _i2.SortOrder? event;

  final _i2.SortOrder? utenteUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? leadUuid;

  final _i2.HistoryCountOrderByAggregateInput? $count;

  final _i2.HistoryMaxOrderByAggregateInput? $max;

  final _i2.HistoryMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class HistoryScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final _i1.PrismaUnion<_i2.HistoryScalarWhereWithAggregatesInput,
      Iterable<_i2.HistoryScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.HistoryScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryScalarWhereWithAggregatesInput,
      Iterable<_i2.HistoryScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? uuid;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? timestamp;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? event;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? utenteUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCountAggregateOutputTypeSelect({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.$all,
  });

  final bool? uuid;

  final bool? timestamp;

  final bool? event;

  final bool? utenteUuid;

  final bool? leadUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        '_all': $all,
      };
}

class HistoryGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryGroupByOutputTypeCountArgs({this.select});

  final _i2.HistoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryMinAggregateOutputTypeSelect({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final bool? uuid;

  final bool? timestamp;

  final bool? event;

  final bool? utenteUuid;

  final bool? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryGroupByOutputTypeMinArgs({this.select});

  final _i2.HistoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryMaxAggregateOutputTypeSelect({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
  });

  final bool? uuid;

  final bool? timestamp;

  final bool? event;

  final bool? utenteUuid;

  final bool? leadUuid;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
      };
}

class HistoryGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryGroupByOutputTypeMaxArgs({this.select});

  final _i2.HistoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryGroupByOutputTypeSelect({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? uuid;

  final bool? timestamp;

  final bool? event;

  final bool? utenteUuid;

  final bool? leadUuid;

  final _i1.PrismaUnion<bool, _i2.HistoryGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.HistoryGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.HistoryGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateHistory {
  const AggregateHistory({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateHistory.fromJson(Map json) => AggregateHistory(
        $count: json['_count'] is Map
            ? _i2.HistoryCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.HistoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.HistoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.HistoryCountAggregateOutputType? $count;

  final _i2.HistoryMinAggregateOutputType? $min;

  final _i2.HistoryMaxAggregateOutputType? $max;
}

class AggregateHistoryCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryCountArgs({this.select});

  final _i2.HistoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryMinArgs({this.select});

  final _i2.HistoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryMaxArgs({this.select});

  final _i2.HistoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistorySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistorySelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum HistoryCommentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  comment<String>('comment', 'HistoryComment'),
  historyUuid<String>('historyUuid', 'HistoryComment');

  const HistoryCommentScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class HistoryCreateWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateWithoutCommentInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.attachment,
    required this.utente,
    this.lead,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i2.HistoryAttachmentCreateNestedOneWithoutHistoryInput? attachment;

  final _i2.UtenteCreateNestedOneWithoutHistoryInput utente;

  final _i2.LeadCreateNestedOneWithoutHistoryInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryUncheckedCreateWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateWithoutCommentInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    required this.utenteUuid,
    this.leadUuid,
    this.attachment,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final _i2.HistoryAttachmentUncheckedCreateNestedOneWithoutHistoryInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'attachment': attachment,
      };
}

class HistoryCreateOrConnectWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateOrConnectWithoutCommentInput({
    required this.where,
    required this.create,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutCommentInput,
      _i2.HistoryUncheckedCreateWithoutCommentInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class HistoryCreateNestedOneWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateNestedOneWithoutCommentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutCommentInput,
      _i2.HistoryUncheckedCreateWithoutCommentInput>? create;

  final _i2.HistoryCreateOrConnectWithoutCommentInput? connectOrCreate;

  final _i2.HistoryWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryCommentCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCreateInput({
    required this.comment,
    required this.history,
  });

  final String comment;

  final _i2.HistoryCreateNestedOneWithoutCommentInput history;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'History': history,
      };
}

class HistoryCommentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedCreateInput({
    required this.comment,
    required this.historyUuid,
  });

  final String comment;

  final String historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCreateManyInput({
    required this.comment,
    required this.historyUuid,
  });

  final String comment;

  final String historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryUpdateWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateWithoutCommentInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.attachment,
    this.utente,
    this.lead,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i2.HistoryAttachmentUpdateOneWithoutHistoryNestedInput? attachment;

  final _i2.UtenteUpdateOneRequiredWithoutHistoryNestedInput? utente;

  final _i2.LeadUpdateOneWithoutHistoryNestedInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'attachment': attachment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryUncheckedUpdateWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateWithoutCommentInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.attachment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i2.HistoryAttachmentUncheckedUpdateOneWithoutHistoryNestedInput?
      attachment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'attachment': attachment,
      };
}

class HistoryUpsertWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpsertWithoutCommentInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutCommentInput,
      _i2.HistoryUncheckedUpdateWithoutCommentInput> update;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutCommentInput,
      _i2.HistoryUncheckedCreateWithoutCommentInput> create;

  final _i2.HistoryWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class HistoryUpdateToOneWithWhereWithoutCommentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateToOneWithWhereWithoutCommentInput({
    this.where,
    required this.data,
  });

  final _i2.HistoryWhereInput? where;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutCommentInput,
      _i2.HistoryUncheckedUpdateWithoutCommentInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryUpdateOneRequiredWithoutCommentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateOneRequiredWithoutCommentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutCommentInput,
      _i2.HistoryUncheckedCreateWithoutCommentInput>? create;

  final _i2.HistoryCreateOrConnectWithoutCommentInput? connectOrCreate;

  final _i2.HistoryUpsertWithoutCommentInput? upsert;

  final _i2.HistoryWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.HistoryUpdateToOneWithWhereWithoutCommentInput,
      _i1.PrismaUnion<_i2.HistoryUpdateWithoutCommentInput,
          _i2.HistoryUncheckedUpdateWithoutCommentInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class HistoryCommentUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUpdateInput({
    this.comment,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? comment;

  final _i2.HistoryUpdateOneRequiredWithoutCommentNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'History': history,
      };
}

class HistoryCommentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedUpdateInput({
    this.comment,
    this.historyUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? comment;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUpdateManyMutationInput({this.comment});

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? comment;

  @override
  Map<String, dynamic> toJson() => {'comment': comment};
}

class HistoryCommentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentUncheckedUpdateManyInput({
    this.comment,
    this.historyUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? comment;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentCountAggregateOutputType {
  const HistoryCommentCountAggregateOutputType({
    this.comment,
    this.historyUuid,
    this.$all,
  });

  factory HistoryCommentCountAggregateOutputType.fromJson(Map json) =>
      HistoryCommentCountAggregateOutputType(
        comment: json['comment'],
        historyUuid: json['historyUuid'],
        $all: json['_all'],
      );

  final int? comment;

  final int? historyUuid;

  final int? $all;
}

class HistoryCommentMinAggregateOutputType {
  const HistoryCommentMinAggregateOutputType({
    this.comment,
    this.historyUuid,
  });

  factory HistoryCommentMinAggregateOutputType.fromJson(Map json) =>
      HistoryCommentMinAggregateOutputType(
        comment: json['comment'],
        historyUuid: json['historyUuid'],
      );

  final String? comment;

  final String? historyUuid;
}

class HistoryCommentMaxAggregateOutputType {
  const HistoryCommentMaxAggregateOutputType({
    this.comment,
    this.historyUuid,
  });

  factory HistoryCommentMaxAggregateOutputType.fromJson(Map json) =>
      HistoryCommentMaxAggregateOutputType(
        comment: json['comment'],
        historyUuid: json['historyUuid'],
      );

  final String? comment;

  final String? historyUuid;
}

class HistoryCommentGroupByOutputType {
  const HistoryCommentGroupByOutputType({
    this.comment,
    this.historyUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory HistoryCommentGroupByOutputType.fromJson(Map json) =>
      HistoryCommentGroupByOutputType(
        comment: json['comment'],
        historyUuid: json['historyUuid'],
        $count: json['_count'] is Map
            ? _i2.HistoryCommentCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.HistoryCommentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.HistoryCommentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? comment;

  final String? historyUuid;

  final _i2.HistoryCommentCountAggregateOutputType? $count;

  final _i2.HistoryCommentMinAggregateOutputType? $min;

  final _i2.HistoryCommentMaxAggregateOutputType? $max;
}

class HistoryCommentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCountOrderByAggregateInput({
    this.comment,
    this.historyUuid,
  });

  final _i2.SortOrder? comment;

  final _i2.SortOrder? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentMaxOrderByAggregateInput({
    this.comment,
    this.historyUuid,
  });

  final _i2.SortOrder? comment;

  final _i2.SortOrder? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentMinOrderByAggregateInput({
    this.comment,
    this.historyUuid,
  });

  final _i2.SortOrder? comment;

  final _i2.SortOrder? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentOrderByWithAggregationInput({
    this.comment,
    this.historyUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? comment;

  final _i2.SortOrder? historyUuid;

  final _i2.HistoryCommentCountOrderByAggregateInput? $count;

  final _i2.HistoryCommentMaxOrderByAggregateInput? $max;

  final _i2.HistoryCommentMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class HistoryCommentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.comment,
    this.historyUuid,
  });

  final _i1.PrismaUnion<_i2.HistoryCommentScalarWhereWithAggregatesInput,
      Iterable<_i2.HistoryCommentScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.HistoryCommentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryCommentScalarWhereWithAggregatesInput,
      Iterable<_i2.HistoryCommentScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? comment;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentCountAggregateOutputTypeSelect({
    this.comment,
    this.historyUuid,
    this.$all,
  });

  final bool? comment;

  final bool? historyUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
        '_all': $all,
      };
}

class HistoryCommentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentGroupByOutputTypeCountArgs({this.select});

  final _i2.HistoryCommentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryCommentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentMinAggregateOutputTypeSelect({
    this.comment,
    this.historyUuid,
  });

  final bool? comment;

  final bool? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentGroupByOutputTypeMinArgs({this.select});

  final _i2.HistoryCommentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryCommentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentMaxAggregateOutputTypeSelect({
    this.comment,
    this.historyUuid,
  });

  final bool? comment;

  final bool? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
      };
}

class HistoryCommentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentGroupByOutputTypeMaxArgs({this.select});

  final _i2.HistoryCommentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryCommentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCommentGroupByOutputTypeSelect({
    this.comment,
    this.historyUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? comment;

  final bool? historyUuid;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.HistoryCommentGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'comment': comment,
        'historyUuid': historyUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateHistoryComment {
  const AggregateHistoryComment({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateHistoryComment.fromJson(Map json) => AggregateHistoryComment(
        $count: json['_count'] is Map
            ? _i2.HistoryCommentCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.HistoryCommentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.HistoryCommentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.HistoryCommentCountAggregateOutputType? $count;

  final _i2.HistoryCommentMinAggregateOutputType? $min;

  final _i2.HistoryCommentMaxAggregateOutputType? $max;
}

class AggregateHistoryCommentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryCommentCountArgs({this.select});

  final _i2.HistoryCommentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryCommentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryCommentMinArgs({this.select});

  final _i2.HistoryCommentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryCommentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryCommentMaxArgs({this.select});

  final _i2.HistoryCommentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryCommentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryCommentSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryCommentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryCommentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryCommentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

enum HistoryAttachmentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  url<String>('url', 'HistoryAttachment'),
  name$<String>('name', 'HistoryAttachment'),
  historyUuid<String>('historyUuid', 'HistoryAttachment');

  const HistoryAttachmentScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class HistoryCreateWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateWithoutAttachmentInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    this.comment,
    required this.utente,
    this.lead,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final _i2.HistoryCommentCreateNestedOneWithoutHistoryInput? comment;

  final _i2.UtenteCreateNestedOneWithoutHistoryInput utente;

  final _i2.LeadCreateNestedOneWithoutHistoryInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryUncheckedCreateWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedCreateWithoutAttachmentInput({
    this.uuid,
    required this.timestamp,
    required this.event,
    required this.utenteUuid,
    this.leadUuid,
    this.comment,
  });

  final String? uuid;

  final DateTime timestamp;

  final String event;

  final String utenteUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? leadUuid;

  final _i2.HistoryCommentUncheckedCreateNestedOneWithoutHistoryInput? comment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
      };
}

class HistoryCreateOrConnectWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateOrConnectWithoutAttachmentInput({
    required this.where,
    required this.create,
  });

  final _i2.HistoryWhereUniqueInput where;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutAttachmentInput,
      _i2.HistoryUncheckedCreateWithoutAttachmentInput> create;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'create': create,
      };
}

class HistoryCreateNestedOneWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryCreateNestedOneWithoutAttachmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutAttachmentInput,
      _i2.HistoryUncheckedCreateWithoutAttachmentInput>? create;

  final _i2.HistoryCreateOrConnectWithoutAttachmentInput? connectOrCreate;

  final _i2.HistoryWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'connect': connect,
      };
}

class HistoryAttachmentCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCreateInput({
    required this.url,
    required this.name,
    required this.history,
  });

  final String url;

  final String name;

  final _i2.HistoryCreateNestedOneWithoutAttachmentInput history;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'History': history,
      };
}

class HistoryAttachmentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedCreateInput({
    required this.url,
    required this.name,
    required this.historyUuid,
  });

  final String url;

  final String name;

  final String historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCreateManyInput({
    required this.url,
    required this.name,
    required this.historyUuid,
  });

  final String url;

  final String name;

  final String historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryUpdateWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateWithoutAttachmentInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.comment,
    this.utente,
    this.lead,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i2.HistoryCommentUpdateOneWithoutHistoryNestedInput? comment;

  final _i2.UtenteUpdateOneRequiredWithoutHistoryNestedInput? utente;

  final _i2.LeadUpdateOneWithoutHistoryNestedInput? lead;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'comment': comment,
        'Utente': utente,
        'Lead': lead,
      };
}

class HistoryUncheckedUpdateWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUncheckedUpdateWithoutAttachmentInput({
    this.uuid,
    this.timestamp,
    this.event,
    this.utenteUuid,
    this.leadUuid,
    this.comment,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? uuid;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      timestamp;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? event;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      utenteUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? leadUuid;

  final _i2.HistoryCommentUncheckedUpdateOneWithoutHistoryNestedInput? comment;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'timestamp': timestamp,
        'event': event,
        'utenteUuid': utenteUuid,
        'leadUuid': leadUuid,
        'comment': comment,
      };
}

class HistoryUpsertWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpsertWithoutAttachmentInput({
    required this.update,
    required this.create,
    this.where,
  });

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutAttachmentInput,
      _i2.HistoryUncheckedUpdateWithoutAttachmentInput> update;

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutAttachmentInput,
      _i2.HistoryUncheckedCreateWithoutAttachmentInput> create;

  final _i2.HistoryWhereInput? where;

  @override
  Map<String, dynamic> toJson() => {
        'update': update,
        'create': create,
        'where': where,
      };
}

class HistoryUpdateToOneWithWhereWithoutAttachmentInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateToOneWithWhereWithoutAttachmentInput({
    this.where,
    required this.data,
  });

  final _i2.HistoryWhereInput? where;

  final _i1.PrismaUnion<_i2.HistoryUpdateWithoutAttachmentInput,
      _i2.HistoryUncheckedUpdateWithoutAttachmentInput> data;

  @override
  Map<String, dynamic> toJson() => {
        'where': where,
        'data': data,
      };
}

class HistoryUpdateOneRequiredWithoutAttachmentNestedInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryUpdateOneRequiredWithoutAttachmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  final _i1.PrismaUnion<_i2.HistoryCreateWithoutAttachmentInput,
      _i2.HistoryUncheckedCreateWithoutAttachmentInput>? create;

  final _i2.HistoryCreateOrConnectWithoutAttachmentInput? connectOrCreate;

  final _i2.HistoryUpsertWithoutAttachmentInput? upsert;

  final _i2.HistoryWhereUniqueInput? connect;

  final _i1.PrismaUnion<
      _i2.HistoryUpdateToOneWithWhereWithoutAttachmentInput,
      _i1.PrismaUnion<_i2.HistoryUpdateWithoutAttachmentInput,
          _i2.HistoryUncheckedUpdateWithoutAttachmentInput>>? update;

  @override
  Map<String, dynamic> toJson() => {
        'create': create,
        'connectOrCreate': connectOrCreate,
        'upsert': upsert,
        'connect': connect,
        'update': update,
      };
}

class HistoryAttachmentUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUpdateInput({
    this.url,
    this.name,
    this.history,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? url;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i2.HistoryUpdateOneRequiredWithoutAttachmentNestedInput? history;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'History': history,
      };
}

class HistoryAttachmentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedUpdateInput({
    this.url,
    this.name,
    this.historyUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? url;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUpdateManyMutationInput({
    this.url,
    this.name,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? url;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
      };
}

class HistoryAttachmentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentUncheckedUpdateManyInput({
    this.url,
    this.name,
    this.historyUuid,
  });

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? url;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>? name;

  final _i1.PrismaUnion<String, _i2.StringFieldUpdateOperationsInput>?
      historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentCountAggregateOutputType {
  const HistoryAttachmentCountAggregateOutputType({
    this.url,
    this.name,
    this.historyUuid,
    this.$all,
  });

  factory HistoryAttachmentCountAggregateOutputType.fromJson(Map json) =>
      HistoryAttachmentCountAggregateOutputType(
        url: json['url'],
        name: json['name'],
        historyUuid: json['historyUuid'],
        $all: json['_all'],
      );

  final int? url;

  final int? name;

  final int? historyUuid;

  final int? $all;
}

class HistoryAttachmentMinAggregateOutputType {
  const HistoryAttachmentMinAggregateOutputType({
    this.url,
    this.name,
    this.historyUuid,
  });

  factory HistoryAttachmentMinAggregateOutputType.fromJson(Map json) =>
      HistoryAttachmentMinAggregateOutputType(
        url: json['url'],
        name: json['name'],
        historyUuid: json['historyUuid'],
      );

  final String? url;

  final String? name;

  final String? historyUuid;
}

class HistoryAttachmentMaxAggregateOutputType {
  const HistoryAttachmentMaxAggregateOutputType({
    this.url,
    this.name,
    this.historyUuid,
  });

  factory HistoryAttachmentMaxAggregateOutputType.fromJson(Map json) =>
      HistoryAttachmentMaxAggregateOutputType(
        url: json['url'],
        name: json['name'],
        historyUuid: json['historyUuid'],
      );

  final String? url;

  final String? name;

  final String? historyUuid;
}

class HistoryAttachmentGroupByOutputType {
  const HistoryAttachmentGroupByOutputType({
    this.url,
    this.name,
    this.historyUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  factory HistoryAttachmentGroupByOutputType.fromJson(Map json) =>
      HistoryAttachmentGroupByOutputType(
        url: json['url'],
        name: json['name'],
        historyUuid: json['historyUuid'],
        $count: json['_count'] is Map
            ? _i2.HistoryAttachmentCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.HistoryAttachmentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.HistoryAttachmentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final String? url;

  final String? name;

  final String? historyUuid;

  final _i2.HistoryAttachmentCountAggregateOutputType? $count;

  final _i2.HistoryAttachmentMinAggregateOutputType? $min;

  final _i2.HistoryAttachmentMaxAggregateOutputType? $max;
}

class HistoryAttachmentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCountOrderByAggregateInput({
    this.url,
    this.name,
    this.historyUuid,
  });

  final _i2.SortOrder? url;

  final _i2.SortOrder? name;

  final _i2.SortOrder? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentMaxOrderByAggregateInput({
    this.url,
    this.name,
    this.historyUuid,
  });

  final _i2.SortOrder? url;

  final _i2.SortOrder? name;

  final _i2.SortOrder? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentMinOrderByAggregateInput({
    this.url,
    this.name,
    this.historyUuid,
  });

  final _i2.SortOrder? url;

  final _i2.SortOrder? name;

  final _i2.SortOrder? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentOrderByWithAggregationInput({
    this.url,
    this.name,
    this.historyUuid,
    this.$count,
    this.$max,
    this.$min,
  });

  final _i2.SortOrder? url;

  final _i2.SortOrder? name;

  final _i2.SortOrder? historyUuid;

  final _i2.HistoryAttachmentCountOrderByAggregateInput? $count;

  final _i2.HistoryAttachmentMaxOrderByAggregateInput? $max;

  final _i2.HistoryAttachmentMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
        '_count': $count,
        '_max': $max,
        '_min': $min,
      };
}

class HistoryAttachmentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.url,
    this.name,
    this.historyUuid,
  });

  final _i1.PrismaUnion<_i2.HistoryAttachmentScalarWhereWithAggregatesInput,
      Iterable<_i2.HistoryAttachmentScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.HistoryAttachmentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.HistoryAttachmentScalarWhereWithAggregatesInput,
      Iterable<_i2.HistoryAttachmentScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? url;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? name;

  final _i1.PrismaUnion<_i2.StringWithAggregatesFilter, String>? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentCountAggregateOutputTypeSelect({
    this.url,
    this.name,
    this.historyUuid,
    this.$all,
  });

  final bool? url;

  final bool? name;

  final bool? historyUuid;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
        '_all': $all,
      };
}

class HistoryAttachmentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentGroupByOutputTypeCountArgs({this.select});

  final _i2.HistoryAttachmentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryAttachmentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentMinAggregateOutputTypeSelect({
    this.url,
    this.name,
    this.historyUuid,
  });

  final bool? url;

  final bool? name;

  final bool? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentGroupByOutputTypeMinArgs({this.select});

  final _i2.HistoryAttachmentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryAttachmentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentMaxAggregateOutputTypeSelect({
    this.url,
    this.name,
    this.historyUuid,
  });

  final bool? url;

  final bool? name;

  final bool? historyUuid;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
      };
}

class HistoryAttachmentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentGroupByOutputTypeMaxArgs({this.select});

  final _i2.HistoryAttachmentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class HistoryAttachmentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const HistoryAttachmentGroupByOutputTypeSelect({
    this.url,
    this.name,
    this.historyUuid,
    this.$count,
    this.$min,
    this.$max,
  });

  final bool? url;

  final bool? name;

  final bool? historyUuid;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.HistoryAttachmentGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'url': url,
        'name': name,
        'historyUuid': historyUuid,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateHistoryAttachment {
  const AggregateHistoryAttachment({
    this.$count,
    this.$min,
    this.$max,
  });

  factory AggregateHistoryAttachment.fromJson(Map json) =>
      AggregateHistoryAttachment(
        $count: json['_count'] is Map
            ? _i2.HistoryAttachmentCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $min: json['_min'] is Map
            ? _i2.HistoryAttachmentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.HistoryAttachmentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.HistoryAttachmentCountAggregateOutputType? $count;

  final _i2.HistoryAttachmentMinAggregateOutputType? $min;

  final _i2.HistoryAttachmentMaxAggregateOutputType? $max;
}

class AggregateHistoryAttachmentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryAttachmentCountArgs({this.select});

  final _i2.HistoryAttachmentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryAttachmentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryAttachmentMinArgs({this.select});

  final _i2.HistoryAttachmentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryAttachmentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryAttachmentMaxArgs({this.select});

  final _i2.HistoryAttachmentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateHistoryAttachmentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateHistoryAttachmentSelect({
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryAttachmentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryAttachmentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateHistoryAttachmentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}
