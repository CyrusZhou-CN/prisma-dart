// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/prisma_flutter.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class QueryEngineBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  QueryEngineBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  QueryEngineBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Int32> _PRISMA_OK =
      _lookup<ffi.Int32>('PRISMA_OK');

  int get PRISMA_OK => _PRISMA_OK.value;

  late final ffi.Pointer<ffi.Int32> _PRISMA_UNKNOWN_ERROR =
      _lookup<ffi.Int32>('PRISMA_UNKNOWN_ERROR');

  int get PRISMA_UNKNOWN_ERROR => _PRISMA_UNKNOWN_ERROR.value;

  late final ffi.Pointer<ffi.Int32> _PRISMA_MISSING_POINTER =
      _lookup<ffi.Int32>('PRISMA_MISSING_POINTER');

  int get PRISMA_MISSING_POINTER => _PRISMA_MISSING_POINTER.value;

  /// # Safety
  /// The calling context needs to pass a valid pointer that will store the reference
  /// The calling context also need to clear the pointer of the error string if it is not null
  int prisma_create(
    ConstructorOptions options,
    ffi.Pointer<ffi.Pointer<QueryEngine>> qe_ptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error_string_ptr,
  ) {
    return _prisma_create(
      options,
      qe_ptr,
      error_string_ptr,
    );
  }

  late final _prisma_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ConstructorOptions,
              ffi.Pointer<ffi.Pointer<QueryEngine>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('prisma_create');
  late final _prisma_create = _prisma_createPtr.asFunction<
      int Function(ConstructorOptions, ffi.Pointer<ffi.Pointer<QueryEngine>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  /// The calling context also need to clear the pointer of the error string if it is not null
  int prisma_connect(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> trace,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error_string_ptr,
  ) {
    return _prisma_connect(
      qe,
      trace,
      error_string_ptr,
    );
  }

  late final _prisma_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('prisma_connect');
  late final _prisma_connect = _prisma_connectPtr.asFunction<
      int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  /// The calling context also need to clear the pointer of the error string if it is not null
  ffi.Pointer<ffi.Char> prisma_query(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> body_str,
    ffi.Pointer<ffi.Char> header_str,
    ffi.Pointer<ffi.Char> tx_id_str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error_string_ptr,
  ) {
    return _prisma_query(
      qe,
      body_str,
      header_str,
      tx_id_str,
      error_string_ptr,
    );
  }

  late final _prisma_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('prisma_query');
  late final _prisma_query = _prisma_queryPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<QueryEngine>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  /// The calling context also need to clear the pointer of the error string if it is not null
  ffi.Pointer<ffi.Char> prisma_start_transaction(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> options_str,
    ffi.Pointer<ffi.Char> header_str,
  ) {
    return _prisma_start_transaction(
      qe,
      options_str,
      header_str,
    );
  }

  late final _prisma_start_transactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('prisma_start_transaction');
  late final _prisma_start_transaction =
      _prisma_start_transactionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  ffi.Pointer<ffi.Char> prisma_commit_transaction(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> tx_id_str,
    ffi.Pointer<ffi.Char> header_str,
  ) {
    return _prisma_commit_transaction(
      qe,
      tx_id_str,
      header_str,
    );
  }

  late final _prisma_commit_transactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('prisma_commit_transaction');
  late final _prisma_commit_transaction =
      _prisma_commit_transactionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  ffi.Pointer<ffi.Char> prisma_rollback_transaction(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> tx_id_str,
    ffi.Pointer<ffi.Char> header_str,
  ) {
    return _prisma_rollback_transaction(
      qe,
      tx_id_str,
      header_str,
    );
  }

  late final _prisma_rollback_transactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('prisma_rollback_transaction');
  late final _prisma_rollback_transaction =
      _prisma_rollback_transactionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  int prisma_disconnect(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> header_str,
  ) {
    return _prisma_disconnect(
      qe,
      header_str,
    );
  }

  late final _prisma_disconnectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>)>>('prisma_disconnect');
  late final _prisma_disconnect = _prisma_disconnectPtr.asFunction<
      int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>)>();

  /// # Safety
  ///
  /// The calling context needs to pass a valid pointer that will store the reference to the error string
  /// The calling context also need to clear the pointer of the error string if it is not null
  int prisma_apply_pending_migrations(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> migration_folder_path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error_string_ptr,
  ) {
    return _prisma_apply_pending_migrations(
      qe,
      migration_folder_path,
      error_string_ptr,
    );
  }

  late final _prisma_apply_pending_migrationsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'prisma_apply_pending_migrations');
  late final _prisma_apply_pending_migrations =
      _prisma_apply_pending_migrationsPtr.asFunction<
          int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// # Safety
  ///
  /// Will destroy the pointer to the query engine
  int prisma_destroy(
    ffi.Pointer<QueryEngine> qe,
  ) {
    return _prisma_destroy(
      qe,
    );
  }

  late final _prisma_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<QueryEngine>)>>(
          'prisma_destroy');
  late final _prisma_destroy =
      _prisma_destroyPtr.asFunction<int Function(ffi.Pointer<QueryEngine>)>();
}

final class QueryEngine extends ffi.Opaque {}

final class ConstructorOptionsNative extends ffi.Struct {
  external ffi.Pointer<ffi.Char> config_dir;
}

/// Parameters defining the construction of an engine.
/// Unlike the Node version, this doesn't support the GraphQL protocol for talking with the prisma/client, since it is
/// deprecated and going forward everything should be done via JSON rpc.
final class ConstructorOptions extends ffi.Struct {
  external ffi.Pointer<ffi.Char> id;

  external ffi.Pointer<ffi.Char> datamodel;

  external ffi.Pointer<ffi.Char> base_path;

  external ffi.Pointer<ffi.Char> log_level;

  @ffi.Bool()
  external bool log_queries;

  external ffi.Pointer<ffi.Char> datasource_overrides;

  external ffi.Pointer<ffi.Char> env;

  @ffi.Bool()
  external bool ignore_env_var_errors;

  external ConstructorOptionsNative native;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>
      log_callback;
}
