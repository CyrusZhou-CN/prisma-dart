// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/prisma_flutter.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class QueryEngineBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  QueryEngineBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  QueryEngineBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Create a new [QueryEngine]
  ///
  /// Returns a [Status] code.
  int create(
    ConstructorOptions options,
    ffi.Pointer<ffi.Pointer<QueryEngine>> qePtr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> errorStringPtr,
  ) {
    return _create(
      options,
      qePtr,
      errorStringPtr,
    );
  }

  late final _createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ConstructorOptions,
              ffi.Pointer<ffi.Pointer<QueryEngine>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('create');
  late final _create = _createPtr.asFunction<
      int Function(ConstructorOptions, ffi.Pointer<ffi.Pointer<QueryEngine>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Destroy a [QueryEngine]
  int destroy(
    ffi.Pointer<QueryEngine> qe,
  ) {
    return _destroy(
      qe,
    );
  }

  late final _destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<QueryEngine>)>>(
          'destroy');
  late final _destroy =
      _destroyPtr.asFunction<int Function(ffi.Pointer<QueryEngine>)>();

  /// Start a [QueryEngine]
  int start(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> trace,
    ffi.Pointer<ffi.Pointer<ffi.Char>> errorStringPtr,
  ) {
    return _start(
      qe,
      trace,
      errorStringPtr,
    );
  }

  late final _startPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('start');
  late final _start = _startPtr.asFunction<
      int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Stop a [QueryEngine]
  int stop(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> headerStr,
  ) {
    return _stop(
      qe,
      headerStr,
    );
  }

  late final _stopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>)>>('stop');
  late final _stop = _stopPtr.asFunction<
      int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>)>();

  /// Apply migrations
  int applyMigrations(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> migrationsPath,
    ffi.Pointer<ffi.Pointer<ffi.Char>> errorStringPtr,
  ) {
    return _applyMigrations(
      qe,
      migrationsPath,
      errorStringPtr,
    );
  }

  late final _applyMigrationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('applyMigrations');
  late final _applyMigrations = _applyMigrationsPtr.asFunction<
      int Function(ffi.Pointer<QueryEngine>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Query a prisma request
  ffi.Pointer<ffi.Char> query(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> bodyStr,
    ffi.Pointer<ffi.Char> headerStr,
    ffi.Pointer<ffi.Char> txIdStr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> errorStringPtr,
  ) {
    return _query(
      qe,
      bodyStr,
      headerStr,
      txIdStr,
      errorStringPtr,
    );
  }

  late final _queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('query');
  late final _query = _queryPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<QueryEngine>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Statr a transaction
  ffi.Pointer<ffi.Char> startTransaction(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> optionsStr,
    ffi.Pointer<ffi.Char> headerStr,
  ) {
    return _startTransaction(
      qe,
      optionsStr,
      headerStr,
    );
  }

  late final _startTransactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('startTransaction');
  late final _startTransaction = _startTransactionPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<QueryEngine>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Commit a transaction querys
  ffi.Pointer<ffi.Char> commitTransaction(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> txIdStr,
    ffi.Pointer<ffi.Char> headerStr,
  ) {
    return _commitTransaction(
      qe,
      txIdStr,
      headerStr,
    );
  }

  late final _commitTransactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('commitTransaction');
  late final _commitTransaction = _commitTransactionPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<QueryEngine>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Roolback a transaction
  ffi.Pointer<ffi.Char> rollbackTransaction(
    ffi.Pointer<QueryEngine> qe,
    ffi.Pointer<ffi.Char> txIdStr,
    ffi.Pointer<ffi.Char> headerStr,
  ) {
    return _rollbackTransaction(
      qe,
      txIdStr,
      headerStr,
    );
  }

  late final _rollbackTransactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<QueryEngine>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('rollbackTransaction');
  late final _rollbackTransaction = _rollbackTransactionPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<QueryEngine>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();
}

final class QueryEngine extends ffi.Opaque {}

final class ConstructorOptionsNative extends ffi.Struct {
  external ffi.Pointer<ffi.Char> config_dir;
}

/// Parameters defining the construction of an engine.
/// Unlike the Node version, this doesn't support the GraphQL protocol for talking with the prisma/client, since it is
/// deprecated and going forward everything should be done via JSON rpc.
final class ConstructorOptions extends ffi.Struct {
  external ffi.Pointer<ffi.Char> id;

  external ffi.Pointer<ffi.Char> datamodel;

  external ffi.Pointer<ffi.Char> base_path;

  external ffi.Pointer<ffi.Char> log_level;

  @ffi.Bool()
  external bool log_queries;

  external ffi.Pointer<ffi.Char> datasource_overrides;

  external ffi.Pointer<ffi.Char> env;

  @ffi.Bool()
  external bool ignore_env_var_errors;

  external ConstructorOptionsNative native;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>
      log_callback;
}

/// function returns status code.
///
/// see:
/// - [QueryEngineBindings.create]
/// - [QueryEngineBindings.destroy]
/// - [QueryEngineBindings.start]
/// - [QueryEngineBindings.stop]
/// - [QueryEngineBindings.applyMigrations]
abstract class Status {
  /// Success
  static const int ok = 0;

  /// Error
  static const int err = 1;

  /// Missing pointer, only create returns.
  static const int miss = 2;
}
